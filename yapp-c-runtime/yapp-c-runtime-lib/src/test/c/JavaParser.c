/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

#include "JavaParser.h"
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

YAPP_RULE TERMINAL_RULE = { "Terminal", TRUE, 0 };
YAPP_RULE JAVA_COMPILATION_UNIT = {"CompilationUnit", FALSE, FALSE, 1};
YAPP_RULE JAVA_PACKAGE_DECLARATION = {"PackageDeclaration", FALSE, FALSE, 2};
YAPP_RULE JAVA_IMPORT_DECLARATION = {"ImportDeclaration", FALSE, FALSE, 3};
YAPP_RULE JAVA_TYPE_DECLARATION = {"TypeDeclaration", FALSE, TRUE, 4};
YAPP_RULE JAVA_ANNOTATIONS = {"Annotations", FALSE, FALSE, 5};
YAPP_RULE JAVA_ANNOTATION = {"Annotation", FALSE, FALSE, 6};
YAPP_RULE JAVA_QUALIFIED_IDENTIFIER = {"QualifiedIdentifier", FALSE, FALSE, 7};
YAPP_RULE JAVA_DOT_STAR = {"DotStar", FALSE, FALSE, 8};
YAPP_RULE JAVA_MODIFIERS = {"Modifiers", FALSE, FALSE, 9};
YAPP_RULE JAVA_MODIFIER = {"Modifier", FALSE, TRUE, 10};
YAPP_RULE JAVA_CLASS_DECLARATION = {"ClassDeclaration", FALSE, FALSE, 11};
YAPP_RULE JAVA_ENUM_DECLARATION = {"EnumDeclaration", FALSE, FALSE, 12};
YAPP_RULE JAVA_INTERFACE_DECLARATION = {"InterfaceDeclaration", FALSE, FALSE, 13};
YAPP_RULE JAVA_ANNOTATION_DECLARATION = {"AnnotationDeclaration", FALSE, FALSE, 14};
YAPP_RULE JAVA_EXTENDS = {"Extends", FALSE, FALSE, 15};
YAPP_RULE JAVA_QUALIFIED_CLASS_NAME = {"QualifiedClassName", FALSE, FALSE, 16};
YAPP_RULE JAVA_IMPLEMENTS = {"Implements", FALSE, FALSE, 17};
YAPP_RULE JAVA_CLASS_TYPE_LIST = {"ClassTypeList", FALSE, TRUE, 18};
YAPP_RULE JAVA_IDENTIFIER = {"Identifier", FALSE, TRUE, 19};
YAPP_RULE JAVA_TYPE_PARAMETERS = {"TypeParameters", FALSE, FALSE, 20};
YAPP_RULE JAVA_CLASS_BODY = {"ClassBody", FALSE, FALSE, 21};
YAPP_RULE JAVA_CLASS_BODY_DECLARATION = {"ClassBodyDeclaration", FALSE, TRUE, 22};
YAPP_RULE JAVA_STATIC_BLOCK = {"StaticBlock", FALSE, FALSE, 23};
YAPP_RULE JAVA_BLOCK = {"Block", FALSE, FALSE, 24};
YAPP_RULE JAVA_METHOD_DECLARATION = {"MethodDeclaration", FALSE, FALSE, 25};
YAPP_RULE JAVA_CONSTRUCTOR_DECLARATION = {"ConstructorDeclaration", FALSE, FALSE, 26};
YAPP_RULE JAVA_FIELDS_DECLARATIONS = {"FieldsDeclarations", FALSE, FALSE, 27};
YAPP_RULE JAVA_TYPE = {"Type", FALSE, FALSE, 28};
YAPP_RULE JAVA_VARIABLE_DECLARATIONS = {"VariableDeclarations", FALSE, FALSE, 29};
YAPP_RULE JAVA_THROWS = {"Throws", FALSE, FALSE, 30};
YAPP_RULE JAVA_EMPTY_BODY = {"EmptyBody", FALSE, FALSE, 31};
YAPP_RULE JAVA_RETURN_TYPE = {"ReturnType", FALSE, FALSE, 32};
YAPP_RULE JAVA_METHOD_SIGNATURE = {"MethodSignature", FALSE, FALSE, 33};
YAPP_RULE JAVA_PARAMETERS_DECLARATIONS = {"ParametersDeclarations", FALSE, FALSE, 34};
YAPP_RULE JAVA_DIMENSIONS = {"Dimensions", FALSE, FALSE, 35};
YAPP_RULE JAVA_INTERFACE_BODY = {"InterfaceBody", FALSE, FALSE, 36};
YAPP_RULE JAVA_INTERFACE_BODY_DECLARATION = {"InterfaceBodyDeclaration", FALSE, TRUE, 37};
YAPP_RULE JAVA_INTERFACE_METHOD = {"InterfaceMethod", FALSE, FALSE, 38};
YAPP_RULE JAVA_CONSTANTS_DECLARATIONS = {"ConstantsDeclarations", FALSE, FALSE, 39};
YAPP_RULE JAVA_CONSTANTS_DECLARATIONS_LIST = {"ConstantsDeclarationsList", FALSE, FALSE, 40};
YAPP_RULE JAVA_CONSTANT_DECLARATION = {"ConstantDeclaration", FALSE, FALSE, 41};
YAPP_RULE JAVA_VARIABLE_INITIALIZER = {"VariableInitializer", FALSE, FALSE, 42};
YAPP_RULE JAVA_ENUM_BODY = {"EnumBody", FALSE, FALSE, 43};
YAPP_RULE JAVA_ENUM_CONSTANTS = {"EnumConstants", FALSE, FALSE, 44};
YAPP_RULE JAVA_ENUM_BODY_DECLARATIONS = {"EnumBodyDeclarations", FALSE, FALSE, 45};
YAPP_RULE JAVA_ENUM_CONSTANT = {"EnumConstant", FALSE, FALSE, 46};
YAPP_RULE JAVA_ARGUMENTS = {"Arguments", FALSE, FALSE, 47};
YAPP_RULE JAVA_FINAL = {"Final", FALSE, FALSE, 48};
YAPP_RULE JAVA_VARIABLE_MODIFIERS = {"VariableModifiers", FALSE, FALSE, 49};
YAPP_RULE JAVA_LOCAL_VARIABLE_DECLARATION_STATEMENT = {"LocalVariableDeclarationStatement", FALSE, FALSE, 50};
YAPP_RULE JAVA_VARIABLE_DECLARATION = {"VariableDeclaration", FALSE, FALSE, 51};
YAPP_RULE JAVA_VARIABLE_INITIALIZATION = {"VariableInitialization", FALSE, TRUE, 52};
YAPP_RULE JAVA_PARAMETERS_DECLARATION_LIST = {"ParametersDeclarationList", FALSE, TRUE, 53};
YAPP_RULE JAVA_PARAMETER_DECLARATION = {"ParameterDeclaration", FALSE, FALSE, 54};
YAPP_RULE JAVA_PARAMETER_VARIABLE_DECLARATION = {"ParameterVariableDeclaration", FALSE, FALSE, 55};
YAPP_RULE JAVA_BLOCK_STATEMENTS = {"BlockStatements", FALSE, TRUE, 56};
YAPP_RULE JAVA_BLOCK_STATEMENT = {"BlockStatement", FALSE, TRUE, 57};
YAPP_RULE JAVA_STATEMENT = {"Statement", FALSE, TRUE, 58};
YAPP_RULE JAVA_ASSERT_STATEMENT = {"AssertStatement", FALSE, FALSE, 59};
YAPP_RULE JAVA_IF_STATEMENT = {"IfStatement", FALSE, FALSE, 60};
YAPP_RULE JAVA_FOR_STATEMENT = {"ForStatement", FALSE, FALSE, 61};
YAPP_RULE JAVA_FOR_ITERABLE_STATEMENT = {"ForIterableStatement", FALSE, FALSE, 62};
YAPP_RULE JAVA_WHILE_STATEMENT = {"WhileStatement", FALSE, FALSE, 63};
YAPP_RULE JAVA_DO_WHILE_STATEMENT = {"DoWhileStatement", FALSE, FALSE, 64};
YAPP_RULE JAVA_TRY_CATCH_STATEMENT = {"TryCatchStatement", FALSE, FALSE, 65};
YAPP_RULE JAVA_RESOURCE_SPECIFICATION = {"ResourceSpecification", FALSE, TRUE, 66};
YAPP_RULE JAVA_RESOURCES = {"Resources", FALSE, FALSE, 67};
YAPP_RULE JAVA_RESOURCE = {"Resource", FALSE, FALSE, 68};
YAPP_RULE JAVA_SWITCH_STATEMENT = {"SwitchStatement", FALSE, FALSE, 69};
YAPP_RULE JAVA_SYNCHRONIZED_STATEMENT = {"SynchronizedStatement", FALSE, FALSE, 70};
YAPP_RULE JAVA_RETURN_STATEMENT = {"ReturnStatement", FALSE, FALSE, 71};
YAPP_RULE JAVA_THROW_STATEMENT = {"ThrowStatement", FALSE, FALSE, 72};
YAPP_RULE JAVA_BREAK_STATEMENT = {"BreakStatement", FALSE, FALSE, 73};
YAPP_RULE JAVA_CONTINUE_STATEMENT = {"ContinueStatement", FALSE, FALSE, 74};
YAPP_RULE JAVA_IDENTIFIED_STATEMENT = {"IdentifiedStatement", FALSE, FALSE, 75};
YAPP_RULE JAVA_STATEMENT_EXPRESSION = {"StatementExpression", FALSE, TRUE, 76};
YAPP_RULE JAVA_ELSE_STATEMENT = {"ElseStatement", FALSE, FALSE, 77};
YAPP_RULE JAVA_PAR_EXPRESSION = {"ParExpression", FALSE, TRUE, 78};
YAPP_RULE JAVA_EXPRESSION = {"Expression", FALSE, FALSE, 79};
YAPP_RULE JAVA_FOR_INIT = {"ForInit", FALSE, FALSE, 80};
YAPP_RULE JAVA_FOR_UPDATE = {"ForUpdate", FALSE, FALSE, 81};
YAPP_RULE JAVA_CATCH_TYPE = {"CatchType", FALSE, FALSE, 82};
YAPP_RULE JAVA_CATCH_PARAMETER = {"CatchParameter", FALSE, FALSE, 83};
YAPP_RULE JAVA_CATCH = {"Catch", FALSE, FALSE, 84};
YAPP_RULE JAVA_FINALLY = {"Finally", FALSE, FALSE, 85};
YAPP_RULE JAVA_SWITCH_BLOCK_STATEMENT_GROUPS = {"SwitchBlockStatementGroups", FALSE, FALSE, 86};
YAPP_RULE JAVA_SWITCH_BLOCK_STATEMENT_GROUP = {"SwitchBlockStatementGroup", FALSE, FALSE, 87};
YAPP_RULE JAVA_SWITCH_LABEL = {"SwitchLabel", FALSE, FALSE, 88};
YAPP_RULE JAVA_ENUM_CONSTANT_NAME = {"EnumConstantName", FALSE, FALSE, 89};
YAPP_RULE JAVA_FOR_INIT_VARIABLES = {"ForInitVariables", FALSE, FALSE, 90};
YAPP_RULE JAVA_FOR_INIT_EXPRESSIONS = {"ForInitExpressions", FALSE, FALSE, 91};
YAPP_RULE JAVA_ASSIGNMENT_EXPRESSION = {"AssignmentExpression", FALSE, FALSE, 92};
YAPP_RULE JAVA_CONDITIONAL_EXPRESSION = {"ConditionalExpression", FALSE, TRUE, 93};
YAPP_RULE JAVA_ASSIGNMENT_OPERATOR = {"AssignmentOperator", FALSE, TRUE, 94};
YAPP_RULE JAVA_TERNARY_EXPRESSION = {"TernaryExpression", FALSE, FALSE, 95};
YAPP_RULE JAVA_CONDITIONAL_OR_EXPRESSION = {"ConditionalOrExpression", FALSE, TRUE, 96};
YAPP_RULE JAVA_OR_EXPRESSION = {"OrExpression", FALSE, FALSE, 97};
YAPP_RULE JAVA_CONDITIONAL_AND_EXPRESSION = {"ConditionalAndExpression", FALSE, TRUE, 98};
YAPP_RULE JAVA_AND_EXPRESSION = {"AndExpression", FALSE, FALSE, 99};
YAPP_RULE JAVA_OPTIONAL_BIT_OR_EXPRESSION = {"OptionalBitOrExpression", FALSE, TRUE, 100};
YAPP_RULE JAVA_BIT_OR_EXPRESSION = {"BitOrExpression", FALSE, FALSE, 101};
YAPP_RULE JAVA_OPTIONAL_BIT_XOR_EXPRESSION = {"OptionalBitXOrExpression", FALSE, TRUE, 102};
YAPP_RULE JAVA_BIT_XOR_EXPRESSION = {"BitXOrExpression", FALSE, FALSE, 103};
YAPP_RULE JAVA_OPTIONAL_BIT_AND_EXPRESSION = {"OptionalBitAndExpression", FALSE, TRUE, 104};
YAPP_RULE JAVA_BIT_AND_EXPRESSION = {"BitAndExpression", FALSE, FALSE, 105};
YAPP_RULE JAVA_OPTIONAL_RELATIONAL_EXPRESSION = {"OptionalRelationalExpression", FALSE, TRUE, 106};
YAPP_RULE JAVA_RELATIONAL_EXPRESSION = {"RelationalExpression", FALSE, FALSE, 107};
YAPP_RULE JAVA_OPTIONAL_INSTANCE_OF_EXPRESSION = {"OptionalInstanceOfExpression", FALSE, TRUE, 108};
YAPP_RULE JAVA_INSTANCE_OF_EXPRESSION = {"InstanceOfExpression", FALSE, FALSE, 109};
YAPP_RULE JAVA_OPTIONAL_ADDITIVE_EXPRESSION = {"OptionalAdditiveExpression", FALSE, TRUE, 110};
YAPP_RULE JAVA_REFERENCE_TYPE = {"ReferenceType", FALSE, TRUE, 111};
YAPP_RULE JAVA_ADDITIVE_EXPRESSION = {"AdditiveExpression", FALSE, FALSE, 112};
YAPP_RULE JAVA_OPTIONAL_MULTIPLICATIVE_EXPRESSION = {"OptionalMultiplicativeExpression", FALSE, TRUE, 113};
YAPP_RULE JAVA_MULTIPLICATIVE_EXPRESSION = {"MultiplicativeExpression", FALSE, FALSE, 114};
YAPP_RULE JAVA_OPTIONAL_SHIFT_EXPRESSION = {"OptionalShiftExpression", FALSE, TRUE, 115};
YAPP_RULE JAVA_SHIFT_EXPRESSION = {"ShiftExpression", FALSE, FALSE, 116};
YAPP_RULE JAVA_UNARY_EXPRESSION = {"UnaryExpression", FALSE, TRUE, 117};
YAPP_RULE JAVA_PREFIXED_EXPRESSION = {"PrefixedExpression", FALSE, FALSE, 118};
YAPP_RULE JAVA_CAST_EXPRESSION = {"CastExpression", FALSE, FALSE, 119};
YAPP_RULE JAVA_POSTFIXED_EXPRESSION = {"PostfixedExpression", FALSE, FALSE, 120};
YAPP_RULE JAVA_PREFIX_OP = {"PrefixOp", TRUE, FALSE, 121};
YAPP_RULE JAVA_POST_FIX_OP = {"PostFixOp", FALSE, FALSE, 122};
YAPP_RULE JAVA_PRIMARY = {"Primary", FALSE, TRUE, 123};
YAPP_RULE JAVA_QUALIFIED_EXPRESSION = {"QualifiedExpression", FALSE, FALSE, 124};
YAPP_RULE JAVA_ARRAY_ACCESS = {"ArrayAccess", FALSE, FALSE, 125};
YAPP_RULE JAVA_ATOMIC = {"Atomic", FALSE, TRUE, 126};
YAPP_RULE JAVA_CLASS_TYPE_REFERENCE = {"ClassTypeReference", FALSE, FALSE, 127};
YAPP_RULE JAVA_LITERAL = {"Literal", FALSE, TRUE, 128};
YAPP_RULE JAVA_BASIC_TYPE_CLASS_REFERENCE = {"BasicTypeClassReference", FALSE, FALSE, 129};
YAPP_RULE JAVA_VOID_CLASS_REFERENCE = {"VoidClassReference", FALSE, FALSE, 130};
YAPP_RULE JAVA_THIS_METHOD_CALL = {"ThisMethodCall", FALSE, FALSE, 131};
YAPP_RULE JAVA_THIS = {"This", FALSE, FALSE, 132};
YAPP_RULE JAVA_SUPER = {"Super", FALSE, FALSE, 133};
YAPP_RULE JAVA_SUPER_METHOD_CALL = {"SuperMethodCall", FALSE, FALSE, 134};
YAPP_RULE JAVA_SUPER_CONSTRUCTOR_CALL = {"SuperConstructorCall", FALSE, FALSE, 135};
YAPP_RULE JAVA_SUPER_FIELD_ACCESS = {"SuperFieldAccess", FALSE, FALSE, 136};
YAPP_RULE JAVA_NEW = {"New", FALSE, FALSE, 137};
YAPP_RULE JAVA_CLASS_CREATOR = {"ClassCreator", FALSE, FALSE, 138};
YAPP_RULE JAVA_ARRAY_CREATOR = {"ArrayCreator", FALSE, TRUE, 139};
YAPP_RULE JAVA_METHOD_CALL = {"MethodCall", FALSE, FALSE, 140};
YAPP_RULE JAVA_ARRAY_INDEX = {"ArrayIndex", FALSE, FALSE, 141};
YAPP_RULE JAVA_DIM_EXPR = {"DimExpr", FALSE, FALSE, 142};
YAPP_RULE JAVA_BASIC_TYPE = {"BasicType", FALSE, TRUE, 143};
YAPP_RULE JAVA_NON_WILDCARD_TYPE_ARGUMENTS = {"NonWildcardTypeArguments", FALSE, FALSE, 144};
YAPP_RULE JAVA_CREATED_NAME = {"CreatedName", FALSE, FALSE, 145};
YAPP_RULE JAVA_INITIALIZED_ARRAY_CREATOR = {"InitializedArrayCreator", FALSE, FALSE, 146};
YAPP_RULE JAVA_EMPTY_ARRAY_CREATOR = {"EmptyArrayCreator", FALSE, FALSE, 147};
YAPP_RULE JAVA_ARRAY_TYPE = {"ArrayType", FALSE, TRUE, 148};
YAPP_RULE JAVA_DIM = {"Dim", FALSE, FALSE, 149};
YAPP_RULE JAVA_ARRAY_INITIALIZER = {"ArrayInitializer", FALSE, FALSE, 150};
YAPP_RULE JAVA_TYPED_NAME = {"TypedName", FALSE, FALSE, 151};
YAPP_RULE JAVA_TYPE_NAME = {"TypeName", FALSE, TRUE, 152};
YAPP_RULE JAVA_ARRAY = {"Array", FALSE, FALSE, 153};
YAPP_RULE JAVA_BASIC_TYPE_ARRAY = {"BasicTypeArray", FALSE, FALSE, 154};
YAPP_RULE JAVA_QUALIFIED_CLASS_NAME_ARRAY = {"QualifiedClassNameArray", FALSE, FALSE, 155};
YAPP_RULE JAVA_CLASS_NAME = {"ClassName", FALSE, TRUE, 156};
YAPP_RULE JAVA_TYPED_CLASS_NAME = {"TypedClassName", FALSE, FALSE, 157};
YAPP_RULE JAVA_TYPE_ARGUMENTS = {"TypeArguments", FALSE, FALSE, 158};
YAPP_RULE JAVA_TYPE_ARGUMENT = {"TypeArgument", FALSE, FALSE, 159};
YAPP_RULE JAVA_QUERY_TYPE = {"QueryType", FALSE, FALSE, 160};
YAPP_RULE JAVA_TYPE_PARAMETER = {"TypeParameter", FALSE, FALSE, 161};
YAPP_RULE JAVA_BOUND = {"Bound", FALSE, FALSE, 162};
YAPP_RULE JAVA_ANNOTATION_TYPE_BODY = {"AnnotationTypeBody", FALSE, FALSE, 163};
YAPP_RULE JAVA_ANNOTATION_TYPE_ELEMENT_DECLARATION = {"AnnotationTypeElementDeclaration", FALSE, TRUE, 164};
YAPP_RULE JAVA_ANNOTATION_METHOD = {"AnnotationMethod", FALSE, FALSE, 165};
YAPP_RULE JAVA_ANNOTATIONS_CONSTANTS = {"AnnotationsConstants", FALSE, FALSE, 166};
YAPP_RULE JAVA_DEFAULT_VALUE = {"DefaultValue", FALSE, FALSE, 167};
YAPP_RULE JAVA_ELEMENT_VALUE = {"ElementValue", FALSE, FALSE, 168};
YAPP_RULE JAVA_ANNOTATION_PARAMETERS = {"AnnotationParameters", FALSE, FALSE, 169};
YAPP_RULE JAVA_NORMAL_ANNOTATION_REST = {"NormalAnnotationRest", FALSE, TRUE, 170};
YAPP_RULE JAVA_SINGLE_ELEMENT_ANNOTATION_REST = {"SingleElementAnnotationRest", FALSE, TRUE, 171};
YAPP_RULE JAVA_ELEMENT_VALUE_PAIRS = {"ElementValuePairs", FALSE, TRUE, 172};
YAPP_RULE JAVA_ELEMENT_VALUE_PAIR = {"ElementValuePair", FALSE, FALSE, 173};
YAPP_RULE JAVA_ELEMENT_VALUE_ARRAY_INITIALIZER = {"ElementValueArrayInitializer", FALSE, FALSE, 174};
YAPP_RULE JAVA_ELEMENT_VALUES = {"ElementValues", FALSE, TRUE, 175};
YAPP_RULE JAVA_TEST_NO_ALPHA = {"TestNoAlpha", FALSE, FALSE, 176};
YAPP_RULE JAVA_SPACING = {"Spacing", FALSE, FALSE, 177};
YAPP_RULE JAVA_SPACES = {"Spaces", TRUE, FALSE, 178};
YAPP_RULE JAVA_BLOCK_COMMENT = {"BlockComment", TRUE, FALSE, 179};
YAPP_RULE JAVA_NEW_LINE = {"NewLine", TRUE, FALSE, 180};
YAPP_RULE JAVA_LINE_COMMENT = {"LineComment", TRUE, FALSE, 181};
YAPP_RULE JAVA_FLOAT_LITERAL = {"FloatLiteral", FALSE, FALSE, 182};
YAPP_RULE JAVA_LONG_LITERAL = {"LongLiteral", TRUE, FALSE, 183};
YAPP_RULE JAVA_INTEGER_LITERAL = {"IntegerLiteral", TRUE, FALSE, 184};
YAPP_RULE JAVA_CHAR_LITERAL = {"CharLiteral", TRUE, FALSE, 185};
YAPP_RULE JAVA_STRING_LITERAL = {"StringLiteral", TRUE, FALSE, 186};
YAPP_RULE JAVA_TRUE = {"True", FALSE, FALSE, 187};
YAPP_RULE JAVA_FALSE = {"False", FALSE, FALSE, 188};
YAPP_RULE JAVA_NULL = {"Null", FALSE, FALSE, 189};
YAPP_RULE JAVA_HEX_FLOAT = {"HexFloat", TRUE, FALSE, 190};
YAPP_RULE JAVA_DECIMAL_FLOAT = {"DecimalFloat", TRUE, FALSE, 191};
YAPP_RULE JAVA_SEMICOLON = {"Semicolon", FALSE, FALSE, 192};

#define RULES_COUNT 193

static JavaParser s_parser_model = {0, NULL, NULL, FALSE, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL, -1, 0, NULL, NULL};

#define NODE_SET_CURRENT(c, n) c->sibling = n; c = c->sibling

static BOOL compilationUnit_rule(JavaParser *parser);
static BOOL packageDeclaration_rule(JavaParser *parser);
static BOOL importDeclaration_rule(JavaParser *parser);
static BOOL typeDeclaration_rule(JavaParser *parser);
static BOOL annotations_rule(JavaParser *parser);
static BOOL annotation_rule(JavaParser *parser);
static BOOL qualifiedIdentifier_rule(JavaParser *parser);
static BOOL dotStar_rule(JavaParser *parser);
static BOOL modifiers_rule(JavaParser *parser);
static BOOL modifier_rule(JavaParser *parser);
static BOOL classDeclaration_rule(JavaParser *parser);
static BOOL enumDeclaration_rule(JavaParser *parser);
static BOOL interfaceDeclaration_rule(JavaParser *parser);
static BOOL annotationDeclaration_rule(JavaParser *parser);
static BOOL extends_rule(JavaParser *parser);
static BOOL qualifiedClassName_rule(JavaParser *parser);
static BOOL implements_rule(JavaParser *parser);
static BOOL classTypeList_rule(JavaParser *parser);
static BOOL identifier_rule(JavaParser *parser);
static BOOL identifierPattern_rule(JavaParser *parser);
static BOOL typeParameters_rule(JavaParser *parser);
static BOOL classBody_rule(JavaParser *parser);
static BOOL classBodyDeclaration_rule(JavaParser *parser);
static BOOL staticBlock_rule(JavaParser *parser);
static BOOL block_rule(JavaParser *parser);
static BOOL methodDeclaration_rule(JavaParser *parser);
static BOOL constructorDeclaration_rule(JavaParser *parser);
static BOOL fieldsDeclarations_rule(JavaParser *parser);
static BOOL type_rule(JavaParser *parser);
static BOOL variableDeclarations_rule(JavaParser *parser);
static BOOL throws_rule(JavaParser *parser);
static BOOL emptyBody_rule(JavaParser *parser);
static BOOL returnType_rule(JavaParser *parser);
static BOOL methodSignature_rule(JavaParser *parser);
static BOOL parametersDeclarations_rule(JavaParser *parser);
static BOOL dimensions_rule(JavaParser *parser);
static BOOL extendsInterfaces_rule(JavaParser *parser);
static BOOL interfaceBody_rule(JavaParser *parser);
static BOOL interfaceBodyDeclaration_rule(JavaParser *parser);
static BOOL interfaceMethod_rule(JavaParser *parser);
static BOOL constantsDeclarations_rule(JavaParser *parser);
static BOOL constantsDeclarationsList_rule(JavaParser *parser);
static BOOL constantDeclaration_rule(JavaParser *parser);
static BOOL variableInitializer_rule(JavaParser *parser);
static BOOL enumBody_rule(JavaParser *parser);
static BOOL enumConstants_rule(JavaParser *parser);
static BOOL enumBodyDeclarations_rule(JavaParser *parser);
static BOOL enumConstant_rule(JavaParser *parser);
static BOOL arguments_rule(JavaParser *parser);
static BOOL final_rule(JavaParser *parser);
static BOOL variableModifiers_rule(JavaParser *parser);
static BOOL localVariableDeclarationStatement_rule(JavaParser *parser);
static BOOL variableDeclaration_rule(JavaParser *parser);
static BOOL variableInitialization_rule(JavaParser *parser);
static BOOL parametersDeclarationList_rule(JavaParser *parser);
static BOOL parameterDeclaration_rule(JavaParser *parser);
static BOOL parameterVariableDeclaration_rule(JavaParser *parser);
static BOOL blockStatements_rule(JavaParser *parser);
static BOOL blockStatement_rule(JavaParser *parser);
static BOOL statement_rule(JavaParser *parser);
static BOOL assertStatement_rule(JavaParser *parser);
static BOOL ifStatement_rule(JavaParser *parser);
static BOOL forStatement_rule(JavaParser *parser);
static BOOL forIterableStatement_rule(JavaParser *parser);
static BOOL whileStatement_rule(JavaParser *parser);
static BOOL doWhileStatement_rule(JavaParser *parser);
static BOOL tryCatchStatement_rule(JavaParser *parser);
static BOOL resourceSpecification_rule(JavaParser *parser);
static BOOL resources_rule(JavaParser *parser);
static BOOL resource_rule(JavaParser *parser);
static BOOL switchStatement_rule(JavaParser *parser);
static BOOL synchronizedStatement_rule(JavaParser *parser);
static BOOL returnStatement_rule(JavaParser *parser);
static BOOL throwStatement_rule(JavaParser *parser);
static BOOL breakStatement_rule(JavaParser *parser);
static BOOL continueStatement_rule(JavaParser *parser);
static BOOL identifiedStatement_rule(JavaParser *parser);
static BOOL statementExpression_rule(JavaParser *parser);
static BOOL elseStatement_rule(JavaParser *parser);
static BOOL parExpression_rule(JavaParser *parser);
static BOOL expression_rule(JavaParser *parser);
static BOOL forInit_rule(JavaParser *parser);
static BOOL forUpdate_rule(JavaParser *parser);
static BOOL catchType_rule(JavaParser *parser);
static BOOL catchParameter_rule(JavaParser *parser);
static BOOL catch_rule(JavaParser *parser);
static BOOL finally_rule(JavaParser *parser);
static BOOL switchBlockStatementGroups_rule(JavaParser *parser);
static BOOL switchBlockStatementGroup_rule(JavaParser *parser);
static BOOL switchLabel_rule(JavaParser *parser);
static BOOL enumConstantName_rule(JavaParser *parser);
static BOOL forInitVariables_rule(JavaParser *parser);
static BOOL forInitExpressions_rule(JavaParser *parser);
static BOOL assignmentExpression_rule(JavaParser *parser);
static BOOL conditionalExpression_rule(JavaParser *parser);
static BOOL assignmentOperator_rule(JavaParser *parser);
static BOOL ternaryExpression_rule(JavaParser *parser);
static BOOL conditionalOrExpression_rule(JavaParser *parser);
static BOOL orExpression_rule(JavaParser *parser);
static BOOL conditionalAndExpression_rule(JavaParser *parser);
static BOOL andExpression_rule(JavaParser *parser);
static BOOL optionalBitOrExpression_rule(JavaParser *parser);
static BOOL bitOrExpression_rule(JavaParser *parser);
static BOOL optionalBitXOrExpression_rule(JavaParser *parser);
static BOOL bitXOrExpression_rule(JavaParser *parser);
static BOOL optionalBitAndExpression_rule(JavaParser *parser);
static BOOL bitAndExpression_rule(JavaParser *parser);
static BOOL optionalRelationalExpression_rule(JavaParser *parser);
static BOOL relationalExpression_rule(JavaParser *parser);
static BOOL optionalInstanceOfExpression_rule(JavaParser *parser);
static BOOL instanceOfExpression_rule(JavaParser *parser);
static BOOL optionalAdditiveExpression_rule(JavaParser *parser);
static BOOL referenceType_rule(JavaParser *parser);
static BOOL additiveExpression_rule(JavaParser *parser);
static BOOL optionalMultiplicativeExpression_rule(JavaParser *parser);
static BOOL multiplicativeExpression_rule(JavaParser *parser);
static BOOL optionalShiftExpression_rule(JavaParser *parser);
static BOOL shiftExpression_rule(JavaParser *parser);
static BOOL unaryExpression_rule(JavaParser *parser);
static BOOL prefixedExpression_rule(JavaParser *parser);
static BOOL castExpression_rule(JavaParser *parser);
static BOOL postfixedExpression_rule(JavaParser *parser);
static BOOL prefixOp_rule(JavaParser *parser);
static BOOL postFixOp_rule(JavaParser *parser);
static BOOL primary_rule(JavaParser *parser);
static BOOL qualifiedExpression_rule(JavaParser *parser);
static BOOL arrayAccess_rule(JavaParser *parser);
static BOOL atomic_rule(JavaParser *parser);
static BOOL classTypeReference_rule(JavaParser *parser);
static BOOL literal_rule(JavaParser *parser);
static BOOL basicTypeClassReference_rule(JavaParser *parser);
static BOOL voidClassReference_rule(JavaParser *parser);
static BOOL thisMethodCall_rule(JavaParser *parser);
static BOOL this_rule(JavaParser *parser);
static BOOL super_rule(JavaParser *parser);
static BOOL superMethodCall_rule(JavaParser *parser);
static BOOL superConstructorCall_rule(JavaParser *parser);
static BOOL superFieldAccess_rule(JavaParser *parser);
static BOOL new_rule(JavaParser *parser);
static BOOL classCreator_rule(JavaParser *parser);
static BOOL arrayCreator_rule(JavaParser *parser);
static BOOL methodCall_rule(JavaParser *parser);
static BOOL arrayIndex_rule(JavaParser *parser);
static BOOL dimExpr_rule(JavaParser *parser);
static BOOL basicType_rule(JavaParser *parser);
static BOOL basicTypeName_rule(JavaParser *parser);
static BOOL nonWildcardTypeArguments_rule(JavaParser *parser);
static BOOL createdName_rule(JavaParser *parser);
static BOOL initializedArrayCreator_rule(JavaParser *parser);
static BOOL emptyArrayCreator_rule(JavaParser *parser);
static BOOL arrayType_rule(JavaParser *parser);
static BOOL dim_rule(JavaParser *parser);
static BOOL arrayInitializer_rule(JavaParser *parser);
static BOOL typedName_rule(JavaParser *parser);
static BOOL typeName_rule(JavaParser *parser);
static BOOL array_rule(JavaParser *parser);
static BOOL basicTypeArray_rule(JavaParser *parser);
static BOOL qualifiedClassNameArray_rule(JavaParser *parser);
static BOOL className_rule(JavaParser *parser);
static BOOL typedClassName_rule(JavaParser *parser);
static BOOL typeArguments_rule(JavaParser *parser);
static BOOL typeArgument_rule(JavaParser *parser);
static BOOL queryType_rule(JavaParser *parser);
static BOOL typeParameter_rule(JavaParser *parser);
static BOOL bound_rule(JavaParser *parser);
static BOOL annotationTypeBody_rule(JavaParser *parser);
static BOOL annotationTypeElementDeclaration_rule(JavaParser *parser);
static BOOL annotationMethod_rule(JavaParser *parser);
static BOOL annotationsConstants_rule(JavaParser *parser);
static BOOL defaultValue_rule(JavaParser *parser);
static BOOL elementValue_rule(JavaParser *parser);
static BOOL annotationParameters_rule(JavaParser *parser);
static BOOL normalAnnotationRest_rule(JavaParser *parser);
static BOOL singleElementAnnotationRest_rule(JavaParser *parser);
static BOOL elementValuePairs_rule(JavaParser *parser);
static BOOL elementValuePair_rule(JavaParser *parser);
static BOOL elementValueArrayInitializer_rule(JavaParser *parser);
static BOOL elementValues_rule(JavaParser *parser);
static BOOL testNoAlpha_rule(JavaParser *parser);
static BOOL spacing_rule(JavaParser *parser);
static BOOL optionalSpacing_rule(JavaParser *parser);
static BOOL spaces_rule(JavaParser *parser);
static BOOL blockComment_rule(JavaParser *parser);
static BOOL newLine_rule(JavaParser *parser);
static BOOL lineComment_rule(JavaParser *parser);
static BOOL floatLiteral_rule(JavaParser *parser);
static BOOL longLiteral_rule(JavaParser *parser);
static BOOL integerLiteral_rule(JavaParser *parser);
static BOOL charLiteral_rule(JavaParser *parser);
static BOOL stringLiteral_rule(JavaParser *parser);
static BOOL true_rule(JavaParser *parser);
static BOOL false_rule(JavaParser *parser);
static BOOL null_rule(JavaParser *parser);
static BOOL hexFloat_rule(JavaParser *parser);
static BOOL decimalFloat_rule(JavaParser *parser);
static BOOL semicolon_rule(JavaParser *parser);

static void * allocMemory(JavaParser *parser, INT32 size) {
   if (parser->memoryManager != NULL) {
      return (void *) yapp_mem_alloc(parser->memoryManager, size);
   } else {
      return malloc(size);
   }
}

static char * strDup(JavaParser *parser, char *str, INT32 strLen, char encloseChar) {
   char *result;
   if (encloseChar == '\0') {
      result = (char *) allocMemory(parser, sizeof(char) * (strLen + 1));
      memcpy(result, str, strLen + 1);
   } else {
      result = (char *) allocMemory(parser, sizeof(char) * (strLen + 3));
      result[0] = encloseChar;
      memcpy(&result[1], str, strLen);
      result[strLen + 1] = encloseChar;
      result[strLen + 2] = '\0';
   }
   return result;
}

static char * charSequence(JavaParser *parser, INT32 count, ...) {
   char *result = (char *) allocMemory(parser, sizeof(char) * (count + 1));
   INT32 i = 0;
   va_list va;
   va_start(va, count);
   for(i = 0; i < count; i++) {
      result[i] = va_arg(va, char);
   }
   va_end(va);
   result[i] = '\0';
   return result;
}

static YAPP_NODE * createNode(JavaParser *parser, YAPP_RULE *rule, INT32 startIndex, INT32 endIndex, BOOL semantic, BOOL skipNode) {
   YAPP_NODE *node;
   if (parser->memoryManager != NULL) {
      node = yapp_node_newManaged(parser->memoryManager, rule, startIndex, endIndex, semantic, skipNode);
   } else {
      node = yapp_node_new(rule, startIndex, endIndex, semantic, skipNode);
      node->nextNode = parser->lastNodeCreated;
      parser->lastNodeCreated = node;
   }
   return node;
}


static BOOL charMatcher(JavaParser * parser, char c) {
   if (yapp_buffer_matchChar(parser->buffer, parser->index, c)) {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + 1, FALSE, FALSE));
      }
      ++parser->index;
      return TRUE;
   }
   return FALSE;
}

static BOOL ignoreCaseCharMatcher(JavaParser * parser, char c) {
   if (yapp_buffer_matchIgnoreCaseChar(parser->buffer, parser->index, c)) {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + 1, FALSE, FALSE));
      }
      ++parser->index;
      return TRUE;
   }
   return FALSE;
}

static BOOL stringMatcher(JavaParser * parser, char * str, INT32 strLen) {
   if (yapp_buffer_matchString(parser->buffer, parser->index, str, strLen)) {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + strLen, FALSE, FALSE));
      }
      parser->index += strLen;
      return TRUE;
   }
   return FALSE;
}

static BOOL partialStringMatcher(JavaParser * parser, char * str, INT32 strLen, INT32 minLen) {
   INT32 i;
   for (i = 0; i < strLen; i++) {
      if (! yapp_buffer_matchChar(parser->buffer, parser->index + i, str[i])) {
         if (i < minLen) {
            return FALSE;
         } else {
            break;
         }
      }
   }
   if (! parser->currentRuleIsAtomic) {
      NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + i, FALSE, FALSE));
   }
   parser->index += i;
   return TRUE;
}

static BOOL ignoreCaseStringMatcher(JavaParser * parser, char * str, INT32 strLen) {
   if (yapp_buffer_matchIgnoreCaseString(parser->buffer, parser->index, str, strLen)) {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + strLen, FALSE, FALSE));
      }
      parser->index += strLen;
      return TRUE;
   }
   return FALSE;
}

static BOOL partialIgnoreCaseStringMatcher(JavaParser * parser, char * str, INT32 strLen, INT32 minLen) {
   INT32 i;
   for (i = 0; i < strLen; i++) {
      if (! yapp_buffer_matchIgnoreCaseChar(parser->buffer, parser->index + i, str[i])) {
         if (i < minLen) {
            return FALSE;
         } else {
            break;
         }
      }
   }
   if (! parser->currentRuleIsAtomic) {
      NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + i, FALSE, FALSE));
   }
   parser->index += i;
   return TRUE;
}

static BOOL charRangeMatcher(JavaParser * parser, char charIni, char charEnd) {
   if (yapp_buffer_matchCharRange(parser->buffer, parser->index, charIni, charEnd)) {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + 1, FALSE, FALSE));
      }
      ++parser->index;
      return TRUE;
   }
   return FALSE;
}

static BOOL anyCharMatcher(JavaParser * parser) {
   if (yapp_buffer_getChar(parser->buffer, parser->index) != '\0') {
      if (! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, parser->index, parser->index + 1, FALSE, FALSE));
      }
      ++parser->index;
      return TRUE;
   }
   return FALSE;
}

static BOOL eoi(JavaParser * parser) {
   if (yapp_buffer_getChar(parser->buffer, parser->index) == '\0') {
      return TRUE;
   }
   return FALSE;
}

static BOOL charTest(JavaParser * parser, char c) {
   return yapp_buffer_getChar(parser->buffer, parser->index) == c;
}

static BOOL ignoreCaseCharTest(JavaParser * parser, char c) {
   return yapp_buffer_matchIgnoreCaseChar(parser->buffer, parser->index, c);
}

static BOOL stringTest(JavaParser * parser, char * str, INT32 strLen) {
   return yapp_buffer_matchString(parser->buffer, parser->index, str, strLen);
}

static BOOL partialStringTest(JavaParser * parser, char * str, INT32 strLen, INT32 minLen) {
   INT32 i;
   for (i = 0; i < strLen; i++) {
      if (! yapp_buffer_matchChar(parser->buffer, parser->index + i, str[i])) {
         if (i < minLen) {
            return FALSE;
         } else {
            break;
         }
      }
   }
   return TRUE;
}

static BOOL ignoreCaseStringTest(JavaParser * parser, char * str, INT32 strLen) {
   return yapp_buffer_matchIgnoreCaseString(parser->buffer, parser->index, str, strLen);
}

static BOOL partialIgnoreCaseStringTest(JavaParser * parser, char * str, INT32 strLen, INT32 minLen) {
   INT32 i;
   for (i = 0; i < strLen; i++) {
      if (! yapp_buffer_matchIgnoreCaseChar(parser->buffer, parser->index + i, str[i])) {
         if (i < minLen) {
            return FALSE;
         } else {
            break;
         }
      }
   }
   return TRUE;
}

static BOOL charRangeTest(JavaParser * parser, char charIni, char charEnd) {
   return yapp_buffer_matchCharRange(parser->buffer, parser->index, charIni, charEnd);
}

static BOOL anyCharTest(JavaParser * parser) {
   return yapp_buffer_getChar(parser->buffer, parser->index) != '\0';
}

static BOOL eoiTest(JavaParser * parser) {
   return yapp_buffer_getChar(parser->buffer, parser->index) == '\0';
}
YAPP_PARSER_ERROR* javaParser_getMismatches(JavaParser *parser) {
   return NULL;
}

void javaParser_setTraceParser(JavaParser *parser, YAPP_TRACE_PARSER *tracePath) {
}

void javaParser_setTrace(JavaParser *parser, BOOL trace) {
}

JavaParser* javaParser_new(YAPP_BUFFER *inputBuffer) {
   JavaParser *parser = (JavaParser*) malloc(sizeof(JavaParser));
   memcpy(parser, &s_parser_model, sizeof(JavaParser));
   parser->buffer = inputBuffer;
   parser->currentNode = createNode(parser, NULL, -1, -1, FALSE, FALSE);
   return parser;
}

JavaParser* javaParser_newManaged(YAPP_MEM_MANAGER *memoryManager, YAPP_BUFFER *inputBuffer) {
   JavaParser *parser = (JavaParser*) malloc(sizeof(JavaParser));
   memcpy(parser, &s_parser_model, sizeof(JavaParser));
   parser->memoryManager = memoryManager;
   parser->buffer = inputBuffer;
   parser->currentNode = createNode(parser, NULL, -1, -1, FALSE, FALSE);
   return parser;
}

void javaParser_free(JavaParser *parser) {
   YAPP_NODE *node;
   YAPP_NODE *nextNode;
   node = parser->lastNodeCreated;
   while(node != NULL) {
       nextNode = node->nextNode;
       yapp_node_free(node);
       node = nextNode;
   }
   free(parser);
}

YAPP_NODE* javaParser_parse(JavaParser *parser) {
   if (compilationUnit_rule(parser)) {
      return parser->currentNode;
   } else {
      return NULL;
   }
}

INT32 javaParser_rulesCount(JavaParser *parser) {
   return RULES_COUNT;
}


//CompilationUnit : (Spacing? PackageDeclaration? ImportDeclaration* TypeDeclaration* <EOI>)
static BOOL compilationUnit_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Spacing? PackageDeclaration? ImportDeclaration* TypeDeclaration* <EOI>)
   // Spacing?
   // Spacing
   spacing_rule(parser);
   // PackageDeclaration?
   // PackageDeclaration
   packageDeclaration_rule(parser);
   // ImportDeclaration*
   do {
      // ImportDeclaration
      match = importDeclaration_rule(parser);
   } while(match);
   // TypeDeclaration*
   do {
      // TypeDeclaration
      match = typeDeclaration_rule(parser);
   } while(match);
   // <EOI>
   match = eoi(parser);
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_COMPILATION_UNIT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//PackageDeclaration : (Annotations 'package' TestNoAlpha OptionalSpacing QualifiedIdentifier Semicolon)
static BOOL packageDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Annotations 'package' TestNoAlpha OptionalSpacing QualifiedIdentifier Semicolon)
   // Annotations
   match = annotations_rule(parser);
   if (match) {
      // 'package'
      match = stringMatcher(parser, "package", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // QualifiedIdentifier
               match = qualifiedIdentifier_rule(parser);
               if (match) {
                  // Semicolon
                  match = semicolon_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PACKAGE_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ImportDeclaration : ('import' TestNoAlpha OptionalSpacing ('static' TestNoAlpha OptionalSpacing)? QualifiedIdentifier DotStar? Semicolon)
static BOOL importDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('import' TestNoAlpha OptionalSpacing ('static' TestNoAlpha OptionalSpacing)? QualifiedIdentifier DotStar? Semicolon)
   // 'import'
   match = stringMatcher(parser, "import", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ('static' TestNoAlpha OptionalSpacing)?
            // ('static' TestNoAlpha OptionalSpacing)
            YAPP_NODE * lastNode_1 = parser->currentNode;
            INT32 lastIndex_1 = parser->index;
            // 'static'
            match = stringMatcher(parser, "static", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha_rule(parser);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (! match) {
                     parser->index = lastIndex_1;
                     lastNode_1->sibling = NULL;
                     parser->currentNode = lastNode_1;
                  }
               } else {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
               }
            }
            // QualifiedIdentifier
            match = qualifiedIdentifier_rule(parser);
            if (match) {
               // DotStar?
               // DotStar
               dotStar_rule(parser);
               // Semicolon
               match = semicolon_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IMPORT_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeDeclaration : (ClassDeclaration | EnumDeclaration | InterfaceDeclaration | AnnotationDeclaration | Semicolon)
static BOOL typeDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ClassDeclaration | EnumDeclaration | InterfaceDeclaration | AnnotationDeclaration | Semicolon)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case ';': {
         // Semicolon
         match = semicolon_rule(parser);
         break;
      }
      case '@':
      case 'p':
      case 'a':
      case 's':
      case 't':
      case 'f':
      case 'v':
      case 'n': {
         // ClassDeclaration
         match = classDeclaration_rule(parser);
         if (! match) {
            // EnumDeclaration
            match = enumDeclaration_rule(parser);
            if (! match) {
               // InterfaceDeclaration
               match = interfaceDeclaration_rule(parser);
               if (! match) {
                  // AnnotationDeclaration
                  match = annotationDeclaration_rule(parser);
               }
            }
         }
         break;
      }
      case 'c': {
         // ClassDeclaration
         match = classDeclaration_rule(parser);
         break;
      }
      case 'e': {
         // EnumDeclaration
         match = enumDeclaration_rule(parser);
         break;
      }
      case 'i': {
         // InterfaceDeclaration
         match = interfaceDeclaration_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPE_DECLARATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Annotations : Annotation*
static BOOL annotations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // Annotation*
   do {
      // Annotation
      match = annotation_rule(parser);
   } while(match);
   if (! parser->currentRuleIsAtomic) {
      parser->currentNode = createNode(parser, &JAVA_ANNOTATIONS, startIndex, parser->index, TRUE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
   }
   return TRUE;
}

//Annotation : ('@' OptionalSpacing 'interface'! QualifiedIdentifier AnnotationParameters?)
static BOOL annotation_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->annotation_ruleMemoStart == parser->index) {
      if (parser->annotation_ruleMemoStart <= parser->annotation_ruleMemoEnd) {
         parser->index = parser->annotation_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->annotation_ruleMemoStart == parser->annotation_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_ANNOTATION, parser->annotation_ruleMemoStart, parser->annotation_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->annotation_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->annotation_ruleMemoFirstNode;
               parser->currentNode = parser->annotation_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // ('@' OptionalSpacing 'interface'! QualifiedIdentifier AnnotationParameters?)
   // '@'
   match = charMatcher(parser, '@');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // 'interface'!
         // 'interface'
         match = stringTest(parser, "interface", 9);
         match = ! match;
         if (match) {
            // QualifiedIdentifier
            match = qualifiedIdentifier_rule(parser);
            if (match) {
               // AnnotationParameters?
               // AnnotationParameters
               annotationParameters_rule(parser);
               match = TRUE;
            }
         }
      }
   }
   if (match) {
      parser->annotation_ruleMemoStart = startIndex;
      parser->annotation_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->annotation_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->annotation_ruleMemoFirstNode = parser->currentNode;
         parser->annotation_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->annotation_ruleMemoStart = startIndex;
      parser->annotation_ruleMemoEnd = -1;
      parser->annotation_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//QualifiedIdentifier : (Identifier ('.' OptionalSpacing Identifier)*)
static BOOL qualifiedIdentifier_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier ('.' OptionalSpacing Identifier)*)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // ('.' OptionalSpacing Identifier)*
      do {
         // ('.' OptionalSpacing Identifier)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '.'
         match = charMatcher(parser, '.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Identifier
               match = identifier_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_QUALIFIED_IDENTIFIER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//DotStar : ('.' OptionalSpacing '*' OptionalSpacing)
static BOOL dotStar_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('.' OptionalSpacing '*' OptionalSpacing)
   // '.'
   match = charMatcher(parser, '.');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // '*'
         match = charMatcher(parser, '*');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DOT_STAR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Modifiers : Modifier*
static BOOL modifiers_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->modifiers_ruleMemoStart == parser->index) {
      if (parser->modifiers_ruleMemoStart <= parser->modifiers_ruleMemoEnd) {
         parser->index = parser->modifiers_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->modifiers_ruleMemoStart == parser->modifiers_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_MODIFIERS, parser->modifiers_ruleMemoStart, parser->modifiers_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->modifiers_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->modifiers_ruleMemoFirstNode;
               parser->currentNode = parser->modifiers_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // Modifier*
   do {
      // Modifier
      match = modifier_rule(parser);
   } while(match);
   parser->modifiers_ruleMemoStart = startIndex;
   parser->modifiers_ruleMemoEnd = parser->index;
   if (parser->currentRuleIsAtomic) {
      parser->modifiers_ruleMemoFirstNode = NULL;
   } else {
      parser->currentNode = createNode(parser, &JAVA_MODIFIERS, startIndex, parser->index, TRUE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
      parser->modifiers_ruleMemoFirstNode = parser->currentNode;
      parser->modifiers_ruleMemoLastNode = parser->currentNode;
   }
   return TRUE;
}

//Modifier : (Annotation | ('public' TestNoAlpha OptionalSpacing) | ('protected' TestNoAlpha OptionalSpacing) | ('private' TestNoAlpha OptionalSpacing) | ('static' TestNoAlpha OptionalSpacing) | ('abstract' TestNoAlpha OptionalSpacing) | ('final' TestNoAlpha OptionalSpacing) | ('native' TestNoAlpha OptionalSpacing) | ('synchronized' TestNoAlpha OptionalSpacing) | ('transient' TestNoAlpha OptionalSpacing) | ('volatile' TestNoAlpha OptionalSpacing) | ('strictfp' TestNoAlpha OptionalSpacing))
static BOOL modifier_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Annotation | ('public' TestNoAlpha OptionalSpacing) | ('protected' TestNoAlpha OptionalSpacing) | ('private' TestNoAlpha OptionalSpacing) | ('static' TestNoAlpha OptionalSpacing) | ('abstract' TestNoAlpha OptionalSpacing) | ('final' TestNoAlpha OptionalSpacing) | ('native' TestNoAlpha OptionalSpacing) | ('synchronized' TestNoAlpha OptionalSpacing) | ('transient' TestNoAlpha OptionalSpacing) | ('volatile' TestNoAlpha OptionalSpacing) | ('strictfp' TestNoAlpha OptionalSpacing))
   // Annotation
   match = annotation_rule(parser);
   if (! match) {
      // ('public' TestNoAlpha OptionalSpacing)
      YAPP_NODE * lastNode_1 = parser->currentNode;
      INT32 lastIndex_1 = parser->index;
      // 'public'
      match = stringMatcher(parser, "public", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         } else {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
         }
      }
      if (! match) {
         // ('protected' TestNoAlpha OptionalSpacing)
         YAPP_NODE * lastNode_2 = parser->currentNode;
         INT32 lastIndex_2 = parser->index;
         // 'protected'
         match = stringMatcher(parser, "protected", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha_rule(parser);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (! match) {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
                  parser->currentNode = lastNode_2;
               }
            } else {
               parser->index = lastIndex_2;
               lastNode_2->sibling = NULL;
            }
         }
         if (! match) {
            // ('private' TestNoAlpha OptionalSpacing)
            YAPP_NODE * lastNode_3 = parser->currentNode;
            INT32 lastIndex_3 = parser->index;
            // 'private'
            match = stringMatcher(parser, "private", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha_rule(parser);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (! match) {
                     parser->index = lastIndex_3;
                     lastNode_3->sibling = NULL;
                     parser->currentNode = lastNode_3;
                  }
               } else {
                  parser->index = lastIndex_3;
                  lastNode_3->sibling = NULL;
               }
            }
            if (! match) {
               // ('static' TestNoAlpha OptionalSpacing)
               YAPP_NODE * lastNode_4 = parser->currentNode;
               INT32 lastIndex_4 = parser->index;
               // 'static'
               match = stringMatcher(parser, "static", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha_rule(parser);
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_4;
                        lastNode_4->sibling = NULL;
                        parser->currentNode = lastNode_4;
                     }
                  } else {
                     parser->index = lastIndex_4;
                     lastNode_4->sibling = NULL;
                  }
               }
               if (! match) {
                  // ('abstract' TestNoAlpha OptionalSpacing)
                  YAPP_NODE * lastNode_5 = parser->currentNode;
                  INT32 lastIndex_5 = parser->index;
                  // 'abstract'
                  match = stringMatcher(parser, "abstract", 8);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha_rule(parser);
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing_rule(parser);
                        if (! match) {
                           parser->index = lastIndex_5;
                           lastNode_5->sibling = NULL;
                           parser->currentNode = lastNode_5;
                        }
                     } else {
                        parser->index = lastIndex_5;
                        lastNode_5->sibling = NULL;
                     }
                  }
                  if (! match) {
                     // ('final' TestNoAlpha OptionalSpacing)
                     YAPP_NODE * lastNode_6 = parser->currentNode;
                     INT32 lastIndex_6 = parser->index;
                     // 'final'
                     match = stringMatcher(parser, "final", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha_rule(parser);
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing_rule(parser);
                           if (! match) {
                              parser->index = lastIndex_6;
                              lastNode_6->sibling = NULL;
                              parser->currentNode = lastNode_6;
                           }
                        } else {
                           parser->index = lastIndex_6;
                           lastNode_6->sibling = NULL;
                        }
                     }
                     if (! match) {
                        // ('native' TestNoAlpha OptionalSpacing)
                        YAPP_NODE * lastNode_7 = parser->currentNode;
                        INT32 lastIndex_7 = parser->index;
                        // 'native'
                        match = stringMatcher(parser, "native", 6);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha_rule(parser);
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing_rule(parser);
                              if (! match) {
                                 parser->index = lastIndex_7;
                                 lastNode_7->sibling = NULL;
                                 parser->currentNode = lastNode_7;
                              }
                           } else {
                              parser->index = lastIndex_7;
                              lastNode_7->sibling = NULL;
                           }
                        }
                        if (! match) {
                           // ('synchronized' TestNoAlpha OptionalSpacing)
                           YAPP_NODE * lastNode_8 = parser->currentNode;
                           INT32 lastIndex_8 = parser->index;
                           // 'synchronized'
                           match = stringMatcher(parser, "synchronized", 12);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha_rule(parser);
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing_rule(parser);
                                 if (! match) {
                                    parser->index = lastIndex_8;
                                    lastNode_8->sibling = NULL;
                                    parser->currentNode = lastNode_8;
                                 }
                              } else {
                                 parser->index = lastIndex_8;
                                 lastNode_8->sibling = NULL;
                              }
                           }
                           if (! match) {
                              // ('transient' TestNoAlpha OptionalSpacing)
                              YAPP_NODE * lastNode_9 = parser->currentNode;
                              INT32 lastIndex_9 = parser->index;
                              // 'transient'
                              match = stringMatcher(parser, "transient", 9);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha_rule(parser);
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing_rule(parser);
                                    if (! match) {
                                       parser->index = lastIndex_9;
                                       lastNode_9->sibling = NULL;
                                       parser->currentNode = lastNode_9;
                                    }
                                 } else {
                                    parser->index = lastIndex_9;
                                    lastNode_9->sibling = NULL;
                                 }
                              }
                              if (! match) {
                                 // ('volatile' TestNoAlpha OptionalSpacing)
                                 YAPP_NODE * lastNode_10 = parser->currentNode;
                                 INT32 lastIndex_10 = parser->index;
                                 // 'volatile'
                                 match = stringMatcher(parser, "volatile", 8);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha_rule(parser);
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing_rule(parser);
                                       if (! match) {
                                          parser->index = lastIndex_10;
                                          lastNode_10->sibling = NULL;
                                          parser->currentNode = lastNode_10;
                                       }
                                    } else {
                                       parser->index = lastIndex_10;
                                       lastNode_10->sibling = NULL;
                                    }
                                 }
                                 if (! match) {
                                    // ('strictfp' TestNoAlpha OptionalSpacing)
                                    YAPP_NODE * lastNode_11 = parser->currentNode;
                                    INT32 lastIndex_11 = parser->index;
                                    // 'strictfp'
                                    match = stringMatcher(parser, "strictfp", 8);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha_rule(parser);
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing_rule(parser);
                                          if (! match) {
                                             parser->index = lastIndex_11;
                                             lastNode_11->sibling = NULL;
                                             parser->currentNode = lastNode_11;
                                          }
                                       } else {
                                          parser->index = lastIndex_11;
                                          lastNode_11->sibling = NULL;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_MODIFIER, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassDeclaration : (Modifiers 'class' TestNoAlpha OptionalSpacing Identifier TypeParameters? Extends? Implements? ClassBody)
static BOOL classDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers 'class' TestNoAlpha OptionalSpacing Identifier TypeParameters? Extends? Implements? ClassBody)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // 'class'
      match = stringMatcher(parser, "class", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Identifier
               match = identifier_rule(parser);
               if (match) {
                  // TypeParameters?
                  // TypeParameters
                  typeParameters_rule(parser);
                  // Extends?
                  // Extends
                  extends_rule(parser);
                  // Implements?
                  // Implements
                  implements_rule(parser);
                  // ClassBody
                  match = classBody_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumDeclaration : (Modifiers 'enum' TestNoAlpha OptionalSpacing Identifier Implements? EnumBody)
static BOOL enumDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers 'enum' TestNoAlpha OptionalSpacing Identifier Implements? EnumBody)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // 'enum'
      match = stringMatcher(parser, "enum", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Identifier
               match = identifier_rule(parser);
               if (match) {
                  // Implements?
                  // Implements
                  implements_rule(parser);
                  // EnumBody
                  match = enumBody_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InterfaceDeclaration : (Modifiers 'interface' TestNoAlpha OptionalSpacing Identifier TypeParameters? ExtendsInterfaces? InterfaceBody)
static BOOL interfaceDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers 'interface' TestNoAlpha OptionalSpacing Identifier TypeParameters? ExtendsInterfaces? InterfaceBody)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // 'interface'
      match = stringMatcher(parser, "interface", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Identifier
               match = identifier_rule(parser);
               if (match) {
                  // TypeParameters?
                  // TypeParameters
                  typeParameters_rule(parser);
                  // ExtendsInterfaces?
                  // ExtendsInterfaces
                  extendsInterfaces_rule(parser);
                  // InterfaceBody
                  match = interfaceBody_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INTERFACE_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationDeclaration : (Modifiers '@' OptionalSpacing 'interface' TestNoAlpha OptionalSpacing Identifier AnnotationTypeBody)
static BOOL annotationDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers '@' OptionalSpacing 'interface' TestNoAlpha OptionalSpacing Identifier AnnotationTypeBody)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // '@'
      match = charMatcher(parser, '@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // 'interface'
            match = stringMatcher(parser, "interface", 9);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha_rule(parser);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // Identifier
                     match = identifier_rule(parser);
                     if (match) {
                        // AnnotationTypeBody
                        match = annotationTypeBody_rule(parser);
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Extends : ('extends' TestNoAlpha OptionalSpacing QualifiedClassName)
static BOOL extends_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('extends' TestNoAlpha OptionalSpacing QualifiedClassName)
   // 'extends'
   match = stringMatcher(parser, "extends", 7);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // QualifiedClassName
            match = qualifiedClassName_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_EXTENDS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//QualifiedClassName : (ClassName ('.' OptionalSpacing ClassName)*)
static BOOL qualifiedClassName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->qualifiedClassName_ruleMemoStart == parser->index) {
      if (parser->qualifiedClassName_ruleMemoStart <= parser->qualifiedClassName_ruleMemoEnd) {
         parser->index = parser->qualifiedClassName_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->qualifiedClassName_ruleMemoStart == parser->qualifiedClassName_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_QUALIFIED_CLASS_NAME, parser->qualifiedClassName_ruleMemoStart, parser->qualifiedClassName_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->qualifiedClassName_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->qualifiedClassName_ruleMemoFirstNode;
               parser->currentNode = parser->qualifiedClassName_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (ClassName ('.' OptionalSpacing ClassName)*)
   // ClassName
   match = className_rule(parser);
   if (match) {
      // ('.' OptionalSpacing ClassName)*
      do {
         // ('.' OptionalSpacing ClassName)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '.'
         match = charMatcher(parser, '.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // ClassName
               match = className_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      parser->qualifiedClassName_ruleMemoStart = startIndex;
      parser->qualifiedClassName_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->qualifiedClassName_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_QUALIFIED_CLASS_NAME, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->qualifiedClassName_ruleMemoFirstNode = parser->currentNode;
         parser->qualifiedClassName_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->qualifiedClassName_ruleMemoStart = startIndex;
      parser->qualifiedClassName_ruleMemoEnd = -1;
      parser->qualifiedClassName_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Implements : ('implements' TestNoAlpha OptionalSpacing ClassTypeList)
static BOOL implements_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('implements' TestNoAlpha OptionalSpacing ClassTypeList)
   // 'implements'
   match = stringMatcher(parser, "implements", 10);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ClassTypeList
            match = classTypeList_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IMPLEMENTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassTypeList : (QualifiedClassName (',' OptionalSpacing QualifiedClassName)*)
static BOOL classTypeList_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (QualifiedClassName (',' OptionalSpacing QualifiedClassName)*)
   // QualifiedClassName
   match = qualifiedClassName_rule(parser);
   if (match) {
      // (',' OptionalSpacing QualifiedClassName)*
      do {
         // (',' OptionalSpacing QualifiedClassName)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // QualifiedClassName
               match = qualifiedClassName_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_TYPE_LIST, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Identifier : (Keyword! IdentifierPattern OptionalSpacing)
static BOOL identifier_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->identifier_ruleMemoStart == parser->index) {
      if (parser->identifier_ruleMemoStart <= parser->identifier_ruleMemoEnd) {
         parser->index = parser->identifier_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->identifier_ruleMemoStart == parser->identifier_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_IDENTIFIER, parser->identifier_ruleMemoStart, parser->identifier_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->identifier_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->identifier_ruleMemoFirstNode;
               parser->currentNode = parser->identifier_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (Keyword! IdentifierPattern OptionalSpacing)
   // Keyword!
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   BOOL lastAtomic_1 = parser->currentRuleIsAtomic;
   // (('abstract' | 'continue' | 'for' | 'new' | 'switch' | 'assert' | 'default' | 'goto' | 'package' | 'synchronized' | 'boolean' | 'do' | 'if' | 'private' | 'this' | 'break' | 'double' | 'implements' | 'protected' | 'throws' | 'throw' | 'byte' | 'else' | 'import' | 'public' | 'case' | 'enum' | 'instanceof' | 'return' | 'transient' | 'catch' | 'extends' | 'int' | 'short' | 'try' | 'char' | 'final' | 'interface' | 'static' | 'void' | 'class' | 'finally' | 'long' | 'strictfp' | 'volatile' | 'const' | 'float' | 'native' | 'super' | 'while') TestNoAlpha)
   // ('abstract' | 'continue' | 'for' | 'new' | 'switch' | 'assert' | 'default' | 'goto' | 'package' | 'synchronized' | 'boolean' | 'do' | 'if' | 'private' | 'this' | 'break' | 'double' | 'implements' | 'protected' | 'throws' | 'throw' | 'byte' | 'else' | 'import' | 'public' | 'case' | 'enum' | 'instanceof' | 'return' | 'transient' | 'catch' | 'extends' | 'int' | 'short' | 'try' | 'char' | 'final' | 'interface' | 'static' | 'void' | 'class' | 'finally' | 'long' | 'strictfp' | 'volatile' | 'const' | 'float' | 'native' | 'super' | 'while')
   INT32 startIndex_2 = parser->index;
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'l': {
         ++parser->index;
         // 'ong'
         if (match = stringTest(parser, "ong", 3)) {
            parser->index += 3;
         }
         break;
      }
      case 'n': {
         ++parser->index;
         // ('ative' | 'ew')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'a': {
               ++parser->index;
               // 'tive'
               if (match = stringTest(parser, "tive", 4)) {
                  parser->index += 4;
               }
               break;
            }
            case 'e': {
               ++parser->index;
               // 'w'
               if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 'w')) {
                  ++parser->index;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'p': {
         ++parser->index;
         // ('rotected' | 'ackage' | 'rivate' | 'ublic')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'a': {
               ++parser->index;
               // 'ckage'
               if (match = stringTest(parser, "ckage", 5)) {
                  parser->index += 5;
               }
               break;
            }
            case 'r': {
               ++parser->index;
               // ('otected' | 'ivate')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'o': {
                     ++parser->index;
                     // 'tected'
                     if (match = stringTest(parser, "tected", 6)) {
                        parser->index += 6;
                     }
                     break;
                  }
                  case 'i': {
                     ++parser->index;
                     // 'vate'
                     if (match = stringTest(parser, "vate", 4)) {
                        parser->index += 4;
                     }
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            case 'u': {
               ++parser->index;
               // 'blic'
               if (match = stringTest(parser, "blic", 4)) {
                  parser->index += 4;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'r': {
         ++parser->index;
         // 'eturn'
         if (match = stringTest(parser, "eturn", 5)) {
            parser->index += 5;
         }
         break;
      }
      case 's': {
         ++parser->index;
         // ('ynchronized' | 'trictfp' | 'witch' | 'tatic' | 'hort' | 'uper')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 't': {
               ++parser->index;
               // ('rictfp' | 'atic')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'a': {
                     ++parser->index;
                     // 'tic'
                     if (match = stringTest(parser, "tic", 3)) {
                        parser->index += 3;
                     }
                     break;
                  }
                  case 'r': {
                     ++parser->index;
                     // 'ictfp'
                     if (match = stringTest(parser, "ictfp", 5)) {
                        parser->index += 5;
                     }
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            case 'u': {
               ++parser->index;
               // 'per'
               if (match = stringTest(parser, "per", 3)) {
                  parser->index += 3;
               }
               break;
            }
            case 'w': {
               ++parser->index;
               // 'itch'
               if (match = stringTest(parser, "itch", 4)) {
                  parser->index += 4;
               }
               break;
            }
            case 'h': {
               ++parser->index;
               // 'ort'
               if (match = stringTest(parser, "ort", 3)) {
                  parser->index += 3;
               }
               break;
            }
            case 'y': {
               ++parser->index;
               // 'nchronized'
               if (match = stringTest(parser, "nchronized", 10)) {
                  parser->index += 10;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 't': {
         ++parser->index;
         // ('ransient' | 'hrows' | 'hrow' | 'his' | 'ry')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'r': {
               ++parser->index;
               // ('ansient' | 'y')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'a': {
                     ++parser->index;
                     // 'nsient'
                     if (match = stringTest(parser, "nsient", 6)) {
                        parser->index += 6;
                     }
                     break;
                  }
                  case 'y': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            case 'h': {
               ++parser->index;
               // ('rows' | 'row' | 'is')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'r': {
                     ++parser->index;
                     // ('ows' | 'ow')
                     if (yapp_buffer_matchChar(parser->buffer, parser->index, 'o')) {
                        ++parser->index;
                        // ('ws' | 'w')
                        if (yapp_buffer_matchChar(parser->buffer, parser->index, 'w')) {
                           ++parser->index;
                           // ('s' | <EMPTY>)
                           if (yapp_buffer_matchChar(parser->buffer, parser->index, 's')) {
                              ++parser->index;
                              // <EMPTY>
                              match = TRUE;
                           } else {
                              match = TRUE;
                           }
                        } else {
                           match = FALSE;
                        }
                     } else {
                        match = FALSE;
                     }
                     break;
                  }
                  case 'i': {
                     ++parser->index;
                     // 's'
                     if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 's')) {
                        ++parser->index;
                     }
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'v': {
         ++parser->index;
         // ('olatile' | 'oid')
         if (yapp_buffer_matchChar(parser->buffer, parser->index, 'o')) {
            ++parser->index;
            // ('latile' | 'id')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case 'l': {
                  ++parser->index;
                  // 'atile'
                  if (match = stringTest(parser, "atile", 5)) {
                     parser->index += 5;
                  }
                  break;
               }
               case 'i': {
                  ++parser->index;
                  // 'd'
                  if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 'd')) {
                     ++parser->index;
                  }
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
         } else {
            match = FALSE;
         }
         break;
      }
      case 'w': {
         ++parser->index;
         // 'hile'
         if (match = stringTest(parser, "hile", 4)) {
            parser->index += 4;
         }
         break;
      }
      case 'a': {
         ++parser->index;
         // ('bstract' | 'ssert')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'b': {
               ++parser->index;
               // 'stract'
               if (match = stringTest(parser, "stract", 6)) {
                  parser->index += 6;
               }
               break;
            }
            case 's': {
               ++parser->index;
               // 'sert'
               if (match = stringTest(parser, "sert", 4)) {
                  parser->index += 4;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'b': {
         ++parser->index;
         // ('oolean' | 'reak' | 'yte')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'o': {
               ++parser->index;
               // 'olean'
               if (match = stringTest(parser, "olean", 5)) {
                  parser->index += 5;
               }
               break;
            }
            case 'r': {
               ++parser->index;
               // 'eak'
               if (match = stringTest(parser, "eak", 3)) {
                  parser->index += 3;
               }
               break;
            }
            case 'y': {
               ++parser->index;
               // 'te'
               if (match = stringTest(parser, "te", 2)) {
                  parser->index += 2;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'c': {
         ++parser->index;
         // ('ontinue' | 'atch' | 'lass' | 'onst' | 'ase' | 'har')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'l': {
               ++parser->index;
               // 'ass'
               if (match = stringTest(parser, "ass", 3)) {
                  parser->index += 3;
               }
               break;
            }
            case 'o': {
               ++parser->index;
               // ('ntinue' | 'nst')
               if (yapp_buffer_matchChar(parser->buffer, parser->index, 'n')) {
                  ++parser->index;
                  // ('tinue' | 'st')
                  switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                     case 's': {
                        ++parser->index;
                        // 't'
                        if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 't')) {
                           ++parser->index;
                        }
                        break;
                     }
                     case 't': {
                        ++parser->index;
                        // 'inue'
                        if (match = stringTest(parser, "inue", 4)) {
                           parser->index += 4;
                        }
                        break;
                     }
                     default: {
                        match = FALSE;
                     }
                  }
               } else {
                  match = FALSE;
               }
               break;
            }
            case 'a': {
               ++parser->index;
               // ('tch' | 'se')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 's': {
                     ++parser->index;
                     // 'e'
                     if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 'e')) {
                        ++parser->index;
                     }
                     break;
                  }
                  case 't': {
                     ++parser->index;
                     // 'ch'
                     if (match = stringTest(parser, "ch", 2)) {
                        parser->index += 2;
                     }
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            case 'h': {
               ++parser->index;
               // 'ar'
               if (match = stringTest(parser, "ar", 2)) {
                  parser->index += 2;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'd': {
         ++parser->index;
         // ('efault' | 'ouble' | 'o')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'o': {
               ++parser->index;
               // ('uble' | <EMPTY>)
               if (yapp_buffer_matchChar(parser->buffer, parser->index, 'u')) {
                  ++parser->index;
                  // 'ble'
                  if (match = stringTest(parser, "ble", 3)) {
                     parser->index += 3;
                  }
               } else {
                  match = TRUE;
               }
               break;
            }
            case 'e': {
               ++parser->index;
               // 'fault'
               if (match = stringTest(parser, "fault", 5)) {
                  parser->index += 5;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'e': {
         ++parser->index;
         // ('xtends' | 'lse' | 'num')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'l': {
               ++parser->index;
               // 'se'
               if (match = stringTest(parser, "se", 2)) {
                  parser->index += 2;
               }
               break;
            }
            case 'n': {
               ++parser->index;
               // 'um'
               if (match = stringTest(parser, "um", 2)) {
                  parser->index += 2;
               }
               break;
            }
            case 'x': {
               ++parser->index;
               // 'tends'
               if (match = stringTest(parser, "tends", 5)) {
                  parser->index += 5;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'f': {
         ++parser->index;
         // ('inally' | 'inal' | 'loat' | 'or')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'l': {
               ++parser->index;
               // 'oat'
               if (match = stringTest(parser, "oat", 3)) {
                  parser->index += 3;
               }
               break;
            }
            case 'o': {
               ++parser->index;
               // 'r'
               if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 'r')) {
                  ++parser->index;
               }
               break;
            }
            case 'i': {
               ++parser->index;
               // ('nally' | 'nal')
               if (yapp_buffer_matchChar(parser->buffer, parser->index, 'n')) {
                  ++parser->index;
                  // ('ally' | 'al')
                  if (yapp_buffer_matchChar(parser->buffer, parser->index, 'a')) {
                     ++parser->index;
                     // ('lly' | 'l')
                     if (yapp_buffer_matchChar(parser->buffer, parser->index, 'l')) {
                        ++parser->index;
                        // ('ly' | <EMPTY>)
                        if (yapp_buffer_matchChar(parser->buffer, parser->index, 'l')) {
                           ++parser->index;
                           // 'y'
                           if (match = yapp_buffer_matchChar(parser->buffer, parser->index, 'y')) {
                              ++parser->index;
                           }
                        } else {
                           match = TRUE;
                        }
                     } else {
                        match = FALSE;
                     }
                  } else {
                     match = FALSE;
                  }
               } else {
                  match = FALSE;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 'g': {
         ++parser->index;
         // 'oto'
         if (match = stringTest(parser, "oto", 3)) {
            parser->index += 3;
         }
         break;
      }
      case 'i': {
         ++parser->index;
         // ('mplements' | 'nstanceof' | 'nterface' | 'mport' | 'nt' | 'f')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'm': {
               ++parser->index;
               // ('plements' | 'port')
               if (yapp_buffer_matchChar(parser->buffer, parser->index, 'p')) {
                  ++parser->index;
                  // ('lements' | 'ort')
                  switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                     case 'l': {
                        ++parser->index;
                        // 'ements'
                        if (match = stringTest(parser, "ements", 6)) {
                           parser->index += 6;
                        }
                        break;
                     }
                     case 'o': {
                        ++parser->index;
                        // 'rt'
                        if (match = stringTest(parser, "rt", 2)) {
                           parser->index += 2;
                        }
                        break;
                     }
                     default: {
                        match = FALSE;
                     }
                  }
               } else {
                  match = FALSE;
               }
               break;
            }
            case 'n': {
               ++parser->index;
               // ('stanceof' | 'terface' | 't')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 's': {
                     ++parser->index;
                     // 'tanceof'
                     if (match = stringTest(parser, "tanceof", 7)) {
                        parser->index += 7;
                     }
                     break;
                  }
                  case 't': {
                     ++parser->index;
                     // ('erface' | <EMPTY>)
                     if (yapp_buffer_matchChar(parser->buffer, parser->index, 'e')) {
                        ++parser->index;
                        // 'rface'
                        if (match = stringTest(parser, "rface", 5)) {
                           parser->index += 5;
                        }
                     } else {
                        match = TRUE;
                     }
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               break;
            }
            case 'f': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (! match) {
      parser->index = startIndex_2;
   } else if(! parser->currentRuleIsAtomic) {
      NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_2, parser->index, FALSE, FALSE));
   }
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
   }
   parser->currentRuleIsAtomic = lastAtomic_1;
   parser->index = lastIndex_1;
   lastNode_1->sibling = NULL;
   parser->currentNode = lastNode_1;
   match = ! match;
   if (match) {
      // IdentifierPattern
      match = identifierPattern_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      parser->identifier_ruleMemoStart = startIndex;
      parser->identifier_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->identifier_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_IDENTIFIER, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->identifier_ruleMemoFirstNode = parser->currentNode;
         parser->identifier_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->identifier_ruleMemoStart = startIndex;
      parser->identifier_ruleMemoEnd = -1;
      parser->identifier_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//IdentifierPattern : (('a'-'z' | 'A'-'Z' | '_' | '$') ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')*)
static BOOL identifierPattern_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (('a'-'z' | 'A'-'Z' | '_' | '$') ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')*)
   // ('a'-'z' | 'A'-'Z' | '_' | '$')
   // 'a'-'z'
   match = charRangeMatcher(parser, 'a', 'z');
   if (! match) {
      // 'A'-'Z'
      match = charRangeMatcher(parser, 'A', 'Z');
      if (! match) {
         // '_'
         match = charMatcher(parser, '_');
         if (! match) {
            // '$'
            match = charMatcher(parser, '$');
         }
      }
   }
   if (match) {
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')*
      do {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')
         // 'a'-'z'
         match = charRangeMatcher(parser, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = charRangeMatcher(parser, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
               if (! match) {
                  // '_'
                  match = charMatcher(parser, '_');
                  if (! match) {
                     // '$'
                     match = charMatcher(parser, '$');
                  }
               }
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IDENTIFIER, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeParameters : ('<' OptionalSpacing TypeParameter (',' OptionalSpacing TypeParameter)* '>' OptionalSpacing)
static BOOL typeParameters_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->typeParameters_ruleMemoStart == parser->index) {
      if (parser->typeParameters_ruleMemoStart <= parser->typeParameters_ruleMemoEnd) {
         parser->index = parser->typeParameters_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->typeParameters_ruleMemoStart == parser->typeParameters_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_TYPE_PARAMETERS, parser->typeParameters_ruleMemoStart, parser->typeParameters_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->typeParameters_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->typeParameters_ruleMemoFirstNode;
               parser->currentNode = parser->typeParameters_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // ('<' OptionalSpacing TypeParameter (',' OptionalSpacing TypeParameter)* '>' OptionalSpacing)
   // '<'
   match = charMatcher(parser, '<');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // TypeParameter
         match = typeParameter_rule(parser);
         if (match) {
            // (',' OptionalSpacing TypeParameter)*
            do {
               // (',' OptionalSpacing TypeParameter)
               YAPP_NODE * lastNode_1 = parser->currentNode;
               INT32 lastIndex_1 = parser->index;
               // ','
               match = charMatcher(parser, ',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // TypeParameter
                     match = typeParameter_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_1;
                        lastNode_1->sibling = NULL;
                        parser->currentNode = lastNode_1;
                     }
                  } else {
                     parser->index = lastIndex_1;
                     lastNode_1->sibling = NULL;
                  }
               }
            } while(match);
            // '>'
            match = charMatcher(parser, '>');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      parser->typeParameters_ruleMemoStart = startIndex;
      parser->typeParameters_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->typeParameters_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_TYPE_PARAMETERS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->typeParameters_ruleMemoFirstNode = parser->currentNode;
         parser->typeParameters_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->typeParameters_ruleMemoStart = startIndex;
      parser->typeParameters_ruleMemoEnd = -1;
      parser->typeParameters_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassBody : ('{' OptionalSpacing ClassBodyDeclaration* '}' OptionalSpacing)
static BOOL classBody_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing ClassBodyDeclaration* '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ClassBodyDeclaration*
         do {
            // ClassBodyDeclaration
            match = classBodyDeclaration_rule(parser);
         } while(match);
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_BODY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassBodyDeclaration : (Semicolon | StaticBlock | MethodDeclaration | ConstructorDeclaration | FieldsDeclarations | InterfaceDeclaration | ClassDeclaration | EnumDeclaration | AnnotationDeclaration)
static BOOL classBodyDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Semicolon | StaticBlock | MethodDeclaration | ConstructorDeclaration | FieldsDeclarations | InterfaceDeclaration | ClassDeclaration | EnumDeclaration | AnnotationDeclaration)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case ';': {
         // Semicolon
         match = semicolon_rule(parser);
         break;
      }
      case '{': {
         // StaticBlock
         match = staticBlock_rule(parser);
         break;
      }
      case '<': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
         }
         break;
      }
      case '@':
      case 'p':
      case 'a':
      case 't':
      case 'f':
      case 'v':
      case 'n': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
            if (! match) {
               // FieldsDeclarations
               match = fieldsDeclarations_rule(parser);
               if (! match) {
                  // InterfaceDeclaration
                  match = interfaceDeclaration_rule(parser);
                  if (! match) {
                     // ClassDeclaration
                     match = classDeclaration_rule(parser);
                     if (! match) {
                        // EnumDeclaration
                        match = enumDeclaration_rule(parser);
                        if (! match) {
                           // AnnotationDeclaration
                           match = annotationDeclaration_rule(parser);
                        }
                     }
                  }
               }
            }
         }
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'b':
      case 'd':
      case '$':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'o':
      case 'q':
      case 'r':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
            if (! match) {
               // FieldsDeclarations
               match = fieldsDeclarations_rule(parser);
            }
         }
         break;
      }
      case 'c': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
            if (! match) {
               // FieldsDeclarations
               match = fieldsDeclarations_rule(parser);
               if (! match) {
                  // ClassDeclaration
                  match = classDeclaration_rule(parser);
               }
            }
         }
         break;
      }
      case 's': {
         // StaticBlock
         match = staticBlock_rule(parser);
         if (! match) {
            // MethodDeclaration
            match = methodDeclaration_rule(parser);
            if (! match) {
               // ConstructorDeclaration
               match = constructorDeclaration_rule(parser);
               if (! match) {
                  // FieldsDeclarations
                  match = fieldsDeclarations_rule(parser);
                  if (! match) {
                     // InterfaceDeclaration
                     match = interfaceDeclaration_rule(parser);
                     if (! match) {
                        // ClassDeclaration
                        match = classDeclaration_rule(parser);
                        if (! match) {
                           // EnumDeclaration
                           match = enumDeclaration_rule(parser);
                           if (! match) {
                              // AnnotationDeclaration
                              match = annotationDeclaration_rule(parser);
                           }
                        }
                     }
                  }
               }
            }
         }
         break;
      }
      case 'e': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
            if (! match) {
               // FieldsDeclarations
               match = fieldsDeclarations_rule(parser);
               if (! match) {
                  // EnumDeclaration
                  match = enumDeclaration_rule(parser);
               }
            }
         }
         break;
      }
      case 'i': {
         // MethodDeclaration
         match = methodDeclaration_rule(parser);
         if (! match) {
            // ConstructorDeclaration
            match = constructorDeclaration_rule(parser);
            if (! match) {
               // FieldsDeclarations
               match = fieldsDeclarations_rule(parser);
               if (! match) {
                  // InterfaceDeclaration
                  match = interfaceDeclaration_rule(parser);
               }
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_BODY_DECLARATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//StaticBlock : (('static' TestNoAlpha OptionalSpacing)? Block)
static BOOL staticBlock_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (('static' TestNoAlpha OptionalSpacing)? Block)
   // ('static' TestNoAlpha OptionalSpacing)?
   // ('static' TestNoAlpha OptionalSpacing)
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   // 'static'
   match = stringMatcher(parser, "static", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (! match) {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
            parser->currentNode = lastNode_1;
         }
      } else {
         parser->index = lastIndex_1;
         lastNode_1->sibling = NULL;
      }
   }
   // Block
   match = block_rule(parser);
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_STATIC_BLOCK, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Block : ('{' OptionalSpacing BlockStatements '}' OptionalSpacing)
static BOOL block_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing BlockStatements '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // BlockStatements
         match = blockStatements_rule(parser);
         if (match) {
            // '}'
            match = charMatcher(parser, '}');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BLOCK, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//MethodDeclaration : (Modifiers MethodSignature (Block | EmptyBody))
static BOOL methodDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers MethodSignature (Block | EmptyBody))
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // MethodSignature
      match = methodSignature_rule(parser);
      if (match) {
         // (Block | EmptyBody)
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '{': {
               // Block
               match = block_rule(parser);
               break;
            }
            case ';': {
               // EmptyBody
               match = emptyBody_rule(parser);
               break;
            }
            default: {
               match = FALSE;
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_METHOD_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConstructorDeclaration : (Modifiers TypeParameters? Identifier ParametersDeclarations Throws? Block)
static BOOL constructorDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers TypeParameters? Identifier ParametersDeclarations Throws? Block)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // TypeParameters?
      // TypeParameters
      typeParameters_rule(parser);
      // Identifier
      match = identifier_rule(parser);
      if (match) {
         // ParametersDeclarations
         match = parametersDeclarations_rule(parser);
         if (match) {
            // Throws?
            // Throws
            throws_rule(parser);
            // Block
            match = block_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CONSTRUCTOR_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//FieldsDeclarations : (Modifiers Type VariableDeclarations Semicolon)
static BOOL fieldsDeclarations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers Type VariableDeclarations Semicolon)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // VariableDeclarations
         match = variableDeclarations_rule(parser);
         if (match) {
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FIELDS_DECLARATIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Type : (Array | BasicType | QualifiedClassName)
static BOOL type_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->type_ruleMemoStart == parser->index) {
      if (parser->type_ruleMemoStart <= parser->type_ruleMemoEnd) {
         parser->index = parser->type_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->type_ruleMemoStart == parser->type_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_TYPE, parser->type_ruleMemoStart, parser->type_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->type_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->type_ruleMemoFirstNode;
               parser->currentNode = parser->type_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (Array | BasicType | QualifiedClassName)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // Array
         match = array_rule(parser);
         if (! match) {
            // QualifiedClassName
            match = qualifiedClassName_rule(parser);
         }
         break;
      }
      case 'b':
      case 'c':
      case 's':
      case 'd':
      case 'f':
      case 'i':
      case 'l': {
         // Array
         match = array_rule(parser);
         if (! match) {
            // BasicType
            match = basicType_rule(parser);
            if (! match) {
               // QualifiedClassName
               match = qualifiedClassName_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->type_ruleMemoStart = startIndex;
      parser->type_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->type_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_TYPE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->type_ruleMemoFirstNode = parser->currentNode;
         parser->type_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->type_ruleMemoStart = startIndex;
      parser->type_ruleMemoEnd = -1;
      parser->type_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VariableDeclarations : (VariableDeclaration (',' OptionalSpacing VariableDeclaration)*)
static BOOL variableDeclarations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableDeclaration (',' OptionalSpacing VariableDeclaration)*)
   // VariableDeclaration
   match = variableDeclaration_rule(parser);
   if (match) {
      // (',' OptionalSpacing VariableDeclaration)*
      do {
         // (',' OptionalSpacing VariableDeclaration)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // VariableDeclaration
               match = variableDeclaration_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_VARIABLE_DECLARATIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Throws : ('throws' TestNoAlpha OptionalSpacing ClassTypeList)
static BOOL throws_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('throws' TestNoAlpha OptionalSpacing ClassTypeList)
   // 'throws'
   match = stringMatcher(parser, "throws", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ClassTypeList
            match = classTypeList_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_THROWS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EmptyBody : Semicolon
static BOOL emptyBody_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // Semicolon
   match = semicolon_rule(parser);
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_EMPTY_BODY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ReturnType : (Type | ('void' TestNoAlpha OptionalSpacing))
static BOOL returnType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Type | ('void' TestNoAlpha OptionalSpacing))
   // Type
   match = type_rule(parser);
   if (! match) {
      // ('void' TestNoAlpha OptionalSpacing)
      YAPP_NODE * lastNode_1 = parser->currentNode;
      INT32 lastIndex_1 = parser->index;
      // 'void'
      match = stringMatcher(parser, "void", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         } else {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RETURN_TYPE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//MethodSignature : (TypeParameters? ReturnType Identifier ParametersDeclarations Dimensions Throws?)
static BOOL methodSignature_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (TypeParameters? ReturnType Identifier ParametersDeclarations Dimensions Throws?)
   // TypeParameters?
   // TypeParameters
   typeParameters_rule(parser);
   // ReturnType
   match = returnType_rule(parser);
   if (match) {
      // Identifier
      match = identifier_rule(parser);
      if (match) {
         // ParametersDeclarations
         match = parametersDeclarations_rule(parser);
         if (match) {
            // Dimensions
            match = dimensions_rule(parser);
            if (match) {
               // Throws?
               // Throws
               throws_rule(parser);
               match = TRUE;
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_METHOD_SIGNATURE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ParametersDeclarations : ('(' OptionalSpacing ParametersDeclarationList? ')' OptionalSpacing)
static BOOL parametersDeclarations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing ParametersDeclarationList? ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ParametersDeclarationList?
         // ParametersDeclarationList
         parametersDeclarationList_rule(parser);
         // ')'
         match = charMatcher(parser, ')');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PARAMETERS_DECLARATIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Dimensions : Dim*
static BOOL dimensions_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->dimensions_ruleMemoStart == parser->index) {
      if (parser->dimensions_ruleMemoStart <= parser->dimensions_ruleMemoEnd) {
         parser->index = parser->dimensions_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->dimensions_ruleMemoStart == parser->dimensions_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_DIMENSIONS, parser->dimensions_ruleMemoStart, parser->dimensions_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->dimensions_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->dimensions_ruleMemoFirstNode;
               parser->currentNode = parser->dimensions_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // Dim*
   do {
      // Dim
      match = dim_rule(parser);
   } while(match);
   parser->dimensions_ruleMemoStart = startIndex;
   parser->dimensions_ruleMemoEnd = parser->index;
   if (parser->currentRuleIsAtomic) {
      parser->dimensions_ruleMemoFirstNode = NULL;
   } else {
      parser->currentNode = createNode(parser, &JAVA_DIMENSIONS, startIndex, parser->index, TRUE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
      parser->dimensions_ruleMemoFirstNode = parser->currentNode;
      parser->dimensions_ruleMemoLastNode = parser->currentNode;
   }
   return TRUE;
}

//ExtendsInterfaces : ('extends' TestNoAlpha OptionalSpacing ClassTypeList)
static BOOL extendsInterfaces_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('extends' TestNoAlpha OptionalSpacing ClassTypeList)
   // 'extends'
   match = stringMatcher(parser, "extends", 7);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ClassTypeList
            match = classTypeList_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IMPLEMENTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InterfaceBody : ('{' OptionalSpacing InterfaceBodyDeclaration* '}' OptionalSpacing)
static BOOL interfaceBody_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing InterfaceBodyDeclaration* '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // InterfaceBodyDeclaration*
         do {
            // InterfaceBodyDeclaration
            match = interfaceBodyDeclaration_rule(parser);
         } while(match);
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INTERFACE_BODY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InterfaceBodyDeclaration : (InterfaceMethod | ConstantsDeclarations | InterfaceDeclaration | AnnotationDeclaration | ClassDeclaration | EnumDeclaration | Semicolon)
static BOOL interfaceBodyDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (InterfaceMethod | ConstantsDeclarations | InterfaceDeclaration | AnnotationDeclaration | ClassDeclaration | EnumDeclaration | Semicolon)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case ';': {
         // Semicolon
         match = semicolon_rule(parser);
         break;
      }
      case '<': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         break;
      }
      case '@':
      case 'p':
      case 'a':
      case 's':
      case 't':
      case 'f':
      case 'v':
      case 'n': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         if (! match) {
            // ConstantsDeclarations
            match = constantsDeclarations_rule(parser);
            if (! match) {
               // InterfaceDeclaration
               match = interfaceDeclaration_rule(parser);
               if (! match) {
                  // AnnotationDeclaration
                  match = annotationDeclaration_rule(parser);
                  if (! match) {
                     // ClassDeclaration
                     match = classDeclaration_rule(parser);
                     if (! match) {
                        // EnumDeclaration
                        match = enumDeclaration_rule(parser);
                     }
                  }
               }
            }
         }
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'b':
      case 'd':
      case '$':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'o':
      case 'q':
      case 'r':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         if (! match) {
            // ConstantsDeclarations
            match = constantsDeclarations_rule(parser);
         }
         break;
      }
      case 'c': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         if (! match) {
            // ConstantsDeclarations
            match = constantsDeclarations_rule(parser);
            if (! match) {
               // ClassDeclaration
               match = classDeclaration_rule(parser);
            }
         }
         break;
      }
      case 'e': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         if (! match) {
            // ConstantsDeclarations
            match = constantsDeclarations_rule(parser);
            if (! match) {
               // EnumDeclaration
               match = enumDeclaration_rule(parser);
            }
         }
         break;
      }
      case 'i': {
         // InterfaceMethod
         match = interfaceMethod_rule(parser);
         if (! match) {
            // ConstantsDeclarations
            match = constantsDeclarations_rule(parser);
            if (! match) {
               // InterfaceDeclaration
               match = interfaceDeclaration_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INTERFACE_BODY_DECLARATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InterfaceMethod : (Modifiers MethodSignature Semicolon)
static BOOL interfaceMethod_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers MethodSignature Semicolon)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // MethodSignature
      match = methodSignature_rule(parser);
      if (match) {
         // Semicolon
         match = semicolon_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INTERFACE_METHOD, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConstantsDeclarations : (Modifiers Type ConstantsDeclarationsList Semicolon)
static BOOL constantsDeclarations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers Type ConstantsDeclarationsList Semicolon)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // ConstantsDeclarationsList
         match = constantsDeclarationsList_rule(parser);
         if (match) {
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CONSTANTS_DECLARATIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConstantsDeclarationsList : (ConstantDeclaration (',' OptionalSpacing ConstantDeclaration)*)
static BOOL constantsDeclarationsList_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ConstantDeclaration (',' OptionalSpacing ConstantDeclaration)*)
   // ConstantDeclaration
   match = constantDeclaration_rule(parser);
   if (match) {
      // (',' OptionalSpacing ConstantDeclaration)*
      do {
         // (',' OptionalSpacing ConstantDeclaration)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // ConstantDeclaration
               match = constantDeclaration_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CONSTANTS_DECLARATIONS_LIST, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConstantDeclaration : (Identifier Dimensions '=' OptionalSpacing VariableInitializer)
static BOOL constantDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier Dimensions '=' OptionalSpacing VariableInitializer)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // Dimensions
      match = dimensions_rule(parser);
      if (match) {
         // '='
         match = charMatcher(parser, '=');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // VariableInitializer
               match = variableInitializer_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CONSTANT_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VariableInitializer : (ArrayInitializer | Expression)
static BOOL variableInitializer_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ArrayInitializer | Expression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // Expression
         match = expression_rule(parser);
         break;
      }
      case '{': {
         // ArrayInitializer
         match = arrayInitializer_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_VARIABLE_INITIALIZER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumBody : ('{' OptionalSpacing EnumConstants? (',' OptionalSpacing)? EnumBodyDeclarations? '}' OptionalSpacing)
static BOOL enumBody_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing EnumConstants? (',' OptionalSpacing)? EnumBodyDeclarations? '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // EnumConstants?
         // EnumConstants
         enumConstants_rule(parser);
         match = TRUE;
         // (',' OptionalSpacing)?
         // (',' OptionalSpacing)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
         // EnumBodyDeclarations?
         // EnumBodyDeclarations
         enumBodyDeclarations_rule(parser);
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_BODY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumConstants : (EnumConstant (',' OptionalSpacing EnumConstant)*)
static BOOL enumConstants_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (EnumConstant (',' OptionalSpacing EnumConstant)*)
   // EnumConstant
   match = enumConstant_rule(parser);
   if (match) {
      // (',' OptionalSpacing EnumConstant)*
      do {
         // (',' OptionalSpacing EnumConstant)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // EnumConstant
               match = enumConstant_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_CONSTANTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumBodyDeclarations : (Semicolon ClassBodyDeclaration*)
static BOOL enumBodyDeclarations_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Semicolon ClassBodyDeclaration*)
   // Semicolon
   match = semicolon_rule(parser);
   if (match) {
      // ClassBodyDeclaration*
      do {
         // ClassBodyDeclaration
         match = classBodyDeclaration_rule(parser);
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_BODY_DECLARATIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumConstant : (Annotations Identifier Arguments? ClassBody?)
static BOOL enumConstant_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Annotations Identifier Arguments? ClassBody?)
   // Annotations
   match = annotations_rule(parser);
   if (match) {
      // Identifier
      match = identifier_rule(parser);
      if (match) {
         // Arguments?
         // Arguments
         arguments_rule(parser);
         // ClassBody?
         // ClassBody
         classBody_rule(parser);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_CONSTANT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Arguments : ('(' OptionalSpacing (Expression (',' OptionalSpacing Expression)*)? ')' OptionalSpacing)
static BOOL arguments_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing (Expression (',' OptionalSpacing Expression)*)? ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // (Expression (',' OptionalSpacing Expression)*)?
         // (Expression (',' OptionalSpacing Expression)*)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // Expression
         match = expression_rule(parser);
         if (match) {
            // (',' OptionalSpacing Expression)*
            do {
               // (',' OptionalSpacing Expression)
               YAPP_NODE * lastNode_2 = parser->currentNode;
               INT32 lastIndex_2 = parser->index;
               // ','
               match = charMatcher(parser, ',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // Expression
                     match = expression_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_2;
                        lastNode_2->sibling = NULL;
                        parser->currentNode = lastNode_2;
                     }
                  } else {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                  }
               }
            } while(match);
            match = TRUE;
         }
         // ')'
         match = charMatcher(parser, ')');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARGUMENTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Final : ('final' TestNoAlpha OptionalSpacing)
static BOOL final_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('final' TestNoAlpha OptionalSpacing)
   // 'final'
   match = stringMatcher(parser, "final", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FINAL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VariableModifiers : (Final | Annotation)*
static BOOL variableModifiers_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Final | Annotation)*
   do {
      // (Final | Annotation)
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case '@': {
            // Annotation
            match = annotation_rule(parser);
            break;
         }
         case 'f': {
            // Final
            match = final_rule(parser);
            break;
         }
         default: {
            match = FALSE;
         }
      }
   } while(match);
   if (! parser->currentRuleIsAtomic) {
      parser->currentNode = createNode(parser, &JAVA_VARIABLE_MODIFIERS, startIndex, parser->index, TRUE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
   }
   return TRUE;
}

//LocalVariableDeclarationStatement : (VariableModifiers Type VariableDeclarations Semicolon)
static BOOL localVariableDeclarationStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableModifiers Type VariableDeclarations Semicolon)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // VariableDeclarations
         match = variableDeclarations_rule(parser);
         if (match) {
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_LOCAL_VARIABLE_DECLARATION_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VariableDeclaration : (Identifier Dimensions VariableInitialization?)
static BOOL variableDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier Dimensions VariableInitialization?)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // Dimensions
      match = dimensions_rule(parser);
      if (match) {
         // VariableInitialization?
         // VariableInitialization
         variableInitialization_rule(parser);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_VARIABLE_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VariableInitialization : ('=' OptionalSpacing VariableInitializer)
static BOOL variableInitialization_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('=' OptionalSpacing VariableInitializer)
   // '='
   match = charMatcher(parser, '=');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // VariableInitializer
         match = variableInitializer_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_VARIABLE_INITIALIZATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ParametersDeclarationList : ((ParameterDeclaration ',' OptionalSpacing ParametersDeclarationList) | ParameterDeclaration | ParameterVariableDeclaration)
static BOOL parametersDeclarationList_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ((ParameterDeclaration ',' OptionalSpacing ParametersDeclarationList) | ParameterDeclaration | ParameterVariableDeclaration)
   // (ParameterDeclaration ',' OptionalSpacing ParametersDeclarationList)
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   // ParameterDeclaration
   match = parameterDeclaration_rule(parser);
   if (match) {
      // ','
      match = charMatcher(parser, ',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ParametersDeclarationList
            match = parametersDeclarationList_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         } else {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
         }
      } else {
         parser->index = lastIndex_1;
         lastNode_1->sibling = NULL;
      }
   }
   if (! match) {
      // ParameterDeclaration
      match = parameterDeclaration_rule(parser);
      if (! match) {
         // ParameterVariableDeclaration
         match = parameterVariableDeclaration_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PARAMETERS_DECLARATION_LIST, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ParameterDeclaration : (VariableModifiers Type Identifier Dimensions)
static BOOL parameterDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->parameterDeclaration_ruleMemoStart == parser->index) {
      if (parser->parameterDeclaration_ruleMemoStart <= parser->parameterDeclaration_ruleMemoEnd) {
         parser->index = parser->parameterDeclaration_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->parameterDeclaration_ruleMemoStart == parser->parameterDeclaration_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_PARAMETER_DECLARATION, parser->parameterDeclaration_ruleMemoStart, parser->parameterDeclaration_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->parameterDeclaration_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->parameterDeclaration_ruleMemoFirstNode;
               parser->currentNode = parser->parameterDeclaration_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (VariableModifiers Type Identifier Dimensions)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // Identifier
         match = identifier_rule(parser);
         if (match) {
            // Dimensions
            match = dimensions_rule(parser);
         }
      }
   }
   if (match) {
      parser->parameterDeclaration_ruleMemoStart = startIndex;
      parser->parameterDeclaration_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->parameterDeclaration_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_PARAMETER_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->parameterDeclaration_ruleMemoFirstNode = parser->currentNode;
         parser->parameterDeclaration_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->parameterDeclaration_ruleMemoStart = startIndex;
      parser->parameterDeclaration_ruleMemoEnd = -1;
      parser->parameterDeclaration_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ParameterVariableDeclaration : (VariableModifiers Type '...' OptionalSpacing Identifier Dimensions)
static BOOL parameterVariableDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableModifiers Type '...' OptionalSpacing Identifier Dimensions)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // '...'
         match = stringMatcher(parser, "...", 3);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Identifier
               match = identifier_rule(parser);
               if (match) {
                  // Dimensions
                  match = dimensions_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PARAMETER_VARIABLE_DECLARATION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BlockStatements : BlockStatement*
static BOOL blockStatements_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // BlockStatement*
   do {
      // BlockStatement
      match = blockStatement_rule(parser);
   } while(match);
   if (! parser->currentRuleIsAtomic) {
      parser->currentNode = createNode(parser, &JAVA_BLOCK_STATEMENTS, startIndex, parser->index, TRUE, TRUE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
   }
   return TRUE;
}

//BlockStatement : (LocalVariableDeclarationStatement | ClassDeclaration | EnumDeclaration | Statement)
static BOOL blockStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (LocalVariableDeclarationStatement | ClassDeclaration | EnumDeclaration | Statement)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case ';':
      case '{':
      case '~': {
         // Statement
         match = statement_rule(parser);
         break;
      }
      case '@': {
         // LocalVariableDeclarationStatement
         match = localVariableDeclarationStatement_rule(parser);
         if (! match) {
            // ClassDeclaration
            match = classDeclaration_rule(parser);
            if (! match) {
               // EnumDeclaration
               match = enumDeclaration_rule(parser);
            }
         }
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'b':
      case 'd':
      case '$':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'o':
      case 'q':
      case 'r':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // LocalVariableDeclarationStatement
         match = localVariableDeclarationStatement_rule(parser);
         if (! match) {
            // Statement
            match = statement_rule(parser);
         }
         break;
      }
      case 'p':
      case 'a':
      case 's':
      case 't':
      case 'f':
      case 'v':
      case 'n': {
         // LocalVariableDeclarationStatement
         match = localVariableDeclarationStatement_rule(parser);
         if (! match) {
            // ClassDeclaration
            match = classDeclaration_rule(parser);
            if (! match) {
               // EnumDeclaration
               match = enumDeclaration_rule(parser);
               if (! match) {
                  // Statement
                  match = statement_rule(parser);
               }
            }
         }
         break;
      }
      case 'c': {
         // LocalVariableDeclarationStatement
         match = localVariableDeclarationStatement_rule(parser);
         if (! match) {
            // ClassDeclaration
            match = classDeclaration_rule(parser);
            if (! match) {
               // Statement
               match = statement_rule(parser);
            }
         }
         break;
      }
      case 'e': {
         // LocalVariableDeclarationStatement
         match = localVariableDeclarationStatement_rule(parser);
         if (! match) {
            // EnumDeclaration
            match = enumDeclaration_rule(parser);
            if (! match) {
               // Statement
               match = statement_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BLOCK_STATEMENT, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Statement : (Block | AssertStatement | IfStatement | ForStatement | ForIterableStatement | WhileStatement | DoWhileStatement | TryCatchStatement | SwitchStatement | SynchronizedStatement | ReturnStatement | ThrowStatement | BreakStatement | ContinueStatement | IdentifiedStatement | StatementExpression | Semicolon)
static BOOL statement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Block | AssertStatement | IfStatement | ForStatement | ForIterableStatement | WhileStatement | DoWhileStatement | TryCatchStatement | SwitchStatement | SynchronizedStatement | ReturnStatement | ThrowStatement | BreakStatement | ContinueStatement | IdentifiedStatement | StatementExpression | Semicolon)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '~': {
         // StatementExpression
         match = statementExpression_rule(parser);
         break;
      }
      case 'r': {
         // ReturnStatement
         match = returnStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case 's': {
         // SwitchStatement
         match = switchStatement_rule(parser);
         if (! match) {
            // SynchronizedStatement
            match = synchronizedStatement_rule(parser);
            if (! match) {
               // IdentifiedStatement
               match = identifiedStatement_rule(parser);
               if (! match) {
                  // StatementExpression
                  match = statementExpression_rule(parser);
               }
            }
         }
         break;
      }
      case 't': {
         // TryCatchStatement
         match = tryCatchStatement_rule(parser);
         if (! match) {
            // ThrowStatement
            match = throwStatement_rule(parser);
            if (! match) {
               // IdentifiedStatement
               match = identifiedStatement_rule(parser);
               if (! match) {
                  // StatementExpression
                  match = statementExpression_rule(parser);
               }
            }
         }
         break;
      }
      case 'w': {
         // WhileStatement
         match = whileStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case ';': {
         // Semicolon
         match = semicolon_rule(parser);
         break;
      }
      case '{': {
         // Block
         match = block_rule(parser);
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'u':
      case 'v':
      case 'x':
      case 'y':
      case 'z': {
         // IdentifiedStatement
         match = identifiedStatement_rule(parser);
         if (! match) {
            // StatementExpression
            match = statementExpression_rule(parser);
         }
         break;
      }
      case 'a': {
         // AssertStatement
         match = assertStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case 'b': {
         // BreakStatement
         match = breakStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case 'c': {
         // ContinueStatement
         match = continueStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case 'd': {
         // DoWhileStatement
         match = doWhileStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      case 'f': {
         // ForStatement
         match = forStatement_rule(parser);
         if (! match) {
            // ForIterableStatement
            match = forIterableStatement_rule(parser);
            if (! match) {
               // IdentifiedStatement
               match = identifiedStatement_rule(parser);
               if (! match) {
                  // StatementExpression
                  match = statementExpression_rule(parser);
               }
            }
         }
         break;
      }
      case 'i': {
         // IfStatement
         match = ifStatement_rule(parser);
         if (! match) {
            // IdentifiedStatement
            match = identifiedStatement_rule(parser);
            if (! match) {
               // StatementExpression
               match = statementExpression_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_STATEMENT, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AssertStatement : ('assert' TestNoAlpha OptionalSpacing Expression (':' OptionalSpacing Expression)? Semicolon)
static BOOL assertStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('assert' TestNoAlpha OptionalSpacing Expression (':' OptionalSpacing Expression)? Semicolon)
   // 'assert'
   match = stringMatcher(parser, "assert", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Expression
            match = expression_rule(parser);
            if (match) {
               // (':' OptionalSpacing Expression)?
               // (':' OptionalSpacing Expression)
               YAPP_NODE * lastNode_1 = parser->currentNode;
               INT32 lastIndex_1 = parser->index;
               // ':'
               match = charMatcher(parser, ':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // Expression
                     match = expression_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_1;
                        lastNode_1->sibling = NULL;
                        parser->currentNode = lastNode_1;
                     }
                  } else {
                     parser->index = lastIndex_1;
                     lastNode_1->sibling = NULL;
                  }
               }
               // Semicolon
               match = semicolon_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ASSERT_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//IfStatement : ('if' TestNoAlpha OptionalSpacing ParExpression Statement ElseStatement?)
static BOOL ifStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('if' TestNoAlpha OptionalSpacing ParExpression Statement ElseStatement?)
   // 'if'
   match = stringMatcher(parser, "if", 2);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ParExpression
            match = parExpression_rule(parser);
            if (match) {
               // Statement
               match = statement_rule(parser);
               if (match) {
                  // ElseStatement?
                  // ElseStatement
                  elseStatement_rule(parser);
                  match = TRUE;
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IF_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForStatement : ('for' TestNoAlpha OptionalSpacing '(' OptionalSpacing ForInit? Semicolon Expression? Semicolon ForUpdate? ')' OptionalSpacing Statement)
static BOOL forStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('for' TestNoAlpha OptionalSpacing '(' OptionalSpacing ForInit? Semicolon Expression? Semicolon ForUpdate? ')' OptionalSpacing Statement)
   // 'for'
   match = stringMatcher(parser, "for", 3);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // '('
            match = charMatcher(parser, '(');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // ForInit?
                  // ForInit
                  forInit_rule(parser);
                  // Semicolon
                  match = semicolon_rule(parser);
                  if (match) {
                     // Expression?
                     // Expression
                     expression_rule(parser);
                     // Semicolon
                     match = semicolon_rule(parser);
                     if (match) {
                        // ForUpdate?
                        // ForUpdate
                        forUpdate_rule(parser);
                        // ')'
                        match = charMatcher(parser, ')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing_rule(parser);
                           if (match) {
                              // Statement
                              match = statement_rule(parser);
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForIterableStatement : ('for' TestNoAlpha OptionalSpacing '(' OptionalSpacing ParameterDeclaration ':' OptionalSpacing Expression ')' OptionalSpacing Statement)
static BOOL forIterableStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('for' TestNoAlpha OptionalSpacing '(' OptionalSpacing ParameterDeclaration ':' OptionalSpacing Expression ')' OptionalSpacing Statement)
   // 'for'
   match = stringMatcher(parser, "for", 3);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // '('
            match = charMatcher(parser, '(');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // ParameterDeclaration
                  match = parameterDeclaration_rule(parser);
                  if (match) {
                     // ':'
                     match = charMatcher(parser, ':');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing_rule(parser);
                        if (match) {
                           // Expression
                           match = expression_rule(parser);
                           if (match) {
                              // ')'
                              match = charMatcher(parser, ')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing_rule(parser);
                                 if (match) {
                                    // Statement
                                    match = statement_rule(parser);
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_ITERABLE_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//WhileStatement : ('while' TestNoAlpha OptionalSpacing ParExpression Statement)
static BOOL whileStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('while' TestNoAlpha OptionalSpacing ParExpression Statement)
   // 'while'
   match = stringMatcher(parser, "while", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ParExpression
            match = parExpression_rule(parser);
            if (match) {
               // Statement
               match = statement_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_WHILE_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//DoWhileStatement : ('do' TestNoAlpha OptionalSpacing Statement 'while' TestNoAlpha OptionalSpacing ParExpression Semicolon)
static BOOL doWhileStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('do' TestNoAlpha OptionalSpacing Statement 'while' TestNoAlpha OptionalSpacing ParExpression Semicolon)
   // 'do'
   match = stringMatcher(parser, "do", 2);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Statement
            match = statement_rule(parser);
            if (match) {
               // 'while'
               match = stringMatcher(parser, "while", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha_rule(parser);
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (match) {
                        // ParExpression
                        match = parExpression_rule(parser);
                        if (match) {
                           // Semicolon
                           match = semicolon_rule(parser);
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DO_WHILE_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TryCatchStatement : ('try' TestNoAlpha OptionalSpacing ResourceSpecification? Block Catch* Finally?)
static BOOL tryCatchStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('try' TestNoAlpha OptionalSpacing ResourceSpecification? Block Catch* Finally?)
   // 'try'
   match = stringMatcher(parser, "try", 3);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ResourceSpecification?
            // ResourceSpecification
            resourceSpecification_rule(parser);
            // Block
            match = block_rule(parser);
            if (match) {
               // Catch*
               do {
                  // Catch
                  match = catch_rule(parser);
               } while(match);
               // Finally?
               // Finally
               finally_rule(parser);
               match = TRUE;
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TRY_CATCH_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ResourceSpecification : ('(' OptionalSpacing Resources (';' OptionalSpacing)? ')' OptionalSpacing)
static BOOL resourceSpecification_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing Resources (';' OptionalSpacing)? ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // Resources
         match = resources_rule(parser);
         if (match) {
            // (';' OptionalSpacing)?
            // (';' OptionalSpacing)
            YAPP_NODE * lastNode_1 = parser->currentNode;
            INT32 lastIndex_1 = parser->index;
            // ';'
            match = charMatcher(parser, ';');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            }
            // ')'
            match = charMatcher(parser, ')');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RESOURCE_SPECIFICATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Resources : (Resource (';' OptionalSpacing Resource)*)
static BOOL resources_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Resource (';' OptionalSpacing Resource)*)
   // Resource
   match = resource_rule(parser);
   if (match) {
      // (';' OptionalSpacing Resource)*
      do {
         // (';' OptionalSpacing Resource)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ';'
         match = charMatcher(parser, ';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Resource
               match = resource_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RESOURCES, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Resource : (VariableModifiers QualifiedClassName Identifier Dimensions '=' OptionalSpacing Expression)
static BOOL resource_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableModifiers QualifiedClassName Identifier Dimensions '=' OptionalSpacing Expression)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // QualifiedClassName
      match = qualifiedClassName_rule(parser);
      if (match) {
         // Identifier
         match = identifier_rule(parser);
         if (match) {
            // Dimensions
            match = dimensions_rule(parser);
            if (match) {
               // '='
               match = charMatcher(parser, '=');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // Expression
                     match = expression_rule(parser);
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RESOURCE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SwitchStatement : ('switch' TestNoAlpha OptionalSpacing ParExpression '{' OptionalSpacing SwitchBlockStatementGroups '}' OptionalSpacing)
static BOOL switchStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('switch' TestNoAlpha OptionalSpacing ParExpression '{' OptionalSpacing SwitchBlockStatementGroups '}' OptionalSpacing)
   // 'switch'
   match = stringMatcher(parser, "switch", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ParExpression
            match = parExpression_rule(parser);
            if (match) {
               // '{'
               match = charMatcher(parser, '{');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // SwitchBlockStatementGroups
                     match = switchBlockStatementGroups_rule(parser);
                     if (match) {
                        // '}'
                        match = charMatcher(parser, '}');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing_rule(parser);
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SWITCH_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SynchronizedStatement : ('synchronized' TestNoAlpha OptionalSpacing ParExpression Block)
static BOOL synchronizedStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('synchronized' TestNoAlpha OptionalSpacing ParExpression Block)
   // 'synchronized'
   match = stringMatcher(parser, "synchronized", 12);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ParExpression
            match = parExpression_rule(parser);
            if (match) {
               // Block
               match = block_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SYNCHRONIZED_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ReturnStatement : ('return' TestNoAlpha OptionalSpacing Expression? Semicolon)
static BOOL returnStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('return' TestNoAlpha OptionalSpacing Expression? Semicolon)
   // 'return'
   match = stringMatcher(parser, "return", 6);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Expression?
            // Expression
            expression_rule(parser);
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RETURN_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ThrowStatement : ('throw' TestNoAlpha OptionalSpacing Expression Semicolon)
static BOOL throwStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('throw' TestNoAlpha OptionalSpacing Expression Semicolon)
   // 'throw'
   match = stringMatcher(parser, "throw", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Expression
            match = expression_rule(parser);
            if (match) {
               // Semicolon
               match = semicolon_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_THROW_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BreakStatement : ('break' TestNoAlpha OptionalSpacing Identifier? Semicolon)
static BOOL breakStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('break' TestNoAlpha OptionalSpacing Identifier? Semicolon)
   // 'break'
   match = stringMatcher(parser, "break", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Identifier?
            // Identifier
            identifier_rule(parser);
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BREAK_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ContinueStatement : ('continue' TestNoAlpha OptionalSpacing Identifier? Semicolon)
static BOOL continueStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('continue' TestNoAlpha OptionalSpacing Identifier? Semicolon)
   // 'continue'
   match = stringMatcher(parser, "continue", 8);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Identifier?
            // Identifier
            identifier_rule(parser);
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CONTINUE_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//IdentifiedStatement : (Identifier ':' OptionalSpacing Statement)
static BOOL identifiedStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier ':' OptionalSpacing Statement)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // ':'
      match = charMatcher(parser, ':');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Statement
            match = statement_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_IDENTIFIED_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//StatementExpression : (Expression Semicolon)
static BOOL statementExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Expression Semicolon)
   // Expression
   match = expression_rule(parser);
   if (match) {
      // Semicolon
      match = semicolon_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_STATEMENT_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElseStatement : ('else' TestNoAlpha OptionalSpacing Statement)
static BOOL elseStatement_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('else' TestNoAlpha OptionalSpacing Statement)
   // 'else'
   match = stringMatcher(parser, "else", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Statement
            match = statement_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELSE_STATEMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ParExpression : ('(' OptionalSpacing Expression ')' OptionalSpacing)
static BOOL parExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing Expression ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // Expression
         match = expression_rule(parser);
         if (match) {
            // ')'
            match = charMatcher(parser, ')');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PAR_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Expression : (AssignmentExpression | ConditionalExpression)
static BOOL expression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (AssignmentExpression | ConditionalExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // AssignmentExpression
         match = assignmentExpression_rule(parser);
         if (! match) {
            // ConditionalExpression
            match = conditionalExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForInit : (ForInitVariables | ForInitExpressions)
static BOOL forInit_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ForInitVariables | ForInitExpressions)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '~': {
         // ForInitExpressions
         match = forInitExpressions_rule(parser);
         break;
      }
      case '@': {
         // ForInitVariables
         match = forInitVariables_rule(parser);
         break;
      }
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // ForInitVariables
         match = forInitVariables_rule(parser);
         if (! match) {
            // ForInitExpressions
            match = forInitExpressions_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_INIT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForUpdate : (Expression (',' OptionalSpacing Expression)*)
static BOOL forUpdate_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Expression (',' OptionalSpacing Expression)*)
   // Expression
   match = expression_rule(parser);
   if (match) {
      // (',' OptionalSpacing Expression)*
      do {
         // (',' OptionalSpacing Expression)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Expression
               match = expression_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_UPDATE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//CatchType : (QualifiedIdentifier ('|' OptionalSpacing QualifiedIdentifier)*)
static BOOL catchType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (QualifiedIdentifier ('|' OptionalSpacing QualifiedIdentifier)*)
   // QualifiedIdentifier
   match = qualifiedIdentifier_rule(parser);
   if (match) {
      // ('|' OptionalSpacing QualifiedIdentifier)*
      do {
         // ('|' OptionalSpacing QualifiedIdentifier)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '|'
         match = charMatcher(parser, '|');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // QualifiedIdentifier
               match = qualifiedIdentifier_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CATCH_TYPE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//CatchParameter : (VariableModifiers CatchType Identifier)
static BOOL catchParameter_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableModifiers CatchType Identifier)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // CatchType
      match = catchType_rule(parser);
      if (match) {
         // Identifier
         match = identifier_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CATCH_PARAMETER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Catch : ('catch' TestNoAlpha OptionalSpacing '(' OptionalSpacing CatchParameter ')' OptionalSpacing Block)
static BOOL catch_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('catch' TestNoAlpha OptionalSpacing '(' OptionalSpacing CatchParameter ')' OptionalSpacing Block)
   // 'catch'
   match = stringMatcher(parser, "catch", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // '('
            match = charMatcher(parser, '(');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // CatchParameter
                  match = catchParameter_rule(parser);
                  if (match) {
                     // ')'
                     match = charMatcher(parser, ')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing_rule(parser);
                        if (match) {
                           // Block
                           match = block_rule(parser);
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CATCH, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Finally : ('finally' TestNoAlpha OptionalSpacing Block)
static BOOL finally_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('finally' TestNoAlpha OptionalSpacing Block)
   // 'finally'
   match = stringMatcher(parser, "finally", 7);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Block
            match = block_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FINALLY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SwitchBlockStatementGroups : SwitchBlockStatementGroup*
static BOOL switchBlockStatementGroups_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // SwitchBlockStatementGroup*
   do {
      // SwitchBlockStatementGroup
      match = switchBlockStatementGroup_rule(parser);
   } while(match);
   if (! parser->currentRuleIsAtomic) {
      parser->currentNode = createNode(parser, &JAVA_SWITCH_BLOCK_STATEMENT_GROUPS, startIndex, parser->index, TRUE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
   }
   return TRUE;
}

//SwitchBlockStatementGroup : (SwitchLabel BlockStatements)
static BOOL switchBlockStatementGroup_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (SwitchLabel BlockStatements)
   // SwitchLabel
   match = switchLabel_rule(parser);
   if (match) {
      // BlockStatements
      match = blockStatements_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SWITCH_BLOCK_STATEMENT_GROUP, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SwitchLabel : (('case' TestNoAlpha OptionalSpacing Expression ':' OptionalSpacing) | ('case' TestNoAlpha OptionalSpacing EnumConstantName ':' OptionalSpacing) | ('default' TestNoAlpha OptionalSpacing ':' OptionalSpacing))
static BOOL switchLabel_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (('case' TestNoAlpha OptionalSpacing Expression ':' OptionalSpacing) | ('case' TestNoAlpha OptionalSpacing EnumConstantName ':' OptionalSpacing) | ('default' TestNoAlpha OptionalSpacing ':' OptionalSpacing))
   // ('case' TestNoAlpha OptionalSpacing Expression ':' OptionalSpacing)
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   // 'case'
   match = stringMatcher(parser, "case", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Expression
            match = expression_rule(parser);
            if (match) {
               // ':'
               match = charMatcher(parser, ':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (! match) {
                     parser->index = lastIndex_1;
                     lastNode_1->sibling = NULL;
                     parser->currentNode = lastNode_1;
                  }
               } else {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         } else {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
         }
      } else {
         parser->index = lastIndex_1;
         lastNode_1->sibling = NULL;
      }
   }
   if (! match) {
      // ('case' TestNoAlpha OptionalSpacing EnumConstantName ':' OptionalSpacing)
      YAPP_NODE * lastNode_2 = parser->currentNode;
      INT32 lastIndex_2 = parser->index;
      // 'case'
      match = stringMatcher(parser, "case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // EnumConstantName
               match = enumConstantName_rule(parser);
               if (match) {
                  // ':'
                  match = charMatcher(parser, ':');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_2;
                        lastNode_2->sibling = NULL;
                        parser->currentNode = lastNode_2;
                     }
                  } else {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                  }
               } else {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
               }
            } else {
               parser->index = lastIndex_2;
               lastNode_2->sibling = NULL;
            }
         } else {
            parser->index = lastIndex_2;
            lastNode_2->sibling = NULL;
         }
      }
      if (! match) {
         // ('default' TestNoAlpha OptionalSpacing ':' OptionalSpacing)
         YAPP_NODE * lastNode_3 = parser->currentNode;
         INT32 lastIndex_3 = parser->index;
         // 'default'
         match = stringMatcher(parser, "default", 7);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha_rule(parser);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // ':'
                  match = charMatcher(parser, ':');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_3;
                        lastNode_3->sibling = NULL;
                        parser->currentNode = lastNode_3;
                     }
                  } else {
                     parser->index = lastIndex_3;
                     lastNode_3->sibling = NULL;
                  }
               } else {
                  parser->index = lastIndex_3;
                  lastNode_3->sibling = NULL;
               }
            } else {
               parser->index = lastIndex_3;
               lastNode_3->sibling = NULL;
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SWITCH_LABEL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EnumConstantName : Identifier
static BOOL enumConstantName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ENUM_CONSTANT_NAME, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForInitVariables : (VariableModifiers Type VariableDeclarations)
static BOOL forInitVariables_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (VariableModifiers Type VariableDeclarations)
   // VariableModifiers
   match = variableModifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // VariableDeclarations
         match = variableDeclarations_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_INIT_VARIABLES, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ForInitExpressions : (Expression (',' OptionalSpacing Expression)*)
static BOOL forInitExpressions_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Expression (',' OptionalSpacing Expression)*)
   // Expression
   match = expression_rule(parser);
   if (match) {
      // (',' OptionalSpacing Expression)*
      do {
         // (',' OptionalSpacing Expression)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // Expression
               match = expression_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FOR_INIT_EXPRESSIONS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AssignmentExpression : (ConditionalExpression AssignmentOperator Expression)
static BOOL assignmentExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ConditionalExpression AssignmentOperator Expression)
   // ConditionalExpression
   match = conditionalExpression_rule(parser);
   if (match) {
      // AssignmentOperator
      match = assignmentOperator_rule(parser);
      if (match) {
         // Expression
         match = expression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ASSIGNMENT_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConditionalExpression : (TernaryExpression | ConditionalOrExpression)
static BOOL conditionalExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->conditionalExpression_ruleMemoStart == parser->index) {
      if (parser->conditionalExpression_ruleMemoStart <= parser->conditionalExpression_ruleMemoEnd) {
         parser->index = parser->conditionalExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->conditionalExpression_ruleMemoStart == parser->conditionalExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_EXPRESSION, parser->conditionalExpression_ruleMemoStart, parser->conditionalExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->conditionalExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->conditionalExpression_ruleMemoFirstNode;
               parser->currentNode = parser->conditionalExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (TernaryExpression | ConditionalOrExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // TernaryExpression
         match = ternaryExpression_rule(parser);
         if (! match) {
            // ConditionalOrExpression
            match = conditionalOrExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->conditionalExpression_ruleMemoStart = startIndex;
      parser->conditionalExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->conditionalExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->conditionalExpression_ruleMemoFirstNode = parser->currentNode;
         parser->conditionalExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->conditionalExpression_ruleMemoStart = startIndex;
      parser->conditionalExpression_ruleMemoEnd = -1;
      parser->conditionalExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AssignmentOperator : (('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '%=' | '<<=' | '>>=' | '>>>=') OptionalSpacing)
static BOOL assignmentOperator_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->assignmentOperator_ruleMemoStart == parser->index) {
      if (parser->assignmentOperator_ruleMemoStart <= parser->assignmentOperator_ruleMemoEnd) {
         parser->index = parser->assignmentOperator_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->assignmentOperator_ruleMemoStart == parser->assignmentOperator_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_ASSIGNMENT_OPERATOR, parser->assignmentOperator_ruleMemoStart, parser->assignmentOperator_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->assignmentOperator_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->assignmentOperator_ruleMemoFirstNode;
               parser->currentNode = parser->assignmentOperator_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '%=' | '<<=' | '>>=' | '>>>=') OptionalSpacing)
   // ('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '%=' | '<<=' | '>>=' | '>>>=')
   INT32 startIndex_1 = parser->index;
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '+': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '|': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '<': {
         ++parser->index;
         // '<='
         if (match = stringTest(parser, "<=", 2)) {
            parser->index += 2;
         }
         break;
      }
      case '=': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      case '-': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '^': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '>': {
         ++parser->index;
         // ('>>=' | '>=')
         if (yapp_buffer_matchChar(parser->buffer, parser->index, '>')) {
            ++parser->index;
            // ('>=' | '=')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case '=': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '>': {
                  ++parser->index;
                  // '='
                  if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
                     ++parser->index;
                  }
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
         } else {
            match = FALSE;
         }
         break;
      }
      case '/': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '%': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '&': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      case '*': {
         ++parser->index;
         // '='
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
            ++parser->index;
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (! match) {
      parser->index = startIndex_1;
   } else if(! parser->currentRuleIsAtomic) {
      NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
   }
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
   }
   if (match) {
      parser->assignmentOperator_ruleMemoStart = startIndex;
      parser->assignmentOperator_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->assignmentOperator_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_ASSIGNMENT_OPERATOR, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->assignmentOperator_ruleMemoFirstNode = parser->currentNode;
         parser->assignmentOperator_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->assignmentOperator_ruleMemoStart = startIndex;
      parser->assignmentOperator_ruleMemoEnd = -1;
      parser->assignmentOperator_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TernaryExpression : (ConditionalOrExpression '?' OptionalSpacing Expression ':' OptionalSpacing ConditionalExpression)
static BOOL ternaryExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ConditionalOrExpression '?' OptionalSpacing Expression ':' OptionalSpacing ConditionalExpression)
   // ConditionalOrExpression
   match = conditionalOrExpression_rule(parser);
   if (match) {
      // '?'
      match = charMatcher(parser, '?');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Expression
            match = expression_rule(parser);
            if (match) {
               // ':'
               match = charMatcher(parser, ':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // ConditionalExpression
                     match = conditionalExpression_rule(parser);
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TERNARY_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConditionalOrExpression : (OrExpression | ConditionalAndExpression)
static BOOL conditionalOrExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->conditionalOrExpression_ruleMemoStart == parser->index) {
      if (parser->conditionalOrExpression_ruleMemoStart <= parser->conditionalOrExpression_ruleMemoEnd) {
         parser->index = parser->conditionalOrExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->conditionalOrExpression_ruleMemoStart == parser->conditionalOrExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_OR_EXPRESSION, parser->conditionalOrExpression_ruleMemoStart, parser->conditionalOrExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->conditionalOrExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->conditionalOrExpression_ruleMemoFirstNode;
               parser->currentNode = parser->conditionalOrExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (OrExpression | ConditionalAndExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // OrExpression
         match = orExpression_rule(parser);
         if (! match) {
            // ConditionalAndExpression
            match = conditionalAndExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->conditionalOrExpression_ruleMemoStart = startIndex;
      parser->conditionalOrExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->conditionalOrExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_OR_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->conditionalOrExpression_ruleMemoFirstNode = parser->currentNode;
         parser->conditionalOrExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->conditionalOrExpression_ruleMemoStart = startIndex;
      parser->conditionalOrExpression_ruleMemoEnd = -1;
      parser->conditionalOrExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OrExpression : (ConditionalAndExpression '||' OptionalSpacing ConditionalOrExpression)
static BOOL orExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ConditionalAndExpression '||' OptionalSpacing ConditionalOrExpression)
   // ConditionalAndExpression
   match = conditionalAndExpression_rule(parser);
   if (match) {
      // '||'
      match = stringMatcher(parser, "||", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ConditionalOrExpression
            match = conditionalOrExpression_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_OR_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ConditionalAndExpression : (AndExpression | OptionalBitOrExpression)
static BOOL conditionalAndExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->conditionalAndExpression_ruleMemoStart == parser->index) {
      if (parser->conditionalAndExpression_ruleMemoStart <= parser->conditionalAndExpression_ruleMemoEnd) {
         parser->index = parser->conditionalAndExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->conditionalAndExpression_ruleMemoStart == parser->conditionalAndExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_AND_EXPRESSION, parser->conditionalAndExpression_ruleMemoStart, parser->conditionalAndExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->conditionalAndExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->conditionalAndExpression_ruleMemoFirstNode;
               parser->currentNode = parser->conditionalAndExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (AndExpression | OptionalBitOrExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // AndExpression
         match = andExpression_rule(parser);
         if (! match) {
            // OptionalBitOrExpression
            match = optionalBitOrExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->conditionalAndExpression_ruleMemoStart = startIndex;
      parser->conditionalAndExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->conditionalAndExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_CONDITIONAL_AND_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->conditionalAndExpression_ruleMemoFirstNode = parser->currentNode;
         parser->conditionalAndExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->conditionalAndExpression_ruleMemoStart = startIndex;
      parser->conditionalAndExpression_ruleMemoEnd = -1;
      parser->conditionalAndExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AndExpression : (OptionalBitOrExpression '&&' OptionalSpacing ConditionalAndExpression)
static BOOL andExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalBitOrExpression '&&' OptionalSpacing ConditionalAndExpression)
   // OptionalBitOrExpression
   match = optionalBitOrExpression_rule(parser);
   if (match) {
      // '&&'
      match = stringMatcher(parser, "&&", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ConditionalAndExpression
            match = conditionalAndExpression_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_AND_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalBitOrExpression : (BitOrExpression | OptionalBitXOrExpression)
static BOOL optionalBitOrExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalBitOrExpression_ruleMemoStart == parser->index) {
      if (parser->optionalBitOrExpression_ruleMemoStart <= parser->optionalBitOrExpression_ruleMemoEnd) {
         parser->index = parser->optionalBitOrExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalBitOrExpression_ruleMemoStart == parser->optionalBitOrExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_OR_EXPRESSION, parser->optionalBitOrExpression_ruleMemoStart, parser->optionalBitOrExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalBitOrExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalBitOrExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalBitOrExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BitOrExpression | OptionalBitXOrExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // BitOrExpression
         match = bitOrExpression_rule(parser);
         if (! match) {
            // OptionalBitXOrExpression
            match = optionalBitXOrExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalBitOrExpression_ruleMemoStart = startIndex;
      parser->optionalBitOrExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalBitOrExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_OR_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalBitOrExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalBitOrExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalBitOrExpression_ruleMemoStart = startIndex;
      parser->optionalBitOrExpression_ruleMemoEnd = -1;
      parser->optionalBitOrExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BitOrExpression : (OptionalBitXOrExpression '|' OptionalSpacing OptionalBitOrExpression)
static BOOL bitOrExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalBitXOrExpression '|' OptionalSpacing OptionalBitOrExpression)
   // OptionalBitXOrExpression
   match = optionalBitXOrExpression_rule(parser);
   if (match) {
      // '|'
      match = charMatcher(parser, '|');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // OptionalBitOrExpression
            match = optionalBitOrExpression_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BIT_OR_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalBitXOrExpression : (BitXOrExpression | OptionalBitAndExpression)
static BOOL optionalBitXOrExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalBitXOrExpression_ruleMemoStart == parser->index) {
      if (parser->optionalBitXOrExpression_ruleMemoStart <= parser->optionalBitXOrExpression_ruleMemoEnd) {
         parser->index = parser->optionalBitXOrExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalBitXOrExpression_ruleMemoStart == parser->optionalBitXOrExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_XOR_EXPRESSION, parser->optionalBitXOrExpression_ruleMemoStart, parser->optionalBitXOrExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalBitXOrExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalBitXOrExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalBitXOrExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BitXOrExpression | OptionalBitAndExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // BitXOrExpression
         match = bitXOrExpression_rule(parser);
         if (! match) {
            // OptionalBitAndExpression
            match = optionalBitAndExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalBitXOrExpression_ruleMemoStart = startIndex;
      parser->optionalBitXOrExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalBitXOrExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_XOR_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalBitXOrExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalBitXOrExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalBitXOrExpression_ruleMemoStart = startIndex;
      parser->optionalBitXOrExpression_ruleMemoEnd = -1;
      parser->optionalBitXOrExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BitXOrExpression : (OptionalBitAndExpression '^' OptionalSpacing OptionalBitXOrExpression)
static BOOL bitXOrExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalBitAndExpression '^' OptionalSpacing OptionalBitXOrExpression)
   // OptionalBitAndExpression
   match = optionalBitAndExpression_rule(parser);
   if (match) {
      // '^'
      match = charMatcher(parser, '^');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // OptionalBitXOrExpression
            match = optionalBitXOrExpression_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BIT_XOR_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalBitAndExpression : (BitAndExpression | OptionalRelationalExpression)
static BOOL optionalBitAndExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalBitAndExpression_ruleMemoStart == parser->index) {
      if (parser->optionalBitAndExpression_ruleMemoStart <= parser->optionalBitAndExpression_ruleMemoEnd) {
         parser->index = parser->optionalBitAndExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalBitAndExpression_ruleMemoStart == parser->optionalBitAndExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_AND_EXPRESSION, parser->optionalBitAndExpression_ruleMemoStart, parser->optionalBitAndExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalBitAndExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalBitAndExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalBitAndExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BitAndExpression | OptionalRelationalExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // BitAndExpression
         match = bitAndExpression_rule(parser);
         if (! match) {
            // OptionalRelationalExpression
            match = optionalRelationalExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalBitAndExpression_ruleMemoStart = startIndex;
      parser->optionalBitAndExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalBitAndExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_BIT_AND_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalBitAndExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalBitAndExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalBitAndExpression_ruleMemoStart = startIndex;
      parser->optionalBitAndExpression_ruleMemoEnd = -1;
      parser->optionalBitAndExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BitAndExpression : (OptionalRelationalExpression '&' OptionalSpacing OptionalBitAndExpression)
static BOOL bitAndExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalRelationalExpression '&' OptionalSpacing OptionalBitAndExpression)
   // OptionalRelationalExpression
   match = optionalRelationalExpression_rule(parser);
   if (match) {
      // '&'
      match = charMatcher(parser, '&');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // OptionalBitAndExpression
            match = optionalBitAndExpression_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BIT_AND_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalRelationalExpression : (RelationalExpression | OptionalInstanceOfExpression)
static BOOL optionalRelationalExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalRelationalExpression_ruleMemoStart == parser->index) {
      if (parser->optionalRelationalExpression_ruleMemoStart <= parser->optionalRelationalExpression_ruleMemoEnd) {
         parser->index = parser->optionalRelationalExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalRelationalExpression_ruleMemoStart == parser->optionalRelationalExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_RELATIONAL_EXPRESSION, parser->optionalRelationalExpression_ruleMemoStart, parser->optionalRelationalExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalRelationalExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalRelationalExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalRelationalExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (RelationalExpression | OptionalInstanceOfExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // RelationalExpression
         match = relationalExpression_rule(parser);
         if (! match) {
            // OptionalInstanceOfExpression
            match = optionalInstanceOfExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalRelationalExpression_ruleMemoStart = startIndex;
      parser->optionalRelationalExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalRelationalExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_RELATIONAL_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalRelationalExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalRelationalExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalRelationalExpression_ruleMemoStart = startIndex;
      parser->optionalRelationalExpression_ruleMemoEnd = -1;
      parser->optionalRelationalExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//RelationalExpression : (OptionalInstanceOfExpression (('==' | '!=' | '<=' | '>=' | '<' | '>') OptionalSpacing) OptionalRelationalExpression)
static BOOL relationalExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalInstanceOfExpression (('==' | '!=' | '<=' | '>=' | '<' | '>') OptionalSpacing) OptionalRelationalExpression)
   // OptionalInstanceOfExpression
   match = optionalInstanceOfExpression_rule(parser);
   if (match) {
      // (('==' | '!=' | '<=' | '>=' | '<' | '>') OptionalSpacing)
      // ('==' | '!=' | '<=' | '>=' | '<' | '>')
      INT32 startIndex_1 = parser->index;
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case '<': {
            ++parser->index;
            // ('=' | <EMPTY>)
            if (yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
            } else {
               match = TRUE;
            }
            break;
         }
         case '=': {
            ++parser->index;
            // '='
            if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
               ++parser->index;
            }
            break;
         }
         case '>': {
            ++parser->index;
            // ('=' | <EMPTY>)
            if (yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
            } else {
               match = TRUE;
            }
            break;
         }
         case '!': {
            ++parser->index;
            // '='
            if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '=')) {
               ++parser->index;
            }
            break;
         }
         default: {
            match = FALSE;
         }
      }
      if (! match) {
         parser->index = startIndex_1;
      } else if(! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
      if (match) {
         // OptionalRelationalExpression
         match = optionalRelationalExpression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_RELATIONAL_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalInstanceOfExpression : (InstanceOfExpression | OptionalAdditiveExpression)
static BOOL optionalInstanceOfExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalInstanceOfExpression_ruleMemoStart == parser->index) {
      if (parser->optionalInstanceOfExpression_ruleMemoStart <= parser->optionalInstanceOfExpression_ruleMemoEnd) {
         parser->index = parser->optionalInstanceOfExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalInstanceOfExpression_ruleMemoStart == parser->optionalInstanceOfExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_INSTANCE_OF_EXPRESSION, parser->optionalInstanceOfExpression_ruleMemoStart, parser->optionalInstanceOfExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalInstanceOfExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalInstanceOfExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalInstanceOfExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (InstanceOfExpression | OptionalAdditiveExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // InstanceOfExpression
         match = instanceOfExpression_rule(parser);
         if (! match) {
            // OptionalAdditiveExpression
            match = optionalAdditiveExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalInstanceOfExpression_ruleMemoStart = startIndex;
      parser->optionalInstanceOfExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalInstanceOfExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_INSTANCE_OF_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalInstanceOfExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalInstanceOfExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalInstanceOfExpression_ruleMemoStart = startIndex;
      parser->optionalInstanceOfExpression_ruleMemoEnd = -1;
      parser->optionalInstanceOfExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InstanceOfExpression : (OptionalAdditiveExpression 'instanceof' TestNoAlpha OptionalSpacing ReferenceType)
static BOOL instanceOfExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalAdditiveExpression 'instanceof' TestNoAlpha OptionalSpacing ReferenceType)
   // OptionalAdditiveExpression
   match = optionalAdditiveExpression_rule(parser);
   if (match) {
      // 'instanceof'
      match = stringMatcher(parser, "instanceof", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha_rule(parser);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // ReferenceType
               match = referenceType_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INSTANCE_OF_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalAdditiveExpression : (AdditiveExpression | OptionalMultiplicativeExpression)
static BOOL optionalAdditiveExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalAdditiveExpression_ruleMemoStart == parser->index) {
      if (parser->optionalAdditiveExpression_ruleMemoStart <= parser->optionalAdditiveExpression_ruleMemoEnd) {
         parser->index = parser->optionalAdditiveExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalAdditiveExpression_ruleMemoStart == parser->optionalAdditiveExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_ADDITIVE_EXPRESSION, parser->optionalAdditiveExpression_ruleMemoStart, parser->optionalAdditiveExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalAdditiveExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalAdditiveExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalAdditiveExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (AdditiveExpression | OptionalMultiplicativeExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // AdditiveExpression
         match = additiveExpression_rule(parser);
         if (! match) {
            // OptionalMultiplicativeExpression
            match = optionalMultiplicativeExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalAdditiveExpression_ruleMemoStart = startIndex;
      parser->optionalAdditiveExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalAdditiveExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_ADDITIVE_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalAdditiveExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalAdditiveExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalAdditiveExpression_ruleMemoStart = startIndex;
      parser->optionalAdditiveExpression_ruleMemoEnd = -1;
      parser->optionalAdditiveExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ReferenceType : (BasicTypeArray | QualifiedClassNameArray | QualifiedClassName)
static BOOL referenceType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->referenceType_ruleMemoStart == parser->index) {
      if (parser->referenceType_ruleMemoStart <= parser->referenceType_ruleMemoEnd) {
         parser->index = parser->referenceType_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->referenceType_ruleMemoStart == parser->referenceType_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_REFERENCE_TYPE, parser->referenceType_ruleMemoStart, parser->referenceType_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->referenceType_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->referenceType_ruleMemoFirstNode;
               parser->currentNode = parser->referenceType_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BasicTypeArray | QualifiedClassNameArray | QualifiedClassName)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // QualifiedClassNameArray
         match = qualifiedClassNameArray_rule(parser);
         if (! match) {
            // QualifiedClassName
            match = qualifiedClassName_rule(parser);
         }
         break;
      }
      case 'b':
      case 'c':
      case 's':
      case 'd':
      case 'f':
      case 'i':
      case 'l': {
         // BasicTypeArray
         match = basicTypeArray_rule(parser);
         if (! match) {
            // QualifiedClassNameArray
            match = qualifiedClassNameArray_rule(parser);
            if (! match) {
               // QualifiedClassName
               match = qualifiedClassName_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->referenceType_ruleMemoStart = startIndex;
      parser->referenceType_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->referenceType_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_REFERENCE_TYPE, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->referenceType_ruleMemoFirstNode = parser->currentNode;
         parser->referenceType_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->referenceType_ruleMemoStart = startIndex;
      parser->referenceType_ruleMemoEnd = -1;
      parser->referenceType_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AdditiveExpression : (OptionalMultiplicativeExpression (('+' | '-') OptionalSpacing) OptionalAdditiveExpression)
static BOOL additiveExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalMultiplicativeExpression (('+' | '-') OptionalSpacing) OptionalAdditiveExpression)
   // OptionalMultiplicativeExpression
   match = optionalMultiplicativeExpression_rule(parser);
   if (match) {
      // (('+' | '-') OptionalSpacing)
      // ('+' | '-')
      INT32 startIndex_1 = parser->index;
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case '+': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case '-': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         default: {
            match = FALSE;
         }
      }
      if (! match) {
         parser->index = startIndex_1;
      } else if(! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
      if (match) {
         // OptionalAdditiveExpression
         match = optionalAdditiveExpression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ADDITIVE_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalMultiplicativeExpression : (MultiplicativeExpression | OptionalShiftExpression)
static BOOL optionalMultiplicativeExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalMultiplicativeExpression_ruleMemoStart == parser->index) {
      if (parser->optionalMultiplicativeExpression_ruleMemoStart <= parser->optionalMultiplicativeExpression_ruleMemoEnd) {
         parser->index = parser->optionalMultiplicativeExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalMultiplicativeExpression_ruleMemoStart == parser->optionalMultiplicativeExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_MULTIPLICATIVE_EXPRESSION, parser->optionalMultiplicativeExpression_ruleMemoStart, parser->optionalMultiplicativeExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalMultiplicativeExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalMultiplicativeExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalMultiplicativeExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (MultiplicativeExpression | OptionalShiftExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // MultiplicativeExpression
         match = multiplicativeExpression_rule(parser);
         if (! match) {
            // OptionalShiftExpression
            match = optionalShiftExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalMultiplicativeExpression_ruleMemoStart = startIndex;
      parser->optionalMultiplicativeExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalMultiplicativeExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_MULTIPLICATIVE_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalMultiplicativeExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalMultiplicativeExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalMultiplicativeExpression_ruleMemoStart = startIndex;
      parser->optionalMultiplicativeExpression_ruleMemoEnd = -1;
      parser->optionalMultiplicativeExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//MultiplicativeExpression : (OptionalShiftExpression (('*' | '/' | '%') OptionalSpacing) OptionalMultiplicativeExpression)
static BOOL multiplicativeExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (OptionalShiftExpression (('*' | '/' | '%') OptionalSpacing) OptionalMultiplicativeExpression)
   // OptionalShiftExpression
   match = optionalShiftExpression_rule(parser);
   if (match) {
      // (('*' | '/' | '%') OptionalSpacing)
      // ('*' | '/' | '%')
      INT32 startIndex_1 = parser->index;
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case '/': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case '%': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case '*': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         default: {
            match = FALSE;
         }
      }
      if (! match) {
         parser->index = startIndex_1;
      } else if(! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
      if (match) {
         // OptionalMultiplicativeExpression
         match = optionalMultiplicativeExpression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_MULTIPLICATIVE_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalShiftExpression : (ShiftExpression | UnaryExpression)
static BOOL optionalShiftExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalShiftExpression_ruleMemoStart == parser->index) {
      if (parser->optionalShiftExpression_ruleMemoStart <= parser->optionalShiftExpression_ruleMemoEnd) {
         parser->index = parser->optionalShiftExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalShiftExpression_ruleMemoStart == parser->optionalShiftExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_OPTIONAL_SHIFT_EXPRESSION, parser->optionalShiftExpression_ruleMemoStart, parser->optionalShiftExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalShiftExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalShiftExpression_ruleMemoFirstNode;
               parser->currentNode = parser->optionalShiftExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (ShiftExpression | UnaryExpression)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // ShiftExpression
         match = shiftExpression_rule(parser);
         if (! match) {
            // UnaryExpression
            match = unaryExpression_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->optionalShiftExpression_ruleMemoStart = startIndex;
      parser->optionalShiftExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->optionalShiftExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_OPTIONAL_SHIFT_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->optionalShiftExpression_ruleMemoFirstNode = parser->currentNode;
         parser->optionalShiftExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->optionalShiftExpression_ruleMemoStart = startIndex;
      parser->optionalShiftExpression_ruleMemoEnd = -1;
      parser->optionalShiftExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ShiftExpression : (UnaryExpression (('<<' | '>>>' | '>>') OptionalSpacing) OptionalShiftExpression)
static BOOL shiftExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (UnaryExpression (('<<' | '>>>' | '>>') OptionalSpacing) OptionalShiftExpression)
   // UnaryExpression
   match = unaryExpression_rule(parser);
   if (match) {
      // (('<<' | '>>>' | '>>') OptionalSpacing)
      // ('<<' | '>>>' | '>>')
      INT32 startIndex_1 = parser->index;
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case '<': {
            ++parser->index;
            // '<'
            if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '<')) {
               ++parser->index;
            }
            break;
         }
         case '>': {
            ++parser->index;
            // ('>>' | '>')
            if (yapp_buffer_matchChar(parser->buffer, parser->index, '>')) {
               ++parser->index;
               // ('>' | <EMPTY>)
               if (yapp_buffer_matchChar(parser->buffer, parser->index, '>')) {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
               } else {
                  match = TRUE;
               }
            } else {
               match = FALSE;
            }
            break;
         }
         default: {
            match = FALSE;
         }
      }
      if (! match) {
         parser->index = startIndex_1;
      } else if(! parser->currentRuleIsAtomic) {
         NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
      if (match) {
         // OptionalShiftExpression
         match = optionalShiftExpression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SHIFT_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//UnaryExpression : (PrefixedExpression | CastExpression | PostfixedExpression | Primary)
static BOOL unaryExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->unaryExpression_ruleMemoStart == parser->index) {
      if (parser->unaryExpression_ruleMemoStart <= parser->unaryExpression_ruleMemoEnd) {
         parser->index = parser->unaryExpression_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->unaryExpression_ruleMemoStart == parser->unaryExpression_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_UNARY_EXPRESSION, parser->unaryExpression_ruleMemoStart, parser->unaryExpression_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->unaryExpression_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->unaryExpression_ruleMemoFirstNode;
               parser->currentNode = parser->unaryExpression_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (PrefixedExpression | CastExpression | PostfixedExpression | Primary)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '+':
      case '-':
      case '~': {
         // PrefixedExpression
         match = prefixedExpression_rule(parser);
         break;
      }
      case '\"':
      case '$':
      case '\'':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // PostfixedExpression
         match = postfixedExpression_rule(parser);
         if (! match) {
            // Primary
            match = primary_rule(parser);
         }
         break;
      }
      case '(': {
         // CastExpression
         match = castExpression_rule(parser);
         if (! match) {
            // PostfixedExpression
            match = postfixedExpression_rule(parser);
            if (! match) {
               // Primary
               match = primary_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->unaryExpression_ruleMemoStart = startIndex;
      parser->unaryExpression_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->unaryExpression_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_UNARY_EXPRESSION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->unaryExpression_ruleMemoFirstNode = parser->currentNode;
         parser->unaryExpression_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->unaryExpression_ruleMemoStart = startIndex;
      parser->unaryExpression_ruleMemoEnd = -1;
      parser->unaryExpression_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//PrefixedExpression : (PrefixOp OptionalSpacing Expression)
static BOOL prefixedExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (PrefixOp OptionalSpacing Expression)
   // PrefixOp
   match = prefixOp_rule(parser);
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // Expression
         match = expression_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PREFIXED_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//CastExpression : ('(' OptionalSpacing Type ')' OptionalSpacing Expression)
static BOOL castExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing Type ')' OptionalSpacing Expression)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // Type
         match = type_rule(parser);
         if (match) {
            // ')'
            match = charMatcher(parser, ')');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // Expression
                  match = expression_rule(parser);
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CAST_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//PostfixedExpression : (Primary PostFixOp+)
static BOOL postfixedExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Primary PostFixOp+)
   // Primary
   match = primary_rule(parser);
   if (match) {
      // PostFixOp+
      // PostFixOp
      match = postFixOp_rule(parser);
      if (match) {
         do {
            // PostFixOp
            match = postFixOp_rule(parser);
         } while(match);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_POSTFIXED_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//PrefixOp : ('++' | '--' | '!' | '~' | '+' | '-')
static BOOL prefixOp_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('++' | '--' | '!' | '~' | '+' | '-')
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '+': {
         ++parser->index;
         // ('+' | <EMPTY>)
         if (yapp_buffer_matchChar(parser->buffer, parser->index, '+')) {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
         } else {
            match = TRUE;
         }
         break;
      }
      case '-': {
         ++parser->index;
         // ('-' | <EMPTY>)
         if (yapp_buffer_matchChar(parser->buffer, parser->index, '-')) {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
         } else {
            match = TRUE;
         }
         break;
      }
      case '~': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      case '!': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_PREFIX_OP, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//PostFixOp : (('++' | '--') OptionalSpacing)
static BOOL postFixOp_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (('++' | '--') OptionalSpacing)
   // ('++' | '--')
   INT32 startIndex_1 = parser->index;
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '+': {
         ++parser->index;
         // '+'
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '+')) {
            ++parser->index;
         }
         break;
      }
      case '-': {
         ++parser->index;
         // '-'
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '-')) {
            ++parser->index;
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (! match) {
      parser->index = startIndex_1;
   } else if(! parser->currentRuleIsAtomic) {
      NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_1, parser->index, FALSE, FALSE));
   }
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_POST_FIX_OP, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Primary : (QualifiedExpression | ArrayAccess | Atomic)
static BOOL primary_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->primary_ruleMemoStart == parser->index) {
      if (parser->primary_ruleMemoStart <= parser->primary_ruleMemoEnd) {
         parser->index = parser->primary_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->primary_ruleMemoStart == parser->primary_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_PRIMARY, parser->primary_ruleMemoStart, parser->primary_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->primary_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->primary_ruleMemoFirstNode;
               parser->currentNode = parser->primary_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (QualifiedExpression | ArrayAccess | Atomic)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // QualifiedExpression
         match = qualifiedExpression_rule(parser);
         if (! match) {
            // ArrayAccess
            match = arrayAccess_rule(parser);
            if (! match) {
               // Atomic
               match = atomic_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->primary_ruleMemoStart = startIndex;
      parser->primary_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->primary_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_PRIMARY, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->primary_ruleMemoFirstNode = parser->currentNode;
         parser->primary_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->primary_ruleMemoStart = startIndex;
      parser->primary_ruleMemoEnd = -1;
      parser->primary_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//QualifiedExpression : ((ArrayAccess | Atomic) ('.' OptionalSpacing NonWildcardTypeArguments? (ArrayAccess | Atomic))+)
static BOOL qualifiedExpression_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ((ArrayAccess | Atomic) ('.' OptionalSpacing NonWildcardTypeArguments? (ArrayAccess | Atomic))+)
   // (ArrayAccess | Atomic)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // ArrayAccess
         match = arrayAccess_rule(parser);
         if (! match) {
            // Atomic
            match = atomic_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      // ('.' OptionalSpacing NonWildcardTypeArguments? (ArrayAccess | Atomic))+
      // ('.' OptionalSpacing NonWildcardTypeArguments? (ArrayAccess | Atomic))
      YAPP_NODE * lastNode_1 = parser->currentNode;
      INT32 lastIndex_1 = parser->index;
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // NonWildcardTypeArguments?
            // NonWildcardTypeArguments
            nonWildcardTypeArguments_rule(parser);
            match = TRUE;
            // (ArrayAccess | Atomic)
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case '\"':
               case '$':
               case '\'':
               case '(':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z': {
                  // ArrayAccess
                  match = arrayAccess_rule(parser);
                  if (! match) {
                     // Atomic
                     match = atomic_rule(parser);
                  }
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
         } else {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
         }
      }
      if (match) {
         do {
            // ('.' OptionalSpacing NonWildcardTypeArguments? (ArrayAccess | Atomic))
            YAPP_NODE * lastNode_2 = parser->currentNode;
            INT32 lastIndex_2 = parser->index;
            // '.'
            match = charMatcher(parser, '.');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // NonWildcardTypeArguments?
                  // NonWildcardTypeArguments
                  nonWildcardTypeArguments_rule(parser);
                  match = TRUE;
                  // (ArrayAccess | Atomic)
                  switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                     case '\"':
                     case '$':
                     case '\'':
                     case '(':
                     case '.':
                     case '0':
                     case '1':
                     case '2':
                     case '3':
                     case '4':
                     case '5':
                     case '6':
                     case '7':
                     case '8':
                     case '9':
                     case 'A':
                     case 'B':
                     case 'C':
                     case 'D':
                     case 'E':
                     case 'F':
                     case 'G':
                     case 'H':
                     case 'I':
                     case 'J':
                     case 'K':
                     case 'L':
                     case 'M':
                     case 'N':
                     case 'O':
                     case 'P':
                     case 'Q':
                     case 'R':
                     case 'S':
                     case 'T':
                     case 'U':
                     case 'V':
                     case 'W':
                     case 'X':
                     case 'Y':
                     case 'Z':
                     case '_':
                     case 'a':
                     case 'b':
                     case 'c':
                     case 'd':
                     case 'e':
                     case 'f':
                     case 'g':
                     case 'h':
                     case 'i':
                     case 'j':
                     case 'k':
                     case 'l':
                     case 'm':
                     case 'n':
                     case 'o':
                     case 'p':
                     case 'q':
                     case 'r':
                     case 's':
                     case 't':
                     case 'u':
                     case 'v':
                     case 'w':
                     case 'x':
                     case 'y':
                     case 'z': {
                        // ArrayAccess
                        match = arrayAccess_rule(parser);
                        if (! match) {
                           // Atomic
                           match = atomic_rule(parser);
                        }
                        break;
                     }
                     default: {
                        match = FALSE;
                     }
                  }
               } else {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
               }
            }
         } while(match);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_QUALIFIED_EXPRESSION, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ArrayAccess : (Atomic ArrayIndex)
static BOOL arrayAccess_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Atomic ArrayIndex)
   // Atomic
   match = atomic_rule(parser);
   if (match) {
      // ArrayIndex
      match = arrayIndex_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARRAY_ACCESS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Atomic : (ParExpression | ClassTypeReference | Literal | BasicTypeClassReference | VoidClassReference | ThisMethodCall | This | SuperMethodCall | SuperConstructorCall | SuperFieldAccess | ClassCreator | ArrayCreator | MethodCall | Identifier)
static BOOL atomic_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->atomic_ruleMemoStart == parser->index) {
      if (parser->atomic_ruleMemoStart <= parser->atomic_ruleMemoEnd) {
         parser->index = parser->atomic_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->atomic_ruleMemoStart == parser->atomic_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_ATOMIC, parser->atomic_ruleMemoStart, parser->atomic_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->atomic_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->atomic_ruleMemoFirstNode;
               parser->currentNode = parser->atomic_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (ParExpression | ClassTypeReference | Literal | BasicTypeClassReference | VoidClassReference | ThisMethodCall | This | SuperMethodCall | SuperConstructorCall | SuperFieldAccess | ClassCreator | ArrayCreator | MethodCall | Identifier)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '\"':
      case '\'':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': {
         // Literal
         match = literal_rule(parser);
         break;
      }
      case 'n': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // Literal
            match = literal_rule(parser);
            if (! match) {
               // ClassCreator
               match = classCreator_rule(parser);
               if (! match) {
                  // ArrayCreator
                  match = arrayCreator_rule(parser);
                  if (! match) {
                     // MethodCall
                     match = methodCall_rule(parser);
                     if (! match) {
                        // Identifier
                        match = identifier_rule(parser);
                     }
                  }
               }
            }
         }
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // MethodCall
            match = methodCall_rule(parser);
            if (! match) {
               // Identifier
               match = identifier_rule(parser);
            }
         }
         break;
      }
      case 'b':
      case 'c':
      case 'd':
      case 'i':
      case 'l': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // BasicTypeClassReference
            match = basicTypeClassReference_rule(parser);
            if (! match) {
               // MethodCall
               match = methodCall_rule(parser);
               if (! match) {
                  // Identifier
                  match = identifier_rule(parser);
               }
            }
         }
         break;
      }
      case 's': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // BasicTypeClassReference
            match = basicTypeClassReference_rule(parser);
            if (! match) {
               // SuperMethodCall
               match = superMethodCall_rule(parser);
               if (! match) {
                  // SuperConstructorCall
                  match = superConstructorCall_rule(parser);
                  if (! match) {
                     // SuperFieldAccess
                     match = superFieldAccess_rule(parser);
                     if (! match) {
                        // MethodCall
                        match = methodCall_rule(parser);
                        if (! match) {
                           // Identifier
                           match = identifier_rule(parser);
                        }
                     }
                  }
               }
            }
         }
         break;
      }
      case 't': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // Literal
            match = literal_rule(parser);
            if (! match) {
               // ThisMethodCall
               match = thisMethodCall_rule(parser);
               if (! match) {
                  // This
                  match = this_rule(parser);
                  if (! match) {
                     // MethodCall
                     match = methodCall_rule(parser);
                     if (! match) {
                        // Identifier
                        match = identifier_rule(parser);
                     }
                  }
               }
            }
         }
         break;
      }
      case 'f': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // Literal
            match = literal_rule(parser);
            if (! match) {
               // BasicTypeClassReference
               match = basicTypeClassReference_rule(parser);
               if (! match) {
                  // MethodCall
                  match = methodCall_rule(parser);
                  if (! match) {
                     // Identifier
                     match = identifier_rule(parser);
                  }
               }
            }
         }
         break;
      }
      case 'v': {
         // ClassTypeReference
         match = classTypeReference_rule(parser);
         if (! match) {
            // VoidClassReference
            match = voidClassReference_rule(parser);
            if (! match) {
               // MethodCall
               match = methodCall_rule(parser);
               if (! match) {
                  // Identifier
                  match = identifier_rule(parser);
               }
            }
         }
         break;
      }
      case '(': {
         // ParExpression
         match = parExpression_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->atomic_ruleMemoStart = startIndex;
      parser->atomic_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->atomic_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_ATOMIC, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->atomic_ruleMemoFirstNode = parser->currentNode;
         parser->atomic_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->atomic_ruleMemoStart = startIndex;
      parser->atomic_ruleMemoEnd = -1;
      parser->atomic_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassTypeReference : (QualifiedIdentifier Dimensions '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
static BOOL classTypeReference_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (QualifiedIdentifier Dimensions '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
   // QualifiedIdentifier
   match = qualifiedIdentifier_rule(parser);
   if (match) {
      // Dimensions
      match = dimensions_rule(parser);
      if (match) {
         // '.'
         match = charMatcher(parser, '.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // 'class'
               match = stringMatcher(parser, "class", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha_rule(parser);
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_TYPE_REFERENCE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Literal : ((FloatLiteral | LongLiteral | IntegerLiteral | CharLiteral | StringLiteral | True | False | Null) OptionalSpacing)
static BOOL literal_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ((FloatLiteral | LongLiteral | IntegerLiteral | CharLiteral | StringLiteral | True | False | Null) OptionalSpacing)
   // (FloatLiteral | LongLiteral | IntegerLiteral | CharLiteral | StringLiteral | True | False | Null)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '.': {
         // FloatLiteral
         match = floatLiteral_rule(parser);
         break;
      }
      case 'n': {
         // Null
         match = null_rule(parser);
         break;
      }
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': {
         // FloatLiteral
         match = floatLiteral_rule(parser);
         if (! match) {
            // LongLiteral
            match = longLiteral_rule(parser);
            if (! match) {
               // IntegerLiteral
               match = integerLiteral_rule(parser);
            }
         }
         break;
      }
      case '\"': {
         // StringLiteral
         match = stringLiteral_rule(parser);
         break;
      }
      case 't': {
         // True
         match = true_rule(parser);
         break;
      }
      case 'f': {
         // False
         match = false_rule(parser);
         break;
      }
      case '\'': {
         // CharLiteral
         match = charLiteral_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_LITERAL, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BasicTypeClassReference : (BasicType Dimensions '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
static BOOL basicTypeClassReference_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (BasicType Dimensions '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
   // BasicType
   match = basicType_rule(parser);
   if (match) {
      // Dimensions
      match = dimensions_rule(parser);
      if (match) {
         // '.'
         match = charMatcher(parser, '.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // 'class'
               match = stringMatcher(parser, "class", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha_rule(parser);
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BASIC_TYPE_CLASS_REFERENCE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//VoidClassReference : ('void' TestNoAlpha OptionalSpacing '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
static BOOL voidClassReference_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('void' TestNoAlpha OptionalSpacing '.' OptionalSpacing 'class' TestNoAlpha OptionalSpacing)
   // 'void'
   match = stringMatcher(parser, "void", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // '.'
            match = charMatcher(parser, '.');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // 'class'
                  match = stringMatcher(parser, "class", 5);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha_rule(parser);
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing_rule(parser);
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_VOID_CLASS_REFERENCE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ThisMethodCall : (This Arguments)
static BOOL thisMethodCall_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (This Arguments)
   // This
   match = this_rule(parser);
   if (match) {
      // Arguments
      match = arguments_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_THIS_METHOD_CALL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//This : ('this' TestNoAlpha OptionalSpacing)
static BOOL this_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->this_ruleMemoStart == parser->index) {
      if (parser->this_ruleMemoStart <= parser->this_ruleMemoEnd) {
         parser->index = parser->this_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->this_ruleMemoStart == parser->this_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_THIS, parser->this_ruleMemoStart, parser->this_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->this_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->this_ruleMemoFirstNode;
               parser->currentNode = parser->this_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // ('this' TestNoAlpha OptionalSpacing)
   // 'this'
   match = stringMatcher(parser, "this", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      parser->this_ruleMemoStart = startIndex;
      parser->this_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->this_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_THIS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->this_ruleMemoFirstNode = parser->currentNode;
         parser->this_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->this_ruleMemoStart = startIndex;
      parser->this_ruleMemoEnd = -1;
      parser->this_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Super : ('super' TestNoAlpha OptionalSpacing)
static BOOL super_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->super_ruleMemoStart == parser->index) {
      if (parser->super_ruleMemoStart <= parser->super_ruleMemoEnd) {
         parser->index = parser->super_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->super_ruleMemoStart == parser->super_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_SUPER, parser->super_ruleMemoStart, parser->super_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->super_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->super_ruleMemoFirstNode;
               parser->currentNode = parser->super_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // ('super' TestNoAlpha OptionalSpacing)
   // 'super'
   match = stringMatcher(parser, "super", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      parser->super_ruleMemoStart = startIndex;
      parser->super_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->super_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_SUPER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->super_ruleMemoFirstNode = parser->currentNode;
         parser->super_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->super_ruleMemoStart = startIndex;
      parser->super_ruleMemoEnd = -1;
      parser->super_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SuperMethodCall : (Super '.' OptionalSpacing Identifier Arguments)
static BOOL superMethodCall_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Super '.' OptionalSpacing Identifier Arguments)
   // Super
   match = super_rule(parser);
   if (match) {
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Identifier
            match = identifier_rule(parser);
            if (match) {
               // Arguments
               match = arguments_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SUPER_METHOD_CALL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SuperConstructorCall : (Super Arguments)
static BOOL superConstructorCall_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Super Arguments)
   // Super
   match = super_rule(parser);
   if (match) {
      // Arguments
      match = arguments_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SUPER_CONSTRUCTOR_CALL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SuperFieldAccess : (Super '.' OptionalSpacing Identifier)
static BOOL superFieldAccess_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Super '.' OptionalSpacing Identifier)
   // Super
   match = super_rule(parser);
   if (match) {
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // Identifier
            match = identifier_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SUPER_FIELD_ACCESS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//New : ('new' TestNoAlpha OptionalSpacing)
static BOOL new_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->new_ruleMemoStart == parser->index) {
      if (parser->new_ruleMemoStart <= parser->new_ruleMemoEnd) {
         parser->index = parser->new_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->new_ruleMemoStart == parser->new_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_NEW, parser->new_ruleMemoStart, parser->new_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->new_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->new_ruleMemoFirstNode;
               parser->currentNode = parser->new_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // ('new' TestNoAlpha OptionalSpacing)
   // 'new'
   match = stringMatcher(parser, "new", 3);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      parser->new_ruleMemoStart = startIndex;
      parser->new_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->new_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_NEW, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->new_ruleMemoFirstNode = parser->currentNode;
         parser->new_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->new_ruleMemoStart = startIndex;
      parser->new_ruleMemoEnd = -1;
      parser->new_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassCreator : (New CreatedName Arguments ClassBody?)
static BOOL classCreator_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (New CreatedName Arguments ClassBody?)
   // New
   match = new_rule(parser);
   if (match) {
      // CreatedName
      match = createdName_rule(parser);
      if (match) {
         // Arguments
         match = arguments_rule(parser);
         if (match) {
            // ClassBody?
            // ClassBody
            classBody_rule(parser);
            match = TRUE;
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_CREATOR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ArrayCreator : (InitializedArrayCreator | EmptyArrayCreator)
static BOOL arrayCreator_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (InitializedArrayCreator | EmptyArrayCreator)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'n': {
         // InitializedArrayCreator
         match = initializedArrayCreator_rule(parser);
         if (! match) {
            // EmptyArrayCreator
            match = emptyArrayCreator_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARRAY_CREATOR, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//MethodCall : (Identifier Arguments)
static BOOL methodCall_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->methodCall_ruleMemoStart == parser->index) {
      if (parser->methodCall_ruleMemoStart <= parser->methodCall_ruleMemoEnd) {
         parser->index = parser->methodCall_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->methodCall_ruleMemoStart == parser->methodCall_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_METHOD_CALL, parser->methodCall_ruleMemoStart, parser->methodCall_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->methodCall_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->methodCall_ruleMemoFirstNode;
               parser->currentNode = parser->methodCall_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (Identifier Arguments)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // Arguments
      match = arguments_rule(parser);
   }
   if (match) {
      parser->methodCall_ruleMemoStart = startIndex;
      parser->methodCall_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->methodCall_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_METHOD_CALL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->methodCall_ruleMemoFirstNode = parser->currentNode;
         parser->methodCall_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->methodCall_ruleMemoStart = startIndex;
      parser->methodCall_ruleMemoEnd = -1;
      parser->methodCall_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ArrayIndex : DimExpr+
static BOOL arrayIndex_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->arrayIndex_ruleMemoStart == parser->index) {
      if (parser->arrayIndex_ruleMemoStart <= parser->arrayIndex_ruleMemoEnd) {
         parser->index = parser->arrayIndex_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->arrayIndex_ruleMemoStart == parser->arrayIndex_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_ARRAY_INDEX, parser->arrayIndex_ruleMemoStart, parser->arrayIndex_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->arrayIndex_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->arrayIndex_ruleMemoFirstNode;
               parser->currentNode = parser->arrayIndex_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // DimExpr+
   // DimExpr
   match = dimExpr_rule(parser);
   if (match) {
      do {
         // DimExpr
         match = dimExpr_rule(parser);
      } while(match);
      match = TRUE;
   }
   if (match) {
      parser->arrayIndex_ruleMemoStart = startIndex;
      parser->arrayIndex_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->arrayIndex_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_ARRAY_INDEX, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->arrayIndex_ruleMemoFirstNode = parser->currentNode;
         parser->arrayIndex_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->arrayIndex_ruleMemoStart = startIndex;
      parser->arrayIndex_ruleMemoEnd = -1;
      parser->arrayIndex_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//DimExpr : ('[' OptionalSpacing Expression ']' OptionalSpacing)
static BOOL dimExpr_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('[' OptionalSpacing Expression ']' OptionalSpacing)
   // '['
   match = charMatcher(parser, '[');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // Expression
         match = expression_rule(parser);
         if (match) {
            // ']'
            match = charMatcher(parser, ']');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DIM_EXPR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BasicType : (BasicTypeName TestNoAlpha OptionalSpacing)
static BOOL basicType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->basicType_ruleMemoStart == parser->index) {
      if (parser->basicType_ruleMemoStart <= parser->basicType_ruleMemoEnd) {
         parser->index = parser->basicType_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->basicType_ruleMemoStart == parser->basicType_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_BASIC_TYPE, parser->basicType_ruleMemoStart, parser->basicType_ruleMemoEnd, TRUE, TRUE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->basicType_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->basicType_ruleMemoFirstNode;
               parser->currentNode = parser->basicType_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BasicTypeName TestNoAlpha OptionalSpacing)
   // BasicTypeName
   match = basicTypeName_rule(parser);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      parser->basicType_ruleMemoStart = startIndex;
      parser->basicType_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->basicType_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_BASIC_TYPE, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->basicType_ruleMemoFirstNode = parser->currentNode;
         parser->basicType_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->basicType_ruleMemoStart = startIndex;
      parser->basicType_ruleMemoEnd = -1;
      parser->basicType_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BasicTypeName : ('byte' | 'short' | 'char' | 'int' | 'long' | 'float' | 'double' | 'boolean')
static BOOL basicTypeName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('byte' | 'short' | 'char' | 'int' | 'long' | 'float' | 'double' | 'boolean')
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'l': {
         ++parser->index;
         // 'ong'
         if (match = stringTest(parser, "ong", 3)) {
            parser->index += 3;
         }
         break;
      }
      case 'b': {
         ++parser->index;
         // ('oolean' | 'yte')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'o': {
               ++parser->index;
               // 'olean'
               if (match = stringTest(parser, "olean", 5)) {
                  parser->index += 5;
               }
               break;
            }
            case 'y': {
               ++parser->index;
               // 'te'
               if (match = stringTest(parser, "te", 2)) {
                  parser->index += 2;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         break;
      }
      case 's': {
         ++parser->index;
         // 'hort'
         if (match = stringTest(parser, "hort", 4)) {
            parser->index += 4;
         }
         break;
      }
      case 'c': {
         ++parser->index;
         // 'har'
         if (match = stringTest(parser, "har", 3)) {
            parser->index += 3;
         }
         break;
      }
      case 'd': {
         ++parser->index;
         // 'ouble'
         if (match = stringTest(parser, "ouble", 5)) {
            parser->index += 5;
         }
         break;
      }
      case 'f': {
         ++parser->index;
         // 'loat'
         if (match = stringTest(parser, "loat", 4)) {
            parser->index += 4;
         }
         break;
      }
      case 'i': {
         ++parser->index;
         // 'nt'
         if (match = stringTest(parser, "nt", 2)) {
            parser->index += 2;
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BASIC_TYPE, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//NonWildcardTypeArguments : ('<' OptionalSpacing (ReferenceType (',' OptionalSpacing ReferenceType)*)? '>' OptionalSpacing)
static BOOL nonWildcardTypeArguments_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('<' OptionalSpacing (ReferenceType (',' OptionalSpacing ReferenceType)*)? '>' OptionalSpacing)
   // '<'
   match = charMatcher(parser, '<');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // (ReferenceType (',' OptionalSpacing ReferenceType)*)?
         // (ReferenceType (',' OptionalSpacing ReferenceType)*)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ReferenceType
         match = referenceType_rule(parser);
         if (match) {
            // (',' OptionalSpacing ReferenceType)*
            do {
               // (',' OptionalSpacing ReferenceType)
               YAPP_NODE * lastNode_2 = parser->currentNode;
               INT32 lastIndex_2 = parser->index;
               // ','
               match = charMatcher(parser, ',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // ReferenceType
                     match = referenceType_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_2;
                        lastNode_2->sibling = NULL;
                        parser->currentNode = lastNode_2;
                     }
                  } else {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                  }
               }
            } while(match);
            match = TRUE;
         }
         // '>'
         match = charMatcher(parser, '>');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_NON_WILDCARD_TYPE_ARGUMENTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//CreatedName : (TypeName ('.' OptionalSpacing TypeName)*)
static BOOL createdName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (TypeName ('.' OptionalSpacing TypeName)*)
   // TypeName
   match = typeName_rule(parser);
   if (match) {
      // ('.' OptionalSpacing TypeName)*
      do {
         // ('.' OptionalSpacing TypeName)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '.'
         match = charMatcher(parser, '.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // TypeName
               match = typeName_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CREATED_NAME, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//InitializedArrayCreator : (New ArrayType Dim+ ArrayInitializer)
static BOOL initializedArrayCreator_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (New ArrayType Dim+ ArrayInitializer)
   // New
   match = new_rule(parser);
   if (match) {
      // ArrayType
      match = arrayType_rule(parser);
      if (match) {
         // Dim+
         // Dim
         match = dim_rule(parser);
         if (match) {
            do {
               // Dim
               match = dim_rule(parser);
            } while(match);
            match = TRUE;
         }
         if (match) {
            // ArrayInitializer
            match = arrayInitializer_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_INITIALIZED_ARRAY_CREATOR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//EmptyArrayCreator : (New ArrayType DimExpr+ Dimensions)
static BOOL emptyArrayCreator_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (New ArrayType DimExpr+ Dimensions)
   // New
   match = new_rule(parser);
   if (match) {
      // ArrayType
      match = arrayType_rule(parser);
      if (match) {
         // DimExpr+
         // DimExpr
         match = dimExpr_rule(parser);
         if (match) {
            do {
               // DimExpr
               match = dimExpr_rule(parser);
            } while(match);
            match = TRUE;
         }
         if (match) {
            // Dimensions
            match = dimensions_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_EMPTY_ARRAY_CREATOR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ArrayType : (QualifiedClassName | BasicType)
static BOOL arrayType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (QualifiedClassName | BasicType)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // QualifiedClassName
         match = qualifiedClassName_rule(parser);
         break;
      }
      case 'b':
      case 'c':
      case 's':
      case 'd':
      case 'f':
      case 'i':
      case 'l': {
         // QualifiedClassName
         match = qualifiedClassName_rule(parser);
         if (! match) {
            // BasicType
            match = basicType_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARRAY_TYPE, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Dim : ('[' OptionalSpacing ']' OptionalSpacing)
static BOOL dim_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('[' OptionalSpacing ']' OptionalSpacing)
   // '['
   match = charMatcher(parser, '[');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ']'
         match = charMatcher(parser, ']');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DIM, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ArrayInitializer : ('{' OptionalSpacing (VariableInitializer (',' OptionalSpacing VariableInitializer)*)? (',' OptionalSpacing)? '}' OptionalSpacing)
static BOOL arrayInitializer_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing (VariableInitializer (',' OptionalSpacing VariableInitializer)*)? (',' OptionalSpacing)? '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // (VariableInitializer (',' OptionalSpacing VariableInitializer)*)?
         // (VariableInitializer (',' OptionalSpacing VariableInitializer)*)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // VariableInitializer
         match = variableInitializer_rule(parser);
         if (match) {
            // (',' OptionalSpacing VariableInitializer)*
            do {
               // (',' OptionalSpacing VariableInitializer)
               YAPP_NODE * lastNode_2 = parser->currentNode;
               INT32 lastIndex_2 = parser->index;
               // ','
               match = charMatcher(parser, ',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // VariableInitializer
                     match = variableInitializer_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_2;
                        lastNode_2->sibling = NULL;
                        parser->currentNode = lastNode_2;
                     }
                  } else {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                  }
               }
            } while(match);
            match = TRUE;
         }
         match = TRUE;
         // (',' OptionalSpacing)?
         // (',' OptionalSpacing)
         YAPP_NODE * lastNode_3 = parser->currentNode;
         INT32 lastIndex_3 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (! match) {
               parser->index = lastIndex_3;
               lastNode_3->sibling = NULL;
               parser->currentNode = lastNode_3;
            }
         }
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARRAY_INITIALIZER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypedName : (Identifier NonWildcardTypeArguments)
static BOOL typedName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier NonWildcardTypeArguments)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // NonWildcardTypeArguments
      match = nonWildcardTypeArguments_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPED_NAME, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeName : (TypedName | Identifier)
static BOOL typeName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (TypedName | Identifier)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // TypedName
         match = typedName_rule(parser);
         if (! match) {
            // Identifier
            match = identifier_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPE_NAME, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Array : ((BasicType | QualifiedClassName) Dim+)
static BOOL array_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ((BasicType | QualifiedClassName) Dim+)
   // (BasicType | QualifiedClassName)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case '$':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // QualifiedClassName
         match = qualifiedClassName_rule(parser);
         break;
      }
      case 'b':
      case 'c':
      case 's':
      case 'd':
      case 'f':
      case 'i':
      case 'l': {
         // BasicType
         match = basicType_rule(parser);
         if (! match) {
            // QualifiedClassName
            match = qualifiedClassName_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      // Dim+
      // Dim
      match = dim_rule(parser);
      if (match) {
         do {
            // Dim
            match = dim_rule(parser);
         } while(match);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ARRAY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BasicTypeArray : (BasicType Dim+)
static BOOL basicTypeArray_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (BasicType Dim+)
   // BasicType
   match = basicType_rule(parser);
   if (match) {
      // Dim+
      // Dim
      match = dim_rule(parser);
      if (match) {
         do {
            // Dim
            match = dim_rule(parser);
         } while(match);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BASIC_TYPE_ARRAY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//QualifiedClassNameArray : (QualifiedClassName Dim+)
static BOOL qualifiedClassNameArray_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (QualifiedClassName Dim+)
   // QualifiedClassName
   match = qualifiedClassName_rule(parser);
   if (match) {
      // Dim+
      // Dim
      match = dim_rule(parser);
      if (match) {
         do {
            // Dim
            match = dim_rule(parser);
         } while(match);
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_QUALIFIED_CLASS_NAME_ARRAY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ClassName : (TypedClassName | Identifier)
static BOOL className_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (TypedClassName | Identifier)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // TypedClassName
         match = typedClassName_rule(parser);
         if (! match) {
            // Identifier
            match = identifier_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CLASS_NAME, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypedClassName : (Identifier TypeArguments)
static BOOL typedClassName_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier TypeArguments)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // TypeArguments
      match = typeArguments_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPED_CLASS_NAME, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeArguments : ('<' OptionalSpacing TypeArgument (',' OptionalSpacing TypeArgument)* '>' OptionalSpacing)
static BOOL typeArguments_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('<' OptionalSpacing TypeArgument (',' OptionalSpacing TypeArgument)* '>' OptionalSpacing)
   // '<'
   match = charMatcher(parser, '<');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // TypeArgument
         match = typeArgument_rule(parser);
         if (match) {
            // (',' OptionalSpacing TypeArgument)*
            do {
               // (',' OptionalSpacing TypeArgument)
               YAPP_NODE * lastNode_1 = parser->currentNode;
               INT32 lastIndex_1 = parser->index;
               // ','
               match = charMatcher(parser, ',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing_rule(parser);
                  if (match) {
                     // TypeArgument
                     match = typeArgument_rule(parser);
                     if (! match) {
                        parser->index = lastIndex_1;
                        lastNode_1->sibling = NULL;
                        parser->currentNode = lastNode_1;
                     }
                  } else {
                     parser->index = lastIndex_1;
                     lastNode_1->sibling = NULL;
                  }
               }
            } while(match);
            // '>'
            match = charMatcher(parser, '>');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPE_ARGUMENTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeArgument : (ReferenceType | QueryType)
static BOOL typeArgument_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ReferenceType | QueryType)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '?': {
         // QueryType
         match = queryType_rule(parser);
         break;
      }
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // ReferenceType
         match = referenceType_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPE_ARGUMENT, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//QueryType : ('?' OptionalSpacing ((('extends' | 'super') TestNoAlpha OptionalSpacing) ReferenceType)?)
static BOOL queryType_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('?' OptionalSpacing ((('extends' | 'super') TestNoAlpha OptionalSpacing) ReferenceType)?)
   // '?'
   match = charMatcher(parser, '?');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ((('extends' | 'super') TestNoAlpha OptionalSpacing) ReferenceType)?
         // ((('extends' | 'super') TestNoAlpha OptionalSpacing) ReferenceType)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // (('extends' | 'super') TestNoAlpha OptionalSpacing)
         YAPP_NODE * lastNode_2 = parser->currentNode;
         INT32 lastIndex_2 = parser->index;
         // ('extends' | 'super')
         INT32 startIndex_3 = parser->index;
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 's': {
               ++parser->index;
               // 'uper'
               if (match = stringTest(parser, "uper", 4)) {
                  parser->index += 4;
               }
               break;
            }
            case 'e': {
               ++parser->index;
               // 'xtends'
               if (match = stringTest(parser, "xtends", 6)) {
                  parser->index += 6;
               }
               break;
            }
            default: {
               match = FALSE;
            }
         }
         if (! match) {
            parser->index = startIndex_3;
         } else if(! parser->currentRuleIsAtomic) {
            NODE_SET_CURRENT(parser->currentNode, createNode(parser, &TERMINAL_RULE, startIndex_3, parser->index, FALSE, FALSE));
         }
         if (match) {
            // TestNoAlpha
            match = testNoAlpha_rule(parser);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (! match) {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
                  parser->currentNode = lastNode_2;
               }
            } else {
               parser->index = lastIndex_2;
               lastNode_2->sibling = NULL;
            }
         }
         if (match) {
            // ReferenceType
            match = referenceType_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
         match = TRUE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_QUERY_TYPE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TypeParameter : (Identifier Bound?)
static BOOL typeParameter_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier Bound?)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // Bound?
      // Bound
      bound_rule(parser);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TYPE_PARAMETER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Bound : ('extends' TestNoAlpha OptionalSpacing QualifiedClassName ('&' OptionalSpacing QualifiedClassName)*)
static BOOL bound_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('extends' TestNoAlpha OptionalSpacing QualifiedClassName ('&' OptionalSpacing QualifiedClassName)*)
   // 'extends'
   match = stringMatcher(parser, "extends", 7);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // QualifiedClassName
            match = qualifiedClassName_rule(parser);
            if (match) {
               // ('&' OptionalSpacing QualifiedClassName)*
               do {
                  // ('&' OptionalSpacing QualifiedClassName)
                  YAPP_NODE * lastNode_1 = parser->currentNode;
                  INT32 lastIndex_1 = parser->index;
                  // '&'
                  match = charMatcher(parser, '&');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (match) {
                        // QualifiedClassName
                        match = qualifiedClassName_rule(parser);
                        if (! match) {
                           parser->index = lastIndex_1;
                           lastNode_1->sibling = NULL;
                           parser->currentNode = lastNode_1;
                        }
                     } else {
                        parser->index = lastIndex_1;
                        lastNode_1->sibling = NULL;
                     }
                  }
               } while(match);
               match = TRUE;
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BOUND, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationTypeBody : ('{' OptionalSpacing AnnotationTypeElementDeclaration* '}' OptionalSpacing)
static BOOL annotationTypeBody_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing AnnotationTypeElementDeclaration* '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // AnnotationTypeElementDeclaration*
         do {
            // AnnotationTypeElementDeclaration
            match = annotationTypeElementDeclaration_rule(parser);
         } while(match);
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION_TYPE_BODY, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationTypeElementDeclaration : (AnnotationMethod | AnnotationsConstants | ClassDeclaration | EnumDeclaration | InterfaceDeclaration | AnnotationDeclaration | Semicolon)
static BOOL annotationTypeElementDeclaration_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (AnnotationMethod | AnnotationsConstants | ClassDeclaration | EnumDeclaration | InterfaceDeclaration | AnnotationDeclaration | Semicolon)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case ';': {
         // Semicolon
         match = semicolon_rule(parser);
         break;
      }
      case '@':
      case 'p':
      case 'a':
      case 's':
      case 't':
      case 'f':
      case 'v':
      case 'n': {
         // AnnotationMethod
         match = annotationMethod_rule(parser);
         if (! match) {
            // AnnotationsConstants
            match = annotationsConstants_rule(parser);
            if (! match) {
               // ClassDeclaration
               match = classDeclaration_rule(parser);
               if (! match) {
                  // EnumDeclaration
                  match = enumDeclaration_rule(parser);
                  if (! match) {
                     // InterfaceDeclaration
                     match = interfaceDeclaration_rule(parser);
                     if (! match) {
                        // AnnotationDeclaration
                        match = annotationDeclaration_rule(parser);
                     }
                  }
               }
            }
         }
         break;
      }
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'b':
      case 'd':
      case '$':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'o':
      case 'q':
      case 'r':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z': {
         // AnnotationMethod
         match = annotationMethod_rule(parser);
         if (! match) {
            // AnnotationsConstants
            match = annotationsConstants_rule(parser);
         }
         break;
      }
      case 'c': {
         // AnnotationMethod
         match = annotationMethod_rule(parser);
         if (! match) {
            // AnnotationsConstants
            match = annotationsConstants_rule(parser);
            if (! match) {
               // ClassDeclaration
               match = classDeclaration_rule(parser);
            }
         }
         break;
      }
      case 'e': {
         // AnnotationMethod
         match = annotationMethod_rule(parser);
         if (! match) {
            // AnnotationsConstants
            match = annotationsConstants_rule(parser);
            if (! match) {
               // EnumDeclaration
               match = enumDeclaration_rule(parser);
            }
         }
         break;
      }
      case 'i': {
         // AnnotationMethod
         match = annotationMethod_rule(parser);
         if (! match) {
            // AnnotationsConstants
            match = annotationsConstants_rule(parser);
            if (! match) {
               // InterfaceDeclaration
               match = interfaceDeclaration_rule(parser);
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION_TYPE_ELEMENT_DECLARATION, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationMethod : (Modifiers Type Identifier '(' OptionalSpacing ')' OptionalSpacing DefaultValue? Semicolon)
static BOOL annotationMethod_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers Type Identifier '(' OptionalSpacing ')' OptionalSpacing DefaultValue? Semicolon)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // Identifier
         match = identifier_rule(parser);
         if (match) {
            // '('
            match = charMatcher(parser, '(');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
               if (match) {
                  // ')'
                  match = charMatcher(parser, ')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing_rule(parser);
                     if (match) {
                        // DefaultValue?
                        // DefaultValue
                        defaultValue_rule(parser);
                        // Semicolon
                        match = semicolon_rule(parser);
                     }
                  }
               }
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION_METHOD, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationsConstants : (Modifiers Type VariableDeclarations Semicolon)
static BOOL annotationsConstants_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Modifiers Type VariableDeclarations Semicolon)
   // Modifiers
   match = modifiers_rule(parser);
   if (match) {
      // Type
      match = type_rule(parser);
      if (match) {
         // VariableDeclarations
         match = variableDeclarations_rule(parser);
         if (match) {
            // Semicolon
            match = semicolon_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATIONS_CONSTANTS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//DefaultValue : ('default' TestNoAlpha OptionalSpacing ElementValue)
static BOOL defaultValue_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('default' TestNoAlpha OptionalSpacing ElementValue)
   // 'default'
   match = stringMatcher(parser, "default", 7);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ElementValue
            match = elementValue_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DEFAULT_VALUE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElementValue : (ConditionalExpression | Annotation | ElementValueArrayInitializer)
static BOOL elementValue_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ConditionalExpression | Annotation | ElementValueArrayInitializer)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '!':
      case '\"':
      case '$':
      case '\'':
      case '(':
      case '+':
      case '-':
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case '~': {
         // ConditionalExpression
         match = conditionalExpression_rule(parser);
         break;
      }
      case '{': {
         // ElementValueArrayInitializer
         match = elementValueArrayInitializer_rule(parser);
         break;
      }
      case '@': {
         // Annotation
         match = annotation_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELEMENT_VALUE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//AnnotationParameters : (NormalAnnotationRest | SingleElementAnnotationRest)
static BOOL annotationParameters_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (NormalAnnotationRest | SingleElementAnnotationRest)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '(': {
         // NormalAnnotationRest
         match = normalAnnotationRest_rule(parser);
         if (! match) {
            // SingleElementAnnotationRest
            match = singleElementAnnotationRest_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ANNOTATION_PARAMETERS, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//NormalAnnotationRest : ('(' OptionalSpacing ElementValuePairs? ')' OptionalSpacing)
static BOOL normalAnnotationRest_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing ElementValuePairs? ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ElementValuePairs?
         // ElementValuePairs
         elementValuePairs_rule(parser);
         // ')'
         match = charMatcher(parser, ')');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_NORMAL_ANNOTATION_REST, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//SingleElementAnnotationRest : ('(' OptionalSpacing ElementValue ')' OptionalSpacing)
static BOOL singleElementAnnotationRest_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('(' OptionalSpacing ElementValue ')' OptionalSpacing)
   // '('
   match = charMatcher(parser, '(');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ElementValue
         match = elementValue_rule(parser);
         if (match) {
            // ')'
            match = charMatcher(parser, ')');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing_rule(parser);
            }
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SINGLE_ELEMENT_ANNOTATION_REST, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElementValuePairs : (ElementValuePair (',' OptionalSpacing ElementValuePair)*)
static BOOL elementValuePairs_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ElementValuePair (',' OptionalSpacing ElementValuePair)*)
   // ElementValuePair
   match = elementValuePair_rule(parser);
   if (match) {
      // (',' OptionalSpacing ElementValuePair)*
      do {
         // (',' OptionalSpacing ElementValuePair)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // ElementValuePair
               match = elementValuePair_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELEMENT_VALUE_PAIRS, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElementValuePair : (Identifier '=' OptionalSpacing ElementValue)
static BOOL elementValuePair_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (Identifier '=' OptionalSpacing ElementValue)
   // Identifier
   match = identifier_rule(parser);
   if (match) {
      // '='
      match = charMatcher(parser, '=');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
         if (match) {
            // ElementValue
            match = elementValue_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELEMENT_VALUE_PAIR, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElementValueArrayInitializer : ('{' OptionalSpacing ElementValues? (',' OptionalSpacing)? '}' OptionalSpacing)
static BOOL elementValueArrayInitializer_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('{' OptionalSpacing ElementValues? (',' OptionalSpacing)? '}' OptionalSpacing)
   // '{'
   match = charMatcher(parser, '{');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
      if (match) {
         // ElementValues?
         // ElementValues
         elementValues_rule(parser);
         match = TRUE;
         // (',' OptionalSpacing)?
         // (',' OptionalSpacing)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
         // '}'
         match = charMatcher(parser, '}');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
         }
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELEMENT_VALUE_ARRAY_INITIALIZER, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//ElementValues : (ElementValue (',' OptionalSpacing ElementValue)*)
static BOOL elementValues_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (ElementValue (',' OptionalSpacing ElementValue)*)
   // ElementValue
   match = elementValue_rule(parser);
   if (match) {
      // (',' OptionalSpacing ElementValue)*
      do {
         // (',' OptionalSpacing ElementValue)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // ','
         match = charMatcher(parser, ',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing_rule(parser);
            if (match) {
               // ElementValue
               match = elementValue_rule(parser);
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_ELEMENT_VALUES, startIndex, parser->index, TRUE, TRUE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//TestNoAlpha : ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')!
static BOOL testNoAlpha_rule(JavaParser * parser) {
   BOOL match;
   // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')!
   // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$')
   // 'a'-'z'
   match = yapp_buffer_matchCharRange(parser->buffer, parser->index, 'a', 'z');
   if (! match) {
      // 'A'-'Z'
      match = yapp_buffer_matchCharRange(parser->buffer, parser->index, 'A', 'Z');
      if (! match) {
         // '0'-'9'
         match = yapp_buffer_matchCharRange(parser->buffer, parser->index, '0', '9');
         if (! match) {
            // '_'
            match = yapp_buffer_matchChar(parser->buffer, parser->index, '_');
            if (! match) {
               // '$'
               match = yapp_buffer_matchChar(parser->buffer, parser->index, '$');
            }
         }
      }
   }
   match = ! match;
   if (match) {
      return TRUE;
   } else {
      return FALSE;
   }
}

//Spacing : (BlockComment | LineComment | NewLine | Spaces)+
static BOOL spacing_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->spacing_ruleMemoStart == parser->index) {
      if (parser->spacing_ruleMemoStart <= parser->spacing_ruleMemoEnd) {
         parser->index = parser->spacing_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->spacing_ruleMemoStart == parser->spacing_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_SPACING, parser->spacing_ruleMemoStart, parser->spacing_ruleMemoEnd, FALSE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->spacing_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->spacing_ruleMemoFirstNode;
               parser->currentNode = parser->spacing_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BlockComment | LineComment | NewLine | Spaces)+
   // (BlockComment | LineComment | NewLine | Spaces)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case ' ':
      case '\t':
      case '\f': {
         // Spaces
         match = spaces_rule(parser);
         break;
      }
      case '\r': {
         // NewLine
         match = newLine_rule(parser);
         if (! match) {
            // Spaces
            match = spaces_rule(parser);
         }
         break;
      }
      case '/': {
         // BlockComment
         match = blockComment_rule(parser);
         if (! match) {
            // LineComment
            match = lineComment_rule(parser);
         }
         break;
      }
      case '\n': {
         // NewLine
         match = newLine_rule(parser);
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      do {
         // (BlockComment | LineComment | NewLine | Spaces)
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case ' ':
            case '\t':
            case '\f': {
               // Spaces
               match = spaces_rule(parser);
               break;
            }
            case '\r': {
               // NewLine
               match = newLine_rule(parser);
               if (! match) {
                  // Spaces
                  match = spaces_rule(parser);
               }
               break;
            }
            case '/': {
               // BlockComment
               match = blockComment_rule(parser);
               if (! match) {
                  // LineComment
                  match = lineComment_rule(parser);
               }
               break;
            }
            case '\n': {
               // NewLine
               match = newLine_rule(parser);
               break;
            }
            default: {
               match = FALSE;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      parser->spacing_ruleMemoStart = startIndex;
      parser->spacing_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->spacing_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_SPACING, startIndex, parser->index, FALSE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
         parser->spacing_ruleMemoFirstNode = parser->currentNode;
         parser->spacing_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->spacing_ruleMemoStart = startIndex;
      parser->spacing_ruleMemoEnd = -1;
      parser->spacing_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//OptionalSpacing : (BlockComment | LineComment | NewLine | Spaces)*
static BOOL optionalSpacing_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   if (parser->optionalSpacing_ruleMemoStart == parser->index) {
      if (parser->optionalSpacing_ruleMemoStart <= parser->optionalSpacing_ruleMemoEnd) {
         parser->index = parser->optionalSpacing_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->optionalSpacing_ruleMemoStart == parser->optionalSpacing_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_SPACING, parser->optionalSpacing_ruleMemoStart, parser->optionalSpacing_ruleMemoEnd, FALSE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->optionalSpacing_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->optionalSpacing_ruleMemoFirstNode;
               parser->currentNode = parser->optionalSpacing_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   startIndex = parser->index;
   // (BlockComment | LineComment | NewLine | Spaces)*
   do {
      // (BlockComment | LineComment | NewLine | Spaces)
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case ' ':
         case '\t':
         case '\f': {
            // Spaces
            match = spaces_rule(parser);
            break;
         }
         case '\r': {
            // NewLine
            match = newLine_rule(parser);
            if (! match) {
               // Spaces
               match = spaces_rule(parser);
            }
            break;
         }
         case '/': {
            // BlockComment
            match = blockComment_rule(parser);
            if (! match) {
               // LineComment
               match = lineComment_rule(parser);
            }
            break;
         }
         case '\n': {
            // NewLine
            match = newLine_rule(parser);
            break;
         }
         default: {
            match = FALSE;
         }
      }
   } while(match);
   parser->optionalSpacing_ruleMemoStart = startIndex;
   parser->optionalSpacing_ruleMemoEnd = parser->index;
   if (parser->currentRuleIsAtomic) {
      parser->optionalSpacing_ruleMemoFirstNode = NULL;
   } else {
      parser->currentNode = createNode(parser, &JAVA_SPACING, startIndex, parser->index, FALSE, FALSE);
      parser->currentNode->firstChild = lastNode->sibling;
      lastNode->sibling = parser->currentNode;
      parser->optionalSpacing_ruleMemoFirstNode = parser->currentNode;
      parser->optionalSpacing_ruleMemoLastNode = parser->currentNode;
   }
   return TRUE;
}

//Spaces : (' ' | '\r' | '\t' | '\f')+
static BOOL spaces_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (' ' | '\r' | '\t' | '\f')+
   // (' ' | '\r' | '\t' | '\f')
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '\f': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      case '\r': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      case ' ': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      case '\t': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      do {
         // (' ' | '\r' | '\t' | '\f')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '\f': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '\r': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case ' ': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '\t': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
      } while(match);
      match = TRUE;
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SPACES, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//BlockComment : ('/*' ('*/'! .)* '*/')
static BOOL blockComment_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('/*' ('*/'! .)* '*/')
   // '/*'
   match = stringMatcher(parser, "/*", 2);
   if (match) {
      // ('*/'! .)*
      do {
         // ('*/'! .)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '*/'!
         // '*/'
         match = stringTest(parser, "*/", 2);
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
      } while(match);
      // '*/'
      match = stringMatcher(parser, "*/", 2);
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_BLOCK_COMMENT, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//NewLine : ('\n' | '\r\n')
static BOOL newLine_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('\n' | '\r\n')
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '\r': {
         ++parser->index;
         // '\n'
         if (match = yapp_buffer_matchChar(parser->buffer, parser->index, '\n')) {
            ++parser->index;
         }
         break;
      }
      case '\n': {
         ++parser->index;
         // <EMPTY>
         match = TRUE;
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_NEW_LINE, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//LineComment : ('//' ('\n'! .)* (NewLine | <EOI>))
static BOOL lineComment_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('//' ('\n'! .)* (NewLine | <EOI>))
   // '//'
   match = stringMatcher(parser, "//", 2);
   if (match) {
      // ('\n'! .)*
      do {
         // ('\n'! .)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '\n'!
         // '\n'
         match = yapp_buffer_matchChar(parser->buffer, parser->index, '\n');
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher(parser);
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
      } while(match);
      // (NewLine | <EOI>)
      // NewLine
      match = newLine_rule(parser);
      if (! match) {
         // <EOI>
         match = eoi(parser);
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_LINE_COMMENT, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//FloatLiteral : (HexFloat | DecimalFloat)
static BOOL floatLiteral_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (HexFloat | DecimalFloat)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.': {
         // DecimalFloat
         match = decimalFloat_rule(parser);
         break;
      }
      case '0': {
         // HexFloat
         match = hexFloat_rule(parser);
         if (! match) {
            // DecimalFloat
            match = decimalFloat_rule(parser);
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FLOAT_LITERAL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//LongLiteral : (IntegerLiteral ('l' | 'L'))
static BOOL longLiteral_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (IntegerLiteral ('l' | 'L'))
   // IntegerLiteral
   match = integerLiteral_rule(parser);
   if (match) {
      // ('l' | 'L')
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case 'l': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case 'L': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         default: {
            match = FALSE;
         }
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_LONG_LITERAL, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//IntegerLiteral : (HexNumeral | OctalNumeral | DecimalNumeral)
static BOOL integerLiteral_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   if (parser->integerLiteral_ruleMemoStart == parser->index) {
      if (parser->integerLiteral_ruleMemoStart <= parser->integerLiteral_ruleMemoEnd) {
         parser->index = parser->integerLiteral_ruleMemoEnd;
         if (! parser->currentRuleIsAtomic) {
            if (parser->integerLiteral_ruleMemoStart == parser->integerLiteral_ruleMemoEnd) {
               parser->currentNode = createNode(parser, &JAVA_INTEGER_LITERAL, parser->integerLiteral_ruleMemoStart, parser->integerLiteral_ruleMemoEnd, TRUE, FALSE);
               lastNode->sibling = parser->currentNode;
            } else if(parser->integerLiteral_ruleMemoFirstNode != NULL) {
               lastNode->sibling = parser->integerLiteral_ruleMemoFirstNode;
               parser->currentNode = parser->integerLiteral_ruleMemoLastNode;
            }
         }
         return TRUE;
      } else {
         return FALSE;
      }
   }
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (HexNumeral | OctalNumeral | DecimalNumeral)
   switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
      case '0': {
         // ('0' ('x' | 'X') HexDigit+)
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '0'
         match = charMatcher(parser, '0');
         if (match) {
            // ('x' | 'X')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case 'x': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'X': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            if (match) {
               // HexDigit+
               // ('a'-'f' | 'A'-'F' | '0'-'9')
               // 'a'-'f'
               match = charRangeMatcher(parser, 'a', 'f');
               if (! match) {
                  // 'A'-'F'
                  match = charRangeMatcher(parser, 'A', 'F');
                  if (! match) {
                     // '0'-'9'
                     match = charRangeMatcher(parser, '0', '9');
                  }
               }
               if (match) {
                  do {
                     // ('a'-'f' | 'A'-'F' | '0'-'9')
                     // 'a'-'f'
                     match = charRangeMatcher(parser, 'a', 'f');
                     if (! match) {
                        // 'A'-'F'
                        match = charRangeMatcher(parser, 'A', 'F');
                        if (! match) {
                           // '0'-'9'
                           match = charRangeMatcher(parser, '0', '9');
                        }
                     }
                  } while(match);
                  match = TRUE;
               }
               if (! match) {
                  parser->index = lastIndex_1;
                  lastNode_1->sibling = NULL;
                  parser->currentNode = lastNode_1;
               }
            } else {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
            }
         }
         if (! match) {
            // ('0' '0'-'7'+)
            YAPP_NODE * lastNode_2 = parser->currentNode;
            INT32 lastIndex_2 = parser->index;
            // '0'
            match = charMatcher(parser, '0');
            if (match) {
               // '0'-'7'+
               // '0'-'7'
               match = charRangeMatcher(parser, '0', '7');
               if (match) {
                  do {
                     // '0'-'7'
                     match = charRangeMatcher(parser, '0', '7');
                  } while(match);
                  match = TRUE;
               }
               if (! match) {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
                  parser->currentNode = lastNode_2;
               }
            }
            if (! match) {
               // ('0' | ('1'-'9' Digit*))
               // '0'
               match = charMatcher(parser, '0');
               if (! match) {
                  // ('1'-'9' Digit*)
                  YAPP_NODE * lastNode_3 = parser->currentNode;
                  INT32 lastIndex_3 = parser->index;
                  // '1'-'9'
                  match = charRangeMatcher(parser, '1', '9');
                  if (match) {
                     // Digit*
                     do {
                        // '0'-'9'
                        match = charRangeMatcher(parser, '0', '9');
                     } while(match);
                     match = TRUE;
                     if (! match) {
                        parser->index = lastIndex_3;
                        lastNode_3->sibling = NULL;
                        parser->currentNode = lastNode_3;
                     }
                  }
               }
            }
         }
         break;
      }
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': {
         // ('0' | ('1'-'9' Digit*))
         // '0'
         match = charMatcher(parser, '0');
         if (! match) {
            // ('1'-'9' Digit*)
            YAPP_NODE * lastNode_4 = parser->currentNode;
            INT32 lastIndex_4 = parser->index;
            // '1'-'9'
            match = charRangeMatcher(parser, '1', '9');
            if (match) {
               // Digit*
               do {
                  // '0'-'9'
                  match = charRangeMatcher(parser, '0', '9');
               } while(match);
               match = TRUE;
               if (! match) {
                  parser->index = lastIndex_4;
                  lastNode_4->sibling = NULL;
                  parser->currentNode = lastNode_4;
               }
            }
         }
         break;
      }
      default: {
         match = FALSE;
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->integerLiteral_ruleMemoStart = startIndex;
      parser->integerLiteral_ruleMemoEnd = parser->index;
      if (parser->currentRuleIsAtomic) {
         parser->integerLiteral_ruleMemoFirstNode = NULL;
      } else {
         parser->currentNode = createNode(parser, &JAVA_INTEGER_LITERAL, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
         parser->integerLiteral_ruleMemoFirstNode = parser->currentNode;
         parser->integerLiteral_ruleMemoLastNode = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->integerLiteral_ruleMemoStart = startIndex;
      parser->integerLiteral_ruleMemoEnd = -1;
      parser->integerLiteral_ruleMemoFirstNode = NULL;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//CharLiteral : (''' (Escape | ((''' | '\')! .)) ''')
static BOOL charLiteral_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (''' (Escape | ((''' | '\')! .)) ''')
   // '''
   match = charMatcher(parser, '\'');
   if (match) {
      // (Escape | ((''' | '\')! .))
      // ('\' (('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\') | OctalEscape | UnicodeEscape))
      YAPP_NODE * lastNode_1 = parser->currentNode;
      INT32 lastIndex_1 = parser->index;
      // '\'
      match = charMatcher(parser, '\\');
      if (match) {
         // (('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\') | OctalEscape | UnicodeEscape)
         // ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '\\': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'n': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'b': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'r': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '\"': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 't': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'f': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '\'': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         if (! match) {
            // (('0'-'3' '0'-'7' '0'-'7') | ('0'-'7' '0'-'7') | '0'-'7')
            // ('0'-'3' '0'-'7' '0'-'7')
            YAPP_NODE * lastNode_2 = parser->currentNode;
            INT32 lastIndex_2 = parser->index;
            // '0'-'3'
            match = charRangeMatcher(parser, '0', '3');
            if (match) {
               // '0'-'7'
               match = charRangeMatcher(parser, '0', '7');
               if (match) {
                  // '0'-'7'
                  match = charRangeMatcher(parser, '0', '7');
                  if (! match) {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                     parser->currentNode = lastNode_2;
                  }
               } else {
                  parser->index = lastIndex_2;
                  lastNode_2->sibling = NULL;
               }
            }
            if (! match) {
               // ('0'-'7' '0'-'7')
               YAPP_NODE * lastNode_3 = parser->currentNode;
               INT32 lastIndex_3 = parser->index;
               // '0'-'7'
               match = charRangeMatcher(parser, '0', '7');
               if (match) {
                  // '0'-'7'
                  match = charRangeMatcher(parser, '0', '7');
                  if (! match) {
                     parser->index = lastIndex_3;
                     lastNode_3->sibling = NULL;
                     parser->currentNode = lastNode_3;
                  }
               }
               if (! match) {
                  // '0'-'7'
                  match = charRangeMatcher(parser, '0', '7');
               }
            }
            if (! match) {
               // (('u'+ "005C" ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit))) | ('u'+ HexDigit HexDigit HexDigit HexDigit))
               // ('u'+ "005C" ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit)))
               YAPP_NODE * lastNode_4 = parser->currentNode;
               INT32 lastIndex_4 = parser->index;
               // 'u'+
               // 'u'
               match = charMatcher(parser, 'u');
               if (match) {
                  do {
                     // 'u'
                     match = charMatcher(parser, 'u');
                  } while(match);
                  match = TRUE;
               }
               if (match) {
                  // "005C"
                  match = ignoreCaseStringMatcher(parser, "005C", 4);
                  if (match) {
                     // ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit))
                     // 'b'
                     match = charMatcher(parser, 'b');
                     if (! match) {
                        // 't'
                        match = charMatcher(parser, 't');
                        if (! match) {
                           // 'n'
                           match = charMatcher(parser, 'n');
                           if (! match) {
                              // 'f'
                              match = charMatcher(parser, 'f');
                              if (! match) {
                                 // 'r'
                                 match = charMatcher(parser, 'r');
                                 if (! match) {
                                    // '"'
                                    match = charMatcher(parser, '\"');
                                    if (! match) {
                                       // '''
                                       match = charMatcher(parser, '\'');
                                       if (! match) {
                                          // '\'
                                          match = charMatcher(parser, '\\');
                                          if (! match) {
                                             // ('u'+ HexDigit HexDigit HexDigit HexDigit)
                                             YAPP_NODE * lastNode_5 = parser->currentNode;
                                             INT32 lastIndex_5 = parser->index;
                                             // 'u'+
                                             // 'u'
                                             match = charMatcher(parser, 'u');
                                             if (match) {
                                                do {
                                                   // 'u'
                                                   match = charMatcher(parser, 'u');
                                                } while(match);
                                                match = TRUE;
                                             }
                                             if (match) {
                                                // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                // 'a'-'f'
                                                match = charRangeMatcher(parser, 'a', 'f');
                                                if (! match) {
                                                   // 'A'-'F'
                                                   match = charRangeMatcher(parser, 'A', 'F');
                                                   if (! match) {
                                                      // '0'-'9'
                                                      match = charRangeMatcher(parser, '0', '9');
                                                   }
                                                }
                                                if (match) {
                                                   // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                   // 'a'-'f'
                                                   match = charRangeMatcher(parser, 'a', 'f');
                                                   if (! match) {
                                                      // 'A'-'F'
                                                      match = charRangeMatcher(parser, 'A', 'F');
                                                      if (! match) {
                                                         // '0'-'9'
                                                         match = charRangeMatcher(parser, '0', '9');
                                                      }
                                                   }
                                                   if (match) {
                                                      // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                      // 'a'-'f'
                                                      match = charRangeMatcher(parser, 'a', 'f');
                                                      if (! match) {
                                                         // 'A'-'F'
                                                         match = charRangeMatcher(parser, 'A', 'F');
                                                         if (! match) {
                                                            // '0'-'9'
                                                            match = charRangeMatcher(parser, '0', '9');
                                                         }
                                                      }
                                                      if (match) {
                                                         // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                         // 'a'-'f'
                                                         match = charRangeMatcher(parser, 'a', 'f');
                                                         if (! match) {
                                                            // 'A'-'F'
                                                            match = charRangeMatcher(parser, 'A', 'F');
                                                            if (! match) {
                                                               // '0'-'9'
                                                               match = charRangeMatcher(parser, '0', '9');
                                                            }
                                                         }
                                                         if (! match) {
                                                            parser->index = lastIndex_5;
                                                            lastNode_5->sibling = NULL;
                                                            parser->currentNode = lastNode_5;
                                                         }
                                                      } else {
                                                         parser->index = lastIndex_5;
                                                         lastNode_5->sibling = NULL;
                                                      }
                                                   } else {
                                                      parser->index = lastIndex_5;
                                                      lastNode_5->sibling = NULL;
                                                   }
                                                } else {
                                                   parser->index = lastIndex_5;
                                                   lastNode_5->sibling = NULL;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                     if (! match) {
                        parser->index = lastIndex_4;
                        lastNode_4->sibling = NULL;
                        parser->currentNode = lastNode_4;
                     }
                  } else {
                     parser->index = lastIndex_4;
                     lastNode_4->sibling = NULL;
                  }
               }
               if (! match) {
                  // ('u'+ HexDigit HexDigit HexDigit HexDigit)
                  YAPP_NODE * lastNode_6 = parser->currentNode;
                  INT32 lastIndex_6 = parser->index;
                  // 'u'+
                  // 'u'
                  match = charMatcher(parser, 'u');
                  if (match) {
                     do {
                        // 'u'
                        match = charMatcher(parser, 'u');
                     } while(match);
                     match = TRUE;
                  }
                  if (match) {
                     // ('a'-'f' | 'A'-'F' | '0'-'9')
                     // 'a'-'f'
                     match = charRangeMatcher(parser, 'a', 'f');
                     if (! match) {
                        // 'A'-'F'
                        match = charRangeMatcher(parser, 'A', 'F');
                        if (! match) {
                           // '0'-'9'
                           match = charRangeMatcher(parser, '0', '9');
                        }
                     }
                     if (match) {
                        // ('a'-'f' | 'A'-'F' | '0'-'9')
                        // 'a'-'f'
                        match = charRangeMatcher(parser, 'a', 'f');
                        if (! match) {
                           // 'A'-'F'
                           match = charRangeMatcher(parser, 'A', 'F');
                           if (! match) {
                              // '0'-'9'
                              match = charRangeMatcher(parser, '0', '9');
                           }
                        }
                        if (match) {
                           // ('a'-'f' | 'A'-'F' | '0'-'9')
                           // 'a'-'f'
                           match = charRangeMatcher(parser, 'a', 'f');
                           if (! match) {
                              // 'A'-'F'
                              match = charRangeMatcher(parser, 'A', 'F');
                              if (! match) {
                                 // '0'-'9'
                                 match = charRangeMatcher(parser, '0', '9');
                              }
                           }
                           if (match) {
                              // ('a'-'f' | 'A'-'F' | '0'-'9')
                              // 'a'-'f'
                              match = charRangeMatcher(parser, 'a', 'f');
                              if (! match) {
                                 // 'A'-'F'
                                 match = charRangeMatcher(parser, 'A', 'F');
                                 if (! match) {
                                    // '0'-'9'
                                    match = charRangeMatcher(parser, '0', '9');
                                 }
                              }
                              if (! match) {
                                 parser->index = lastIndex_6;
                                 lastNode_6->sibling = NULL;
                                 parser->currentNode = lastNode_6;
                              }
                           } else {
                              parser->index = lastIndex_6;
                              lastNode_6->sibling = NULL;
                           }
                        } else {
                           parser->index = lastIndex_6;
                           lastNode_6->sibling = NULL;
                        }
                     } else {
                        parser->index = lastIndex_6;
                        lastNode_6->sibling = NULL;
                     }
                  }
               }
            }
         }
         if (! match) {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
            parser->currentNode = lastNode_1;
         }
      }
      if (! match) {
         // ((''' | '\')! .)
         YAPP_NODE * lastNode_7 = parser->currentNode;
         INT32 lastIndex_7 = parser->index;
         // (''' | '\')!
         // (''' | '\')
         INT32 startIndex_8 = parser->index;
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '\\': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '\'': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         parser->index = startIndex_8;
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher(parser);
            if (! match) {
               parser->index = lastIndex_7;
               lastNode_7->sibling = NULL;
               parser->currentNode = lastNode_7;
            }
         }
      }
      if (match) {
         // '''
         match = charMatcher(parser, '\'');
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_CHAR_LITERAL, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//StringLiteral : ('"' (Escape | (('\r' | '\n' | '"' | '\')! .))* '"')
static BOOL stringLiteral_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ('"' (Escape | (('\r' | '\n' | '"' | '\')! .))* '"')
   // '"'
   match = charMatcher(parser, '\"');
   if (match) {
      // (Escape | (('\r' | '\n' | '"' | '\')! .))*
      do {
         // (Escape | (('\r' | '\n' | '"' | '\')! .))
         // ('\' (('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\') | OctalEscape | UnicodeEscape))
         YAPP_NODE * lastNode_1 = parser->currentNode;
         INT32 lastIndex_1 = parser->index;
         // '\'
         match = charMatcher(parser, '\\');
         if (match) {
            // (('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\') | OctalEscape | UnicodeEscape)
            // ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case '\\': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'n': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'b': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'r': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '\"': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 't': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'f': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '\'': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            if (! match) {
               // (('0'-'3' '0'-'7' '0'-'7') | ('0'-'7' '0'-'7') | '0'-'7')
               // ('0'-'3' '0'-'7' '0'-'7')
               YAPP_NODE * lastNode_2 = parser->currentNode;
               INT32 lastIndex_2 = parser->index;
               // '0'-'3'
               match = charRangeMatcher(parser, '0', '3');
               if (match) {
                  // '0'-'7'
                  match = charRangeMatcher(parser, '0', '7');
                  if (match) {
                     // '0'-'7'
                     match = charRangeMatcher(parser, '0', '7');
                     if (! match) {
                        parser->index = lastIndex_2;
                        lastNode_2->sibling = NULL;
                        parser->currentNode = lastNode_2;
                     }
                  } else {
                     parser->index = lastIndex_2;
                     lastNode_2->sibling = NULL;
                  }
               }
               if (! match) {
                  // ('0'-'7' '0'-'7')
                  YAPP_NODE * lastNode_3 = parser->currentNode;
                  INT32 lastIndex_3 = parser->index;
                  // '0'-'7'
                  match = charRangeMatcher(parser, '0', '7');
                  if (match) {
                     // '0'-'7'
                     match = charRangeMatcher(parser, '0', '7');
                     if (! match) {
                        parser->index = lastIndex_3;
                        lastNode_3->sibling = NULL;
                        parser->currentNode = lastNode_3;
                     }
                  }
                  if (! match) {
                     // '0'-'7'
                     match = charRangeMatcher(parser, '0', '7');
                  }
               }
               if (! match) {
                  // (('u'+ "005C" ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit))) | ('u'+ HexDigit HexDigit HexDigit HexDigit))
                  // ('u'+ "005C" ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit)))
                  YAPP_NODE * lastNode_4 = parser->currentNode;
                  INT32 lastIndex_4 = parser->index;
                  // 'u'+
                  // 'u'
                  match = charMatcher(parser, 'u');
                  if (match) {
                     do {
                        // 'u'
                        match = charMatcher(parser, 'u');
                     } while(match);
                     match = TRUE;
                  }
                  if (match) {
                     // "005C"
                     match = ignoreCaseStringMatcher(parser, "005C", 4);
                     if (match) {
                        // ('b' | 't' | 'n' | 'f' | 'r' | '"' | ''' | '\' | ('u'+ HexDigit HexDigit HexDigit HexDigit))
                        // 'b'
                        match = charMatcher(parser, 'b');
                        if (! match) {
                           // 't'
                           match = charMatcher(parser, 't');
                           if (! match) {
                              // 'n'
                              match = charMatcher(parser, 'n');
                              if (! match) {
                                 // 'f'
                                 match = charMatcher(parser, 'f');
                                 if (! match) {
                                    // 'r'
                                    match = charMatcher(parser, 'r');
                                    if (! match) {
                                       // '"'
                                       match = charMatcher(parser, '\"');
                                       if (! match) {
                                          // '''
                                          match = charMatcher(parser, '\'');
                                          if (! match) {
                                             // '\'
                                             match = charMatcher(parser, '\\');
                                             if (! match) {
                                                // ('u'+ HexDigit HexDigit HexDigit HexDigit)
                                                YAPP_NODE * lastNode_5 = parser->currentNode;
                                                INT32 lastIndex_5 = parser->index;
                                                // 'u'+
                                                // 'u'
                                                match = charMatcher(parser, 'u');
                                                if (match) {
                                                   do {
                                                      // 'u'
                                                      match = charMatcher(parser, 'u');
                                                   } while(match);
                                                   match = TRUE;
                                                }
                                                if (match) {
                                                   // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                   // 'a'-'f'
                                                   match = charRangeMatcher(parser, 'a', 'f');
                                                   if (! match) {
                                                      // 'A'-'F'
                                                      match = charRangeMatcher(parser, 'A', 'F');
                                                      if (! match) {
                                                         // '0'-'9'
                                                         match = charRangeMatcher(parser, '0', '9');
                                                      }
                                                   }
                                                   if (match) {
                                                      // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                      // 'a'-'f'
                                                      match = charRangeMatcher(parser, 'a', 'f');
                                                      if (! match) {
                                                         // 'A'-'F'
                                                         match = charRangeMatcher(parser, 'A', 'F');
                                                         if (! match) {
                                                            // '0'-'9'
                                                            match = charRangeMatcher(parser, '0', '9');
                                                         }
                                                      }
                                                      if (match) {
                                                         // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                         // 'a'-'f'
                                                         match = charRangeMatcher(parser, 'a', 'f');
                                                         if (! match) {
                                                            // 'A'-'F'
                                                            match = charRangeMatcher(parser, 'A', 'F');
                                                            if (! match) {
                                                               // '0'-'9'
                                                               match = charRangeMatcher(parser, '0', '9');
                                                            }
                                                         }
                                                         if (match) {
                                                            // ('a'-'f' | 'A'-'F' | '0'-'9')
                                                            // 'a'-'f'
                                                            match = charRangeMatcher(parser, 'a', 'f');
                                                            if (! match) {
                                                               // 'A'-'F'
                                                               match = charRangeMatcher(parser, 'A', 'F');
                                                               if (! match) {
                                                                  // '0'-'9'
                                                                  match = charRangeMatcher(parser, '0', '9');
                                                               }
                                                            }
                                                            if (! match) {
                                                               parser->index = lastIndex_5;
                                                               lastNode_5->sibling = NULL;
                                                               parser->currentNode = lastNode_5;
                                                            }
                                                         } else {
                                                            parser->index = lastIndex_5;
                                                            lastNode_5->sibling = NULL;
                                                         }
                                                      } else {
                                                         parser->index = lastIndex_5;
                                                         lastNode_5->sibling = NULL;
                                                      }
                                                   } else {
                                                      parser->index = lastIndex_5;
                                                      lastNode_5->sibling = NULL;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                        if (! match) {
                           parser->index = lastIndex_4;
                           lastNode_4->sibling = NULL;
                           parser->currentNode = lastNode_4;
                        }
                     } else {
                        parser->index = lastIndex_4;
                        lastNode_4->sibling = NULL;
                     }
                  }
                  if (! match) {
                     // ('u'+ HexDigit HexDigit HexDigit HexDigit)
                     YAPP_NODE * lastNode_6 = parser->currentNode;
                     INT32 lastIndex_6 = parser->index;
                     // 'u'+
                     // 'u'
                     match = charMatcher(parser, 'u');
                     if (match) {
                        do {
                           // 'u'
                           match = charMatcher(parser, 'u');
                        } while(match);
                        match = TRUE;
                     }
                     if (match) {
                        // ('a'-'f' | 'A'-'F' | '0'-'9')
                        // 'a'-'f'
                        match = charRangeMatcher(parser, 'a', 'f');
                        if (! match) {
                           // 'A'-'F'
                           match = charRangeMatcher(parser, 'A', 'F');
                           if (! match) {
                              // '0'-'9'
                              match = charRangeMatcher(parser, '0', '9');
                           }
                        }
                        if (match) {
                           // ('a'-'f' | 'A'-'F' | '0'-'9')
                           // 'a'-'f'
                           match = charRangeMatcher(parser, 'a', 'f');
                           if (! match) {
                              // 'A'-'F'
                              match = charRangeMatcher(parser, 'A', 'F');
                              if (! match) {
                                 // '0'-'9'
                                 match = charRangeMatcher(parser, '0', '9');
                              }
                           }
                           if (match) {
                              // ('a'-'f' | 'A'-'F' | '0'-'9')
                              // 'a'-'f'
                              match = charRangeMatcher(parser, 'a', 'f');
                              if (! match) {
                                 // 'A'-'F'
                                 match = charRangeMatcher(parser, 'A', 'F');
                                 if (! match) {
                                    // '0'-'9'
                                    match = charRangeMatcher(parser, '0', '9');
                                 }
                              }
                              if (match) {
                                 // ('a'-'f' | 'A'-'F' | '0'-'9')
                                 // 'a'-'f'
                                 match = charRangeMatcher(parser, 'a', 'f');
                                 if (! match) {
                                    // 'A'-'F'
                                    match = charRangeMatcher(parser, 'A', 'F');
                                    if (! match) {
                                       // '0'-'9'
                                       match = charRangeMatcher(parser, '0', '9');
                                    }
                                 }
                                 if (! match) {
                                    parser->index = lastIndex_6;
                                    lastNode_6->sibling = NULL;
                                    parser->currentNode = lastNode_6;
                                 }
                              } else {
                                 parser->index = lastIndex_6;
                                 lastNode_6->sibling = NULL;
                              }
                           } else {
                              parser->index = lastIndex_6;
                              lastNode_6->sibling = NULL;
                           }
                        } else {
                           parser->index = lastIndex_6;
                           lastNode_6->sibling = NULL;
                        }
                     }
                  }
               }
            }
            if (! match) {
               parser->index = lastIndex_1;
               lastNode_1->sibling = NULL;
               parser->currentNode = lastNode_1;
            }
         }
         if (! match) {
            // (('\r' | '\n' | '"' | '\')! .)
            YAPP_NODE * lastNode_7 = parser->currentNode;
            INT32 lastIndex_7 = parser->index;
            // ('\r' | '\n' | '"' | '\')!
            // ('\r' | '\n' | '"' | '\')
            INT32 startIndex_8 = parser->index;
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case '\\': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '\r': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '\"': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case '\n': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            parser->index = startIndex_8;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher(parser);
               if (! match) {
                  parser->index = lastIndex_7;
                  lastNode_7->sibling = NULL;
                  parser->currentNode = lastNode_7;
               }
            }
         }
      } while(match);
      // '"'
      match = charMatcher(parser, '\"');
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_STRING_LITERAL, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//True : ('true' TestNoAlpha OptionalSpacing)
static BOOL true_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('true' TestNoAlpha OptionalSpacing)
   // 'true'
   match = stringMatcher(parser, "true", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_TRUE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//False : ('false' TestNoAlpha OptionalSpacing)
static BOOL false_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('false' TestNoAlpha OptionalSpacing)
   // 'false'
   match = stringMatcher(parser, "false", 5);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_FALSE, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Null : ('null' TestNoAlpha OptionalSpacing)
static BOOL null_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // ('null' TestNoAlpha OptionalSpacing)
   // 'null'
   match = stringMatcher(parser, "null", 4);
   if (match) {
      // TestNoAlpha
      match = testNoAlpha_rule(parser);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing_rule(parser);
      }
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_NULL, startIndex, parser->index, TRUE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//HexFloat : (HexSignificant BinaryExponent ('f' | 'F' | 'd' | 'D')?)
static BOOL hexFloat_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // (HexSignificant BinaryExponent ('f' | 'F' | 'd' | 'D')?)
   // ((('0x' | '0X') HexDigit* '.' HexDigit+) | (HexNumeral '.'?))
   // (('0x' | '0X') HexDigit* '.' HexDigit+)
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   // ('0x' | '0X')
   if (yapp_buffer_matchChar(parser->buffer, parser->index, '0')) {
      ++parser->index;
      // ('x' | 'X')
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case 'x': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case 'X': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         default: {
            match = FALSE;
         }
      }
   } else {
      match = FALSE;
   }
   if (match) {
      // HexDigit*
      do {
         // ('a'-'f' | 'A'-'F' | '0'-'9')
         // 'a'-'f'
         match = charRangeMatcher(parser, 'a', 'f');
         if (! match) {
            // 'A'-'F'
            match = charRangeMatcher(parser, 'A', 'F');
            if (! match) {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            }
         }
      } while(match);
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // HexDigit+
         // ('a'-'f' | 'A'-'F' | '0'-'9')
         // 'a'-'f'
         match = charRangeMatcher(parser, 'a', 'f');
         if (! match) {
            // 'A'-'F'
            match = charRangeMatcher(parser, 'A', 'F');
            if (! match) {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            }
         }
         if (match) {
            do {
               // ('a'-'f' | 'A'-'F' | '0'-'9')
               // 'a'-'f'
               match = charRangeMatcher(parser, 'a', 'f');
               if (! match) {
                  // 'A'-'F'
                  match = charRangeMatcher(parser, 'A', 'F');
                  if (! match) {
                     // '0'-'9'
                     match = charRangeMatcher(parser, '0', '9');
                  }
               }
            } while(match);
            match = TRUE;
         }
         if (! match) {
            parser->index = lastIndex_1;
            lastNode_1->sibling = NULL;
            parser->currentNode = lastNode_1;
         }
      } else {
         parser->index = lastIndex_1;
         lastNode_1->sibling = NULL;
      }
   }
   if (! match) {
      // (HexNumeral '.'?)
      YAPP_NODE * lastNode_2 = parser->currentNode;
      INT32 lastIndex_2 = parser->index;
      // ('0' ('x' | 'X') HexDigit+)
      YAPP_NODE * lastNode_3 = parser->currentNode;
      INT32 lastIndex_3 = parser->index;
      // '0'
      match = charMatcher(parser, '0');
      if (match) {
         // ('x' | 'X')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'x': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'X': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         if (match) {
            // HexDigit+
            // ('a'-'f' | 'A'-'F' | '0'-'9')
            // 'a'-'f'
            match = charRangeMatcher(parser, 'a', 'f');
            if (! match) {
               // 'A'-'F'
               match = charRangeMatcher(parser, 'A', 'F');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher(parser, '0', '9');
               }
            }
            if (match) {
               do {
                  // ('a'-'f' | 'A'-'F' | '0'-'9')
                  // 'a'-'f'
                  match = charRangeMatcher(parser, 'a', 'f');
                  if (! match) {
                     // 'A'-'F'
                     match = charRangeMatcher(parser, 'A', 'F');
                     if (! match) {
                        // '0'-'9'
                        match = charRangeMatcher(parser, '0', '9');
                     }
                  }
               } while(match);
               match = TRUE;
            }
            if (! match) {
               parser->index = lastIndex_3;
               lastNode_3->sibling = NULL;
               parser->currentNode = lastNode_3;
            }
         } else {
            parser->index = lastIndex_3;
            lastNode_3->sibling = NULL;
         }
      }
      if (match) {
         // '.'?
         // '.'
         charMatcher(parser, '.');
         match = TRUE;
      }
   }
   if (match) {
      // (('p' | 'P') ('+' | '-')? Digit+)
      // ('p' | 'P')
      switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
         case 'p': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         case 'P': {
            ++parser->index;
            // <EMPTY>
            match = TRUE;
            break;
         }
         default: {
            match = FALSE;
         }
      }
      if (match) {
         // ('+' | '-')?
         // ('+' | '-')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '+': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '-': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         // Digit+
         // '0'-'9'
         match = charRangeMatcher(parser, '0', '9');
         if (match) {
            do {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            } while(match);
            match = TRUE;
         }
      }
      if (match) {
         // ('f' | 'F' | 'd' | 'D')?
         // ('f' | 'F' | 'd' | 'D')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'd': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'D': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'f': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'F': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         match = TRUE;
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_HEX_FLOAT, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//DecimalFloat : ((Digit+ '.' Digit* Exponent? ('f' | 'F' | 'd' | 'D')?) | ('.' Digit+ Exponent? ('f' | 'F' | 'd' | 'D')?) | (Digit+ Exponent ('f' | 'F' | 'd' | 'D')?) | (Digit+ Exponent? ('f' | 'F' | 'd' | 'D')))
static BOOL decimalFloat_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   BOOL lastRuleIsAtomic = parser->currentRuleIsAtomic;
   parser->currentRuleIsAtomic = TRUE;
   startIndex = parser->index;
   // ((Digit+ '.' Digit* Exponent? ('f' | 'F' | 'd' | 'D')?) | ('.' Digit+ Exponent? ('f' | 'F' | 'd' | 'D')?) | (Digit+ Exponent ('f' | 'F' | 'd' | 'D')?) | (Digit+ Exponent? ('f' | 'F' | 'd' | 'D')))
   // (Digit+ '.' Digit* Exponent? ('f' | 'F' | 'd' | 'D')?)
   YAPP_NODE * lastNode_1 = parser->currentNode;
   INT32 lastIndex_1 = parser->index;
   // Digit+
   // '0'-'9'
   match = charRangeMatcher(parser, '0', '9');
   if (match) {
      do {
         // '0'-'9'
         match = charRangeMatcher(parser, '0', '9');
      } while(match);
      match = TRUE;
   }
   if (match) {
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // Digit*
         do {
            // '0'-'9'
            match = charRangeMatcher(parser, '0', '9');
         } while(match);
         match = TRUE;
         // Exponent?
         // (('e' | 'E') ('+' | '-')? Digit+)
         YAPP_NODE * lastNode_2 = parser->currentNode;
         INT32 lastIndex_2 = parser->index;
         // ('e' | 'E')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'e': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'E': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         // ('+' | '-')?
         // ('+' | '-')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case '+': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case '-': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         // Digit+
         // '0'-'9'
         match = charRangeMatcher(parser, '0', '9');
         if (match) {
            do {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            } while(match);
            match = TRUE;
         }
         if (! match) {
            parser->index = lastIndex_2;
            lastNode_2->sibling = NULL;
            parser->currentNode = lastNode_2;
         }
         match = TRUE;
         // ('f' | 'F' | 'd' | 'D')?
         // ('f' | 'F' | 'd' | 'D')
         switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
            case 'd': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'D': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'f': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            case 'F': {
               ++parser->index;
               // <EMPTY>
               match = TRUE;
               break;
            }
            default: {
               match = FALSE;
            }
         }
         match = TRUE;
      } else {
         parser->index = lastIndex_1;
         lastNode_1->sibling = NULL;
      }
   }
   if (! match) {
      // ('.' Digit+ Exponent? ('f' | 'F' | 'd' | 'D')?)
      YAPP_NODE * lastNode_3 = parser->currentNode;
      INT32 lastIndex_3 = parser->index;
      // '.'
      match = charMatcher(parser, '.');
      if (match) {
         // Digit+
         // '0'-'9'
         match = charRangeMatcher(parser, '0', '9');
         if (match) {
            do {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            } while(match);
            match = TRUE;
         }
         if (match) {
            // Exponent?
            // (('e' | 'E') ('+' | '-')? Digit+)
            YAPP_NODE * lastNode_4 = parser->currentNode;
            INT32 lastIndex_4 = parser->index;
            // ('e' | 'E')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case 'e': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'E': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            if (match) {
               // ('+' | '-')?
               // ('+' | '-')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case '+': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case '-': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               // Digit+
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
               if (match) {
                  do {
                     // '0'-'9'
                     match = charRangeMatcher(parser, '0', '9');
                  } while(match);
                  match = TRUE;
               }
               if (! match) {
                  parser->index = lastIndex_4;
                  lastNode_4->sibling = NULL;
                  parser->currentNode = lastNode_4;
               }
            }
            match = TRUE;
            // ('f' | 'F' | 'd' | 'D')?
            // ('f' | 'F' | 'd' | 'D')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case 'd': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'D': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'f': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'F': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            match = TRUE;
         } else {
            parser->index = lastIndex_3;
            lastNode_3->sibling = NULL;
         }
      }
      if (! match) {
         // (Digit+ Exponent ('f' | 'F' | 'd' | 'D')?)
         YAPP_NODE * lastNode_5 = parser->currentNode;
         INT32 lastIndex_5 = parser->index;
         // Digit+
         // '0'-'9'
         match = charRangeMatcher(parser, '0', '9');
         if (match) {
            do {
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
            } while(match);
            match = TRUE;
         }
         if (match) {
            // (('e' | 'E') ('+' | '-')? Digit+)
            YAPP_NODE * lastNode_6 = parser->currentNode;
            INT32 lastIndex_6 = parser->index;
            // ('e' | 'E')
            switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
               case 'e': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               case 'E': {
                  ++parser->index;
                  // <EMPTY>
                  match = TRUE;
                  break;
               }
               default: {
                  match = FALSE;
               }
            }
            if (match) {
               // ('+' | '-')?
               // ('+' | '-')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case '+': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case '-': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               // Digit+
               // '0'-'9'
               match = charRangeMatcher(parser, '0', '9');
               if (match) {
                  do {
                     // '0'-'9'
                     match = charRangeMatcher(parser, '0', '9');
                  } while(match);
                  match = TRUE;
               }
               if (! match) {
                  parser->index = lastIndex_6;
                  lastNode_6->sibling = NULL;
                  parser->currentNode = lastNode_6;
               }
            }
            if (match) {
               // ('f' | 'F' | 'd' | 'D')?
               // ('f' | 'F' | 'd' | 'D')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'd': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'D': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'f': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'F': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               match = TRUE;
            } else {
               parser->index = lastIndex_5;
               lastNode_5->sibling = NULL;
            }
         }
         if (! match) {
            // (Digit+ Exponent? ('f' | 'F' | 'd' | 'D'))
            YAPP_NODE * lastNode_7 = parser->currentNode;
            INT32 lastIndex_7 = parser->index;
            // Digit+
            // '0'-'9'
            match = charRangeMatcher(parser, '0', '9');
            if (match) {
               do {
                  // '0'-'9'
                  match = charRangeMatcher(parser, '0', '9');
               } while(match);
               match = TRUE;
            }
            if (match) {
               // Exponent?
               // (('e' | 'E') ('+' | '-')? Digit+)
               YAPP_NODE * lastNode_8 = parser->currentNode;
               INT32 lastIndex_8 = parser->index;
               // ('e' | 'E')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'e': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'E': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
               if (match) {
                  // ('+' | '-')?
                  // ('+' | '-')
                  switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                     case '+': {
                        ++parser->index;
                        // <EMPTY>
                        match = TRUE;
                        break;
                     }
                     case '-': {
                        ++parser->index;
                        // <EMPTY>
                        match = TRUE;
                        break;
                     }
                     default: {
                        match = FALSE;
                     }
                  }
                  // Digit+
                  // '0'-'9'
                  match = charRangeMatcher(parser, '0', '9');
                  if (match) {
                     do {
                        // '0'-'9'
                        match = charRangeMatcher(parser, '0', '9');
                     } while(match);
                     match = TRUE;
                  }
                  if (! match) {
                     parser->index = lastIndex_8;
                     lastNode_8->sibling = NULL;
                     parser->currentNode = lastNode_8;
                  }
               }
               match = TRUE;
               // ('f' | 'F' | 'd' | 'D')
               switch(yapp_buffer_getChar(parser->buffer, parser->index)) {
                  case 'd': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'D': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'f': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  case 'F': {
                     ++parser->index;
                     // <EMPTY>
                     match = TRUE;
                     break;
                  }
                  default: {
                     match = FALSE;
                  }
               }
            }
         }
      }
   }
   if (match) {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_DECIMAL_FLOAT, startIndex, parser->index, TRUE, FALSE);
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->currentRuleIsAtomic = lastRuleIsAtomic;
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}

//Semicolon : (';' OptionalSpacing)
static BOOL semicolon_rule(JavaParser * parser) {
   YAPP_NODE * lastNode = parser->currentNode;
   INT32 startIndex;
   BOOL match;
   startIndex = parser->index;
   // (';' OptionalSpacing)
   // ';'
   match = charMatcher(parser, ';');
   if (match) {
      // OptionalSpacing
      match = optionalSpacing_rule(parser);
   }
   if (match) {
      if (! parser->currentRuleIsAtomic) {
         parser->currentNode = createNode(parser, &JAVA_SEMICOLON, startIndex, parser->index, FALSE, FALSE);
         parser->currentNode->firstChild = lastNode->sibling;
         lastNode->sibling = parser->currentNode;
      }
      return TRUE;
   } else {
      parser->index = startIndex;
      lastNode->sibling = NULL;
      parser->currentNode = lastNode;
      return FALSE;
   }
}
