/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

package org.uggeri.yapp.runtime.java.test;

import org.uggeri.yapp.runtime.java.parser.Parser;
import org.uggeri.yapp.runtime.java.parser.Rule;
import org.uggeri.yapp.runtime.java.parser.RuleProfile;
import org.uggeri.yapp.runtime.java.buffer.InputBuffer;
import org.uggeri.yapp.runtime.java.node.Node;
import org.uggeri.yapp.runtime.java.node.NodeImpl;
import org.uggeri.yapp.runtime.java.parser.ParserError;
import org.uggeri.yapp.runtime.java.trace.TraceParser;
import java.util.Collections;
import java.util.Collection;
import java.util.Arrays;
import java.util.Map;

public class HarbourUnprocessedParser implements Parser {

   private int index = 0;

   private InputBuffer buffer;

   private boolean currentRuleIsAtomic = false;

   private Node currentNode = new NodeImpl(null, 0, 0, false, false);

   private int statement$RuleMemoStart = -1;
   private int statement$RuleMemoEnd;
   private Node statement$RuleMemoFirstNode;
   private int unknownCommand$RuleMemoStart = -1;
   private int unknownCommand$RuleMemoEnd;
   private Node unknownCommand$RuleMemoFirstNode;
   private int localVariablesDeclaration$RuleMemoStart = -1;
   private int localVariablesDeclaration$RuleMemoEnd;
   private Node localVariablesDeclaration$RuleMemoFirstNode;
   private int functionDeclaration$RuleMemoStart = -1;
   private int functionDeclaration$RuleMemoEnd;
   private Node functionDeclaration$RuleMemoFirstNode;
   private int procedureDeclaration$RuleMemoStart = -1;
   private int procedureDeclaration$RuleMemoEnd;
   private Node procedureDeclaration$RuleMemoFirstNode;
   private int methodDefinition$RuleMemoStart = -1;
   private int methodDefinition$RuleMemoEnd;
   private Node methodDefinition$RuleMemoFirstNode;
   private int createClass$RuleMemoStart = -1;
   private int createClass$RuleMemoEnd;
   private Node createClass$RuleMemoFirstNode;
   private int endClass$RuleMemoStart = -1;
   private int endClass$RuleMemoEnd;
   private Node endClass$RuleMemoFirstNode;
   private int classBodyStmt$RuleMemoStart = -1;
   private int classBodyStmt$RuleMemoEnd;
   private Node classBodyStmt$RuleMemoFirstNode;
   private int sectionScope$RuleMemoStart = -1;
   private int sectionScope$RuleMemoEnd;
   private Node sectionScope$RuleMemoFirstNode;
   private int memberScope$RuleMemoStart = -1;
   private int memberScope$RuleMemoEnd;
   private Node memberScope$RuleMemoFirstNode;
   private int memberScopes$RuleMemoStart = -1;
   private int memberScopes$RuleMemoEnd;
   private Node memberScopes$RuleMemoFirstNode;
   private int methodMember$RuleMemoStart = -1;
   private int methodMember$RuleMemoEnd;
   private Node methodMember$RuleMemoFirstNode;
   private int fieldMember$RuleMemoStart = -1;
   private int fieldMember$RuleMemoEnd;
   private Node fieldMember$RuleMemoFirstNode;
   private int inLineExpression$RuleMemoStart = -1;
   private int inLineExpression$RuleMemoEnd;
   private Node inLineExpression$RuleMemoFirstNode;
   private int variable$RuleMemoStart = -1;
   private int variable$RuleMemoEnd;
   private Node variable$RuleMemoFirstNode;
   private int staticVariablesDeclaration$RuleMemoStart = -1;
   private int staticVariablesDeclaration$RuleMemoEnd;
   private Node staticVariablesDeclaration$RuleMemoFirstNode;
   private int fieldsDeclaration$RuleMemoStart = -1;
   private int fieldsDeclaration$RuleMemoEnd;
   private Node fieldsDeclaration$RuleMemoFirstNode;
   private int classDeclaration$RuleMemoStart = -1;
   private int classDeclaration$RuleMemoEnd;
   private Node classDeclaration$RuleMemoFirstNode;
   private int oldStyleParametersDeclaration$RuleMemoStart = -1;
   private int oldStyleParametersDeclaration$RuleMemoEnd;
   private Node oldStyleParametersDeclaration$RuleMemoFirstNode;
   private int declareStatement$RuleMemoStart = -1;
   private int declareStatement$RuleMemoEnd;
   private Node declareStatement$RuleMemoFirstNode;
   private int exitStmt$RuleMemoStart = -1;
   private int exitStmt$RuleMemoEnd;
   private Node exitStmt$RuleMemoFirstNode;
   private int loopStmt$RuleMemoStart = -1;
   private int loopStmt$RuleMemoEnd;
   private Node loopStmt$RuleMemoFirstNode;
   private int directive$RuleMemoStart = -1;
   private int directive$RuleMemoEnd;
   private Node directive$RuleMemoFirstNode;
   private int lineDirective$RuleMemoStart = -1;
   private int lineDirective$RuleMemoEnd;
   private Node lineDirective$RuleMemoFirstNode;
   private int includeDirective$RuleMemoStart = -1;
   private int includeDirective$RuleMemoEnd;
   private Node includeDirective$RuleMemoFirstNode;
   private int defineDirective$RuleMemoStart = -1;
   private int defineDirective$RuleMemoEnd;
   private Node defineDirective$RuleMemoFirstNode;
   private int translateDirective$RuleMemoStart = -1;
   private int translateDirective$RuleMemoEnd;
   private Node translateDirective$RuleMemoFirstNode;
   private int xTranslateDirective$RuleMemoStart = -1;
   private int xTranslateDirective$RuleMemoEnd;
   private Node xTranslateDirective$RuleMemoFirstNode;
   private int yTranslateDirective$RuleMemoStart = -1;
   private int yTranslateDirective$RuleMemoEnd;
   private Node yTranslateDirective$RuleMemoFirstNode;
   private int untranslateDirective$RuleMemoStart = -1;
   private int untranslateDirective$RuleMemoEnd;
   private Node untranslateDirective$RuleMemoFirstNode;
   private int xUntranslateDirective$RuleMemoStart = -1;
   private int xUntranslateDirective$RuleMemoEnd;
   private Node xUntranslateDirective$RuleMemoFirstNode;
   private int yUntranslateDirective$RuleMemoStart = -1;
   private int yUntranslateDirective$RuleMemoEnd;
   private Node yUntranslateDirective$RuleMemoFirstNode;
   private int commandDirective$RuleMemoStart = -1;
   private int commandDirective$RuleMemoEnd;
   private Node commandDirective$RuleMemoFirstNode;
   private int xCommandDirective$RuleMemoStart = -1;
   private int xCommandDirective$RuleMemoEnd;
   private Node xCommandDirective$RuleMemoFirstNode;
   private int yCommandDirective$RuleMemoStart = -1;
   private int yCommandDirective$RuleMemoEnd;
   private Node yCommandDirective$RuleMemoFirstNode;
   private int uncommandDirective$RuleMemoStart = -1;
   private int uncommandDirective$RuleMemoEnd;
   private Node uncommandDirective$RuleMemoFirstNode;
   private int xUncommandDirective$RuleMemoStart = -1;
   private int xUncommandDirective$RuleMemoEnd;
   private Node xUncommandDirective$RuleMemoFirstNode;
   private int yUncommandDirective$RuleMemoStart = -1;
   private int yUncommandDirective$RuleMemoEnd;
   private Node yUncommandDirective$RuleMemoFirstNode;
   private int ifDefDirective$RuleMemoStart = -1;
   private int ifDefDirective$RuleMemoEnd;
   private Node ifDefDirective$RuleMemoFirstNode;
   private int ifDirective$RuleMemoStart = -1;
   private int ifDirective$RuleMemoEnd;
   private Node ifDirective$RuleMemoFirstNode;
   private int ifNDefDirective$RuleMemoStart = -1;
   private int ifNDefDirective$RuleMemoEnd;
   private Node ifNDefDirective$RuleMemoFirstNode;
   private int elseDirective$RuleMemoStart = -1;
   private int elseDirective$RuleMemoEnd;
   private Node elseDirective$RuleMemoFirstNode;
   private int endIfDirective$RuleMemoStart = -1;
   private int endIfDirective$RuleMemoEnd;
   private Node endIfDirective$RuleMemoFirstNode;
   private int pragmaDirective$RuleMemoStart = -1;
   private int pragmaDirective$RuleMemoEnd;
   private Node pragmaDirective$RuleMemoFirstNode;
   private int undefDirective$RuleMemoStart = -1;
   private int undefDirective$RuleMemoEnd;
   private Node undefDirective$RuleMemoFirstNode;
   private int stdoutDirective$RuleMemoStart = -1;
   private int stdoutDirective$RuleMemoEnd;
   private Node stdoutDirective$RuleMemoFirstNode;
   private int errorDirective$RuleMemoStart = -1;
   private int errorDirective$RuleMemoEnd;
   private Node errorDirective$RuleMemoFirstNode;
   private int anyToken$RuleMemoStart = -1;
   private int anyToken$RuleMemoEnd;
   private Node anyToken$RuleMemoFirstNode;
   private int separator$RuleMemoStart = -1;
   private int separator$RuleMemoEnd;
   private Node separator$RuleMemoFirstNode;
   private int cmdComplementation$RuleMemoStart = -1;
   private int cmdComplementation$RuleMemoEnd;
   private Node cmdComplementation$RuleMemoFirstNode;
   private int unknownIdentifier$RuleMemoStart = -1;
   private int unknownIdentifier$RuleMemoEnd;
   private Node unknownIdentifier$RuleMemoFirstNode;
   private int beginProducer$RuleMemoStart = -1;
   private int beginProducer$RuleMemoEnd;
   private Node beginProducer$RuleMemoFirstNode;
   private int endProducer$RuleMemoStart = -1;
   private int endProducer$RuleMemoEnd;
   private Node endProducer$RuleMemoFirstNode;
   private int beginTransaction$RuleMemoStart = -1;
   private int beginTransaction$RuleMemoEnd;
   private Node beginTransaction$RuleMemoFirstNode;
   private int commitTransaction$RuleMemoStart = -1;
   private int commitTransaction$RuleMemoEnd;
   private Node commitTransaction$RuleMemoFirstNode;
   private int rollbackTransaction$RuleMemoStart = -1;
   private int rollbackTransaction$RuleMemoEnd;
   private Node rollbackTransaction$RuleMemoFirstNode;
   private int useAs$RuleMemoStart = -1;
   private int useAs$RuleMemoEnd;
   private Node useAs$RuleMemoFirstNode;
   private int useAlias$RuleMemoStart = -1;
   private int useAlias$RuleMemoEnd;
   private Node useAlias$RuleMemoFirstNode;
   private int useAsPrecision$RuleMemoStart = -1;
   private int useAsPrecision$RuleMemoEnd;
   private Node useAsPrecision$RuleMemoFirstNode;
   private int useArea$RuleMemoStart = -1;
   private int useArea$RuleMemoEnd;
   private Node useArea$RuleMemoFirstNode;
   private int useCodepage$RuleMemoStart = -1;
   private int useCodepage$RuleMemoEnd;
   private Node useCodepage$RuleMemoFirstNode;
   private int arrobaGetSay$RuleMemoStart = -1;
   private int arrobaGetSay$RuleMemoEnd;
   private Node arrobaGetSay$RuleMemoFirstNode;
   private int setCmd$RuleMemoStart = -1;
   private int setCmd$RuleMemoEnd;
   private Node setCmd$RuleMemoFirstNode;
   private int readCmd$RuleMemoStart = -1;
   private int readCmd$RuleMemoEnd;
   private Node readCmd$RuleMemoFirstNode;
   private int clsCmd$RuleMemoStart = -1;
   private int clsCmd$RuleMemoEnd;
   private Node clsCmd$RuleMemoFirstNode;
   private int clearCmd$RuleMemoStart = -1;
   private int clearCmd$RuleMemoEnd;
   private Node clearCmd$RuleMemoFirstNode;
   private int keyboardCmd$RuleMemoStart = -1;
   private int keyboardCmd$RuleMemoEnd;
   private Node keyboardCmd$RuleMemoFirstNode;
   private int waitCmd$RuleMemoStart = -1;
   private int waitCmd$RuleMemoEnd;
   private Node waitCmd$RuleMemoFirstNode;
   private int acceptCmd$RuleMemoStart = -1;
   private int acceptCmd$RuleMemoEnd;
   private Node acceptCmd$RuleMemoFirstNode;
   private int inputCmd$RuleMemoStart = -1;
   private int inputCmd$RuleMemoEnd;
   private Node inputCmd$RuleMemoFirstNode;
   private int releaseCmd$RuleMemoStart = -1;
   private int releaseCmd$RuleMemoEnd;
   private Node releaseCmd$RuleMemoFirstNode;
   private int restoreCmd$RuleMemoStart = -1;
   private int restoreCmd$RuleMemoEnd;
   private Node restoreCmd$RuleMemoFirstNode;
   private int storeCmd$RuleMemoStart = -1;
   private int storeCmd$RuleMemoEnd;
   private Node storeCmd$RuleMemoFirstNode;
   private int saveCmd$RuleMemoStart = -1;
   private int saveCmd$RuleMemoEnd;
   private Node saveCmd$RuleMemoFirstNode;
   private int joinCmd$RuleMemoStart = -1;
   private int joinCmd$RuleMemoEnd;
   private Node joinCmd$RuleMemoFirstNode;
   private int ejectCmd$RuleMemoStart = -1;
   private int ejectCmd$RuleMemoEnd;
   private Node ejectCmd$RuleMemoFirstNode;
   private int eraseCmd$RuleMemoStart = -1;
   private int eraseCmd$RuleMemoEnd;
   private Node eraseCmd$RuleMemoFirstNode;
   private int deleteCmd$RuleMemoStart = -1;
   private int deleteCmd$RuleMemoEnd;
   private Node deleteCmd$RuleMemoFirstNode;
   private int renameCmd$RuleMemoStart = -1;
   private int renameCmd$RuleMemoEnd;
   private Node renameCmd$RuleMemoFirstNode;
   private int copyCmd$RuleMemoStart = -1;
   private int copyCmd$RuleMemoEnd;
   private Node copyCmd$RuleMemoFirstNode;
   private int dirCmd$RuleMemoStart = -1;
   private int dirCmd$RuleMemoEnd;
   private Node dirCmd$RuleMemoFirstNode;
   private int typeCmd$RuleMemoStart = -1;
   private int typeCmd$RuleMemoEnd;
   private Node typeCmd$RuleMemoFirstNode;
   private int requestCmd$RuleMemoStart = -1;
   private int requestCmd$RuleMemoEnd;
   private Node requestCmd$RuleMemoFirstNode;
   private int cancelCmd$RuleMemoStart = -1;
   private int cancelCmd$RuleMemoEnd;
   private Node cancelCmd$RuleMemoFirstNode;
   private int quitCmd$RuleMemoStart = -1;
   private int quitCmd$RuleMemoEnd;
   private Node quitCmd$RuleMemoFirstNode;
   private int runCmd$RuleMemoStart = -1;
   private int runCmd$RuleMemoEnd;
   private Node runCmd$RuleMemoFirstNode;
   private int outCmd$RuleMemoStart = -1;
   private int outCmd$RuleMemoEnd;
   private Node outCmd$RuleMemoFirstNode;
   private int closeCmd$RuleMemoStart = -1;
   private int closeCmd$RuleMemoEnd;
   private Node closeCmd$RuleMemoFirstNode;
   private int selectCmd$RuleMemoStart = -1;
   private int selectCmd$RuleMemoEnd;
   private Node selectCmd$RuleMemoFirstNode;
   private int appendCmd$RuleMemoStart = -1;
   private int appendCmd$RuleMemoEnd;
   private Node appendCmd$RuleMemoFirstNode;
   private int packCmd$RuleMemoStart = -1;
   private int packCmd$RuleMemoEnd;
   private Node packCmd$RuleMemoFirstNode;
   private int zapCmd$RuleMemoStart = -1;
   private int zapCmd$RuleMemoEnd;
   private Node zapCmd$RuleMemoFirstNode;
   private int unlockCmd$RuleMemoStart = -1;
   private int unlockCmd$RuleMemoEnd;
   private Node unlockCmd$RuleMemoFirstNode;
   private int commitCmd$RuleMemoStart = -1;
   private int commitCmd$RuleMemoEnd;
   private Node commitCmd$RuleMemoFirstNode;
   private int gotoCmd$RuleMemoStart = -1;
   private int gotoCmd$RuleMemoEnd;
   private Node gotoCmd$RuleMemoFirstNode;
   private int skipCmd$RuleMemoStart = -1;
   private int skipCmd$RuleMemoEnd;
   private Node skipCmd$RuleMemoFirstNode;
   private int findCmd$RuleMemoStart = -1;
   private int findCmd$RuleMemoEnd;
   private Node findCmd$RuleMemoFirstNode;
   private int continueCmd$RuleMemoStart = -1;
   private int continueCmd$RuleMemoEnd;
   private Node continueCmd$RuleMemoFirstNode;
   private int seekCmd$RuleMemoStart = -1;
   private int seekCmd$RuleMemoEnd;
   private Node seekCmd$RuleMemoFirstNode;
   private int locateCmd$RuleMemoStart = -1;
   private int locateCmd$RuleMemoEnd;
   private Node locateCmd$RuleMemoFirstNode;
   private int replaceCmd$RuleMemoStart = -1;
   private int replaceCmd$RuleMemoEnd;
   private Node replaceCmd$RuleMemoFirstNode;
   private int recallCmd$RuleMemoStart = -1;
   private int recallCmd$RuleMemoEnd;
   private Node recallCmd$RuleMemoFirstNode;
   private int createCmd$RuleMemoStart = -1;
   private int createCmd$RuleMemoEnd;
   private Node createCmd$RuleMemoFirstNode;
   private int sortCmd$RuleMemoStart = -1;
   private int sortCmd$RuleMemoEnd;
   private Node sortCmd$RuleMemoFirstNode;
   private int totalCmd$RuleMemoStart = -1;
   private int totalCmd$RuleMemoEnd;
   private Node totalCmd$RuleMemoFirstNode;
   private int updateCmd$RuleMemoStart = -1;
   private int updateCmd$RuleMemoEnd;
   private Node updateCmd$RuleMemoFirstNode;
   private int countCmd$RuleMemoStart = -1;
   private int countCmd$RuleMemoEnd;
   private Node countCmd$RuleMemoFirstNode;
   private int sumCmd$RuleMemoStart = -1;
   private int sumCmd$RuleMemoEnd;
   private Node sumCmd$RuleMemoFirstNode;
   private int averageCmd$RuleMemoStart = -1;
   private int averageCmd$RuleMemoEnd;
   private Node averageCmd$RuleMemoFirstNode;
   private int listCmd$RuleMemoStart = -1;
   private int listCmd$RuleMemoEnd;
   private Node listCmd$RuleMemoFirstNode;
   private int displayCmd$RuleMemoStart = -1;
   private int displayCmd$RuleMemoEnd;
   private Node displayCmd$RuleMemoFirstNode;
   private int reportCmd$RuleMemoStart = -1;
   private int reportCmd$RuleMemoEnd;
   private Node reportCmd$RuleMemoFirstNode;
   private int labelCmd$RuleMemoStart = -1;
   private int labelCmd$RuleMemoEnd;
   private Node labelCmd$RuleMemoFirstNode;
   private int indexOnCmd$RuleMemoStart = -1;
   private int indexOnCmd$RuleMemoEnd;
   private Node indexOnCmd$RuleMemoFirstNode;
   private int reindexCmd$RuleMemoStart = -1;
   private int reindexCmd$RuleMemoEnd;
   private Node reindexCmd$RuleMemoFirstNode;
   private int qOutCommand$RuleMemoStart = -1;
   private int qOutCommand$RuleMemoEnd;
   private Node qOutCommand$RuleMemoFirstNode;
   private int menuToCmd$RuleMemoStart = -1;
   private int menuToCmd$RuleMemoEnd;
   private Node menuToCmd$RuleMemoFirstNode;
   private int defaultCmd$RuleMemoStart = -1;
   private int defaultCmd$RuleMemoEnd;
   private Node defaultCmd$RuleMemoFirstNode;
   private int macroSubstition$RuleMemoStart = -1;
   private int macroSubstition$RuleMemoEnd;
   private Node macroSubstition$RuleMemoFirstNode;
   private int ignoreLine$RuleMemoStart = -1;
   private int ignoreLine$RuleMemoEnd;
   private Node ignoreLine$RuleMemoFirstNode;
   private int variableDeclarationList$RuleMemoStart = -1;
   private int variableDeclarationList$RuleMemoEnd;
   private Node variableDeclarationList$RuleMemoFirstNode;
   private int parametersDeclarationList$RuleMemoStart = -1;
   private int parametersDeclarationList$RuleMemoEnd;
   private Node parametersDeclarationList$RuleMemoFirstNode;
   private int variableDefinition$RuleMemoStart = -1;
   private int variableDefinition$RuleMemoEnd;
   private Node variableDefinition$RuleMemoFirstNode;
   private int assignmentOperator$RuleMemoStart = -1;
   private int assignmentOperator$RuleMemoEnd;
   private Node assignmentOperator$RuleMemoFirstNode;
   private int expressionAsType$RuleMemoStart = -1;
   private int expressionAsType$RuleMemoEnd;
   private Node expressionAsType$RuleMemoFirstNode;
   private int asType$RuleMemoStart = -1;
   private int asType$RuleMemoEnd;
   private Node asType$RuleMemoFirstNode;
   private int valuesList$RuleMemoStart = -1;
   private int valuesList$RuleMemoEnd;
   private Node valuesList$RuleMemoFirstNode;
   private int identifierList$RuleMemoStart = -1;
   private int identifierList$RuleMemoEnd;
   private Node identifierList$RuleMemoFirstNode;
   private int memvarDeclaration$RuleMemoStart = -1;
   private int memvarDeclaration$RuleMemoEnd;
   private Node memvarDeclaration$RuleMemoFirstNode;
   private int aliasIdentifier$RuleMemoStart = -1;
   private int aliasIdentifier$RuleMemoEnd;
   private Node aliasIdentifier$RuleMemoFirstNode;
   private int expressionList$RuleMemoStart = -1;
   private int expressionList$RuleMemoEnd;
   private Node expressionList$RuleMemoFirstNode;
   private int macro$RuleMemoStart = -1;
   private int macro$RuleMemoEnd;
   private Node macro$RuleMemoFirstNode;
   private int aliasedExpression$RuleMemoStart = -1;
   private int aliasedExpression$RuleMemoEnd;
   private Node aliasedExpression$RuleMemoFirstNode;
   private int parenthesesExpressionList$RuleMemoStart = -1;
   private int parenthesesExpressionList$RuleMemoEnd;
   private Node parenthesesExpressionList$RuleMemoFirstNode;
   private int parenthesesStatement$RuleMemoStart = -1;
   private int parenthesesStatement$RuleMemoEnd;
   private Node parenthesesStatement$RuleMemoFirstNode;
   private int qualifiedVariable$RuleMemoStart = -1;
   private int qualifiedVariable$RuleMemoEnd;
   private Node qualifiedVariable$RuleMemoFirstNode;
   private int macroFunctionCall$RuleMemoStart = -1;
   private int macroFunctionCall$RuleMemoEnd;
   private Node macroFunctionCall$RuleMemoFirstNode;
   private int parParameters$RuleMemoStart = -1;
   private int parParameters$RuleMemoEnd;
   private Node parParameters$RuleMemoFirstNode;
   private int simpleFunctionCall$RuleMemoStart = -1;
   private int simpleFunctionCall$RuleMemoEnd;
   private Node simpleFunctionCall$RuleMemoFirstNode;
   private int anySimpleFunctionCall$RuleMemoStart = -1;
   private int anySimpleFunctionCall$RuleMemoEnd;
   private Node anySimpleFunctionCall$RuleMemoFirstNode;
   private int ignoreRestOfLine$RuleMemoStart = -1;
   private int ignoreRestOfLine$RuleMemoEnd;
   private Node ignoreRestOfLine$RuleMemoFirstNode;
   private int ifInLine$RuleMemoStart = -1;
   private int ifInLine$RuleMemoEnd;
   private Node ifInLine$RuleMemoFirstNode;
   private int ifBegin$RuleMemoStart = -1;
   private int ifBegin$RuleMemoEnd;
   private Node ifBegin$RuleMemoFirstNode;
   private int condition$RuleMemoStart = -1;
   private int condition$RuleMemoEnd;
   private Node condition$RuleMemoFirstNode;
   private int ifEnd$RuleMemoStart = -1;
   private int ifEnd$RuleMemoEnd;
   private Node ifEnd$RuleMemoFirstNode;
   private int endKeyword$RuleMemoStart = -1;
   private int endKeyword$RuleMemoEnd;
   private Node endKeyword$RuleMemoFirstNode;
   private int doWhileBegin$RuleMemoStart = -1;
   private int doWhileBegin$RuleMemoEnd;
   private Node doWhileBegin$RuleMemoFirstNode;
   private int doWhileEnd$RuleMemoStart = -1;
   private int doWhileEnd$RuleMemoEnd;
   private Node doWhileEnd$RuleMemoFirstNode;
   private int forNextBegin$RuleMemoStart = -1;
   private int forNextBegin$RuleMemoEnd;
   private Node forNextBegin$RuleMemoFirstNode;
   private int forNextEnd$RuleMemoStart = -1;
   private int forNextEnd$RuleMemoEnd;
   private Node forNextEnd$RuleMemoFirstNode;
   private int beginSequenceBegin$RuleMemoStart = -1;
   private int beginSequenceBegin$RuleMemoEnd;
   private Node beginSequenceBegin$RuleMemoFirstNode;
   private int doCaseBegin$RuleMemoStart = -1;
   private int doCaseBegin$RuleMemoEnd;
   private Node doCaseBegin$RuleMemoFirstNode;
   private int doCaseEnd$RuleMemoStart = -1;
   private int doCaseEnd$RuleMemoEnd;
   private Node doCaseEnd$RuleMemoFirstNode;
   private int forEachBegin$RuleMemoStart = -1;
   private int forEachBegin$RuleMemoEnd;
   private Node forEachBegin$RuleMemoFirstNode;
   private int switchBegin$RuleMemoStart = -1;
   private int switchBegin$RuleMemoEnd;
   private Node switchBegin$RuleMemoFirstNode;
   private int switchEnd$RuleMemoStart = -1;
   private int switchEnd$RuleMemoEnd;
   private Node switchEnd$RuleMemoFirstNode;
   private int tryCatchBegin$RuleMemoStart = -1;
   private int tryCatchBegin$RuleMemoEnd;
   private Node tryCatchBegin$RuleMemoFirstNode;
   private int tryCatchEnd$RuleMemoStart = -1;
   private int tryCatchEnd$RuleMemoEnd;
   private Node tryCatchEnd$RuleMemoFirstNode;
   private int finallyBlockBegin$RuleMemoStart = -1;
   private int finallyBlockBegin$RuleMemoEnd;
   private Node finallyBlockBegin$RuleMemoFirstNode;
   private int return$RuleMemoStart = -1;
   private int return$RuleMemoEnd;
   private Node return$RuleMemoFirstNode;
   private int break$RuleMemoStart = -1;
   private int break$RuleMemoEnd;
   private Node break$RuleMemoFirstNode;
   private int classMemberDeclaration$RuleMemoStart = -1;
   private int classMemberDeclaration$RuleMemoEnd;
   private Node classMemberDeclaration$RuleMemoFirstNode;
   private int publicVariableDeclaration$RuleMemoStart = -1;
   private int publicVariableDeclaration$RuleMemoEnd;
   private Node publicVariableDeclaration$RuleMemoFirstNode;
   private int privateVariableDeclaration$RuleMemoStart = -1;
   private int privateVariableDeclaration$RuleMemoEnd;
   private Node privateVariableDeclaration$RuleMemoFirstNode;
   private int external$RuleMemoStart = -1;
   private int external$RuleMemoEnd;
   private Node external$RuleMemoFirstNode;
   private int announce$RuleMemoStart = -1;
   private int announce$RuleMemoEnd;
   private Node announce$RuleMemoFirstNode;
   private int request$RuleMemoStart = -1;
   private int request$RuleMemoEnd;
   private Node request$RuleMemoFirstNode;
   private int throw$RuleMemoStart = -1;
   private int throw$RuleMemoEnd;
   private Node throw$RuleMemoFirstNode;
   private int statementAssignmentExpression$RuleMemoStart = -1;
   private int statementAssignmentExpression$RuleMemoEnd;
   private Node statementAssignmentExpression$RuleMemoFirstNode;
   private int selfExpression$RuleMemoStart = -1;
   private int selfExpression$RuleMemoEnd;
   private Node selfExpression$RuleMemoFirstNode;
   private int aliasedMacro$RuleMemoStart = -1;
   private int aliasedMacro$RuleMemoEnd;
   private Node aliasedMacro$RuleMemoFirstNode;
   private int qualifiedExpression$RuleMemoStart = -1;
   private int qualifiedExpression$RuleMemoEnd;
   private Node qualifiedExpression$RuleMemoFirstNode;
   private int keywordsFunctionCall$RuleMemoStart = -1;
   private int keywordsFunctionCall$RuleMemoEnd;
   private Node keywordsFunctionCall$RuleMemoFirstNode;
   private int methodDeclaration$RuleMemoStart = -1;
   private int methodDeclaration$RuleMemoEnd;
   private Node methodDeclaration$RuleMemoFirstNode;
   private int parParametersDeclaration$RuleMemoStart = -1;
   private int parParametersDeclaration$RuleMemoEnd;
   private Node parParametersDeclaration$RuleMemoFirstNode;
   private int attributeListDeclaration$RuleMemoStart = -1;
   private int attributeListDeclaration$RuleMemoEnd;
   private Node attributeListDeclaration$RuleMemoFirstNode;
   private int macroVar$RuleMemoStart = -1;
   private int macroVar$RuleMemoEnd;
   private Node macroVar$RuleMemoFirstNode;
   private int macroExpression$RuleMemoStart = -1;
   private int macroExpression$RuleMemoEnd;
   private Node macroExpression$RuleMemoFirstNode;
   private int functionReference$RuleMemoStart = -1;
   private int functionReference$RuleMemoEnd;
   private Node functionReference$RuleMemoFirstNode;
   private int valueByReference$RuleMemoStart = -1;
   private int valueByReference$RuleMemoEnd;
   private Node valueByReference$RuleMemoFirstNode;
   private int aliasedField$RuleMemoStart = -1;
   private int aliasedField$RuleMemoEnd;
   private Node aliasedField$RuleMemoFirstNode;
   private int parameter$RuleMemoStart = -1;
   private int parameter$RuleMemoEnd;
   private Node parameter$RuleMemoFirstNode;
   private int parametersList$RuleMemoStart = -1;
   private int parametersList$RuleMemoEnd;
   private Node parametersList$RuleMemoFirstNode;
   private int optionalParametersList$RuleMemoStart = -1;
   private int optionalParametersList$RuleMemoEnd;
   private Node optionalParametersList$RuleMemoFirstNode;
   private int elseIfBegin$RuleMemoStart = -1;
   private int elseIfBegin$RuleMemoEnd;
   private Node elseIfBegin$RuleMemoFirstNode;
   private int elseBegin$RuleMemoStart = -1;
   private int elseBegin$RuleMemoEnd;
   private Node elseBegin$RuleMemoFirstNode;
   private int otherwiseBegin$RuleMemoStart = -1;
   private int otherwiseBegin$RuleMemoEnd;
   private Node otherwiseBegin$RuleMemoFirstNode;
   private int doCaseOptionBegin$RuleMemoStart = -1;
   private int doCaseOptionBegin$RuleMemoEnd;
   private Node doCaseOptionBegin$RuleMemoFirstNode;
   private int codeBlockLiteral$RuleMemoStart = -1;
   private int codeBlockLiteral$RuleMemoEnd;
   private Node codeBlockLiteral$RuleMemoFirstNode;
   private int beginSequenceEnd$RuleMemoStart = -1;
   private int beginSequenceEnd$RuleMemoEnd;
   private Node beginSequenceEnd$RuleMemoFirstNode;
   private int recoverBegin$RuleMemoStart = -1;
   private int recoverBegin$RuleMemoEnd;
   private Node recoverBegin$RuleMemoFirstNode;
   private int alwaysBegin$RuleMemoStart = -1;
   private int alwaysBegin$RuleMemoEnd;
   private Node alwaysBegin$RuleMemoFirstNode;
   private int parenthesesSwitchConstant$RuleMemoStart = -1;
   private int parenthesesSwitchConstant$RuleMemoEnd;
   private Node parenthesesSwitchConstant$RuleMemoFirstNode;
   private int switchConstant$RuleMemoStart = -1;
   private int switchConstant$RuleMemoEnd;
   private Node switchConstant$RuleMemoFirstNode;
   private int logicalLiteral$RuleMemoStart = -1;
   private int logicalLiteral$RuleMemoEnd;
   private Node logicalLiteral$RuleMemoFirstNode;
   private int switchOptionBegin$RuleMemoStart = -1;
   private int switchOptionBegin$RuleMemoEnd;
   private Node switchOptionBegin$RuleMemoFirstNode;
   private int switchDefaultBegin$RuleMemoStart = -1;
   private int switchDefaultBegin$RuleMemoEnd;
   private Node switchDefaultBegin$RuleMemoFirstNode;
   private int catchBlockBegin$RuleMemoStart = -1;
   private int catchBlockBegin$RuleMemoEnd;
   private Node catchBlockBegin$RuleMemoFirstNode;
   private int arrayLiteral$RuleMemoStart = -1;
   private int arrayLiteral$RuleMemoEnd;
   private Node arrayLiteral$RuleMemoFirstNode;
   private int arrayItem$RuleMemoStart = -1;
   private int arrayItem$RuleMemoEnd;
   private Node arrayItem$RuleMemoFirstNode;
   private int variableByRef$RuleMemoStart = -1;
   private int variableByRef$RuleMemoEnd;
   private Node variableByRef$RuleMemoFirstNode;
   private int aliasedFieldByRef$RuleMemoStart = -1;
   private int aliasedFieldByRef$RuleMemoEnd;
   private Node aliasedFieldByRef$RuleMemoFirstNode;
   private int qualifiedVariableByRef$RuleMemoStart = -1;
   private int qualifiedVariableByRef$RuleMemoEnd;
   private Node qualifiedVariableByRef$RuleMemoFirstNode;
   private int arrayByRef$RuleMemoStart = -1;
   private int arrayByRef$RuleMemoEnd;
   private Node arrayByRef$RuleMemoFirstNode;
   private int hashItem$RuleMemoStart = -1;
   private int hashItem$RuleMemoEnd;
   private Node hashItem$RuleMemoFirstNode;
   private int hashItemsList$RuleMemoStart = -1;
   private int hashItemsList$RuleMemoEnd;
   private Node hashItemsList$RuleMemoFirstNode;
   private int hashItems$RuleMemoStart = -1;
   private int hashItems$RuleMemoEnd;
   private Node hashItems$RuleMemoFirstNode;
   private int hashLiteral$RuleMemoStart = -1;
   private int hashLiteral$RuleMemoEnd;
   private Node hashLiteral$RuleMemoFirstNode;
   private int nilValue$RuleMemoStart = -1;
   private int nilValue$RuleMemoEnd;
   private Node nilValue$RuleMemoFirstNode;
   private int literal$RuleMemoStart = -1;
   private int literal$RuleMemoEnd;
   private Node literal$RuleMemoFirstNode;
   private int dateTimeLiteral$RuleMemoStart = -1;
   private int dateTimeLiteral$RuleMemoEnd;
   private Node dateTimeLiteral$RuleMemoFirstNode;
   private int timeLiteral$RuleMemoStart = -1;
   private int timeLiteral$RuleMemoEnd;
   private Node timeLiteral$RuleMemoFirstNode;
   private int integerNumber$RuleMemoStart = -1;
   private int integerNumber$RuleMemoEnd;
   private Node integerNumber$RuleMemoFirstNode;
   private int timePattern$RuleMemoStart = -1;
   private int timePattern$RuleMemoEnd;
   private Node timePattern$RuleMemoFirstNode;
   private int datePattern$RuleMemoStart = -1;
   private int datePattern$RuleMemoEnd;
   private Node datePattern$RuleMemoFirstNode;
   private int indexItem$RuleMemoStart = -1;
   private int indexItem$RuleMemoEnd;
   private Node indexItem$RuleMemoFirstNode;
   private int assignOperator$RuleMemoStart = -1;
   private int assignOperator$RuleMemoEnd;
   private Node assignOperator$RuleMemoFirstNode;
   private int expression$RuleMemoStart = -1;
   private int expression$RuleMemoEnd;
   private Node expression$RuleMemoFirstNode;
   private int assignmentExpression$RuleMemoStart = -1;
   private int assignmentExpression$RuleMemoEnd;
   private Node assignmentExpression$RuleMemoFirstNode;
   private int optionalOrExpression$RuleMemoStart = -1;
   private int optionalOrExpression$RuleMemoEnd;
   private Node optionalOrExpression$RuleMemoFirstNode;
   private int orExpression$RuleMemoStart = -1;
   private int orExpression$RuleMemoEnd;
   private Node orExpression$RuleMemoFirstNode;
   private int optionalAndExpression$RuleMemoStart = -1;
   private int optionalAndExpression$RuleMemoEnd;
   private Node optionalAndExpression$RuleMemoFirstNode;
   private int andExpression$RuleMemoStart = -1;
   private int andExpression$RuleMemoEnd;
   private Node andExpression$RuleMemoFirstNode;
   private int optionalRelationalExpression$RuleMemoStart = -1;
   private int optionalRelationalExpression$RuleMemoEnd;
   private Node optionalRelationalExpression$RuleMemoFirstNode;
   private int relationalExpression$RuleMemoStart = -1;
   private int relationalExpression$RuleMemoEnd;
   private Node relationalExpression$RuleMemoFirstNode;
   private int optionalMathExpression$RuleMemoStart = -1;
   private int optionalMathExpression$RuleMemoEnd;
   private Node optionalMathExpression$RuleMemoFirstNode;
   private int mathExpression$RuleMemoStart = -1;
   private int mathExpression$RuleMemoEnd;
   private Node mathExpression$RuleMemoFirstNode;
   private int prefixedExpression$RuleMemoStart = -1;
   private int prefixedExpression$RuleMemoEnd;
   private Node prefixedExpression$RuleMemoFirstNode;
   private int postfixedExpression$RuleMemoStart = -1;
   private int postfixedExpression$RuleMemoEnd;
   private Node postfixedExpression$RuleMemoFirstNode;
   private int primaryExpression$RuleMemoStart = -1;
   private int primaryExpression$RuleMemoEnd;
   private Node primaryExpression$RuleMemoFirstNode;
   private int atomicExpression$RuleMemoStart = -1;
   private int atomicExpression$RuleMemoEnd;
   private Node atomicExpression$RuleMemoFirstNode;
   private int keyboardCall$RuleMemoStart = -1;
   private int keyboardCall$RuleMemoEnd;
   private Node keyboardCall$RuleMemoFirstNode;
   private int clearTypehead$RuleMemoStart = -1;
   private int clearTypehead$RuleMemoEnd;
   private Node clearTypehead$RuleMemoFirstNode;
   private int arrayAccess$RuleMemoStart = -1;
   private int arrayAccess$RuleMemoEnd;
   private Node arrayAccess$RuleMemoFirstNode;
   private int leftValue$RuleMemoStart = -1;
   private int leftValue$RuleMemoEnd;
   private Node leftValue$RuleMemoFirstNode;
   private int parenthesesLeftValue$RuleMemoStart = -1;
   private int parenthesesLeftValue$RuleMemoEnd;
   private Node parenthesesLeftValue$RuleMemoFirstNode;
   private int dump$RuleMemoStart = -1;
   private int dump$RuleMemoEnd;
   private Node dump$RuleMemoFirstNode;
   private int endDump$RuleMemoStart = -1;
   private int endDump$RuleMemoEnd;
   private Node endDump$RuleMemoFirstNode;
   private int parameterDeclaration$RuleMemoStart = -1;
   private int parameterDeclaration$RuleMemoEnd;
   private Node parameterDeclaration$RuleMemoFirstNode;
   private int functionModifier$RuleMemoStart = -1;
   private int functionModifier$RuleMemoEnd;
   private Node functionModifier$RuleMemoFirstNode;
   private int stringLiteral$RuleMemoStart = -1;
   private int stringLiteral$RuleMemoEnd;
   private Node stringLiteral$RuleMemoFirstNode;
   private int numberLiteral$RuleMemoStart = -1;
   private int numberLiteral$RuleMemoEnd;
   private Node numberLiteral$RuleMemoFirstNode;
   private int dataType$RuleMemoStart = -1;
   private int dataType$RuleMemoEnd;
   private Node dataType$RuleMemoFirstNode;
   private int array$RuleMemoStart = -1;
   private int array$RuleMemoEnd;
   private Node array$RuleMemoFirstNode;
   private int class$RuleMemoStart = -1;
   private int class$RuleMemoEnd;
   private Node class$RuleMemoFirstNode;
   private int anyIdentifier$RuleMemoStart = -1;
   private int anyIdentifier$RuleMemoEnd;
   private Node anyIdentifier$RuleMemoFirstNode;
   private int identifier$RuleMemoStart = -1;
   private int identifier$RuleMemoEnd;
   private Node identifier$RuleMemoFirstNode;
   private int identifierPattern$RuleMemoStart = -1;
   private int identifierPattern$RuleMemoEnd;
   private Node identifierPattern$RuleMemoFirstNode;
   private int whitespace$RuleMemoStart = -1;
   private int whitespace$RuleMemoEnd;
   private Node whitespace$RuleMemoFirstNode;
   private int lineComment$RuleMemoStart = -1;
   private int lineComment$RuleMemoEnd;
   private Node lineComment$RuleMemoFirstNode;
   private int blockComment$RuleMemoStart = -1;
   private int blockComment$RuleMemoEnd;
   private Node blockComment$RuleMemoFirstNode;
   private int aloneLineComment$RuleMemoStart = -1;
   private int aloneLineComment$RuleMemoEnd;
   private Node aloneLineComment$RuleMemoFirstNode;
   private int spacing$RuleMemoStart = -1;
   private int spacing$RuleMemoEnd;
   private Node spacing$RuleMemoFirstNode;
   private int continueNL$RuleMemoStart = -1;
   private int continueNL$RuleMemoEnd;
   private Node continueNL$RuleMemoFirstNode;
   private int optionalSpacing$RuleMemoStart = -1;
   private int optionalSpacing$RuleMemoEnd;
   private Node optionalSpacing$RuleMemoFirstNode;

   private int[] newArrayInt(final int size) {
      final int[] array = new int[size];
      Arrays.fill(array, -1);
      return array;
   }

   protected boolean charMatcher(char c) {
      if (buffer.matchChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean ignoreCaseCharMatcher(char c) {
      if (buffer.matchIgnoreCaseChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean stringMatcher(String str, int strLen) {
      if (buffer.matchString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean ignoreCaseStringMatcher(String str, int strLen) {
      if (buffer.matchIgnoreCaseString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialIgnoreCaseStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean charRangeMatcher(char charIni, char charEnd) {
      if (buffer.matchCharRange(index, charIni, charEnd)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean anyCharMatcher() {
      if (buffer.getChar(index) != '\0') {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean eoi() {
      if (buffer.getChar(index) == '\0') {
         return true;
      }
      return false;
   }

   protected boolean charTest(char c) {
      return buffer.getChar(index) == c;
   }

   protected boolean ignoreCaseCharTest(char c) {
      return buffer.matchIgnoreCaseChar(index, c);
   }

   protected boolean stringTest(String str, int strLen) {
      return buffer.matchString(index, str, strLen);
   }

   protected boolean partialStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean ignoreCaseStringTest(String str, int strLen) {
      return buffer.matchIgnoreCaseString(index, str, strLen);
   }

   protected boolean partialIgnoreCaseStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean charRangeTest(char charIni, char charEnd) {
      return buffer.matchCharRange(index, charIni, charEnd);
   }

   protected boolean anyCharTest() {
      return buffer.getChar(index) != '\0';
   }

   protected boolean eoiTest() {
      return buffer.getChar(index) == '\0';
   }
   @Override
   public Map<Rule, RuleProfile> getProfilesMap() {
      return Collections.emptyMap();
   }

   @Override
   public void setProfilesMap(Map<Rule, RuleProfile> profilesMap) {
   }

   @Override
   public Collection<ParserError> getMismatches() {
      return Collections.emptyList();
   }

   @Override
   public void setTraceParser(TraceParser tracePath) {
   }

   @Override
   public void setTrace(boolean trace) {
   }

   private Node lastChild(Node node) {
      Node child = node.getFirstChild();
      if (child != null) {
         while (child.getSibling() != null) {
            child = child.getSibling();
         }
      }
      return child;
   }

   private Node removeNode(Node parent, Node left, Node node) {
      if (node.getFirstChild() != null) {
         if (node.getSibling() != null) {
            lastChild(node).setSibling(node.getSibling());
         }
         if (left == null) {
            parent.setFirstChild(node.getFirstChild());
         } else {
            left.setSibling(node.getFirstChild());
         }
         return node.getFirstChild();
      } else if (left == null) {
         parent.setFirstChild(node.getSibling());
      } else {
         left.setSibling(node.getSibling());
      }
      return node.getSibling();
   }

   private void removeSkipedNodes(Node node) {
      if (node != null) {
         Node leftNode = null;
         Node child = node.getFirstChild();
         while (child != null) {
            if (child.isSkiped()) {
               child = removeNode(node, leftNode, child);
            } else {
               removeSkipedNodes(child);
               leftNode = child;
               child = child.getSibling();
            }
         }
      }
   }

   @Override
   public Node parse(InputBuffer inputBuffer) {
      buffer = inputBuffer;
      if (harbourProgram$Rule()) {
         removeSkipedNodes(currentNode);
         return currentNode;
      } else {
         return null;
      }
   }


   //HarbourProgram : (Statements <EOI>)
   protected boolean harbourProgram$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Statements <EOI>)
      // Statements
      match = statements$Rule();
      if (match) {
         // <EOI>
         match = eoi();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HARBOUR_PROGRAM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statements : (OptionalSpacing (AloneLineComment | Statement)? (EndStmt OptionalSpacing (AloneLineComment | Statement)?)*)
   protected boolean statements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (OptionalSpacing (AloneLineComment | Statement)? (EndStmt OptionalSpacing (AloneLineComment | Statement)?)*)
      // OptionalSpacing
      match = optionalSpacing$Rule();
      if (match) {
         // (AloneLineComment | Statement)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (AloneLineComment | Statement)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '\0':
            case '!':
            case '\"':
            case '#':
            case '$':
            case '%':
            case '&':
            case '\'':
            case '(':
            case ')':
            case '+':
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
            case '|':
            case '}':
            case '~': {
               // Statement
               match = statement$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '*': {
               // AloneLineComment
               match = aloneLineComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Statement
                  match = statement$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            default: {
               match = false;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // (EndStmt OptionalSpacing (AloneLineComment | Statement)?)*
            Node lastNode_3;
            int lastIndex_3;
            do {
               lastNode_3 = currentNode;
               lastIndex_3 = index;
               // (EndStmt OptionalSpacing (AloneLineComment | Statement)?)
               // EndStmt
               match = endStmt$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (AloneLineComment | Statement)?
                     Node lastNode_4 = currentNode;
                     int lastIndex_4 = index;
                     // (AloneLineComment | Statement)
                     Node lastNode_5 = currentNode;
                     int lastIndex_5 = index;
                     switch(buffer.getChar(index)) {
                        case '\0':
                        case '!':
                        case '\"':
                        case '#':
                        case '$':
                        case '%':
                        case '&':
                        case '\'':
                        case '(':
                        case ')':
                        case '+':
                        case ',':
                        case '-':
                        case '.':
                        case '/':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '<':
                        case '=':
                        case '>':
                        case '?':
                        case '@':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '[':
                        case '\\':
                        case ']':
                        case '^':
                        case '_':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '{':
                        case '|':
                        case '}':
                        case '~': {
                           // Statement
                           match = statement$Rule();
                           if (! match) {
                              index = lastIndex_5;
                              lastNode_5.setSibling(null);
                              currentNode = lastNode_5;
                           }
                           break;
                        }
                        case '*': {
                           // AloneLineComment
                           match = aloneLineComment$Rule();
                           if (! match) {
                              index = lastIndex_5;
                              lastNode_5.setSibling(null);
                              currentNode = lastNode_5;
                              // Statement
                              match = statement$Rule();
                              if (! match) {
                                 index = lastIndex_5;
                                 lastNode_5.setSibling(null);
                                 currentNode = lastNode_5;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (! match) {
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                        index = lastIndex_4;
                        match = true;
                     }
                  }
               }
            } while(match);
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
            index = lastIndex_3;
            match = true;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENTS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statement : (LocalVariablesDeclaration | FunctionDeclaration | ProcedureDeclaration | MethodDefinition | StaticVariablesDeclaration | FieldsDeclaration | CreateClass | ClassBodyStmt | EndClass | ClassDeclaration | OldStyleParametersDeclaration | DeclareStatement | IfInLine | IfBegin | ElseIfBegin | ElseBegin | IfEnd | DoWhileBegin | DoWhileEnd | ForNextBegin | ForNextEnd | BeginSequenceBegin | RecoverBegin | AlwaysBegin | BeginSequenceEnd | DoCaseBegin | DoCaseOptionBegin | OtherwiseBegin | DoCaseEnd | ForEachBegin | SwitchBegin | SwitchOptionBegin | DefaultCmd | SwitchDefaultBegin | SwitchEnd | TryCatchBegin | CatchBlockBegin | FinallyBlockBegin | TryCatchEnd | BeginProducer | EndProducer | EndKeyword | Return | Break | ClassMemberDeclaration | MemvarDeclaration | ExitStmt | LoopStmt | PublicVariableDeclaration | PrivateVariableDeclaration | External | Announce | Request | Throw | StatementAssignmentExpression | SelfExpression | PrefixedExpression | PostfixedExpression | AliasedExpression | AliasedMacro | QualifiedExpression | BeginTransaction | CommitTransaction | RollbackTransaction | UseAs | UseArea | MacroFunctionCall | KeywordsFunctionCall | SimpleFunctionCall | KeyboardCall | Macro | ParenthesesStatement | Dump | Directive | ArrobaGetSay | SetCmd | ReadCmd | ClearCmd | ClsCmd | KeyboardCmd | WaitCmd | AcceptCmd | InputCmd | ReleaseCmd | RestoreCmd | StoreCmd | SaveCmd | JoinCmd | EjectCmd | EraseCmd | DeleteCmd | RenameCmd | CopyCmd | DirCmd | TypeCmd | RequestCmd | CancelCmd | QuitCmd | RunCmd | OutCmd | CloseCmd | SelectCmd | AppendCmd | PackCmd | ZapCmd | UnlockCmd | CommitCmd | GotoCmd | SkipCmd | FindCmd | ContinueCmd | SeekCmd | LocateCmd | ReplaceCmd | RecallCmd | CreateCmd | SortCmd | TotalCmd | UpdateCmd | CountCmd | SumCmd | AverageCmd | ListCmd | DisplayCmd | ReportCmd | LabelCmd | IndexOnCmd | ReindexCmd | QOutCommand | MenuToCmd | UnknownCommand | IgnoreLine)
   protected boolean statement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (statement$RuleMemoStart == index) {
         if (statement$RuleMemoStart <= statement$RuleMemoEnd) {
            index = statement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT, statement$RuleMemoStart, statement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (statement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(statement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LocalVariablesDeclaration | FunctionDeclaration | ProcedureDeclaration | MethodDefinition | StaticVariablesDeclaration | FieldsDeclaration | CreateClass | ClassBodyStmt | EndClass | ClassDeclaration | OldStyleParametersDeclaration | DeclareStatement | IfInLine | IfBegin | ElseIfBegin | ElseBegin | IfEnd | DoWhileBegin | DoWhileEnd | ForNextBegin | ForNextEnd | BeginSequenceBegin | RecoverBegin | AlwaysBegin | BeginSequenceEnd | DoCaseBegin | DoCaseOptionBegin | OtherwiseBegin | DoCaseEnd | ForEachBegin | SwitchBegin | SwitchOptionBegin | DefaultCmd | SwitchDefaultBegin | SwitchEnd | TryCatchBegin | CatchBlockBegin | FinallyBlockBegin | TryCatchEnd | BeginProducer | EndProducer | EndKeyword | Return | Break | ClassMemberDeclaration | MemvarDeclaration | ExitStmt | LoopStmt | PublicVariableDeclaration | PrivateVariableDeclaration | External | Announce | Request | Throw | StatementAssignmentExpression | SelfExpression | PrefixedExpression | PostfixedExpression | AliasedExpression | AliasedMacro | QualifiedExpression | BeginTransaction | CommitTransaction | RollbackTransaction | UseAs | UseArea | MacroFunctionCall | KeywordsFunctionCall | SimpleFunctionCall | KeyboardCall | Macro | ParenthesesStatement | Dump | Directive | ArrobaGetSay | SetCmd | ReadCmd | ClearCmd | ClsCmd | KeyboardCmd | WaitCmd | AcceptCmd | InputCmd | ReleaseCmd | RestoreCmd | StoreCmd | SaveCmd | JoinCmd | EjectCmd | EraseCmd | DeleteCmd | RenameCmd | CopyCmd | DirCmd | TypeCmd | RequestCmd | CancelCmd | QuitCmd | RunCmd | OutCmd | CloseCmd | SelectCmd | AppendCmd | PackCmd | ZapCmd | UnlockCmd | CommitCmd | GotoCmd | SkipCmd | FindCmd | ContinueCmd | SeekCmd | LocateCmd | ReplaceCmd | RecallCmd | CreateCmd | SortCmd | TotalCmd | UpdateCmd | CountCmd | SumCmd | AverageCmd | ListCmd | DisplayCmd | ReportCmd | LabelCmd | IndexOnCmd | ReindexCmd | QOutCommand | MenuToCmd | UnknownCommand | IgnoreLine)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-': {
            // PrefixedExpression
            match = prefixedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // UnknownCommand
               match = unknownCommand$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IgnoreLine
                  match = ignoreLine$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case '$':
         case '%':
         case ')':
         case '*':
         case ',':
         case '/':
         case '<':
         case '\\':
         case '|':
         case '=':
         case ']':
         case '}':
         case '>':
         case '^':
         case '~': {
            // UnknownCommand
            match = unknownCommand$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // IgnoreLine
               match = ignoreLine$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '.': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PrefixedExpression
               match = prefixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // QualifiedExpression
                     match = qualifiedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // UnknownCommand
                        match = unknownCommand$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IgnoreLine
                           match = ignoreLine$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // UnknownCommand
                                 match = unknownCommand$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IgnoreLine
                                    match = ignoreLine$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case ':': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SelfExpression
               match = selfExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // QualifiedExpression
                     match = qualifiedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // UnknownCommand
                        match = unknownCommand$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IgnoreLine
                           match = ignoreLine$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '?': {
            // QOutCommand
            match = qOutCommand$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // UnknownCommand
               match = unknownCommand$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IgnoreLine
                  match = ignoreLine$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case '@': {
            // ArrobaGetSay
            match = arrobaGetSay$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // UnknownCommand
               match = unknownCommand$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IgnoreLine
                  match = ignoreLine$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'A':
         case 'a': {
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AlwaysBegin
               match = alwaysBegin$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Announce
                  match = announce$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // MacroFunctionCall
                                    match = macroFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // AcceptCmd
                                             match = acceptCmd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // AppendCmd
                                                match = appendCmd$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // AverageCmd
                                                   match = averageCmd$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // UnknownCommand
                                                      match = unknownCommand$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // IgnoreLine
                                                         match = ignoreLine$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'B':
         case 'b': {
            // BeginSequenceBegin
            match = beginSequenceBegin$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BeginProducer
               match = beginProducer$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Break
                  match = break$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // BeginTransaction
                                    match = beginTransaction$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // UnknownCommand
                                                   match = unknownCommand$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // IgnoreLine
                                                      match = ignoreLine$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // MethodDefinition
            match = methodDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CreateClass
               match = createClass$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ClassBodyStmt
                  match = classBodyStmt$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // DoCaseOptionBegin
                     match = doCaseOptionBegin$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SwitchOptionBegin
                        match = switchOptionBegin$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // CatchBlockBegin
                           match = catchBlockBegin$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // StatementAssignmentExpression
                              match = statementAssignmentExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // PostfixedExpression
                                 match = postfixedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // AliasedExpression
                                    match = aliasedExpression$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // AliasedMacro
                                       match = aliasedMacro$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // QualifiedExpression
                                          match = qualifiedExpression$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // CommitTransaction
                                             match = commitTransaction$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // MacroFunctionCall
                                                match = macroFunctionCall$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // KeywordsFunctionCall
                                                   match = keywordsFunctionCall$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // SimpleFunctionCall
                                                      match = simpleFunctionCall$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // Macro
                                                         match = macro$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // ClearCmd
                                                            match = clearCmd$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // ClsCmd
                                                               match = clsCmd$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // CopyCmd
                                                                  match = copyCmd$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // CancelCmd
                                                                     match = cancelCmd$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                        // CloseCmd
                                                                        match = closeCmd$Rule();
                                                                        if (! match) {
                                                                           index = lastIndex_1;
                                                                           lastNode_1.setSibling(null);
                                                                           currentNode = lastNode_1;
                                                                           // CommitCmd
                                                                           match = commitCmd$Rule();
                                                                           if (! match) {
                                                                              index = lastIndex_1;
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              // ContinueCmd
                                                                              match = continueCmd$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_1;
                                                                                 lastNode_1.setSibling(null);
                                                                                 currentNode = lastNode_1;
                                                                                 // CreateCmd
                                                                                 match = createCmd$Rule();
                                                                                 if (! match) {
                                                                                    index = lastIndex_1;
                                                                                    lastNode_1.setSibling(null);
                                                                                    currentNode = lastNode_1;
                                                                                    // CountCmd
                                                                                    match = countCmd$Rule();
                                                                                    if (! match) {
                                                                                       index = lastIndex_1;
                                                                                       lastNode_1.setSibling(null);
                                                                                       currentNode = lastNode_1;
                                                                                       // UnknownCommand
                                                                                       match = unknownCommand$Rule();
                                                                                       if (! match) {
                                                                                          index = lastIndex_1;
                                                                                          lastNode_1.setSibling(null);
                                                                                          currentNode = lastNode_1;
                                                                                          // IgnoreLine
                                                                                          match = ignoreLine$Rule();
                                                                                          if (! match) {
                                                                                             index = lastIndex_1;
                                                                                             lastNode_1.setSibling(null);
                                                                                             currentNode = lastNode_1;
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'D':
         case 'd': {
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // DeclareStatement
               match = declareStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // DoWhileBegin
                  match = doWhileBegin$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // DoCaseBegin
                     match = doCaseBegin$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // DefaultCmd
                        match = defaultCmd$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // SwitchDefaultBegin
                           match = switchDefaultBegin$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // StatementAssignmentExpression
                              match = statementAssignmentExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // PostfixedExpression
                                 match = postfixedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // AliasedExpression
                                    match = aliasedExpression$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // AliasedMacro
                                       match = aliasedMacro$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // QualifiedExpression
                                          match = qualifiedExpression$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // MacroFunctionCall
                                             match = macroFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // KeywordsFunctionCall
                                                match = keywordsFunctionCall$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // SimpleFunctionCall
                                                   match = simpleFunctionCall$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // Macro
                                                      match = macro$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // DeleteCmd
                                                         match = deleteCmd$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // DirCmd
                                                            match = dirCmd$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // DisplayCmd
                                                               match = displayCmd$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // UnknownCommand
                                                                  match = unknownCommand$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // IgnoreLine
                                                                     match = ignoreLine$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'E':
         case 'e': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ClassBodyStmt
                  match = classBodyStmt$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // EndClass
                     match = endClass$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ElseIfBegin
                        match = elseIfBegin$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ElseBegin
                           match = elseBegin$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // IfEnd
                              match = ifEnd$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // DoWhileEnd
                                 match = doWhileEnd$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // ForNextEnd
                                    match = forNextEnd$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // BeginSequenceEnd
                                       match = beginSequenceEnd$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // DoCaseEnd
                                          match = doCaseEnd$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // SwitchEnd
                                             match = switchEnd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // TryCatchEnd
                                                match = tryCatchEnd$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // EndProducer
                                                   match = endProducer$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // EndKeyword
                                                      match = endKeyword$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // ExitStmt
                                                         match = exitStmt$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // External
                                                            match = external$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // StatementAssignmentExpression
                                                               match = statementAssignmentExpression$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // PostfixedExpression
                                                                  match = postfixedExpression$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // AliasedExpression
                                                                     match = aliasedExpression$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                        // AliasedMacro
                                                                        match = aliasedMacro$Rule();
                                                                        if (! match) {
                                                                           index = lastIndex_1;
                                                                           lastNode_1.setSibling(null);
                                                                           currentNode = lastNode_1;
                                                                           // QualifiedExpression
                                                                           match = qualifiedExpression$Rule();
                                                                           if (! match) {
                                                                              index = lastIndex_1;
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              // MacroFunctionCall
                                                                              match = macroFunctionCall$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_1;
                                                                                 lastNode_1.setSibling(null);
                                                                                 currentNode = lastNode_1;
                                                                                 // KeywordsFunctionCall
                                                                                 match = keywordsFunctionCall$Rule();
                                                                                 if (! match) {
                                                                                    index = lastIndex_1;
                                                                                    lastNode_1.setSibling(null);
                                                                                    currentNode = lastNode_1;
                                                                                    // SimpleFunctionCall
                                                                                    match = simpleFunctionCall$Rule();
                                                                                    if (! match) {
                                                                                       index = lastIndex_1;
                                                                                       lastNode_1.setSibling(null);
                                                                                       currentNode = lastNode_1;
                                                                                       // Macro
                                                                                       match = macro$Rule();
                                                                                       if (! match) {
                                                                                          index = lastIndex_1;
                                                                                          lastNode_1.setSibling(null);
                                                                                          currentNode = lastNode_1;
                                                                                          // EjectCmd
                                                                                          match = ejectCmd$Rule();
                                                                                          if (! match) {
                                                                                             index = lastIndex_1;
                                                                                             lastNode_1.setSibling(null);
                                                                                             currentNode = lastNode_1;
                                                                                             // EraseCmd
                                                                                             match = eraseCmd$Rule();
                                                                                             if (! match) {
                                                                                                index = lastIndex_1;
                                                                                                lastNode_1.setSibling(null);
                                                                                                currentNode = lastNode_1;
                                                                                                // RunCmd
                                                                                                match = runCmd$Rule();
                                                                                                if (! match) {
                                                                                                   index = lastIndex_1;
                                                                                                   lastNode_1.setSibling(null);
                                                                                                   currentNode = lastNode_1;
                                                                                                   // UnknownCommand
                                                                                                   match = unknownCommand$Rule();
                                                                                                   if (! match) {
                                                                                                      index = lastIndex_1;
                                                                                                      lastNode_1.setSibling(null);
                                                                                                      currentNode = lastNode_1;
                                                                                                      // IgnoreLine
                                                                                                      match = ignoreLine$Rule();
                                                                                                      if (! match) {
                                                                                                         index = lastIndex_1;
                                                                                                         lastNode_1.setSibling(null);
                                                                                                         currentNode = lastNode_1;
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'F':
         case 'f': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FieldsDeclaration
               match = fieldsDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ForNextBegin
                  match = forNextBegin$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ForEachBegin
                     match = forEachBegin$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // FinallyBlockBegin
                        match = finallyBlockBegin$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // StatementAssignmentExpression
                           match = statementAssignmentExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PostfixedExpression
                              match = postfixedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // AliasedExpression
                                 match = aliasedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // AliasedMacro
                                    match = aliasedMacro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // QualifiedExpression
                                       match = qualifiedExpression$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // MacroFunctionCall
                                          match = macroFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // KeywordsFunctionCall
                                             match = keywordsFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // SimpleFunctionCall
                                                match = simpleFunctionCall$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // Macro
                                                   match = macro$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // FindCmd
                                                      match = findCmd$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // UnknownCommand
                                                         match = unknownCommand$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // IgnoreLine
                                                            match = ignoreLine$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'G':
         case 'g': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // GotoCmd
                                    match = gotoCmd$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'V':
         case 'v':
         case 'H':
         case 'h': {
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'I':
         case 'i': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IfInLine
                  match = ifInLine$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // IfBegin
                     match = ifBegin$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // StatementAssignmentExpression
                        match = statementAssignmentExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // PostfixedExpression
                           match = postfixedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedExpression
                              match = aliasedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // AliasedMacro
                                 match = aliasedMacro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // QualifiedExpression
                                    match = qualifiedExpression$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // InputCmd
                                                   match = inputCmd$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // IndexOnCmd
                                                      match = indexOnCmd$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // UnknownCommand
                                                         match = unknownCommand$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // IgnoreLine
                                                            match = ignoreLine$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'J':
         case 'j': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // JoinCmd
                                    match = joinCmd$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'K':
         case 'k': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // KeyboardCall
                                 match = keyboardCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // KeyboardCmd
                                       match = keyboardCmd$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnknownCommand
                                          match = unknownCommand$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // IgnoreLine
                                             match = ignoreLine$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'L':
         case 'l': {
            // LocalVariablesDeclaration
            match = localVariablesDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // LoopStmt
               match = loopStmt$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // KeywordsFunctionCall
                                    match = keywordsFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // LocateCmd
                                             match = locateCmd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // ListCmd
                                                match = listCmd$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // LabelCmd
                                                   match = labelCmd$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // UnknownCommand
                                                      match = unknownCommand$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // IgnoreLine
                                                         match = ignoreLine$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'M':
         case 'm': {
            // MethodDefinition
            match = methodDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ClassBodyStmt
               match = classBodyStmt$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // MemvarDeclaration
                  match = memvarDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // MacroFunctionCall
                                    match = macroFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // MenuToCmd
                                             match = menuToCmd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // UnknownCommand
                                                match = unknownCommand$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // IgnoreLine
                                                   match = ignoreLine$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'N':
         case 'n': {
            // ForNextEnd
            match = forNextEnd$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'O':
         case 'o': {
            // OtherwiseBegin
            match = otherwiseBegin$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // KeywordsFunctionCall
                                 match = keywordsFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // Macro
                                       match = macro$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnknownCommand
                                          match = unknownCommand$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // IgnoreLine
                                             match = ignoreLine$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'P':
         case 'p': {
            // ProcedureDeclaration
            match = procedureDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ClassBodyStmt
               match = classBodyStmt$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // OldStyleParametersDeclaration
                  match = oldStyleParametersDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PublicVariableDeclaration
                     match = publicVariableDeclaration$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PrivateVariableDeclaration
                        match = privateVariableDeclaration$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // StatementAssignmentExpression
                           match = statementAssignmentExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PostfixedExpression
                              match = postfixedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // AliasedExpression
                                 match = aliasedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // AliasedMacro
                                    match = aliasedMacro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // QualifiedExpression
                                       match = qualifiedExpression$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // MacroFunctionCall
                                          match = macroFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // KeywordsFunctionCall
                                             match = keywordsFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // SimpleFunctionCall
                                                match = simpleFunctionCall$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // Macro
                                                   match = macro$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // PackCmd
                                                      match = packCmd$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // UnknownCommand
                                                         match = unknownCommand$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // IgnoreLine
                                                            match = ignoreLine$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'Q':
         case 'q': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // QuitCmd
                                    match = quitCmd$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // OutCmd
                                       match = outCmd$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnknownCommand
                                          match = unknownCommand$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // IgnoreLine
                                             match = ignoreLine$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'R':
         case 'r': {
            // RecoverBegin
            match = recoverBegin$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Return
               match = return$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Request
                  match = request$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // RollbackTransaction
                                    match = rollbackTransaction$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // ReadCmd
                                                   match = readCmd$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // ReleaseCmd
                                                      match = releaseCmd$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // RestoreCmd
                                                         match = restoreCmd$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // RenameCmd
                                                            match = renameCmd$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // RequestCmd
                                                               match = requestCmd$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // RunCmd
                                                                  match = runCmd$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // ReplaceCmd
                                                                     match = replaceCmd$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                        // RecallCmd
                                                                        match = recallCmd$Rule();
                                                                        if (! match) {
                                                                           index = lastIndex_1;
                                                                           lastNode_1.setSibling(null);
                                                                           currentNode = lastNode_1;
                                                                           // ReportCmd
                                                                           match = reportCmd$Rule();
                                                                           if (! match) {
                                                                              index = lastIndex_1;
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              // ReindexCmd
                                                                              match = reindexCmd$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_1;
                                                                                 lastNode_1.setSibling(null);
                                                                                 currentNode = lastNode_1;
                                                                                 // UnknownCommand
                                                                                 match = unknownCommand$Rule();
                                                                                 if (! match) {
                                                                                    index = lastIndex_1;
                                                                                    lastNode_1.setSibling(null);
                                                                                    currentNode = lastNode_1;
                                                                                    // IgnoreLine
                                                                                    match = ignoreLine$Rule();
                                                                                    if (! match) {
                                                                                       index = lastIndex_1;
                                                                                       lastNode_1.setSibling(null);
                                                                                       currentNode = lastNode_1;
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'S':
         case 's': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StaticVariablesDeclaration
                  match = staticVariablesDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SwitchBegin
                     match = switchBegin$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // StatementAssignmentExpression
                        match = statementAssignmentExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // PostfixedExpression
                           match = postfixedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AliasedExpression
                              match = aliasedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // AliasedMacro
                                 match = aliasedMacro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // QualifiedExpression
                                    match = qualifiedExpression$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // SetCmd
                                                   match = setCmd$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // StoreCmd
                                                      match = storeCmd$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // SaveCmd
                                                         match = saveCmd$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // SelectCmd
                                                            match = selectCmd$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // SkipCmd
                                                               match = skipCmd$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // SeekCmd
                                                                  match = seekCmd$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // SortCmd
                                                                     match = sortCmd$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                        // SumCmd
                                                                        match = sumCmd$Rule();
                                                                        if (! match) {
                                                                           index = lastIndex_1;
                                                                           lastNode_1.setSibling(null);
                                                                           currentNode = lastNode_1;
                                                                           // UnknownCommand
                                                                           match = unknownCommand$Rule();
                                                                           if (! match) {
                                                                              index = lastIndex_1;
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              // IgnoreLine
                                                                              match = ignoreLine$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_1;
                                                                                 lastNode_1.setSibling(null);
                                                                                 currentNode = lastNode_1;
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'T':
         case 't': {
            // TryCatchBegin
            match = tryCatchBegin$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Throw
               match = throw$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // KeywordsFunctionCall
                                    match = keywordsFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // TypeCmd
                                             match = typeCmd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // TotalCmd
                                                match = totalCmd$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // UnknownCommand
                                                   match = unknownCommand$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // IgnoreLine
                                                      match = ignoreLine$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'U':
         case 'u': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // UseAs
                           match = useAs$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // UseArea
                              match = useArea$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // Macro
                                       match = macro$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnlockCmd
                                          match = unlockCmd$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // UpdateCmd
                                             match = updateCmd$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // UnknownCommand
                                                match = unknownCommand$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // IgnoreLine
                                                   match = ignoreLine$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'W':
         case 'w': {
            // DoWhileBegin
            match = doWhileBegin$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // WaitCmd
                                       match = waitCmd$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnknownCommand
                                          match = unknownCommand$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // IgnoreLine
                                             match = ignoreLine$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'X':
         case 'x': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // KeywordsFunctionCall
                              match = keywordsFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'Y':
         case 'y': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // UnknownCommand
                                    match = unknownCommand$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // IgnoreLine
                                       match = ignoreLine$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'Z':
         case 'z': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // ZapCmd
                                    match = zapCmd$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // UnknownCommand
                                       match = unknownCommand$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IgnoreLine
                                          match = ignoreLine$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '\'':
         case '[':
         case '{': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QualifiedExpression
                  match = qualifiedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // UnknownCommand
                     match = unknownCommand$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IgnoreLine
                        match = ignoreLine$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case '_': {
            // ClassDeclaration
            match = classDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ClassMemberDeclaration
               match = classMemberDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // Macro
                                       match = macro$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // UnknownCommand
                                          match = unknownCommand$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // IgnoreLine
                                             match = ignoreLine$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '#': {
            // Dump
            match = dump$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Directive
               match = directive$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // UnknownCommand
                  match = unknownCommand$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // IgnoreLine
                     match = ignoreLine$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ParenthesesStatement
                           match = parenthesesStatement$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // UnknownCommand
                              match = unknownCommand$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // IgnoreLine
                                 match = ignoreLine$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            // IgnoreLine
            match = ignoreLine$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         statement$RuleMemoStart = startIndex;
         statement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            statement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            statement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         statement$RuleMemoStart = startIndex;
         statement$RuleMemoEnd = -1;
         statement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UnknownCommand : (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)+
   protected boolean unknownCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (unknownCommand$RuleMemoStart == index) {
         if (unknownCommand$RuleMemoStart <= unknownCommand$RuleMemoEnd) {
            index = unknownCommand$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_COMMAND, unknownCommand$RuleMemoStart, unknownCommand$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unknownCommand$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unknownCommand$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '&':
         case '(':
         case ':':
         case '+':
         case '[':
         case '{':
         case '-':
         case '.': {
            // Expression
            match = expression$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
            break;
         }
         case '@':
         case '#':
         case '$':
         case '%':
         case ')':
         case '*':
         case ',':
         case '/':
         case '<':
         case '\\':
         case '|':
         case '=':
         case ']':
         case '}':
         case '>':
         case '^':
         case '~':
         case '?': {
            // Separator
            match = separator$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '\"':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '\'':
         case '8':
         case '9': {
            // Expression
            match = expression$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // AnySimpleFunctionCall
            match = anySimpleFunctionCall$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // Expression
               match = expression$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // UnknownIdentifier
                  match = unknownIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            switch(buffer.getChar(index)) {
               case '!':
               case '&':
               case '(':
               case ':':
               case '+':
               case '[':
               case '{':
               case '-':
               case '.': {
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     // Separator
                     match = separator$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                  }
                  break;
               }
               case '@':
               case '#':
               case '$':
               case '%':
               case ')':
               case '*':
               case ',':
               case '/':
               case '<':
               case '\\':
               case '|':
               case '=':
               case ']':
               case '}':
               case '>':
               case '^':
               case '~':
               case '?': {
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
                  break;
               }
               case '0':
               case '1':
               case '2':
               case '\"':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '\'':
               case '8':
               case '9': {
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
                  break;
               }
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z': {
                  // AnySimpleFunctionCall
                  match = anySimpleFunctionCall$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     // Expression
                     match = expression$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        // UnknownIdentifier
                        match = unknownIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         unknownCommand$RuleMemoStart = startIndex;
         unknownCommand$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unknownCommand$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_COMMAND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unknownCommand$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         unknownCommand$RuleMemoStart = startIndex;
         unknownCommand$RuleMemoEnd = -1;
         unknownCommand$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LocalVariablesDeclaration : (("local" | "loca") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean localVariablesDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (localVariablesDeclaration$RuleMemoStart == index) {
         if (localVariablesDeclaration$RuleMemoStart <= localVariablesDeclaration$RuleMemoEnd) {
            index = localVariablesDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCAL_VARIABLES_DECLARATION, localVariablesDeclaration$RuleMemoStart, localVariablesDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (localVariablesDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(localVariablesDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("local" | "loca") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("local" | "loca")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
      if (match) {
         ++index;
         // ("ocal" | "oca")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("cal" | "ca")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("al" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("l" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         localVariablesDeclaration$RuleMemoStart = startIndex;
         localVariablesDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            localVariablesDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCAL_VARIABLES_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            localVariablesDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         localVariablesDeclaration$RuleMemoStart = startIndex;
         localVariablesDeclaration$RuleMemoEnd = -1;
         localVariablesDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionDeclaration : (FunctionModifier ("function" | "functio" | "functi" | "funct" | "func") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
   protected boolean functionDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionDeclaration$RuleMemoStart == index) {
         if (functionDeclaration$RuleMemoStart <= functionDeclaration$RuleMemoEnd) {
            index = functionDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_DECLARATION, functionDeclaration$RuleMemoStart, functionDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (FunctionModifier ("function" | "functio" | "functi" | "funct" | "func") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
      // FunctionModifier
      match = functionModifier$Rule();
      if (match) {
         // ("function" | "functio" | "functi" | "funct" | "func")
         int startIndex_1 = index;
         match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
         if (match) {
            ++index;
            // ("unction" | "unctio" | "uncti" | "unct" | "unc")
            match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
            if (match) {
               ++index;
               // ("nction" | "nctio" | "ncti" | "nct" | "nc")
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("ction" | "ctio" | "cti" | "ct" | "c")
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("ion" | "io" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("on" | "o" | <EMPTY>)
                           match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                           if (match) {
                              ++index;
                              // ("n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_1;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // ParParametersDeclaration?
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // ParParametersDeclaration
                     match = parParametersDeclaration$Rule();
                     if (! match) {
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        index = lastIndex_3;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = -1;
         functionDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ProcedureDeclaration : (FunctionModifier ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
   protected boolean procedureDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (procedureDeclaration$RuleMemoStart == index) {
         if (procedureDeclaration$RuleMemoStart <= procedureDeclaration$RuleMemoEnd) {
            index = procedureDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PROCEDURE_DECLARATION, procedureDeclaration$RuleMemoStart, procedureDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (procedureDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(procedureDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (FunctionModifier ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
      // FunctionModifier
      match = functionModifier$Rule();
      if (match) {
         // ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc")
         int startIndex_1 = index;
         match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
         if (match) {
            ++index;
            // ("rocedure" | "rocedur" | "rocedu" | "roced" | "roce" | "roc")
            match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
            if (match) {
               ++index;
               // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
               match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
               if (match) {
                  ++index;
                  // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                        match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                        if (match) {
                           ++index;
                           // ("ure" | "ur" | "u" | <EMPTY>)
                           match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                           if (match) {
                              ++index;
                              // ("re" | "r" | <EMPTY>)
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_1;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // ParParametersDeclaration?
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // ParParametersDeclaration
                     match = parParametersDeclaration$Rule();
                     if (! match) {
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        index = lastIndex_3;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            procedureDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PROCEDURE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            procedureDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = -1;
         procedureDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MethodDefinition : ((("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing) (("procedure" | "function") TestNoAlpha OptionalSpacing)? AnyIdentifier ParParametersDeclaration ClassOwner?)
   protected boolean methodDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodDefinition$RuleMemoStart == index) {
         if (methodDefinition$RuleMemoStart <= methodDefinition$RuleMemoEnd) {
            index = methodDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DEFINITION, methodDefinition$RuleMemoStart, methodDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (methodDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(methodDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing) (("procedure" | "function") TestNoAlpha OptionalSpacing)? AnyIdentifier ParParametersDeclaration ClassOwner?)
      // (("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing)
      // ("method" | "classmethod" | "constructor")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'c':
         case 'C': {
            ++index;
            // ("lassmethod" | "onstructor")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "nstructor"
                  if (match = ignoreCaseStringTest("nstructor", 9)) {
                     index += 9;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "assmethod"
                  if (match = ignoreCaseStringTest("assmethod", 9)) {
                     index += 9;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // "ethod"
            if (match = ignoreCaseStringTest("ethod", 5)) {
               index += 5;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // (("procedure" | "function") TestNoAlpha OptionalSpacing)?
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // (("procedure" | "function") TestNoAlpha OptionalSpacing)
         // ("procedure" | "function")
         int startIndex_4 = index;
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F': {
               ++index;
               // "unction"
               if (match = ignoreCaseStringTest("unction", 7)) {
                  index += 7;
               }
               break;
            }
            case 'p':
            case 'P': {
               ++index;
               // "rocedure"
               if (match = ignoreCaseStringTest("rocedure", 8)) {
                  index += 8;
               }
               break;
            }
            default: {
               match = false;
            }
         }
         if (! match) {
            index = startIndex_4;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
            index = lastIndex_3;
            match = true;
         }
         if (match) {
            // AnyIdentifier
            match = anyIdentifier$Rule();
            if (match) {
               // ParParametersDeclaration
               match = parParametersDeclaration$Rule();
               if (match) {
                  // ClassOwner?
                  Node lastNode_6 = currentNode;
                  int lastIndex_6 = index;
                  // ClassOwner
                  match = classOwner$Rule();
                  if (! match) {
                     lastNode_6.setSibling(null);
                     currentNode = lastNode_6;
                     index = lastIndex_6;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         methodDefinition$RuleMemoStart = startIndex;
         methodDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodDefinition$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         methodDefinition$RuleMemoStart = startIndex;
         methodDefinition$RuleMemoEnd = -1;
         methodDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassOwner : ("class" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean classOwner$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("class" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "class"
      match = ignoreCaseStringMatcher("class", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_OWNER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CreateClass : (("create" TestNoAlpha OptionalSpacing)? "class" TestNoAlpha OptionalSpacing AnyIdentifier ("from" TestNoAlpha OptionalSpacing IdentifierList)?)
   protected boolean createClass$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (createClass$RuleMemoStart == index) {
         if (createClass$RuleMemoStart <= createClass$RuleMemoEnd) {
            index = createClass$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CLASS, createClass$RuleMemoStart, createClass$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createClass$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createClass$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("create" TestNoAlpha OptionalSpacing)? "class" TestNoAlpha OptionalSpacing AnyIdentifier ("from" TestNoAlpha OptionalSpacing IdentifierList)?)
      // ("create" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("create" TestNoAlpha OptionalSpacing)
      // "create"
      match = ignoreCaseStringMatcher("create", 6);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "class"
         match = ignoreCaseStringMatcher("class", 5);
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // AnyIdentifier
                  match = anyIdentifier$Rule();
                  if (match) {
                     // ("from" TestNoAlpha OptionalSpacing IdentifierList)?
                     Node lastNode_4 = currentNode;
                     int lastIndex_4 = index;
                     // ("from" TestNoAlpha OptionalSpacing IdentifierList)
                     // "from"
                     match = ignoreCaseStringMatcher("from", 4);
                     if (match) {
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                        Node lastNode_5 = currentNode;
                        int lastIndex_5 = index;
                        // 'a'-'z'
                        match = buffer.matchCharRange(index, 'a', 'z');
                        if (! match) {
                           // 'A'-'Z'
                           match = buffer.matchCharRange(index, 'A', 'Z');
                           if (! match) {
                              // '0'-'9'
                              match = buffer.matchCharRange(index, '0', '9');
                              if (! match) {
                                 // '_'
                                 match = buffer.matchChar(index, '_');
                              }
                           }
                        }
                        match = ! match;
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // IdentifierList
                              match = identifierList$Rule();
                           }
                        }
                     }
                     if (! match) {
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                        index = lastIndex_4;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         createClass$RuleMemoStart = startIndex;
         createClass$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createClass$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CLASS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createClass$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         createClass$RuleMemoStart = startIndex;
         createClass$RuleMemoEnd = -1;
         createClass$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndClass : ("endclass" TestNoAlpha OptionalSpacing)
   protected boolean endClass$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endClass$RuleMemoStart == index) {
         if (endClass$RuleMemoStart <= endClass$RuleMemoEnd) {
            index = endClass$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_CLASS, endClass$RuleMemoStart, endClass$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (endClass$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endClass$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("endclass" TestNoAlpha OptionalSpacing)
      // "endclass"
      match = ignoreCaseStringMatcher("endclass", 8);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         endClass$RuleMemoStart = startIndex;
         endClass$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endClass$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_CLASS, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endClass$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endClass$RuleMemoStart = startIndex;
         endClass$RuleMemoEnd = -1;
         endClass$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassBodyStmt : (SectionScope | MethodMember | FieldMember)
   protected boolean classBodyStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classBodyStmt$RuleMemoStart == index) {
         if (classBodyStmt$RuleMemoStart <= classBodyStmt$RuleMemoEnd) {
            index = classBodyStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_BODY_STMT, classBodyStmt$RuleMemoStart, classBodyStmt$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (classBodyStmt$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(classBodyStmt$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SectionScope | MethodMember | FieldMember)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'm':
         case 'M': {
            // MethodMember
            match = methodMember$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'p':
         case 'P': {
            // SectionScope
            match = sectionScope$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MethodMember
               match = methodMember$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'a':
         case 'A':
         case 'c':
         case 'C': {
            // MethodMember
            match = methodMember$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FieldMember
               match = fieldMember$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            // FieldMember
            match = fieldMember$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'e':
         case 'E':
         case 'h':
         case 'H': {
            // SectionScope
            match = sectionScope$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'v':
         case 'V': {
            // SectionScope
            match = sectionScope$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FieldMember
               match = fieldMember$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         classBodyStmt$RuleMemoStart = startIndex;
         classBodyStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classBodyStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_BODY_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classBodyStmt$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         classBodyStmt$RuleMemoStart = startIndex;
         classBodyStmt$RuleMemoEnd = -1;
         classBodyStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SectionScope : (MemberScope ':' OptionalSpacing)
   protected boolean sectionScope$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sectionScope$RuleMemoStart == index) {
         if (sectionScope$RuleMemoStart <= sectionScope$RuleMemoEnd) {
            index = sectionScope$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SECTION_SCOPE, sectionScope$RuleMemoStart, sectionScope$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sectionScope$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sectionScope$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MemberScope ':' OptionalSpacing)
      // MemberScope
      match = memberScope$Rule();
      if (match) {
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         sectionScope$RuleMemoStart = startIndex;
         sectionScope$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sectionScope$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SECTION_SCOPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sectionScope$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         sectionScope$RuleMemoStart = startIndex;
         sectionScope$RuleMemoEnd = -1;
         sectionScope$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemberScope : (("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published") TestNoAlpha OptionalSpacing)
   protected boolean memberScope$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (memberScope$RuleMemoStart == index) {
         if (memberScope$RuleMemoStart <= memberScope$RuleMemoEnd) {
            index = memberScope$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPE, memberScope$RuleMemoStart, memberScope$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (memberScope$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(memberScope$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published") TestNoAlpha OptionalSpacing)
      // ("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'v':
         case 'V': {
            ++index;
            // "isible"
            if (match = ignoreCaseStringTest("isible", 6)) {
               index += 6;
            }
            break;
         }
         case 'h':
         case 'H': {
            ++index;
            // "idden"
            if (match = ignoreCaseStringTest("idden", 5)) {
               index += 5;
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // ("rotected" | "ublished" | "rivate" | "ublic")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("otected" | "ivate")
                  switch(buffer.getChar(index)) {
                     case 'o':
                     case 'O': {
                        ++index;
                        // "tected"
                        if (match = ignoreCaseStringTest("tected", 6)) {
                           index += 6;
                        }
                        break;
                     }
                     case 'i':
                     case 'I': {
                        ++index;
                        // "vate"
                        if (match = ignoreCaseStringTest("vate", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("blished" | "blic")
                  match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                  if (match) {
                     ++index;
                     // ("lished" | "lic")
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("ished" | "ic")
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("shed" | "c")
                           switch(buffer.getChar(index)) {
                              case 's':
                              case 'S': {
                                 ++index;
                                 // "hed"
                                 if (match = ignoreCaseStringTest("hed", 3)) {
                                    index += 3;
                                 }
                                 break;
                              }
                              case 'c':
                              case 'C': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // ("xported" | "xport")
            match = buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X');
            if (match) {
               ++index;
               // ("ported" | "port")
               match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
               if (match) {
                  ++index;
                  // ("orted" | "ort")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("rted" | "rt")
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("ted" | "t")
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("ed" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // "d"
                              if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                                 ++index;
                              }
                           } else {
                              match = true;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         memberScope$RuleMemoStart = startIndex;
         memberScope$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            memberScope$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            memberScope$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         memberScope$RuleMemoStart = startIndex;
         memberScope$RuleMemoEnd = -1;
         memberScope$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemberScopes : MemberScope*
   protected boolean memberScopes$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (memberScopes$RuleMemoStart == index) {
         if (memberScopes$RuleMemoStart <= memberScopes$RuleMemoEnd) {
            index = memberScopes$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPES, memberScopes$RuleMemoStart, memberScopes$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (memberScopes$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(memberScopes$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // MemberScope*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // MemberScope
         match = memberScope$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      memberScopes$RuleMemoStart = startIndex;
      memberScopes$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         memberScopes$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPES, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         memberScopes$RuleMemoFirstNode = currentNode;
      }
      return true;
   }

   //MethodMember : ((("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing) AnyIdentifier ParParametersDeclaration ("constructor" TestNoAlpha OptionalSpacing)? AsType MemberScopes InLineExpression)
   protected boolean methodMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodMember$RuleMemoStart == index) {
         if (methodMember$RuleMemoStart <= methodMember$RuleMemoEnd) {
            index = methodMember$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_MEMBER, methodMember$RuleMemoStart, methodMember$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (methodMember$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(methodMember$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing) AnyIdentifier ParParametersDeclaration ("constructor" TestNoAlpha OptionalSpacing)? AsType MemberScopes InLineExpression)
      // (("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing)
      // ("method" | "classmethod" | "constructor" | "procedure" | "assign")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'p':
         case 'P': {
            ++index;
            // "rocedure"
            if (match = ignoreCaseStringTest("rocedure", 8)) {
               index += 8;
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // "ssign"
            if (match = ignoreCaseStringTest("ssign", 5)) {
               index += 5;
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // ("lassmethod" | "onstructor")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "nstructor"
                  if (match = ignoreCaseStringTest("nstructor", 9)) {
                     index += 9;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "assmethod"
                  if (match = ignoreCaseStringTest("assmethod", 9)) {
                     index += 9;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // "ethod"
            if (match = ignoreCaseStringTest("ethod", 5)) {
               index += 5;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // AnyIdentifier
         match = anyIdentifier$Rule();
         if (match) {
            // ParParametersDeclaration
            match = parParametersDeclaration$Rule();
            if (match) {
               // ("constructor" TestNoAlpha OptionalSpacing)?
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ("constructor" TestNoAlpha OptionalSpacing)
               // "constructor"
               match = ignoreCaseStringMatcher("constructor", 11);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  match = true;
               }
               if (match) {
                  // AsType
                  match = asType$Rule();
                  if (match) {
                     // MemberScopes
                     match = memberScopes$Rule();
                     if (match) {
                        // InLineExpression
                        match = inLineExpression$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         methodMember$RuleMemoStart = startIndex;
         methodMember$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodMember$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodMember$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         methodMember$RuleMemoStart = startIndex;
         methodMember$RuleMemoEnd = -1;
         methodMember$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FieldMember : ((("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing) AnyIdentifier AsType InitFieldMember IsInObject? MemberScopes InLineExpression)
   protected boolean fieldMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (fieldMember$RuleMemoStart == index) {
         if (fieldMember$RuleMemoStart <= fieldMember$RuleMemoEnd) {
            index = fieldMember$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELD_MEMBER, fieldMember$RuleMemoStart, fieldMember$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (fieldMember$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(fieldMember$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing) AnyIdentifier AsType InitFieldMember IsInObject? MemberScopes InLineExpression)
      // (("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing)
      // ("data" | "var" | "classvar" | "access")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'v':
         case 'V': {
            ++index;
            // "ar"
            if (match = ignoreCaseStringTest("ar", 2)) {
               index += 2;
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // "ccess"
            if (match = ignoreCaseStringTest("ccess", 5)) {
               index += 5;
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // "lassvar"
            if (match = ignoreCaseStringTest("lassvar", 7)) {
               index += 7;
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // "ata"
            if (match = ignoreCaseStringTest("ata", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // AnyIdentifier
         match = anyIdentifier$Rule();
         if (match) {
            // AsType
            match = asType$Rule();
            if (match) {
               // InitFieldMember
               match = initFieldMember$Rule();
               if (match) {
                  // IsInObject?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // IsInObject
                  match = isInObject$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
                  if (match) {
                     // MemberScopes
                     match = memberScopes$Rule();
                     if (match) {
                        // InLineExpression
                        match = inLineExpression$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         fieldMember$RuleMemoStart = startIndex;
         fieldMember$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fieldMember$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fieldMember$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         fieldMember$RuleMemoStart = startIndex;
         fieldMember$RuleMemoEnd = -1;
         fieldMember$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InLineExpression : ("inline" TestNoAlpha OptionalSpacing ExpressionList)?
   protected boolean inLineExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (inLineExpression$RuleMemoStart == index) {
         if (inLineExpression$RuleMemoStart <= inLineExpression$RuleMemoEnd) {
            index = inLineExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_LINE_EXPRESSION, inLineExpression$RuleMemoStart, inLineExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (inLineExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(inLineExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("inline" TestNoAlpha OptionalSpacing ExpressionList)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("inline" TestNoAlpha OptionalSpacing ExpressionList)
      // "inline"
      match = ignoreCaseStringMatcher("inline", 6);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ExpressionList
               match = expressionList$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         inLineExpression$RuleMemoStart = startIndex;
         inLineExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inLineExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_LINE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inLineExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         inLineExpression$RuleMemoStart = startIndex;
         inLineExpression$RuleMemoEnd = -1;
         inLineExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InitFieldMember : ("init" TestNoAlpha OptionalSpacing Expression)?
   protected boolean initFieldMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("init" TestNoAlpha OptionalSpacing Expression)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("init" TestNoAlpha OptionalSpacing Expression)
      // "init"
      match = ignoreCaseStringMatcher("init", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INIT_FIELD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IsInObject : ("is" TestNoAlpha OptionalSpacing AnyIdentifier "in" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean isInObject$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("is" TestNoAlpha OptionalSpacing AnyIdentifier "in" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "is"
      match = ignoreCaseStringMatcher("is", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
               if (match) {
                  // "in"
                  match = ignoreCaseStringMatcher("in", 2);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // AnyIdentifier
                           match = anyIdentifier$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IS_IN_OBJECT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Variable : (VariablePattern OptionalSpacing)
   protected boolean variable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variable$RuleMemoStart == index) {
         if (variable$RuleMemoStart <= variable$RuleMemoEnd) {
            index = variable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, variable$RuleMemoStart, variable$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (variable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variable$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (VariablePattern OptionalSpacing)
      // VariablePattern
      match = variablePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         variable$RuleMemoStart = startIndex;
         variable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variable$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         variable$RuleMemoStart = startIndex;
         variable$RuleMemoEnd = -1;
         variable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariablePattern : (IdentifierPattern (('(' | '->') OptionalSpacing)!)
   protected boolean variablePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdentifierPattern (('(' | '->') OptionalSpacing)!)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // (('(' | '->') OptionalSpacing)!
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         boolean lastAtomic_1 = currentRuleIsAtomic;
         // (('(' | '->') OptionalSpacing)
         // ('(' | '->')
         int startIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '-': {
               ++index;
               // '>'
               if (match = buffer.matchChar(index, '>')) {
                  ++index;
               }
               break;
            }
            case '(': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (! match) {
            index = startIndex_2;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         currentRuleIsAtomic = lastAtomic_1;
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         match = ! match;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StaticVariablesDeclaration : (("static" | "stati" | "stat") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean staticVariablesDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (staticVariablesDeclaration$RuleMemoStart == index) {
         if (staticVariablesDeclaration$RuleMemoStart <= staticVariablesDeclaration$RuleMemoEnd) {
            index = staticVariablesDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATIC_VARIABLES_DECLARATION, staticVariablesDeclaration$RuleMemoStart, staticVariablesDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (staticVariablesDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(staticVariablesDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("static" | "stati" | "stat") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("static" | "stati" | "stat")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
      if (match) {
         ++index;
         // ("tatic" | "tati" | "tat")
         match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
         if (match) {
            ++index;
            // ("atic" | "ati" | "at")
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("tic" | "ti" | "t")
               match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
               if (match) {
                  ++index;
                  // ("ic" | "i" | <EMPTY>)
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("c" | <EMPTY>)
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         staticVariablesDeclaration$RuleMemoStart = startIndex;
         staticVariablesDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            staticVariablesDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATIC_VARIABLES_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            staticVariablesDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         staticVariablesDeclaration$RuleMemoStart = startIndex;
         staticVariablesDeclaration$RuleMemoEnd = -1;
         staticVariablesDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FieldsDeclaration : (("field" | "fiel") TestNoAlpha OptionalSpacing IdentifierList InTable?)
   protected boolean fieldsDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (fieldsDeclaration$RuleMemoStart == index) {
         if (fieldsDeclaration$RuleMemoStart <= fieldsDeclaration$RuleMemoEnd) {
            index = fieldsDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELDS_DECLARATION, fieldsDeclaration$RuleMemoStart, fieldsDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (fieldsDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(fieldsDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("field" | "fiel") TestNoAlpha OptionalSpacing IdentifierList InTable?)
      // ("field" | "fiel")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
      if (match) {
         ++index;
         // ("ield" | "iel")
         match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
         if (match) {
            ++index;
            // ("eld" | "el")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("ld" | "l")
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("d" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
               if (match) {
                  // InTable?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // InTable
                  match = inTable$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         fieldsDeclaration$RuleMemoStart = startIndex;
         fieldsDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fieldsDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELDS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fieldsDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         fieldsDeclaration$RuleMemoStart = startIndex;
         fieldsDeclaration$RuleMemoEnd = -1;
         fieldsDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassDeclaration : ("_HB_CLASS" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean classDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classDeclaration$RuleMemoStart == index) {
         if (classDeclaration$RuleMemoStart <= classDeclaration$RuleMemoEnd) {
            index = classDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_DECLARATION, classDeclaration$RuleMemoStart, classDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (classDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(classDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("_HB_CLASS" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "_HB_CLASS"
      match = ignoreCaseStringMatcher("_HB_CLASS", 9);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         classDeclaration$RuleMemoStart = startIndex;
         classDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         classDeclaration$RuleMemoStart = startIndex;
         classDeclaration$RuleMemoEnd = -1;
         classDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OldStyleParametersDeclaration : (("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para") TestNoAlpha OptionalSpacing ParametersDeclarationList)
   protected boolean oldStyleParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (oldStyleParametersDeclaration$RuleMemoStart == index) {
         if (oldStyleParametersDeclaration$RuleMemoStart <= oldStyleParametersDeclaration$RuleMemoEnd) {
            index = oldStyleParametersDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_PARAMETERS_DECLARATION, oldStyleParametersDeclaration$RuleMemoStart, oldStyleParametersDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (oldStyleParametersDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(oldStyleParametersDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para") TestNoAlpha OptionalSpacing ParametersDeclarationList)
      // ("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
      if (match) {
         ++index;
         // ("arameters" | "arameter" | "aramete" | "aramet" | "arame" | "aram" | "ara")
         match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
         if (match) {
            ++index;
            // ("rameters" | "rameter" | "ramete" | "ramet" | "rame" | "ram" | "ra")
            match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
            if (match) {
               ++index;
               // ("ameters" | "ameter" | "amete" | "amet" | "ame" | "am" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("meters" | "meter" | "mete" | "met" | "me" | "m" | <EMPTY>)
                  match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                  if (match) {
                     ++index;
                     // ("eters" | "eter" | "ete" | "et" | "e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("ters" | "ter" | "te" | "t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("ers" | "er" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("rs" | "r" | <EMPTY>)
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // ("s" | <EMPTY>)
                                 match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ParametersDeclarationList
               match = parametersDeclarationList$Rule();
            }
         }
      }
      if (match) {
         oldStyleParametersDeclaration$RuleMemoStart = startIndex;
         oldStyleParametersDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            oldStyleParametersDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_PARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            oldStyleParametersDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         oldStyleParametersDeclaration$RuleMemoStart = startIndex;
         oldStyleParametersDeclaration$RuleMemoEnd = -1;
         oldStyleParametersDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DeclareStatement : (("declare" | "declar" | "decla" | "decl") TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean declareStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (declareStatement$RuleMemoStart == index) {
         if (declareStatement$RuleMemoStart <= declareStatement$RuleMemoEnd) {
            index = declareStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DECLARE_STATEMENT, declareStatement$RuleMemoStart, declareStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (declareStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(declareStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("declare" | "declar" | "decla" | "decl") TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // ("declare" | "declar" | "decla" | "decl")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
      if (match) {
         ++index;
         // ("eclare" | "eclar" | "ecla" | "ecl")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("clare" | "clar" | "cla" | "cl")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("lare" | "lar" | "la" | "l")
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("are" | "ar" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("re" | "r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IgnoreRestOfLine
               match = ignoreRestOfLine$Rule();
            }
         }
      }
      if (match) {
         declareStatement$RuleMemoStart = startIndex;
         declareStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            declareStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DECLARE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            declareStatement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         declareStatement$RuleMemoStart = startIndex;
         declareStatement$RuleMemoEnd = -1;
         declareStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExitStmt : ("exit" TestNoAlpha OptionalSpacing)
   protected boolean exitStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (exitStmt$RuleMemoStart == index) {
         if (exitStmt$RuleMemoStart <= exitStmt$RuleMemoEnd) {
            index = exitStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXIT_STMT, exitStmt$RuleMemoStart, exitStmt$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (exitStmt$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(exitStmt$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("exit" TestNoAlpha OptionalSpacing)
      // "exit"
      match = ignoreCaseStringMatcher("exit", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         exitStmt$RuleMemoStart = startIndex;
         exitStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            exitStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXIT_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            exitStmt$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         exitStmt$RuleMemoStart = startIndex;
         exitStmt$RuleMemoEnd = -1;
         exitStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LoopStmt : ("loop" TestNoAlpha OptionalSpacing)
   protected boolean loopStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (loopStmt$RuleMemoStart == index) {
         if (loopStmt$RuleMemoStart <= loopStmt$RuleMemoEnd) {
            index = loopStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOOP_STMT, loopStmt$RuleMemoStart, loopStmt$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (loopStmt$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(loopStmt$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("loop" TestNoAlpha OptionalSpacing)
      // "loop"
      match = ignoreCaseStringMatcher("loop", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         loopStmt$RuleMemoStart = startIndex;
         loopStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            loopStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOOP_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            loopStmt$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         loopStmt$RuleMemoStart = startIndex;
         loopStmt$RuleMemoEnd = -1;
         loopStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Directive : (IncludeDirective | DefineDirective | TranslateDirective | XTranslateDirective | XCommandDirective | YTranslateDirective | YCommandDirective | CommandDirective | IfDefDirective | IfDirective | IfNDefDirective | ElseDirective | EndIfDirective | PragmaDirective | UndefDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | StdoutDirective | ErrorDirective | LineDirective)
   protected boolean directive$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (directive$RuleMemoStart == index) {
         if (directive$RuleMemoStart <= directive$RuleMemoEnd) {
            index = directive$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIRECTIVE, directive$RuleMemoStart, directive$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (directive$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(directive$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IncludeDirective | DefineDirective | TranslateDirective | XTranslateDirective | XCommandDirective | YTranslateDirective | YCommandDirective | CommandDirective | IfDefDirective | IfDirective | IfNDefDirective | ElseDirective | EndIfDirective | PragmaDirective | UndefDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | StdoutDirective | ErrorDirective | LineDirective)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '#': {
            // IncludeDirective
            match = includeDirective$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // DefineDirective
               match = defineDirective$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // TranslateDirective
                  match = translateDirective$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // XTranslateDirective
                     match = xTranslateDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // XCommandDirective
                        match = xCommandDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // YTranslateDirective
                           match = yTranslateDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // YCommandDirective
                              match = yCommandDirective$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // CommandDirective
                                 match = commandDirective$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IfDefDirective
                                    match = ifDefDirective$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // IfDirective
                                       match = ifDirective$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // IfNDefDirective
                                          match = ifNDefDirective$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // ElseDirective
                                             match = elseDirective$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // EndIfDirective
                                                match = endIfDirective$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // PragmaDirective
                                                   match = pragmaDirective$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // UndefDirective
                                                      match = undefDirective$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                         // UntranslateDirective
                                                         match = untranslateDirective$Rule();
                                                         if (! match) {
                                                            index = lastIndex_1;
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            // XUntranslateDirective
                                                            match = xUntranslateDirective$Rule();
                                                            if (! match) {
                                                               index = lastIndex_1;
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               // YUntranslateDirective
                                                               match = yUntranslateDirective$Rule();
                                                               if (! match) {
                                                                  index = lastIndex_1;
                                                                  lastNode_1.setSibling(null);
                                                                  currentNode = lastNode_1;
                                                                  // UncommandDirective
                                                                  match = uncommandDirective$Rule();
                                                                  if (! match) {
                                                                     index = lastIndex_1;
                                                                     lastNode_1.setSibling(null);
                                                                     currentNode = lastNode_1;
                                                                     // XUncommandDirective
                                                                     match = xUncommandDirective$Rule();
                                                                     if (! match) {
                                                                        index = lastIndex_1;
                                                                        lastNode_1.setSibling(null);
                                                                        currentNode = lastNode_1;
                                                                        // YUncommandDirective
                                                                        match = yUncommandDirective$Rule();
                                                                        if (! match) {
                                                                           index = lastIndex_1;
                                                                           lastNode_1.setSibling(null);
                                                                           currentNode = lastNode_1;
                                                                           // StdoutDirective
                                                                           match = stdoutDirective$Rule();
                                                                           if (! match) {
                                                                              index = lastIndex_1;
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              // ErrorDirective
                                                                              match = errorDirective$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_1;
                                                                                 lastNode_1.setSibling(null);
                                                                                 currentNode = lastNode_1;
                                                                                 // LineDirective
                                                                                 match = lineDirective$Rule();
                                                                                 if (! match) {
                                                                                    index = lastIndex_1;
                                                                                    lastNode_1.setSibling(null);
                                                                                    currentNode = lastNode_1;
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         directive$RuleMemoStart = startIndex;
         directive$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            directive$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIRECTIVE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            directive$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         directive$RuleMemoStart = startIndex;
         directive$RuleMemoEnd = -1;
         directive$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineDirective : ('#' OptionalSpacing "line" TestNoAlpha OptionalSpacing NumberLiteral StringLiteral)
   protected boolean lineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (lineDirective$RuleMemoStart == index) {
         if (lineDirective$RuleMemoStart <= lineDirective$RuleMemoEnd) {
            index = lineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_DIRECTIVE, lineDirective$RuleMemoStart, lineDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lineDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "line" TestNoAlpha OptionalSpacing NumberLiteral StringLiteral)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "line"
            match = ignoreCaseStringMatcher("line", 4);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // NumberLiteral
                     match = numberLiteral$Rule();
                     if (match) {
                        // StringLiteral
                        match = stringLiteral$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lineDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = -1;
         lineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeDirective : ('#' OptionalSpacing "include" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean includeDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (includeDirective$RuleMemoStart == index) {
         if (includeDirective$RuleMemoStart <= includeDirective$RuleMemoEnd) {
            index = includeDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.INCLUDE_DIRECTIVE, includeDirective$RuleMemoStart, includeDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (includeDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(includeDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "include" TestNoAlpha OptionalSpacing StringLiteral)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "include"
            match = ignoreCaseStringMatcher("include", 7);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // StringLiteral
                     match = stringLiteral$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            includeDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INCLUDE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            includeDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = -1;
         includeDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineDirective : ('#' OptionalSpacing "define" TestNoAlpha OptionalSpacing AnyIdentifier ParParametersDeclaration? AnyToken*)
   protected boolean defineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (defineDirective$RuleMemoStart == index) {
         if (defineDirective$RuleMemoStart <= defineDirective$RuleMemoEnd) {
            index = defineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFINE_DIRECTIVE, defineDirective$RuleMemoStart, defineDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (defineDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(defineDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "define" TestNoAlpha OptionalSpacing AnyIdentifier ParParametersDeclaration? AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "define"
            match = ignoreCaseStringMatcher("define", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyIdentifier
                     match = anyIdentifier$Rule();
                     if (match) {
                        // ParParametersDeclaration?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // ParParametersDeclaration
                        match = parParametersDeclaration$Rule();
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                        if (match) {
                           // AnyToken*
                           Node lastNode_3;
                           int lastIndex_3;
                           do {
                              lastNode_3 = currentNode;
                              lastIndex_3 = index;
                              // AnyToken
                              match = anyToken$Rule();
                           } while(match);
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            defineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            defineDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = -1;
         defineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TranslateDirective : ('#' OptionalSpacing "translate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean translateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (translateDirective$RuleMemoStart == index) {
         if (translateDirective$RuleMemoStart <= translateDirective$RuleMemoEnd) {
            index = translateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRANSLATE_DIRECTIVE, translateDirective$RuleMemoStart, translateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (translateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(translateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "translate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "translate"
            match = ignoreCaseStringMatcher("translate", 9);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            translateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            translateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = -1;
         translateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslateDirective : ('#' OptionalSpacing "xtranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xTranslateDirective$RuleMemoStart == index) {
         if (xTranslateDirective$RuleMemoStart <= xTranslateDirective$RuleMemoEnd) {
            index = xTranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.XTRANSLATE_DIRECTIVE, xTranslateDirective$RuleMemoStart, xTranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xTranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xTranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xtranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xtranslate"
            match = ignoreCaseStringMatcher("xtranslate", 10);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xTranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xTranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = -1;
         xTranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YTranslateDirective : ('#' OptionalSpacing "ytranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean yTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yTranslateDirective$RuleMemoStart == index) {
         if (yTranslateDirective$RuleMemoStart <= yTranslateDirective$RuleMemoEnd) {
            index = yTranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.YTRANSLATE_DIRECTIVE, yTranslateDirective$RuleMemoStart, yTranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yTranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yTranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ytranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ytranslate"
            match = ignoreCaseStringMatcher("ytranslate", 10);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         yTranslateDirective$RuleMemoStart = startIndex;
         yTranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yTranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.YTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yTranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yTranslateDirective$RuleMemoStart = startIndex;
         yTranslateDirective$RuleMemoEnd = -1;
         yTranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UntranslateDirective : ('#' OptionalSpacing "untranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean untranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (untranslateDirective$RuleMemoStart == index) {
         if (untranslateDirective$RuleMemoStart <= untranslateDirective$RuleMemoEnd) {
            index = untranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNTRANSLATE_DIRECTIVE, untranslateDirective$RuleMemoStart, untranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (untranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(untranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "untranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "untranslate"
            match = ignoreCaseStringMatcher("untranslate", 11);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         untranslateDirective$RuleMemoStart = startIndex;
         untranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            untranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            untranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         untranslateDirective$RuleMemoStart = startIndex;
         untranslateDirective$RuleMemoEnd = -1;
         untranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUntranslateDirective : ('#' OptionalSpacing "xuntranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xUntranslateDirective$RuleMemoStart == index) {
         if (xUntranslateDirective$RuleMemoStart <= xUntranslateDirective$RuleMemoEnd) {
            index = xUntranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.XUNTRANSLATE_DIRECTIVE, xUntranslateDirective$RuleMemoStart, xUntranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xUntranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xUntranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xuntranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xuntranslate"
            match = ignoreCaseStringMatcher("xuntranslate", 12);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xUntranslateDirective$RuleMemoStart = startIndex;
         xUntranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xUntranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xUntranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xUntranslateDirective$RuleMemoStart = startIndex;
         xUntranslateDirective$RuleMemoEnd = -1;
         xUntranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUntranslateDirective : ('#' OptionalSpacing "yuntranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean yUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yUntranslateDirective$RuleMemoStart == index) {
         if (yUntranslateDirective$RuleMemoStart <= yUntranslateDirective$RuleMemoEnd) {
            index = yUntranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.YUNTRANSLATE_DIRECTIVE, yUntranslateDirective$RuleMemoStart, yUntranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yUntranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yUntranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "yuntranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "yuntranslate"
            match = ignoreCaseStringMatcher("yuntranslate", 12);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         yUntranslateDirective$RuleMemoStart = startIndex;
         yUntranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yUntranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.YUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yUntranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yUntranslateDirective$RuleMemoStart = startIndex;
         yUntranslateDirective$RuleMemoEnd = -1;
         yUntranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommandDirective : ('#' OptionalSpacing "command" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean commandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commandDirective$RuleMemoStart == index) {
         if (commandDirective$RuleMemoStart <= commandDirective$RuleMemoEnd) {
            index = commandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMAND_DIRECTIVE, commandDirective$RuleMemoStart, commandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (commandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(commandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "command" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "command"
            match = ignoreCaseStringMatcher("command", 7);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = -1;
         commandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommandDirective : ('#' OptionalSpacing "xcommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xCommandDirective$RuleMemoStart == index) {
         if (xCommandDirective$RuleMemoStart <= xCommandDirective$RuleMemoEnd) {
            index = xCommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.XCOMMAND_DIRECTIVE, xCommandDirective$RuleMemoStart, xCommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xCommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xCommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xcommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xcommand"
            match = ignoreCaseStringMatcher("xcommand", 8);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xCommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xCommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = -1;
         xCommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YCommandDirective : ('#' OptionalSpacing "ycommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean yCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yCommandDirective$RuleMemoStart == index) {
         if (yCommandDirective$RuleMemoStart <= yCommandDirective$RuleMemoEnd) {
            index = yCommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.YCOMMAND_DIRECTIVE, yCommandDirective$RuleMemoStart, yCommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yCommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yCommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ycommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ycommand"
            match = ignoreCaseStringMatcher("ycommand", 8);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         yCommandDirective$RuleMemoStart = startIndex;
         yCommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yCommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.YCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yCommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yCommandDirective$RuleMemoStart = startIndex;
         yCommandDirective$RuleMemoEnd = -1;
         yCommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UncommandDirective : ('#' OptionalSpacing "uncommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean uncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (uncommandDirective$RuleMemoStart == index) {
         if (uncommandDirective$RuleMemoStart <= uncommandDirective$RuleMemoEnd) {
            index = uncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNCOMMAND_DIRECTIVE, uncommandDirective$RuleMemoStart, uncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (uncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(uncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "uncommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "uncommand"
            match = ignoreCaseStringMatcher("uncommand", 9);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         uncommandDirective$RuleMemoStart = startIndex;
         uncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            uncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            uncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         uncommandDirective$RuleMemoStart = startIndex;
         uncommandDirective$RuleMemoEnd = -1;
         uncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUncommandDirective : ('#' OptionalSpacing "xuncommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xUncommandDirective$RuleMemoStart == index) {
         if (xUncommandDirective$RuleMemoStart <= xUncommandDirective$RuleMemoEnd) {
            index = xUncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.XUNCOMMAND_DIRECTIVE, xUncommandDirective$RuleMemoStart, xUncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xUncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xUncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xuncommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xuncommand"
            match = ignoreCaseStringMatcher("xuncommand", 10);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xUncommandDirective$RuleMemoStart = startIndex;
         xUncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xUncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xUncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xUncommandDirective$RuleMemoStart = startIndex;
         xUncommandDirective$RuleMemoEnd = -1;
         xUncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUncommandDirective : ('#' OptionalSpacing "yuncommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean yUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yUncommandDirective$RuleMemoStart == index) {
         if (yUncommandDirective$RuleMemoStart <= yUncommandDirective$RuleMemoEnd) {
            index = yUncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.YUNCOMMAND_DIRECTIVE, yUncommandDirective$RuleMemoStart, yUncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yUncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yUncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "yuncommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "yuncommand"
            match = ignoreCaseStringMatcher("yuncommand", 10);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         yUncommandDirective$RuleMemoStart = startIndex;
         yUncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yUncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.YUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yUncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yUncommandDirective$RuleMemoStart = startIndex;
         yUncommandDirective$RuleMemoEnd = -1;
         yUncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDefDirective : ('#' OptionalSpacing "ifdef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifDefDirective$RuleMemoStart == index) {
         if (ifDefDirective$RuleMemoStart <= ifDefDirective$RuleMemoEnd) {
            index = ifDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DEF_DIRECTIVE, ifDefDirective$RuleMemoStart, ifDefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifDefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifDefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ifdef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ifdef"
            match = ignoreCaseStringMatcher("ifdef", 5);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifDefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = -1;
         ifDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDirective : ('#' OptionalSpacing "if" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifDirective$RuleMemoStart == index) {
         if (ifDirective$RuleMemoStart <= ifDirective$RuleMemoEnd) {
            index = ifDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DIRECTIVE, ifDirective$RuleMemoStart, ifDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "if" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "if"
            match = ignoreCaseStringMatcher("if", 2);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifDirective$RuleMemoStart = startIndex;
         ifDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifDirective$RuleMemoStart = startIndex;
         ifDirective$RuleMemoEnd = -1;
         ifDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDefDirective : ('#' OptionalSpacing "ifndef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifNDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifNDefDirective$RuleMemoStart == index) {
         if (ifNDefDirective$RuleMemoStart <= ifNDefDirective$RuleMemoEnd) {
            index = ifNDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_NDEF_DIRECTIVE, ifNDefDirective$RuleMemoStart, ifNDefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifNDefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifNDefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ifndef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ifndef"
            match = ignoreCaseStringMatcher("ifndef", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifNDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_NDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifNDefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = -1;
         ifNDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseDirective : ('#' OptionalSpacing "else" TestNoAlpha OptionalSpacing)
   protected boolean elseDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseDirective$RuleMemoStart == index) {
         if (elseDirective$RuleMemoStart <= elseDirective$RuleMemoEnd) {
            index = elseDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_DIRECTIVE, elseDirective$RuleMemoStart, elseDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (elseDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(elseDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "else" TestNoAlpha OptionalSpacing)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "else"
            match = ignoreCaseStringMatcher("else", 4);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = -1;
         elseDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIfDirective : ('#' OptionalSpacing "endif" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean endIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endIfDirective$RuleMemoStart == index) {
         if (endIfDirective$RuleMemoStart <= endIfDirective$RuleMemoEnd) {
            index = endIfDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_IF_DIRECTIVE, endIfDirective$RuleMemoStart, endIfDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endIfDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endIfDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "endif" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "endif"
            match = ignoreCaseStringMatcher("endif", 5);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // IgnoreRestOfLine
                     match = ignoreRestOfLine$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endIfDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endIfDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = -1;
         endIfDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PragmaDirective : ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean pragmaDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (pragmaDirective$RuleMemoStart == index) {
         if (pragmaDirective$RuleMemoStart <= pragmaDirective$RuleMemoEnd) {
            index = pragmaDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRAGMA_DIRECTIVE, pragmaDirective$RuleMemoStart, pragmaDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pragmaDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pragmaDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "pragma"
            match = ignoreCaseStringMatcher("pragma", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         pragmaDirective$RuleMemoStart = startIndex;
         pragmaDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragmaDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRAGMA_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragmaDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         pragmaDirective$RuleMemoStart = startIndex;
         pragmaDirective$RuleMemoEnd = -1;
         pragmaDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UndefDirective : ('#' OptionalSpacing "undef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean undefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (undefDirective$RuleMemoStart == index) {
         if (undefDirective$RuleMemoStart <= undefDirective$RuleMemoEnd) {
            index = undefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNDEF_DIRECTIVE, undefDirective$RuleMemoStart, undefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (undefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(undefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "undef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "undef"
            match = ignoreCaseStringMatcher("undef", 5);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            undefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            undefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = -1;
         undefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdoutDirective : ('#' OptionalSpacing "stdout" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean stdoutDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (stdoutDirective$RuleMemoStart == index) {
         if (stdoutDirective$RuleMemoStart <= stdoutDirective$RuleMemoEnd) {
            index = stdoutDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STDOUT_DIRECTIVE, stdoutDirective$RuleMemoStart, stdoutDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (stdoutDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stdoutDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "stdout" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "stdout"
            match = ignoreCaseStringMatcher("stdout", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         stdoutDirective$RuleMemoStart = startIndex;
         stdoutDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdoutDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STDOUT_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdoutDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         stdoutDirective$RuleMemoStart = startIndex;
         stdoutDirective$RuleMemoEnd = -1;
         stdoutDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ErrorDirective : ('#' OptionalSpacing "error" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean errorDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (errorDirective$RuleMemoStart == index) {
         if (errorDirective$RuleMemoStart <= errorDirective$RuleMemoEnd) {
            index = errorDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERROR_DIRECTIVE, errorDirective$RuleMemoStart, errorDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (errorDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(errorDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "error" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "error"
            match = ignoreCaseStringMatcher("error", 5);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            errorDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERROR_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            errorDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = -1;
         errorDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyToken : (AnyIdentifier | Spacing | Separator | StringLiteral | LogicalLiteral | NumberLiteral | TimeLiteral | DateTimeLiteral | (';' OptionalSpacing) | BlockComment | LineComment)
   protected boolean anyToken$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyToken$RuleMemoStart == index) {
         if (anyToken$RuleMemoStart <= anyToken$RuleMemoEnd) {
            index = anyToken$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_TOKEN, anyToken$RuleMemoStart, anyToken$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (anyToken$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyToken$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier | Spacing | Separator | StringLiteral | LogicalLiteral | NumberLiteral | TimeLiteral | DateTimeLiteral | (';' OptionalSpacing) | BlockComment | LineComment)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // Spacing
         match = spacing$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // Separator
            match = separator$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StringLiteral
               match = stringLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // LogicalLiteral
                  match = logicalLiteral$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // NumberLiteral
                     match = numberLiteral$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // TimeLiteral
                        match = timeLiteral$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // DateTimeLiteral
                           match = dateTimeLiteral$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // (';' OptionalSpacing)
                              // ';'
                              match = charMatcher(';');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // BlockComment
                                 match = blockComment$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // LineComment
                                    match = lineComment$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         anyToken$RuleMemoStart = startIndex;
         anyToken$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyToken$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_TOKEN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyToken$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anyToken$RuleMemoStart = startIndex;
         anyToken$RuleMemoEnd = -1;
         anyToken$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Separator : ((',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#') OptionalSpacing)
   protected boolean separator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (separator$RuleMemoStart == index) {
         if (separator$RuleMemoStart <= separator$RuleMemoEnd) {
            index = separator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEPARATOR, separator$RuleMemoStart, separator$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (separator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(separator$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#') OptionalSpacing)
      // (',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#')
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ',': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '-': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '.': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '/': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ':': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '{': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '<': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '|': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '=': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '}': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '>': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '~': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '?': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '@': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '[': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\\': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ']': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '^': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '!': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '#': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '$': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '%': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '&': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '(': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ')': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '*': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            separator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEPARATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            separator$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = -1;
         separator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CmdComplementation : (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)*
   protected boolean cmdComplementation$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (cmdComplementation$RuleMemoStart == index) {
         if (cmdComplementation$RuleMemoStart <= cmdComplementation$RuleMemoEnd) {
            index = cmdComplementation$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CMD_COMPLEMENTATION, cmdComplementation$RuleMemoStart, cmdComplementation$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (cmdComplementation$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cmdComplementation$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (AnySimpleFunctionCall | Expression | UnknownIdentifier | Separator)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '!':
            case '&':
            case '(':
            case ':':
            case '+':
            case '[':
            case '{':
            case '-':
            case '.': {
               // Expression
               match = expression$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '@':
            case '#':
            case '$':
            case '%':
            case ')':
            case '*':
            case ',':
            case '/':
            case '<':
            case '\\':
            case '|':
            case '=':
            case ']':
            case '}':
            case '>':
            case '^':
            case '~':
            case '?': {
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '0':
            case '1':
            case '2':
            case '\"':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '\'':
            case '8':
            case '9': {
               // Expression
               match = expression$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z': {
               // AnySimpleFunctionCall
               match = anySimpleFunctionCall$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // UnknownIdentifier
                     match = unknownIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
               }
               break;
            }
            default: {
               match = false;
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      cmdComplementation$RuleMemoStart = startIndex;
      cmdComplementation$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         cmdComplementation$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.CMD_COMPLEMENTATION, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         cmdComplementation$RuleMemoFirstNode = currentNode;
      }
      return true;
   }

   //UnknownIdentifier : (UnknownIdentifierPattern OptionalSpacing)
   protected boolean unknownIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (unknownIdentifier$RuleMemoStart == index) {
         if (unknownIdentifier$RuleMemoStart <= unknownIdentifier$RuleMemoEnd) {
            index = unknownIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, unknownIdentifier$RuleMemoStart, unknownIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (unknownIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unknownIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UnknownIdentifierPattern OptionalSpacing)
      // UnknownIdentifierPattern
      match = unknownIdentifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         unknownIdentifier$RuleMemoStart = startIndex;
         unknownIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unknownIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unknownIdentifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         unknownIdentifier$RuleMemoStart = startIndex;
         unknownIdentifier$RuleMemoEnd = -1;
         unknownIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UnknownIdentifierPattern : (IdentifierPattern (('(' | '->') OptionalSpacing)!)
   protected boolean unknownIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdentifierPattern (('(' | '->') OptionalSpacing)!)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // (('(' | '->') OptionalSpacing)!
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         boolean lastAtomic_1 = currentRuleIsAtomic;
         // (('(' | '->') OptionalSpacing)
         // ('(' | '->')
         int startIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '-': {
               ++index;
               // '>'
               if (match = buffer.matchChar(index, '>')) {
                  ++index;
               }
               break;
            }
            case '(': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (! match) {
            index = startIndex_2;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         currentRuleIsAtomic = lastAtomic_1;
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         match = ! match;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginProducer : ("begin" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)? (("wait" | "nowait") TestNoAlpha OptionalSpacing)*)
   protected boolean beginProducer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginProducer$RuleMemoStart == index) {
         if (beginProducer$RuleMemoStart <= beginProducer$RuleMemoEnd) {
            index = beginProducer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_PRODUCER, beginProducer$RuleMemoStart, beginProducer$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (beginProducer$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(beginProducer$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("begin" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)? (("wait" | "nowait") TestNoAlpha OptionalSpacing)*)
      // "begin"
      match = ignoreCaseStringMatcher("begin", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "producer"
               match = ignoreCaseStringMatcher("producer", 8);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)?
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)
                        // "transaction"
                        match = ignoreCaseStringMatcher("transaction", 11);
                        if (match) {
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                           Node lastNode_4 = currentNode;
                           int lastIndex_4 = index;
                           // 'a'-'z'
                           match = buffer.matchCharRange(index, 'a', 'z');
                           if (! match) {
                              // 'A'-'Z'
                              match = buffer.matchCharRange(index, 'A', 'Z');
                              if (! match) {
                                 // '0'-'9'
                                 match = buffer.matchCharRange(index, '0', '9');
                                 if (! match) {
                                    // '_'
                                    match = buffer.matchChar(index, '_');
                                 }
                              }
                           }
                           match = ! match;
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // IntegerNumber
                                 match = integerNumber$Rule();
                              }
                           }
                        }
                        if (! match) {
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                        if (match) {
                           // (("wait" | "nowait") TestNoAlpha OptionalSpacing)*
                           Node lastNode_5;
                           int lastIndex_5;
                           do {
                              lastNode_5 = currentNode;
                              lastIndex_5 = index;
                              // (("wait" | "nowait") TestNoAlpha OptionalSpacing)
                              // ("wait" | "nowait")
                              int startIndex_6 = index;
                              switch(buffer.getChar(index)) {
                                 case 'n':
                                 case 'N': {
                                    ++index;
                                    // "owait"
                                    if (match = ignoreCaseStringTest("owait", 5)) {
                                       index += 5;
                                    }
                                    break;
                                 }
                                 case 'w':
                                 case 'W': {
                                    ++index;
                                    // "ait"
                                    if (match = ignoreCaseStringTest("ait", 3)) {
                                       index += 3;
                                    }
                                    break;
                                 }
                                 default: {
                                    match = false;
                                 }
                              }
                              if (! match) {
                                 index = startIndex_6;
                              } else if(! currentRuleIsAtomic) {
                                 currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_6, index, false, false));
                                 currentNode = currentNode.getSibling();
                              }
                              if (match) {
                                 // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                                 // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                                 Node lastNode_7 = currentNode;
                                 int lastIndex_7 = index;
                                 // 'a'-'z'
                                 match = buffer.matchCharRange(index, 'a', 'z');
                                 if (! match) {
                                    // 'A'-'Z'
                                    match = buffer.matchCharRange(index, 'A', 'Z');
                                    if (! match) {
                                       // '0'-'9'
                                       match = buffer.matchCharRange(index, '0', '9');
                                       if (! match) {
                                          // '_'
                                          match = buffer.matchChar(index, '_');
                                       }
                                    }
                                 }
                                 match = ! match;
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           } while(match);
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                           index = lastIndex_5;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         beginProducer$RuleMemoStart = startIndex;
         beginProducer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginProducer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_PRODUCER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginProducer$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         beginProducer$RuleMemoStart = startIndex;
         beginProducer$RuleMemoEnd = -1;
         beginProducer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndProducer : ("end" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing)
   protected boolean endProducer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endProducer$RuleMemoStart == index) {
         if (endProducer$RuleMemoStart <= endProducer$RuleMemoEnd) {
            index = endProducer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_PRODUCER, endProducer$RuleMemoStart, endProducer$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endProducer$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endProducer$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "producer"
               match = ignoreCaseStringMatcher("producer", 8);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         endProducer$RuleMemoStart = startIndex;
         endProducer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endProducer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_PRODUCER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endProducer$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endProducer$RuleMemoStart = startIndex;
         endProducer$RuleMemoEnd = -1;
         endProducer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginTransaction : ("begin" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean beginTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginTransaction$RuleMemoStart == index) {
         if (beginTransaction$RuleMemoStart <= beginTransaction$RuleMemoEnd) {
            index = beginTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_TRANSACTION, beginTransaction$RuleMemoStart, beginTransaction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (beginTransaction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(beginTransaction$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("begin" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "begin"
      match = ignoreCaseStringMatcher("begin", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         beginTransaction$RuleMemoStart = startIndex;
         beginTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginTransaction$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         beginTransaction$RuleMemoStart = startIndex;
         beginTransaction$RuleMemoEnd = -1;
         beginTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommitTransaction : ("commit" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean commitTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commitTransaction$RuleMemoStart == index) {
         if (commitTransaction$RuleMemoStart <= commitTransaction$RuleMemoEnd) {
            index = commitTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_TRANSACTION, commitTransaction$RuleMemoStart, commitTransaction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (commitTransaction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(commitTransaction$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("commit" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "commit"
      match = ignoreCaseStringMatcher("commit", 6);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         commitTransaction$RuleMemoStart = startIndex;
         commitTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commitTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commitTransaction$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         commitTransaction$RuleMemoStart = startIndex;
         commitTransaction$RuleMemoEnd = -1;
         commitTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RollbackTransaction : ("rollback" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean rollbackTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (rollbackTransaction$RuleMemoStart == index) {
         if (rollbackTransaction$RuleMemoStart <= rollbackTransaction$RuleMemoEnd) {
            index = rollbackTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ROLLBACK_TRANSACTION, rollbackTransaction$RuleMemoStart, rollbackTransaction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rollbackTransaction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rollbackTransaction$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("rollback" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "rollback"
      match = ignoreCaseStringMatcher("rollback", 8);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         rollbackTransaction$RuleMemoStart = startIndex;
         rollbackTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rollbackTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ROLLBACK_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rollbackTransaction$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         rollbackTransaction$RuleMemoStart = startIndex;
         rollbackTransaction$RuleMemoEnd = -1;
         rollbackTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAs : (UseAsDatabase UseAsCommand UseAsParams UseAlias UseAsOptions)
   protected boolean useAs$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAs$RuleMemoStart == index) {
         if (useAs$RuleMemoStart <= useAs$RuleMemoEnd) {
            index = useAs$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS, useAs$RuleMemoStart, useAs$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useAs$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useAs$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UseAsDatabase UseAsCommand UseAsParams UseAlias UseAsOptions)
      // UseAsDatabase
      match = useAsDatabase$Rule();
      if (match) {
         // UseAsCommand
         match = useAsCommand$Rule();
         if (match) {
            // UseAsParams
            match = useAsParams$Rule();
            if (match) {
               // UseAlias
               match = useAlias$Rule();
               if (match) {
                  // UseAsOptions
                  match = useAsOptions$Rule();
               }
            }
         }
      }
      if (match) {
         useAs$RuleMemoStart = startIndex;
         useAs$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useAs$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useAs$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         useAs$RuleMemoStart = startIndex;
         useAs$RuleMemoEnd = -1;
         useAs$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsDatabase : ("use" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression))
   protected boolean useAsDatabase$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("use" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression))
      // "use"
      match = ignoreCaseStringMatcher("use", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (AliasIdentifier | Expression)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               switch(buffer.getChar(index)) {
                  case '!':
                  case '\"':
                  case '\'':
                  case ':':
                  case '+':
                  case '[':
                  case '{':
                  case '-':
                  case '.': {
                     // Expression
                     match = expression$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  case '&':
                  case '(':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z': {
                     // AliasIdentifier
                     match = aliasIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        // Expression
                        match = expression$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_DATABASE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsCommand : ("as" TestNoAlpha OptionalSpacing UseAsType Expression)
   protected boolean useAsCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing UseAsType Expression)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // UseAsType
               match = useAsType$Rule();
               if (match) {
                  // Expression
                  match = expression$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_COMMAND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsType : (("fun" | "proc") TestNoAlpha OptionalSpacing)?
   protected boolean useAsType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("fun" | "proc") TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (("fun" | "proc") TestNoAlpha OptionalSpacing)
      // ("fun" | "proc")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // "un"
            if (match = ignoreCaseStringTest("un", 2)) {
               index += 2;
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // "roc"
            if (match = ignoreCaseStringTest("roc", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsParams : ("with" TestNoAlpha OptionalSpacing Expression)?
   protected boolean useAsParams$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing Expression)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("with" TestNoAlpha OptionalSpacing Expression)
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PARAMS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAlias : ("alias" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression))?
   protected boolean useAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAlias$RuleMemoStart == index) {
         if (useAlias$RuleMemoStart <= useAlias$RuleMemoEnd) {
            index = useAlias$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_ALIAS, useAlias$RuleMemoStart, useAlias$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useAlias$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useAlias$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("alias" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression))?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("alias" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression))
      // "alias"
      match = ignoreCaseStringMatcher("alias", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (AliasIdentifier | Expression)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '!':
                  case '\"':
                  case '\'':
                  case ':':
                  case '+':
                  case '[':
                  case '{':
                  case '-':
                  case '.': {
                     // Expression
                     match = expression$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                     break;
                  }
                  case '&':
                  case '(':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z': {
                     // AliasIdentifier
                     match = aliasIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        // Expression
                        match = expression$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         useAlias$RuleMemoStart = startIndex;
         useAlias$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useAlias$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_ALIAS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useAlias$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         useAlias$RuleMemoStart = startIndex;
         useAlias$RuleMemoEnd = -1;
         useAlias$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsPrecision : ("precision" TestNoAlpha OptionalSpacing Expression)
   protected boolean useAsPrecision$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAsPrecision$RuleMemoStart == index) {
         if (useAsPrecision$RuleMemoStart <= useAsPrecision$RuleMemoEnd) {
            index = useAsPrecision$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PRECISION, useAsPrecision$RuleMemoStart, useAsPrecision$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useAsPrecision$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useAsPrecision$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("precision" TestNoAlpha OptionalSpacing Expression)
      // "precision"
      match = ignoreCaseStringMatcher("precision", 9);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         useAsPrecision$RuleMemoStart = startIndex;
         useAsPrecision$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useAsPrecision$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PRECISION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useAsPrecision$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         useAsPrecision$RuleMemoStart = startIndex;
         useAsPrecision$RuleMemoEnd = -1;
         useAsPrecision$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsOptions : (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))*
   protected boolean useAsOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("new" TestNoAlpha OptionalSpacing)
         // "new"
         match = ignoreCaseStringMatcher("new", 3);
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            // ("shared" TestNoAlpha OptionalSpacing)
            // "shared"
            match = ignoreCaseStringMatcher("shared", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // ("exclusive" TestNoAlpha OptionalSpacing)
               // "exclusive"
               match = ignoreCaseStringMatcher("exclusive", 9);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_5 = currentNode;
                  int lastIndex_5 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ("readonly" TestNoAlpha OptionalSpacing)
                  // "readonly"
                  match = ignoreCaseStringMatcher("readonly", 8);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_6 = currentNode;
                     int lastIndex_6 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // UseAsPrecision
                     match = useAsPrecision$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        // ("scrollable" TestNoAlpha OptionalSpacing)
                        // "scrollable"
                        match = ignoreCaseStringMatcher("scrollable", 10);
                        if (match) {
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                           Node lastNode_7 = currentNode;
                           int lastIndex_7 = index;
                           // 'a'-'z'
                           match = buffer.matchCharRange(index, 'a', 'z');
                           if (! match) {
                              // 'A'-'Z'
                              match = buffer.matchCharRange(index, 'A', 'Z');
                              if (! match) {
                                 // '0'-'9'
                                 match = buffer.matchCharRange(index, '0', '9');
                                 if (! match) {
                                    // '_'
                                    match = buffer.matchChar(index, '_');
                                 }
                              }
                           }
                           match = ! match;
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           // ("permanent" TestNoAlpha OptionalSpacing)
                           // "permanent"
                           match = ignoreCaseStringMatcher("permanent", 9);
                           if (match) {
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                              Node lastNode_8 = currentNode;
                              int lastIndex_8 = index;
                              // 'a'-'z'
                              match = buffer.matchCharRange(index, 'a', 'z');
                              if (! match) {
                                 // 'A'-'Z'
                                 match = buffer.matchCharRange(index, 'A', 'Z');
                                 if (! match) {
                                    // '0'-'9'
                                    match = buffer.matchCharRange(index, '0', '9');
                                    if (! match) {
                                       // '_'
                                       match = buffer.matchChar(index, '_');
                                    }
                                 }
                              }
                              match = ! match;
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              // ("overwrite" TestNoAlpha OptionalSpacing)
                              // "overwrite"
                              match = ignoreCaseStringMatcher("overwrite", 9);
                              if (match) {
                                 // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                                 // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                                 Node lastNode_9 = currentNode;
                                 int lastIndex_9 = index;
                                 // 'a'-'z'
                                 match = buffer.matchCharRange(index, 'a', 'z');
                                 if (! match) {
                                    // 'A'-'Z'
                                    match = buffer.matchCharRange(index, 'A', 'Z');
                                    if (! match) {
                                       // '0'-'9'
                                       match = buffer.matchCharRange(index, '0', '9');
                                       if (! match) {
                                          // '_'
                                          match = buffer.matchChar(index, '_');
                                       }
                                    }
                                 }
                                 match = ! match;
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 // ("c1logical" TestNoAlpha OptionalSpacing)
                                 // "c1logical"
                                 match = ignoreCaseStringMatcher("c1logical", 9);
                                 if (match) {
                                    // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                                    // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                                    Node lastNode_10 = currentNode;
                                    int lastIndex_10 = index;
                                    // 'a'-'z'
                                    match = buffer.matchCharRange(index, 'a', 'z');
                                    if (! match) {
                                       // 'A'-'Z'
                                       match = buffer.matchCharRange(index, 'A', 'Z');
                                       if (! match) {
                                          // '0'-'9'
                                          match = buffer.matchCharRange(index, '0', '9');
                                          if (! match) {
                                             // '_'
                                             match = buffer.matchChar(index, '_');
                                          }
                                       }
                                    }
                                    match = ! match;
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                                 if (! match) {
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_OPTIONS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseArea : (UseDatabase UseAreaVia UseAlias UseOptions UseIndexes)
   protected boolean useArea$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useArea$RuleMemoStart == index) {
         if (useArea$RuleMemoStart <= useArea$RuleMemoEnd) {
            index = useArea$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA, useArea$RuleMemoStart, useArea$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useArea$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useArea$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UseDatabase UseAreaVia UseAlias UseOptions UseIndexes)
      // UseDatabase
      match = useDatabase$Rule();
      if (match) {
         // UseAreaVia
         match = useAreaVia$Rule();
         if (match) {
            // UseAlias
            match = useAlias$Rule();
            if (match) {
               // UseOptions
               match = useOptions$Rule();
               if (match) {
                  // UseIndexes
                  match = useIndexes$Rule();
               }
            }
         }
      }
      if (match) {
         useArea$RuleMemoStart = startIndex;
         useArea$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useArea$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useArea$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         useArea$RuleMemoStart = startIndex;
         useArea$RuleMemoEnd = -1;
         useArea$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseDatabase : ("use" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression)?)
   protected boolean useDatabase$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("use" TestNoAlpha OptionalSpacing (AliasIdentifier | Expression)?)
      // "use"
      match = ignoreCaseStringMatcher("use", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (AliasIdentifier | Expression)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (AliasIdentifier | Expression)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '!':
                  case '\"':
                  case '\'':
                  case ':':
                  case '+':
                  case '[':
                  case '{':
                  case '-':
                  case '.': {
                     // Expression
                     match = expression$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                     break;
                  }
                  case '&':
                  case '(':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z': {
                     // AliasIdentifier
                     match = aliasIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        // Expression
                        match = expression$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_DATABASE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAreaVia : ("via" TestNoAlpha OptionalSpacing Expression)?
   protected boolean useAreaVia$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("via" TestNoAlpha OptionalSpacing Expression)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("via" TestNoAlpha OptionalSpacing Expression)
      // "via"
      match = ignoreCaseStringMatcher("via", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA_VIA, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseCodepage : ("codepage" TestNoAlpha OptionalSpacing Expression)
   protected boolean useCodepage$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useCodepage$RuleMemoStart == index) {
         if (useCodepage$RuleMemoStart <= useCodepage$RuleMemoEnd) {
            index = useCodepage$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_CODEPAGE, useCodepage$RuleMemoStart, useCodepage$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useCodepage$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useCodepage$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("codepage" TestNoAlpha OptionalSpacing Expression)
      // "codepage"
      match = ignoreCaseStringMatcher("codepage", 8);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         useCodepage$RuleMemoStart = startIndex;
         useCodepage$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useCodepage$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_CODEPAGE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useCodepage$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         useCodepage$RuleMemoStart = startIndex;
         useCodepage$RuleMemoEnd = -1;
         useCodepage$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseOptions : (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)*
   protected boolean useOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("new" TestNoAlpha OptionalSpacing)
         // "new"
         match = ignoreCaseStringMatcher("new", 3);
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            // ("exclusive" TestNoAlpha OptionalSpacing)
            // "exclusive"
            match = ignoreCaseStringMatcher("exclusive", 9);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // ("shared" TestNoAlpha OptionalSpacing)
               // "shared"
               match = ignoreCaseStringMatcher("shared", 6);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_5 = currentNode;
                  int lastIndex_5 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ("readonly" TestNoAlpha OptionalSpacing)
                  // "readonly"
                  match = ignoreCaseStringMatcher("readonly", 8);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_6 = currentNode;
                     int lastIndex_6 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // UseCodepage
                     match = useCodepage$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
               }
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_OPTIONS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseIndexes : ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)?
   protected boolean useIndexes$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)
      // "index"
      match = ignoreCaseStringMatcher("index", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
               if (match) {
                  // (',' OptionalSpacing Expression)*
                  Node lastNode_3;
                  int lastIndex_3;
                  do {
                     lastNode_3 = currentNode;
                     lastIndex_3 = index;
                     // (',' OptionalSpacing Expression)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Expression
                           match = expression$Rule();
                        }
                     }
                  } while(match);
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  match = true;
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_INDEXES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrobaGetSay : ('@' OptionalSpacing CmdComplementation)
   protected boolean arrobaGetSay$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrobaGetSay$RuleMemoStart == index) {
         if (arrobaGetSay$RuleMemoStart <= arrobaGetSay$RuleMemoEnd) {
            index = arrobaGetSay$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARROBA_GET_SAY, arrobaGetSay$RuleMemoStart, arrobaGetSay$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (arrobaGetSay$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(arrobaGetSay$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing CmdComplementation)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // CmdComplementation
            match = cmdComplementation$Rule();
         }
      }
      if (match) {
         arrobaGetSay$RuleMemoStart = startIndex;
         arrobaGetSay$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrobaGetSay$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARROBA_GET_SAY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrobaGetSay$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         arrobaGetSay$RuleMemoStart = startIndex;
         arrobaGetSay$RuleMemoEnd = -1;
         arrobaGetSay$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SetCmd : ("set" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean setCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (setCmd$RuleMemoStart == index) {
         if (setCmd$RuleMemoStart <= setCmd$RuleMemoEnd) {
            index = setCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SET_CMD, setCmd$RuleMemoStart, setCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (setCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(setCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("set" TestNoAlpha OptionalSpacing CmdComplementation)
      // "set"
      match = ignoreCaseStringMatcher("set", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         setCmd$RuleMemoStart = startIndex;
         setCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            setCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SET_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            setCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         setCmd$RuleMemoStart = startIndex;
         setCmd$RuleMemoEnd = -1;
         setCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReadCmd : ("read" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean readCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (readCmd$RuleMemoStart == index) {
         if (readCmd$RuleMemoStart <= readCmd$RuleMemoEnd) {
            index = readCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.READ_CMD, readCmd$RuleMemoStart, readCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (readCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(readCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("read" TestNoAlpha OptionalSpacing CmdComplementation)
      // "read"
      match = ignoreCaseStringMatcher("read", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         readCmd$RuleMemoStart = startIndex;
         readCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            readCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.READ_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            readCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         readCmd$RuleMemoStart = startIndex;
         readCmd$RuleMemoEnd = -1;
         readCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClsCmd : ("cls" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean clsCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clsCmd$RuleMemoStart == index) {
         if (clsCmd$RuleMemoStart <= clsCmd$RuleMemoEnd) {
            index = clsCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLS_CMD, clsCmd$RuleMemoStart, clsCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clsCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clsCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("cls" TestNoAlpha OptionalSpacing CmdComplementation)
      // "cls"
      match = ignoreCaseStringMatcher("cls", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         clsCmd$RuleMemoStart = startIndex;
         clsCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clsCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLS_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clsCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         clsCmd$RuleMemoStart = startIndex;
         clsCmd$RuleMemoEnd = -1;
         clsCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClearCmd : ("clear" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean clearCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clearCmd$RuleMemoStart == index) {
         if (clearCmd$RuleMemoStart <= clearCmd$RuleMemoEnd) {
            index = clearCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_CMD, clearCmd$RuleMemoStart, clearCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clearCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clearCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("clear" TestNoAlpha OptionalSpacing CmdComplementation)
      // "clear"
      match = ignoreCaseStringMatcher("clear", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         clearCmd$RuleMemoStart = startIndex;
         clearCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clearCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clearCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         clearCmd$RuleMemoStart = startIndex;
         clearCmd$RuleMemoEnd = -1;
         clearCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeyboardCmd : (("keyboard" | "keyboar" | "keyboa" | "keybo" | "keyb") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean keyboardCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keyboardCmd$RuleMemoStart == index) {
         if (keyboardCmd$RuleMemoStart <= keyboardCmd$RuleMemoEnd) {
            index = keyboardCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CMD, keyboardCmd$RuleMemoStart, keyboardCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (keyboardCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(keyboardCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("keyboard" | "keyboar" | "keyboa" | "keybo" | "keyb") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("keyboard" | "keyboar" | "keyboa" | "keybo" | "keyb")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
      if (match) {
         ++index;
         // ("eyboard" | "eyboar" | "eyboa" | "eybo" | "eyb")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("yboard" | "yboar" | "yboa" | "ybo" | "yb")
            match = buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y');
            if (match) {
               ++index;
               // ("board" | "boar" | "boa" | "bo" | "b")
               match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
               if (match) {
                  ++index;
                  // ("oard" | "oar" | "oa" | "o" | <EMPTY>)
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("ard" | "ar" | "a" | <EMPTY>)
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("rd" | "r" | <EMPTY>)
                        match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                        if (match) {
                           ++index;
                           // ("d" | <EMPTY>)
                           match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         keyboardCmd$RuleMemoStart = startIndex;
         keyboardCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keyboardCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keyboardCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         keyboardCmd$RuleMemoStart = startIndex;
         keyboardCmd$RuleMemoEnd = -1;
         keyboardCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WaitCmd : ("wait" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean waitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (waitCmd$RuleMemoStart == index) {
         if (waitCmd$RuleMemoStart <= waitCmd$RuleMemoEnd) {
            index = waitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.WAIT_CMD, waitCmd$RuleMemoStart, waitCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (waitCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(waitCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("wait" TestNoAlpha OptionalSpacing CmdComplementation)
      // "wait"
      match = ignoreCaseStringMatcher("wait", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         waitCmd$RuleMemoStart = startIndex;
         waitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            waitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WAIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            waitCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         waitCmd$RuleMemoStart = startIndex;
         waitCmd$RuleMemoEnd = -1;
         waitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AcceptCmd : (("accept" | "accep" | "acce") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean acceptCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (acceptCmd$RuleMemoStart == index) {
         if (acceptCmd$RuleMemoStart <= acceptCmd$RuleMemoEnd) {
            index = acceptCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ACCEPT_CMD, acceptCmd$RuleMemoStart, acceptCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (acceptCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(acceptCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("accept" | "accep" | "acce") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("accept" | "accep" | "acce")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("ccept" | "ccep" | "cce")
         match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
         if (match) {
            ++index;
            // ("cept" | "cep" | "ce")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("ept" | "ep" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("pt" | "p" | <EMPTY>)
                  match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
                  if (match) {
                     ++index;
                     // ("t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         acceptCmd$RuleMemoStart = startIndex;
         acceptCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            acceptCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ACCEPT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            acceptCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         acceptCmd$RuleMemoStart = startIndex;
         acceptCmd$RuleMemoEnd = -1;
         acceptCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InputCmd : ("input" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean inputCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (inputCmd$RuleMemoStart == index) {
         if (inputCmd$RuleMemoStart <= inputCmd$RuleMemoEnd) {
            index = inputCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.INPUT_CMD, inputCmd$RuleMemoStart, inputCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (inputCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(inputCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("input" TestNoAlpha OptionalSpacing CmdComplementation)
      // "input"
      match = ignoreCaseStringMatcher("input", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         inputCmd$RuleMemoStart = startIndex;
         inputCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inputCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INPUT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inputCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         inputCmd$RuleMemoStart = startIndex;
         inputCmd$RuleMemoEnd = -1;
         inputCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReleaseCmd : (("release" | "releas" | "relea" | "rele") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean releaseCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (releaseCmd$RuleMemoStart == index) {
         if (releaseCmd$RuleMemoStart <= releaseCmd$RuleMemoEnd) {
            index = releaseCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELEASE_CMD, releaseCmd$RuleMemoStart, releaseCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (releaseCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(releaseCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("release" | "releas" | "relea" | "rele") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("release" | "releas" | "relea" | "rele")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("elease" | "eleas" | "elea" | "ele")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("lease" | "leas" | "lea" | "le")
            match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
            if (match) {
               ++index;
               // ("ease" | "eas" | "ea" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("ase" | "as" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("se" | "s" | <EMPTY>)
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         releaseCmd$RuleMemoStart = startIndex;
         releaseCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            releaseCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELEASE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            releaseCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         releaseCmd$RuleMemoStart = startIndex;
         releaseCmd$RuleMemoEnd = -1;
         releaseCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestoreCmd : (("restore" | "restor" | "resto" | "rest") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean restoreCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (restoreCmd$RuleMemoStart == index) {
         if (restoreCmd$RuleMemoStart <= restoreCmd$RuleMemoEnd) {
            index = restoreCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RESTORE_CMD, restoreCmd$RuleMemoStart, restoreCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (restoreCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(restoreCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("restore" | "restor" | "resto" | "rest") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("restore" | "restor" | "resto" | "rest")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("estore" | "estor" | "esto" | "est")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("store" | "stor" | "sto" | "st")
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("tore" | "tor" | "to" | "t")
               match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
               if (match) {
                  ++index;
                  // ("ore" | "or" | "o" | <EMPTY>)
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("re" | "r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         restoreCmd$RuleMemoStart = startIndex;
         restoreCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            restoreCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RESTORE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            restoreCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         restoreCmd$RuleMemoStart = startIndex;
         restoreCmd$RuleMemoEnd = -1;
         restoreCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StoreCmd : (("store" | "stor") TestNoAlpha OptionalSpacing Expression "to" TestNoAlpha OptionalSpacing VariableList)
   protected boolean storeCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (storeCmd$RuleMemoStart == index) {
         if (storeCmd$RuleMemoStart <= storeCmd$RuleMemoEnd) {
            index = storeCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STORE_CMD, storeCmd$RuleMemoStart, storeCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (storeCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(storeCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("store" | "stor") TestNoAlpha OptionalSpacing Expression "to" TestNoAlpha OptionalSpacing VariableList)
      // ("store" | "stor")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
      if (match) {
         ++index;
         // ("tore" | "tor")
         match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
         if (match) {
            ++index;
            // ("ore" | "or")
            match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
            if (match) {
               ++index;
               // ("re" | "r")
               match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
               if (match) {
                  ++index;
                  // ("e" | <EMPTY>)
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
               if (match) {
                  // "to"
                  match = ignoreCaseStringMatcher("to", 2);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // VariableList
                           match = variableList$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         storeCmd$RuleMemoStart = startIndex;
         storeCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            storeCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STORE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            storeCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         storeCmd$RuleMemoStart = startIndex;
         storeCmd$RuleMemoEnd = -1;
         storeCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SaveCmd : ("save" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean saveCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (saveCmd$RuleMemoStart == index) {
         if (saveCmd$RuleMemoStart <= saveCmd$RuleMemoEnd) {
            index = saveCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SAVE_CMD, saveCmd$RuleMemoStart, saveCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (saveCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(saveCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("save" TestNoAlpha OptionalSpacing CmdComplementation)
      // "save"
      match = ignoreCaseStringMatcher("save", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         saveCmd$RuleMemoStart = startIndex;
         saveCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            saveCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SAVE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            saveCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         saveCmd$RuleMemoStart = startIndex;
         saveCmd$RuleMemoEnd = -1;
         saveCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //JoinCmd : ("join" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean joinCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (joinCmd$RuleMemoStart == index) {
         if (joinCmd$RuleMemoStart <= joinCmd$RuleMemoEnd) {
            index = joinCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.JOIN_CMD, joinCmd$RuleMemoStart, joinCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (joinCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(joinCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("join" TestNoAlpha OptionalSpacing CmdComplementation)
      // "join"
      match = ignoreCaseStringMatcher("join", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         joinCmd$RuleMemoStart = startIndex;
         joinCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            joinCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.JOIN_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            joinCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         joinCmd$RuleMemoStart = startIndex;
         joinCmd$RuleMemoEnd = -1;
         joinCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EjectCmd : (("eject" | "ejec") TestNoAlpha OptionalSpacing)
   protected boolean ejectCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ejectCmd$RuleMemoStart == index) {
         if (ejectCmd$RuleMemoStart <= ejectCmd$RuleMemoEnd) {
            index = ejectCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EJECT_CMD, ejectCmd$RuleMemoStart, ejectCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ejectCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ejectCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("eject" | "ejec") TestNoAlpha OptionalSpacing)
      // ("eject" | "ejec")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
      if (match) {
         ++index;
         // ("ject" | "jec")
         match = buffer.matchChar(index, 'j') || buffer.matchChar(index, 'J');
         if (match) {
            ++index;
            // ("ect" | "ec")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("ct" | "c")
               match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
               if (match) {
                  ++index;
                  // ("t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         ejectCmd$RuleMemoStart = startIndex;
         ejectCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ejectCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EJECT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ejectCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ejectCmd$RuleMemoStart = startIndex;
         ejectCmd$RuleMemoEnd = -1;
         ejectCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EraseCmd : ("erase" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean eraseCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (eraseCmd$RuleMemoStart == index) {
         if (eraseCmd$RuleMemoStart <= eraseCmd$RuleMemoEnd) {
            index = eraseCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERASE_CMD, eraseCmd$RuleMemoStart, eraseCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (eraseCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(eraseCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("erase" TestNoAlpha OptionalSpacing CmdComplementation)
      // "erase"
      match = ignoreCaseStringMatcher("erase", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         eraseCmd$RuleMemoStart = startIndex;
         eraseCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            eraseCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERASE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            eraseCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         eraseCmd$RuleMemoStart = startIndex;
         eraseCmd$RuleMemoEnd = -1;
         eraseCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DeleteCmd : (("delete" | "delet" | "dele") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean deleteCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (deleteCmd$RuleMemoStart == index) {
         if (deleteCmd$RuleMemoStart <= deleteCmd$RuleMemoEnd) {
            index = deleteCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DELETE_CMD, deleteCmd$RuleMemoStart, deleteCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (deleteCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(deleteCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("delete" | "delet" | "dele") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("delete" | "delet" | "dele")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
      if (match) {
         ++index;
         // ("elete" | "elet" | "ele")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("lete" | "let" | "le")
            match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
            if (match) {
               ++index;
               // ("ete" | "et" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         deleteCmd$RuleMemoStart = startIndex;
         deleteCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            deleteCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DELETE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            deleteCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         deleteCmd$RuleMemoStart = startIndex;
         deleteCmd$RuleMemoEnd = -1;
         deleteCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RenameCmd : (("rename" | "renam" | "rena") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean renameCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (renameCmd$RuleMemoStart == index) {
         if (renameCmd$RuleMemoStart <= renameCmd$RuleMemoEnd) {
            index = renameCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RENAME_CMD, renameCmd$RuleMemoStart, renameCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (renameCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(renameCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("rename" | "renam" | "rena") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("rename" | "renam" | "rena")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("ename" | "enam" | "ena")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("name" | "nam" | "na")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("ame" | "am" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("me" | "m" | <EMPTY>)
                  match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         renameCmd$RuleMemoStart = startIndex;
         renameCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            renameCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RENAME_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            renameCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         renameCmd$RuleMemoStart = startIndex;
         renameCmd$RuleMemoEnd = -1;
         renameCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CopyCmd : ("copy" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean copyCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (copyCmd$RuleMemoStart == index) {
         if (copyCmd$RuleMemoStart <= copyCmd$RuleMemoEnd) {
            index = copyCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.COPY_CMD, copyCmd$RuleMemoStart, copyCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (copyCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(copyCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("copy" TestNoAlpha OptionalSpacing CmdComplementation)
      // "copy"
      match = ignoreCaseStringMatcher("copy", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         copyCmd$RuleMemoStart = startIndex;
         copyCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            copyCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COPY_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            copyCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         copyCmd$RuleMemoStart = startIndex;
         copyCmd$RuleMemoEnd = -1;
         copyCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirCmd : ("dir" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean dirCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dirCmd$RuleMemoStart == index) {
         if (dirCmd$RuleMemoStart <= dirCmd$RuleMemoEnd) {
            index = dirCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIR_CMD, dirCmd$RuleMemoStart, dirCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dirCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dirCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("dir" TestNoAlpha OptionalSpacing CmdComplementation)
      // "dir"
      match = ignoreCaseStringMatcher("dir", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         dirCmd$RuleMemoStart = startIndex;
         dirCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dirCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIR_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dirCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dirCmd$RuleMemoStart = startIndex;
         dirCmd$RuleMemoEnd = -1;
         dirCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TypeCmd : ("type" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean typeCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (typeCmd$RuleMemoStart == index) {
         if (typeCmd$RuleMemoStart <= typeCmd$RuleMemoEnd) {
            index = typeCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TYPE_CMD, typeCmd$RuleMemoStart, typeCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (typeCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(typeCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("type" TestNoAlpha OptionalSpacing CmdComplementation)
      // "type"
      match = ignoreCaseStringMatcher("type", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         typeCmd$RuleMemoStart = startIndex;
         typeCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            typeCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TYPE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            typeCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         typeCmd$RuleMemoStart = startIndex;
         typeCmd$RuleMemoEnd = -1;
         typeCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RequestCmd : (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean requestCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (requestCmd$RuleMemoStart == index) {
         if (requestCmd$RuleMemoStart <= requestCmd$RuleMemoEnd) {
            index = requestCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST_CMD, requestCmd$RuleMemoStart, requestCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (requestCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(requestCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("request" | "reques" | "reque" | "requ")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("equest" | "eques" | "eque" | "equ")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("quest" | "ques" | "que" | "qu")
            match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
            if (match) {
               ++index;
               // ("uest" | "ues" | "ue" | "u")
               match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
               if (match) {
                  ++index;
                  // ("est" | "es" | "e" | <EMPTY>)
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("st" | "s" | <EMPTY>)
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // ("t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         requestCmd$RuleMemoStart = startIndex;
         requestCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            requestCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            requestCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         requestCmd$RuleMemoStart = startIndex;
         requestCmd$RuleMemoEnd = -1;
         requestCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CancelCmd : (("cancel" | "cance" | "canc") TestNoAlpha OptionalSpacing)
   protected boolean cancelCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (cancelCmd$RuleMemoStart == index) {
         if (cancelCmd$RuleMemoStart <= cancelCmd$RuleMemoEnd) {
            index = cancelCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CANCEL_CMD, cancelCmd$RuleMemoStart, cancelCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cancelCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cancelCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("cancel" | "cance" | "canc") TestNoAlpha OptionalSpacing)
      // ("cancel" | "cance" | "canc")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
      if (match) {
         ++index;
         // ("ancel" | "ance" | "anc")
         match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
         if (match) {
            ++index;
            // ("ncel" | "nce" | "nc")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("cel" | "ce" | "c")
               match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
               if (match) {
                  ++index;
                  // ("el" | "e" | <EMPTY>)
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("l" | <EMPTY>)
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         cancelCmd$RuleMemoStart = startIndex;
         cancelCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cancelCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CANCEL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cancelCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         cancelCmd$RuleMemoStart = startIndex;
         cancelCmd$RuleMemoEnd = -1;
         cancelCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QuitCmd : ("quit" TestNoAlpha OptionalSpacing)
   protected boolean quitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (quitCmd$RuleMemoStart == index) {
         if (quitCmd$RuleMemoStart <= quitCmd$RuleMemoEnd) {
            index = quitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUIT_CMD, quitCmd$RuleMemoStart, quitCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (quitCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(quitCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("quit" TestNoAlpha OptionalSpacing)
      // "quit"
      match = ignoreCaseStringMatcher("quit", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         quitCmd$RuleMemoStart = startIndex;
         quitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            quitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            quitCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         quitCmd$RuleMemoStart = startIndex;
         quitCmd$RuleMemoEnd = -1;
         quitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RunCmd : ((("run" | "exclamation") TestNoAlpha OptionalSpacing) CmdComplementation)
   protected boolean runCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (runCmd$RuleMemoStart == index) {
         if (runCmd$RuleMemoStart <= runCmd$RuleMemoEnd) {
            index = runCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RUN_CMD, runCmd$RuleMemoStart, runCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (runCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(runCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("run" | "exclamation") TestNoAlpha OptionalSpacing) CmdComplementation)
      // (("run" | "exclamation") TestNoAlpha OptionalSpacing)
      // ("run" | "exclamation")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'r':
         case 'R': {
            ++index;
            // "un"
            if (match = ignoreCaseStringTest("un", 2)) {
               index += 2;
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // "xclamation"
            if (match = ignoreCaseStringTest("xclamation", 10)) {
               index += 10;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // CmdComplementation
         match = cmdComplementation$Rule();
      }
      if (match) {
         runCmd$RuleMemoStart = startIndex;
         runCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            runCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RUN_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            runCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         runCmd$RuleMemoStart = startIndex;
         runCmd$RuleMemoEnd = -1;
         runCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OutCmd : (("question" | "questio" | "questi" | "quest" | "ques") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean outCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (outCmd$RuleMemoStart == index) {
         if (outCmd$RuleMemoStart <= outCmd$RuleMemoEnd) {
            index = outCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OUT_CMD, outCmd$RuleMemoStart, outCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (outCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(outCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("question" | "questio" | "questi" | "quest" | "ques") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("question" | "questio" | "questi" | "quest" | "ques")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
      if (match) {
         ++index;
         // ("uestion" | "uestio" | "uesti" | "uest" | "ues")
         match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
         if (match) {
            ++index;
            // ("estion" | "estio" | "esti" | "est" | "es")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("stion" | "stio" | "sti" | "st" | "s")
               match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
               if (match) {
                  ++index;
                  // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("ion" | "io" | "i" | <EMPTY>)
                     match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                     if (match) {
                        ++index;
                        // ("on" | "o" | <EMPTY>)
                        match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                        if (match) {
                           ++index;
                           // ("n" | <EMPTY>)
                           match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         outCmd$RuleMemoStart = startIndex;
         outCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            outCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OUT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            outCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         outCmd$RuleMemoStart = startIndex;
         outCmd$RuleMemoEnd = -1;
         outCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CloseCmd : ("close" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean closeCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (closeCmd$RuleMemoStart == index) {
         if (closeCmd$RuleMemoStart <= closeCmd$RuleMemoEnd) {
            index = closeCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLOSE_CMD, closeCmd$RuleMemoStart, closeCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (closeCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(closeCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("close" TestNoAlpha OptionalSpacing CmdComplementation)
      // "close"
      match = ignoreCaseStringMatcher("close", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         closeCmd$RuleMemoStart = startIndex;
         closeCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            closeCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLOSE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            closeCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         closeCmd$RuleMemoStart = startIndex;
         closeCmd$RuleMemoEnd = -1;
         closeCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SelectCmd : (("select" | "selec" | "sele") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean selectCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (selectCmd$RuleMemoStart == index) {
         if (selectCmd$RuleMemoStart <= selectCmd$RuleMemoEnd) {
            index = selectCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELECT_CMD, selectCmd$RuleMemoStart, selectCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("select" | "selec" | "sele") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("select" | "selec" | "sele")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
      if (match) {
         ++index;
         // ("elect" | "elec" | "ele")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("lect" | "lec" | "le")
            match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
            if (match) {
               ++index;
               // ("ect" | "ec" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("ct" | "c" | <EMPTY>)
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         selectCmd$RuleMemoStart = startIndex;
         selectCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELECT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         selectCmd$RuleMemoStart = startIndex;
         selectCmd$RuleMemoEnd = -1;
         selectCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AppendCmd : (("append" | "appen" | "appe") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean appendCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (appendCmd$RuleMemoStart == index) {
         if (appendCmd$RuleMemoStart <= appendCmd$RuleMemoEnd) {
            index = appendCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.APPEND_CMD, appendCmd$RuleMemoStart, appendCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (appendCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(appendCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("append" | "appen" | "appe") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("append" | "appen" | "appe")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("ppend" | "ppen" | "ppe")
         match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
         if (match) {
            ++index;
            // ("pend" | "pen" | "pe")
            match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
            if (match) {
               ++index;
               // ("end" | "en" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("nd" | "n" | <EMPTY>)
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // ("d" | <EMPTY>)
                     match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         appendCmd$RuleMemoStart = startIndex;
         appendCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            appendCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.APPEND_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            appendCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         appendCmd$RuleMemoStart = startIndex;
         appendCmd$RuleMemoEnd = -1;
         appendCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PackCmd : ("pack" TestNoAlpha OptionalSpacing)
   protected boolean packCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (packCmd$RuleMemoStart == index) {
         if (packCmd$RuleMemoStart <= packCmd$RuleMemoEnd) {
            index = packCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PACK_CMD, packCmd$RuleMemoStart, packCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (packCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(packCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("pack" TestNoAlpha OptionalSpacing)
      // "pack"
      match = ignoreCaseStringMatcher("pack", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         packCmd$RuleMemoStart = startIndex;
         packCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            packCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PACK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            packCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         packCmd$RuleMemoStart = startIndex;
         packCmd$RuleMemoEnd = -1;
         packCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ZapCmd : ("zap" TestNoAlpha OptionalSpacing)
   protected boolean zapCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (zapCmd$RuleMemoStart == index) {
         if (zapCmd$RuleMemoStart <= zapCmd$RuleMemoEnd) {
            index = zapCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ZAP_CMD, zapCmd$RuleMemoStart, zapCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (zapCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(zapCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("zap" TestNoAlpha OptionalSpacing)
      // "zap"
      match = ignoreCaseStringMatcher("zap", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         zapCmd$RuleMemoStart = startIndex;
         zapCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            zapCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ZAP_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            zapCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         zapCmd$RuleMemoStart = startIndex;
         zapCmd$RuleMemoEnd = -1;
         zapCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UnlockCmd : (("unlock" | "unloc" | "unlo") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean unlockCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (unlockCmd$RuleMemoStart == index) {
         if (unlockCmd$RuleMemoStart <= unlockCmd$RuleMemoEnd) {
            index = unlockCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNLOCK_CMD, unlockCmd$RuleMemoStart, unlockCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unlockCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unlockCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("unlock" | "unloc" | "unlo") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("unlock" | "unloc" | "unlo")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
      if (match) {
         ++index;
         // ("nlock" | "nloc" | "nlo")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("lock" | "loc" | "lo")
            match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
            if (match) {
               ++index;
               // ("ock" | "oc" | "o")
               match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
               if (match) {
                  ++index;
                  // ("ck" | "c" | <EMPTY>)
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("k" | <EMPTY>)
                     match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         unlockCmd$RuleMemoStart = startIndex;
         unlockCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unlockCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNLOCK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unlockCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         unlockCmd$RuleMemoStart = startIndex;
         unlockCmd$RuleMemoEnd = -1;
         unlockCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommitCmd : ("commit" TestNoAlpha OptionalSpacing)
   protected boolean commitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commitCmd$RuleMemoStart == index) {
         if (commitCmd$RuleMemoStart <= commitCmd$RuleMemoEnd) {
            index = commitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_CMD, commitCmd$RuleMemoStart, commitCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (commitCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(commitCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("commit" TestNoAlpha OptionalSpacing)
      // "commit"
      match = ignoreCaseStringMatcher("commit", 6);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         commitCmd$RuleMemoStart = startIndex;
         commitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commitCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         commitCmd$RuleMemoStart = startIndex;
         commitCmd$RuleMemoEnd = -1;
         commitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //GotoCmd : ((("goto" | "go") TestNoAlpha OptionalSpacing) CmdComplementation)
   protected boolean gotoCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (gotoCmd$RuleMemoStart == index) {
         if (gotoCmd$RuleMemoStart <= gotoCmd$RuleMemoEnd) {
            index = gotoCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.GOTO_CMD, gotoCmd$RuleMemoStart, gotoCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (gotoCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(gotoCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("goto" | "go") TestNoAlpha OptionalSpacing) CmdComplementation)
      // (("goto" | "go") TestNoAlpha OptionalSpacing)
      // ("goto" | "go")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
      if (match) {
         ++index;
         // ("oto" | "o")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("to" | <EMPTY>)
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // "o"
               if (match = buffer.matchIgnoreCaseChar(index, 'o')) {
                  ++index;
               }
            } else {
               match = true;
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // CmdComplementation
         match = cmdComplementation$Rule();
      }
      if (match) {
         gotoCmd$RuleMemoStart = startIndex;
         gotoCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            gotoCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.GOTO_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            gotoCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         gotoCmd$RuleMemoStart = startIndex;
         gotoCmd$RuleMemoEnd = -1;
         gotoCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SkipCmd : ("skip" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean skipCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (skipCmd$RuleMemoStart == index) {
         if (skipCmd$RuleMemoStart <= skipCmd$RuleMemoEnd) {
            index = skipCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SKIP_CMD, skipCmd$RuleMemoStart, skipCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (skipCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(skipCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("skip" TestNoAlpha OptionalSpacing CmdComplementation)
      // "skip"
      match = ignoreCaseStringMatcher("skip", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         skipCmd$RuleMemoStart = startIndex;
         skipCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            skipCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SKIP_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            skipCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         skipCmd$RuleMemoStart = startIndex;
         skipCmd$RuleMemoEnd = -1;
         skipCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FindCmd : ("find" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean findCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (findCmd$RuleMemoStart == index) {
         if (findCmd$RuleMemoStart <= findCmd$RuleMemoEnd) {
            index = findCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIND_CMD, findCmd$RuleMemoStart, findCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (findCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(findCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("find" TestNoAlpha OptionalSpacing CmdComplementation)
      // "find"
      match = ignoreCaseStringMatcher("find", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         findCmd$RuleMemoStart = startIndex;
         findCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            findCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIND_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            findCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         findCmd$RuleMemoStart = startIndex;
         findCmd$RuleMemoEnd = -1;
         findCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueCmd : (("continue" | "continu" | "contin" | "conti" | "cont") TestNoAlpha OptionalSpacing)
   protected boolean continueCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueCmd$RuleMemoStart == index) {
         if (continueCmd$RuleMemoStart <= continueCmd$RuleMemoEnd) {
            index = continueCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_CMD, continueCmd$RuleMemoStart, continueCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (continueCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(continueCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("continue" | "continu" | "contin" | "conti" | "cont") TestNoAlpha OptionalSpacing)
      // ("continue" | "continu" | "contin" | "conti" | "cont")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
      if (match) {
         ++index;
         // ("ontinue" | "ontinu" | "ontin" | "onti" | "ont")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("ntinue" | "ntinu" | "ntin" | "nti" | "nt")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("tinue" | "tinu" | "tin" | "ti" | "t")
               match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
               if (match) {
                  ++index;
                  // ("inue" | "inu" | "in" | "i" | <EMPTY>)
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("nue" | "nu" | "n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("ue" | "u" | <EMPTY>)
                        match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                        if (match) {
                           ++index;
                           // ("e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         continueCmd$RuleMemoStart = startIndex;
         continueCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         continueCmd$RuleMemoStart = startIndex;
         continueCmd$RuleMemoEnd = -1;
         continueCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SeekCmd : ("seek" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean seekCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (seekCmd$RuleMemoStart == index) {
         if (seekCmd$RuleMemoStart <= seekCmd$RuleMemoEnd) {
            index = seekCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEEK_CMD, seekCmd$RuleMemoStart, seekCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (seekCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(seekCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("seek" TestNoAlpha OptionalSpacing CmdComplementation)
      // "seek"
      match = ignoreCaseStringMatcher("seek", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         seekCmd$RuleMemoStart = startIndex;
         seekCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            seekCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEEK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            seekCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         seekCmd$RuleMemoStart = startIndex;
         seekCmd$RuleMemoEnd = -1;
         seekCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LocateCmd : (("locate" | "locat" | "loca") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean locateCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (locateCmd$RuleMemoStart == index) {
         if (locateCmd$RuleMemoStart <= locateCmd$RuleMemoEnd) {
            index = locateCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCATE_CMD, locateCmd$RuleMemoStart, locateCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (locateCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(locateCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("locate" | "locat" | "loca") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("locate" | "locat" | "loca")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
      if (match) {
         ++index;
         // ("ocate" | "ocat" | "oca")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("cate" | "cat" | "ca")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("ate" | "at" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         locateCmd$RuleMemoStart = startIndex;
         locateCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            locateCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            locateCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         locateCmd$RuleMemoStart = startIndex;
         locateCmd$RuleMemoEnd = -1;
         locateCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReplaceCmd : (("replace" | "replac" | "repla" | "repl") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean replaceCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (replaceCmd$RuleMemoStart == index) {
         if (replaceCmd$RuleMemoStart <= replaceCmd$RuleMemoEnd) {
            index = replaceCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPLACE_CMD, replaceCmd$RuleMemoStart, replaceCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (replaceCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(replaceCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("replace" | "replac" | "repla" | "repl") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("replace" | "replac" | "repla" | "repl")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eplace" | "eplac" | "epla" | "epl")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("place" | "plac" | "pla" | "pl")
            match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
            if (match) {
               ++index;
               // ("lace" | "lac" | "la" | "l")
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("ace" | "ac" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("ce" | "c" | <EMPTY>)
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         replaceCmd$RuleMemoStart = startIndex;
         replaceCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            replaceCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPLACE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            replaceCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         replaceCmd$RuleMemoStart = startIndex;
         replaceCmd$RuleMemoEnd = -1;
         replaceCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RecallCmd : (("recall" | "recal" | "reca") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean recallCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (recallCmd$RuleMemoStart == index) {
         if (recallCmd$RuleMemoStart <= recallCmd$RuleMemoEnd) {
            index = recallCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECALL_CMD, recallCmd$RuleMemoStart, recallCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (recallCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(recallCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("recall" | "recal" | "reca") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("recall" | "recal" | "reca")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("ecall" | "ecal" | "eca")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("call" | "cal" | "ca")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("all" | "al" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("ll" | "l" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // ("l" | <EMPTY>)
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         recallCmd$RuleMemoStart = startIndex;
         recallCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recallCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECALL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recallCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         recallCmd$RuleMemoStart = startIndex;
         recallCmd$RuleMemoEnd = -1;
         recallCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CreateCmd : (("create" | "creat" | "crea") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean createCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (createCmd$RuleMemoStart == index) {
         if (createCmd$RuleMemoStart <= createCmd$RuleMemoEnd) {
            index = createCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CMD, createCmd$RuleMemoStart, createCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("create" | "creat" | "crea") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("create" | "creat" | "crea")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
      if (match) {
         ++index;
         // ("reate" | "reat" | "rea")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("eate" | "eat" | "ea")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("ate" | "at" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         createCmd$RuleMemoStart = startIndex;
         createCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         createCmd$RuleMemoStart = startIndex;
         createCmd$RuleMemoEnd = -1;
         createCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SortCmd : ("sort" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean sortCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sortCmd$RuleMemoStart == index) {
         if (sortCmd$RuleMemoStart <= sortCmd$RuleMemoEnd) {
            index = sortCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SORT_CMD, sortCmd$RuleMemoStart, sortCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sortCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sortCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("sort" TestNoAlpha OptionalSpacing CmdComplementation)
      // "sort"
      match = ignoreCaseStringMatcher("sort", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         sortCmd$RuleMemoStart = startIndex;
         sortCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sortCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SORT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sortCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         sortCmd$RuleMemoStart = startIndex;
         sortCmd$RuleMemoEnd = -1;
         sortCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TotalCmd : ("total" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean totalCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (totalCmd$RuleMemoStart == index) {
         if (totalCmd$RuleMemoStart <= totalCmd$RuleMemoEnd) {
            index = totalCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TOTAL_CMD, totalCmd$RuleMemoStart, totalCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (totalCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(totalCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("total" TestNoAlpha OptionalSpacing CmdComplementation)
      // "total"
      match = ignoreCaseStringMatcher("total", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         totalCmd$RuleMemoStart = startIndex;
         totalCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            totalCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TOTAL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            totalCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         totalCmd$RuleMemoStart = startIndex;
         totalCmd$RuleMemoEnd = -1;
         totalCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UpdateCmd : (("update" | "updat" | "upda") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean updateCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (updateCmd$RuleMemoStart == index) {
         if (updateCmd$RuleMemoStart <= updateCmd$RuleMemoEnd) {
            index = updateCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.UPDATE_CMD, updateCmd$RuleMemoStart, updateCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (updateCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(updateCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("update" | "updat" | "upda") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("update" | "updat" | "upda")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
      if (match) {
         ++index;
         // ("pdate" | "pdat" | "pda")
         match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
         if (match) {
            ++index;
            // ("date" | "dat" | "da")
            match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
            if (match) {
               ++index;
               // ("ate" | "at" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         updateCmd$RuleMemoStart = startIndex;
         updateCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            updateCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UPDATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            updateCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         updateCmd$RuleMemoStart = startIndex;
         updateCmd$RuleMemoEnd = -1;
         updateCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CountCmd : ("count" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean countCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (countCmd$RuleMemoStart == index) {
         if (countCmd$RuleMemoStart <= countCmd$RuleMemoEnd) {
            index = countCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.COUNT_CMD, countCmd$RuleMemoStart, countCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (countCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(countCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("count" TestNoAlpha OptionalSpacing CmdComplementation)
      // "count"
      match = ignoreCaseStringMatcher("count", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         countCmd$RuleMemoStart = startIndex;
         countCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            countCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COUNT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            countCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         countCmd$RuleMemoStart = startIndex;
         countCmd$RuleMemoEnd = -1;
         countCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SumCmd : ("sum" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean sumCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sumCmd$RuleMemoStart == index) {
         if (sumCmd$RuleMemoStart <= sumCmd$RuleMemoEnd) {
            index = sumCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SUM_CMD, sumCmd$RuleMemoStart, sumCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sumCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sumCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("sum" TestNoAlpha OptionalSpacing CmdComplementation)
      // "sum"
      match = ignoreCaseStringMatcher("sum", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         sumCmd$RuleMemoStart = startIndex;
         sumCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sumCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SUM_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sumCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         sumCmd$RuleMemoStart = startIndex;
         sumCmd$RuleMemoEnd = -1;
         sumCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AverageCmd : (("average" | "averag" | "avera" | "aver") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean averageCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (averageCmd$RuleMemoStart == index) {
         if (averageCmd$RuleMemoStart <= averageCmd$RuleMemoEnd) {
            index = averageCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.AVERAGE_CMD, averageCmd$RuleMemoStart, averageCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (averageCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(averageCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("average" | "averag" | "avera" | "aver") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("average" | "averag" | "avera" | "aver")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("verage" | "verag" | "vera" | "ver")
         match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
         if (match) {
            ++index;
            // ("erage" | "erag" | "era" | "er")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("rage" | "rag" | "ra" | "r")
               match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
               if (match) {
                  ++index;
                  // ("age" | "ag" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("ge" | "g" | <EMPTY>)
                     match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         averageCmd$RuleMemoStart = startIndex;
         averageCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            averageCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AVERAGE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            averageCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         averageCmd$RuleMemoStart = startIndex;
         averageCmd$RuleMemoEnd = -1;
         averageCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ListCmd : ("list" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean listCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (listCmd$RuleMemoStart == index) {
         if (listCmd$RuleMemoStart <= listCmd$RuleMemoEnd) {
            index = listCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LIST_CMD, listCmd$RuleMemoStart, listCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (listCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(listCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("list" TestNoAlpha OptionalSpacing CmdComplementation)
      // "list"
      match = ignoreCaseStringMatcher("list", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         listCmd$RuleMemoStart = startIndex;
         listCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LIST_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         listCmd$RuleMemoStart = startIndex;
         listCmd$RuleMemoEnd = -1;
         listCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DisplayCmd : (("display" | "displa" | "displ" | "disp") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean displayCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (displayCmd$RuleMemoStart == index) {
         if (displayCmd$RuleMemoStart <= displayCmd$RuleMemoEnd) {
            index = displayCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DISPLAY_CMD, displayCmd$RuleMemoStart, displayCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (displayCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(displayCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("display" | "displa" | "displ" | "disp") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("display" | "displa" | "displ" | "disp")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
      if (match) {
         ++index;
         // ("isplay" | "ispla" | "ispl" | "isp")
         match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
         if (match) {
            ++index;
            // ("splay" | "spla" | "spl" | "sp")
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("play" | "pla" | "pl" | "p")
               match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
               if (match) {
                  ++index;
                  // ("lay" | "la" | "l" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // ("ay" | "a" | <EMPTY>)
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("y" | <EMPTY>)
                        match = buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         displayCmd$RuleMemoStart = startIndex;
         displayCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            displayCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DISPLAY_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            displayCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         displayCmd$RuleMemoStart = startIndex;
         displayCmd$RuleMemoEnd = -1;
         displayCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReportCmd : (("report" | "repor" | "repo") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean reportCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (reportCmd$RuleMemoStart == index) {
         if (reportCmd$RuleMemoStart <= reportCmd$RuleMemoEnd) {
            index = reportCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPORT_CMD, reportCmd$RuleMemoStart, reportCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (reportCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(reportCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("report" | "repor" | "repo") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("report" | "repor" | "repo")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eport" | "epor" | "epo")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("port" | "por" | "po")
            match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
            if (match) {
               ++index;
               // ("ort" | "or" | "o")
               match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
               if (match) {
                  ++index;
                  // ("rt" | "r" | <EMPTY>)
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         reportCmd$RuleMemoStart = startIndex;
         reportCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            reportCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPORT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            reportCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         reportCmd$RuleMemoStart = startIndex;
         reportCmd$RuleMemoEnd = -1;
         reportCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LabelCmd : (("label" | "labe") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean labelCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (labelCmd$RuleMemoStart == index) {
         if (labelCmd$RuleMemoStart <= labelCmd$RuleMemoEnd) {
            index = labelCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LABEL_CMD, labelCmd$RuleMemoStart, labelCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (labelCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(labelCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("label" | "labe") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("label" | "labe")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
      if (match) {
         ++index;
         // ("abel" | "abe")
         match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
         if (match) {
            ++index;
            // ("bel" | "be")
            match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
            if (match) {
               ++index;
               // ("el" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("l" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         labelCmd$RuleMemoStart = startIndex;
         labelCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            labelCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LABEL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            labelCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         labelCmd$RuleMemoStart = startIndex;
         labelCmd$RuleMemoEnd = -1;
         labelCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexOnCmd : (("index" | "inde") TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean indexOnCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (indexOnCmd$RuleMemoStart == index) {
         if (indexOnCmd$RuleMemoStart <= indexOnCmd$RuleMemoEnd) {
            index = indexOnCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ON_CMD, indexOnCmd$RuleMemoStart, indexOnCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (indexOnCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(indexOnCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("index" | "inde") TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing CmdComplementation)
      // ("index" | "inde")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
      if (match) {
         ++index;
         // ("ndex" | "nde")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("dex" | "de")
            match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
            if (match) {
               ++index;
               // ("ex" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("x" | <EMPTY>)
                  match = buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "on"
               match = ignoreCaseStringMatcher("on", 2);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // CmdComplementation
                        match = cmdComplementation$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         indexOnCmd$RuleMemoStart = startIndex;
         indexOnCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            indexOnCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ON_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            indexOnCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         indexOnCmd$RuleMemoStart = startIndex;
         indexOnCmd$RuleMemoEnd = -1;
         indexOnCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReindexCmd : (("reindex" | "reinde" | "reind" | "rein") TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean reindexCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (reindexCmd$RuleMemoStart == index) {
         if (reindexCmd$RuleMemoStart <= reindexCmd$RuleMemoEnd) {
            index = reindexCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.REINDEX_CMD, reindexCmd$RuleMemoStart, reindexCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (reindexCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(reindexCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("reindex" | "reinde" | "reind" | "rein") TestNoAlpha OptionalSpacing CmdComplementation)
      // ("reindex" | "reinde" | "reind" | "rein")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eindex" | "einde" | "eind" | "ein")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("index" | "inde" | "ind" | "in")
            match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
            if (match) {
               ++index;
               // ("ndex" | "nde" | "nd" | "n")
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("dex" | "de" | "d" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // ("ex" | "e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("x" | <EMPTY>)
                        match = buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         reindexCmd$RuleMemoStart = startIndex;
         reindexCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            reindexCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REINDEX_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            reindexCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         reindexCmd$RuleMemoStart = startIndex;
         reindexCmd$RuleMemoEnd = -1;
         reindexCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QOutCommand : ((('?' | '??') OptionalSpacing) CmdComplementation)
   protected boolean qOutCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qOutCommand$RuleMemoStart == index) {
         if (qOutCommand$RuleMemoStart <= qOutCommand$RuleMemoEnd) {
            index = qOutCommand$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.QOUT_COMMAND, qOutCommand$RuleMemoStart, qOutCommand$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (qOutCommand$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(qOutCommand$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((('?' | '??') OptionalSpacing) CmdComplementation)
      // (('?' | '??') OptionalSpacing)
      // ('?' | '??')
      int startIndex_1 = index;
      match = buffer.matchChar(index, '?');
      if (match) {
         ++index;
         // ('?' | <EMPTY>)
         match = buffer.matchChar(index, '?');
         if (match) {
            ++index;
            // <EMPTY>
            match = true;
         } else {
            match = true;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         // CmdComplementation
         match = cmdComplementation$Rule();
      }
      if (match) {
         qOutCommand$RuleMemoStart = startIndex;
         qOutCommand$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qOutCommand$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QOUT_COMMAND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qOutCommand$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         qOutCommand$RuleMemoStart = startIndex;
         qOutCommand$RuleMemoEnd = -1;
         qOutCommand$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MenuToCmd : ("menu" TestNoAlpha OptionalSpacing "to" TestNoAlpha OptionalSpacing LeftValue)
   protected boolean menuToCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (menuToCmd$RuleMemoStart == index) {
         if (menuToCmd$RuleMemoStart <= menuToCmd$RuleMemoEnd) {
            index = menuToCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MENU_TO_CMD, menuToCmd$RuleMemoStart, menuToCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (menuToCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(menuToCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("menu" TestNoAlpha OptionalSpacing "to" TestNoAlpha OptionalSpacing LeftValue)
      // "menu"
      match = ignoreCaseStringMatcher("menu", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "to"
               match = ignoreCaseStringMatcher("to", 2);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // LeftValue
                        match = leftValue$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         menuToCmd$RuleMemoStart = startIndex;
         menuToCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            menuToCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MENU_TO_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            menuToCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         menuToCmd$RuleMemoStart = startIndex;
         menuToCmd$RuleMemoEnd = -1;
         menuToCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefaultCmd : (("default" | "defaul" | "defau" | "defa") TestNoAlpha OptionalSpacing LeftValue "to" TestNoAlpha OptionalSpacing Expression)
   protected boolean defaultCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (defaultCmd$RuleMemoStart == index) {
         if (defaultCmd$RuleMemoStart <= defaultCmd$RuleMemoEnd) {
            index = defaultCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFAULT_CMD, defaultCmd$RuleMemoStart, defaultCmd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (defaultCmd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(defaultCmd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("default" | "defaul" | "defau" | "defa") TestNoAlpha OptionalSpacing LeftValue "to" TestNoAlpha OptionalSpacing Expression)
      // ("default" | "defaul" | "defau" | "defa")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
      if (match) {
         ++index;
         // ("efault" | "efaul" | "efau" | "efa")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("fault" | "faul" | "fau" | "fa")
            match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
            if (match) {
               ++index;
               // ("ault" | "aul" | "au" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("ult" | "ul" | "u" | <EMPTY>)
                  match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                  if (match) {
                     ++index;
                     // ("lt" | "l" | <EMPTY>)
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // LeftValue
               match = leftValue$Rule();
               if (match) {
                  // "to"
                  match = ignoreCaseStringMatcher("to", 2);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Expression
                           match = expression$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         defaultCmd$RuleMemoStart = startIndex;
         defaultCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            defaultCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFAULT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            defaultCmd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         defaultCmd$RuleMemoStart = startIndex;
         defaultCmd$RuleMemoEnd = -1;
         defaultCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroSubstition : (MacroSubstitionPattern OptionalSpacing)
   protected boolean macroSubstition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroSubstition$RuleMemoStart == index) {
         if (macroSubstition$RuleMemoStart <= macroSubstition$RuleMemoEnd) {
            index = macroSubstition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_SUBSTITION, macroSubstition$RuleMemoStart, macroSubstition$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (macroSubstition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(macroSubstition$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MacroSubstitionPattern OptionalSpacing)
      // MacroSubstitionPattern
      match = macroSubstitionPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         macroSubstition$RuleMemoStart = startIndex;
         macroSubstition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroSubstition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_SUBSTITION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroSubstition$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         macroSubstition$RuleMemoStart = startIndex;
         macroSubstition$RuleMemoEnd = -1;
         macroSubstition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroSubstitionPattern : (('A'-'Z' | '_') ('A'-'Z' | '0'-'9' | '_')*)
   protected boolean macroSubstitionPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('A'-'Z' | '_') ('A'-'Z' | '0'-'9' | '_')*)
      // ('A'-'Z' | '_')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'A'-'Z'
      match = charRangeMatcher('A', 'Z');
      if (! match) {
         // '_'
         match = charMatcher('_');
      }
      if (match) {
         // ('A'-'Z' | '0'-'9' | '_')*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('A'-'Z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
            if (! match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (! match) {
                  // '_'
                  match = charMatcher('_');
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_SUBSTITION, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IgnoreLine : ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))! . OptionalSpacing)+
   protected boolean ignoreLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreLine$RuleMemoStart == index) {
         if (ignoreLine$RuleMemoStart <= ignoreLine$RuleMemoEnd) {
            index = ignoreLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_LINE, ignoreLine$RuleMemoStart, ignoreLine$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ignoreLine$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignoreLine$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))! . OptionalSpacing)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))! . OptionalSpacing)
      // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // ('\n' OptionalSpacing)
      // '\n'
      match = charMatcher('\n');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_3;
         lastNode_3.setSibling(null);
         currentNode = lastNode_3;
         // ('\r' OptionalSpacing)
         // '\r'
         match = charMatcher('\r');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         if (! match) {
            index = lastIndex_3;
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
            // <EOI>
            match = eoi();
            if (! match) {
               index = lastIndex_3;
               lastNode_3.setSibling(null);
               currentNode = lastNode_3;
               // (';' OptionalSpacing)
               // ';'
               match = charMatcher(';');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
            }
         }
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))! . OptionalSpacing)
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI> | (';' OptionalSpacing))
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // ('\n' OptionalSpacing)
            // '\n'
            match = charMatcher('\n');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               index = lastIndex_5;
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               // ('\r' OptionalSpacing)
               // '\r'
               match = charMatcher('\r');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_5;
                  lastNode_5.setSibling(null);
                  currentNode = lastNode_5;
                  // <EOI>
                  match = eoi();
                  if (! match) {
                     index = lastIndex_5;
                     lastNode_5.setSibling(null);
                     currentNode = lastNode_5;
                     // (';' OptionalSpacing)
                     // ';'
                     match = charMatcher(';');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                  }
               }
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         ignoreLine$RuleMemoStart = startIndex;
         ignoreLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_LINE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreLine$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ignoreLine$RuleMemoStart = startIndex;
         ignoreLine$RuleMemoEnd = -1;
         ignoreLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDeclarationList : (VariableDefinition VariableDefinitionCommaList)
   protected boolean variableDeclarationList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variableDeclarationList$RuleMemoStart == index) {
         if (variableDeclarationList$RuleMemoStart <= variableDeclarationList$RuleMemoEnd) {
            index = variableDeclarationList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DECLARATION_LIST, variableDeclarationList$RuleMemoStart, variableDeclarationList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (variableDeclarationList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variableDeclarationList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (VariableDefinition VariableDefinitionCommaList)
      // VariableDefinition
      match = variableDefinition$Rule();
      if (match) {
         // VariableDefinitionCommaList
         match = variableDefinitionCommaList$Rule();
      }
      if (match) {
         variableDeclarationList$RuleMemoStart = startIndex;
         variableDeclarationList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableDeclarationList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DECLARATION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableDeclarationList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         variableDeclarationList$RuleMemoStart = startIndex;
         variableDeclarationList$RuleMemoEnd = -1;
         variableDeclarationList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersDeclarationList : (ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)*)
   protected boolean parametersDeclarationList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parametersDeclarationList$RuleMemoStart == index) {
         if (parametersDeclarationList$RuleMemoStart <= parametersDeclarationList$RuleMemoEnd) {
            index = parametersDeclarationList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION_LIST, parametersDeclarationList$RuleMemoStart, parametersDeclarationList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parametersDeclarationList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parametersDeclarationList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)*)
      // ParameterDeclaration
      match = parameterDeclaration$Rule();
      if (match) {
         // (',' OptionalSpacing ParameterDeclaration)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ParameterDeclaration)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ParameterDeclaration
                  match = parameterDeclaration$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         parametersDeclarationList$RuleMemoStart = startIndex;
         parametersDeclarationList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parametersDeclarationList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parametersDeclarationList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parametersDeclarationList$RuleMemoStart = startIndex;
         parametersDeclarationList$RuleMemoEnd = -1;
         parametersDeclarationList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaVariableDefinition : (',' OptionalSpacing VariableDefinition)
   protected boolean commaVariableDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (',' OptionalSpacing VariableDefinition)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // VariableDefinition
            match = variableDefinition$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_VARIABLE_DEFINITION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDefinition : (AnyIdentifier OptionalArrayDimension AsType InitializeVariable)
   protected boolean variableDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variableDefinition$RuleMemoStart == index) {
         if (variableDefinition$RuleMemoStart <= variableDefinition$RuleMemoEnd) {
            index = variableDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION, variableDefinition$RuleMemoStart, variableDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (variableDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variableDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier OptionalArrayDimension AsType InitializeVariable)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // OptionalArrayDimension
         match = optionalArrayDimension$Rule();
         if (match) {
            // AsType
            match = asType$Rule();
            if (match) {
               // InitializeVariable
               match = initializeVariable$Rule();
            }
         }
      }
      if (match) {
         variableDefinition$RuleMemoStart = startIndex;
         variableDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableDefinition$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         variableDefinition$RuleMemoStart = startIndex;
         variableDefinition$RuleMemoEnd = -1;
         variableDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDefinitionCommaList : CommaVariableDefinition*
   protected boolean variableDefinitionCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaVariableDefinition*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // CommaVariableDefinition
         match = commaVariableDefinition$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //AssignmentOperator : (AssignmentOperatorOnly OptionalSpacing)
   protected boolean assignmentOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignmentOperator$RuleMemoStart == index) {
         if (assignmentOperator$RuleMemoStart <= assignmentOperator$RuleMemoEnd) {
            index = assignmentOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, assignmentOperator$RuleMemoStart, assignmentOperator$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (assignmentOperator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(assignmentOperator$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignmentOperatorOnly OptionalSpacing)
      // AssignmentOperatorOnly
      match = assignmentOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         assignmentOperator$RuleMemoStart = startIndex;
         assignmentOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignmentOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignmentOperator$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         assignmentOperator$RuleMemoStart = startIndex;
         assignmentOperator$RuleMemoEnd = -1;
         assignmentOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignmentOperatorOnly : (':=' | EqualOperator)
   protected boolean assignmentOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (':=' | EqualOperator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ':='
      match = stringMatcher(":=", 2);
      if (! match) {
         // ('=' ('>' | '=')!)
         // '='
         match = charMatcher('=');
         if (match) {
            // ('>' | '=')!
            // ('>' | '=')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '>': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_2;
            match = ! match;
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InitializeVariable : (AssignmentOperator ExpressionAsType)?
   protected boolean initializeVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (AssignmentOperator ExpressionAsType)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (AssignmentOperator ExpressionAsType)
      // AssignmentOperator
      match = assignmentOperator$Rule();
      if (match) {
         // ExpressionAsType
         match = expressionAsType$Rule();
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INITIALIZE_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExpressionAsType : (Expression AsType)
   protected boolean expressionAsType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expressionAsType$RuleMemoStart == index) {
         if (expressionAsType$RuleMemoStart <= expressionAsType$RuleMemoEnd) {
            index = expressionAsType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_AS_TYPE, expressionAsType$RuleMemoStart, expressionAsType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (expressionAsType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(expressionAsType$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression AsType)
      // Expression
      match = expression$Rule();
      if (match) {
         // AsType
         match = asType$Rule();
      }
      if (match) {
         expressionAsType$RuleMemoStart = startIndex;
         expressionAsType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            expressionAsType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_AS_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            expressionAsType$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         expressionAsType$RuleMemoStart = startIndex;
         expressionAsType$RuleMemoEnd = -1;
         expressionAsType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AsType : AsDataType?
   protected boolean asType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (asType$RuleMemoStart == index) {
         if (asType$RuleMemoStart <= asType$RuleMemoEnd) {
            index = asType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_TYPE, asType$RuleMemoStart, asType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (asType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(asType$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // AsDataType?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // AsDataType
      match = asDataType$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         asType$RuleMemoStart = startIndex;
         asType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            asType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            asType$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         asType$RuleMemoStart = startIndex;
         asType$RuleMemoEnd = -1;
         asType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalArrayDimension : ArrayDimension?
   protected boolean optionalArrayDimension$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ArrayDimension?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ArrayDimension
      match = arrayDimension$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_ARRAY_DIMENSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayDimension : ('[' OptionalSpacing ValuesList ']' OptionalSpacing ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*)
   protected boolean arrayDimension$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' OptionalSpacing ValuesList ']' OptionalSpacing ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*)
      // '['
      match = charMatcher('[');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ValuesList
            match = valuesList$Rule();
            if (match) {
               // ']'
               match = charMatcher(']');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*
                     Node lastNode_1;
                     int lastIndex_1;
                     do {
                        lastNode_1 = currentNode;
                        lastIndex_1 = index;
                        // ('[' OptionalSpacing ValuesList ']' OptionalSpacing)
                        // '['
                        match = charMatcher('[');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // ValuesList
                              match = valuesList$Rule();
                              if (match) {
                                 // ']'
                                 match = charMatcher(']');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     } while(match);
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_DIMENSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ValuesList : (Expression? (',' OptionalSpacing Expression?)*)
   protected boolean valuesList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (valuesList$RuleMemoStart == index) {
         if (valuesList$RuleMemoStart <= valuesList$RuleMemoEnd) {
            index = valuesList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUES_LIST, valuesList$RuleMemoStart, valuesList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (valuesList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valuesList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression? (',' OptionalSpacing Expression?)*)
      // Expression?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Expression
      match = expression$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // (',' OptionalSpacing Expression?)*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // (',' OptionalSpacing Expression?)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Expression?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         valuesList$RuleMemoStart = startIndex;
         valuesList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valuesList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUES_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valuesList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         valuesList$RuleMemoStart = startIndex;
         valuesList$RuleMemoEnd = -1;
         valuesList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InTable : ("in" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean inTable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("in" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_TABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableList : (Variable (',' OptionalSpacing Variable)*)
   protected boolean variableList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Variable (',' OptionalSpacing Variable)*)
      // Variable
      match = variable$Rule();
      if (match) {
         // (',' OptionalSpacing Variable)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing Variable)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Variable
                  match = variable$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierList : (AnyIdentifier (',' OptionalSpacing AnyIdentifier)*)
   protected boolean identifierList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (identifierList$RuleMemoStart == index) {
         if (identifierList$RuleMemoStart <= identifierList$RuleMemoEnd) {
            index = identifierList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER_LIST, identifierList$RuleMemoStart, identifierList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifierList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifierList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier (',' OptionalSpacing AnyIdentifier)*)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // (',' OptionalSpacing AnyIdentifier)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing AnyIdentifier)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // AnyIdentifier
                  match = anyIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         identifierList$RuleMemoStart = startIndex;
         identifierList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifierList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         identifierList$RuleMemoStart = startIndex;
         identifierList$RuleMemoEnd = -1;
         identifierList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemvarDeclaration : (("memvar" | "memva" | "memv") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean memvarDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (memvarDeclaration$RuleMemoStart == index) {
         if (memvarDeclaration$RuleMemoStart <= memvarDeclaration$RuleMemoEnd) {
            index = memvarDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMVAR_DECLARATION, memvarDeclaration$RuleMemoStart, memvarDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (memvarDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(memvarDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("memvar" | "memva" | "memv") TestNoAlpha OptionalSpacing IdentifierList)
      // ("memvar" | "memva" | "memv")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
      if (match) {
         ++index;
         // ("emvar" | "emva" | "emv")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("mvar" | "mva" | "mv")
            match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
            if (match) {
               ++index;
               // ("var" | "va" | "v")
               match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
               if (match) {
                  ++index;
                  // ("ar" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         memvarDeclaration$RuleMemoStart = startIndex;
         memvarDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            memvarDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMVAR_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            memvarDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         memvarDeclaration$RuleMemoStart = startIndex;
         memvarDeclaration$RuleMemoEnd = -1;
         memvarDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasIdentifier : (ParenthesesExpressionList | Macro | AnyIdentifier)
   protected boolean aliasIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasIdentifier$RuleMemoStart == index) {
         if (aliasIdentifier$RuleMemoStart <= aliasIdentifier$RuleMemoEnd) {
            index = aliasIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIAS_IDENTIFIER, aliasIdentifier$RuleMemoStart, aliasIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesExpressionList | Macro | AnyIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // Macro
            match = macro$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // Macro
            match = macro$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AnyIdentifier
               match = anyIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '(': {
            // ParenthesesExpressionList
            match = parenthesesExpressionList$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         aliasIdentifier$RuleMemoStart = startIndex;
         aliasIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIAS_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasIdentifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         aliasIdentifier$RuleMemoStart = startIndex;
         aliasIdentifier$RuleMemoEnd = -1;
         aliasIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExpressionList : (Expression? (',' OptionalSpacing Expression?)*)
   protected boolean expressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expressionList$RuleMemoStart == index) {
         if (expressionList$RuleMemoStart <= expressionList$RuleMemoEnd) {
            index = expressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_LIST, expressionList$RuleMemoStart, expressionList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (expressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(expressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression? (',' OptionalSpacing Expression?)*)
      // Expression?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Expression
      match = expression$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // (',' OptionalSpacing Expression?)*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // (',' OptionalSpacing Expression?)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Expression?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         expressionList$RuleMemoStart = startIndex;
         expressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            expressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            expressionList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         expressionList$RuleMemoStart = startIndex;
         expressionList$RuleMemoEnd = -1;
         expressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Macro : (MacroVar | MacroExpression)
   protected boolean macro$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macro$RuleMemoStart == index) {
         if (macro$RuleMemoStart <= macro$RuleMemoEnd) {
            index = macro$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO, macro$RuleMemoStart, macro$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (macro$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(macro$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MacroVar | MacroExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // MacroVar
            match = macroVar$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '&': {
            // MacroVar
            match = macroVar$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MacroExpression
               match = macroExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         macro$RuleMemoStart = startIndex;
         macro$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macro$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macro$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         macro$RuleMemoStart = startIndex;
         macro$RuleMemoEnd = -1;
         macro$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedExpression : (AliasIdentifier '->' OptionalSpacing ParenthesesExpressionList)
   protected boolean aliasedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedExpression$RuleMemoStart == index) {
         if (aliasedExpression$RuleMemoStart <= aliasedExpression$RuleMemoEnd) {
            index = aliasedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_EXPRESSION, aliasedExpression$RuleMemoStart, aliasedExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasedExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasedExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing ParenthesesExpressionList)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ParenthesesExpressionList
               match = parenthesesExpressionList$Rule();
            }
         }
      }
      if (match) {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = -1;
         aliasedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesExpressionList : ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
   protected boolean parenthesesExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesExpressionList$RuleMemoStart == index) {
         if (parenthesesExpressionList$RuleMemoStart <= parenthesesExpressionList$RuleMemoEnd) {
            index = parenthesesExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_EXPRESSION_LIST, parenthesesExpressionList$RuleMemoStart, parenthesesExpressionList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ExpressionList
            match = expressionList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesExpressionList$RuleMemoStart = startIndex;
         parenthesesExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_EXPRESSION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesExpressionList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parenthesesExpressionList$RuleMemoStart = startIndex;
         parenthesesExpressionList$RuleMemoEnd = -1;
         parenthesesExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesStatement : ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
   protected boolean parenthesesStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesStatement$RuleMemoStart == index) {
         if (parenthesesStatement$RuleMemoStart <= parenthesesStatement$RuleMemoEnd) {
            index = parenthesesStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_STATEMENT, parenthesesStatement$RuleMemoStart, parenthesesStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parenthesesStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ExpressionList
            match = expressionList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesStatement$RuleMemoStart = startIndex;
         parenthesesStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesStatement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parenthesesStatement$RuleMemoStart = startIndex;
         parenthesesStatement$RuleMemoEnd = -1;
         parenthesesStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QualifiedVariable : (Variable (':' OptionalSpacing AnyIdentifier)+)
   protected boolean qualifiedVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qualifiedVariable$RuleMemoStart == index) {
         if (qualifiedVariable$RuleMemoStart <= qualifiedVariable$RuleMemoEnd) {
            index = qualifiedVariable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE, qualifiedVariable$RuleMemoStart, qualifiedVariable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (qualifiedVariable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(qualifiedVariable$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Variable (':' OptionalSpacing AnyIdentifier)+)
      // Variable
      match = variable$Rule();
      if (match) {
         // (':' OptionalSpacing AnyIdentifier)+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (':' OptionalSpacing AnyIdentifier)
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // (':' OptionalSpacing AnyIdentifier)
               // ':'
               match = charMatcher(':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyIdentifier
                     match = anyIdentifier$Rule();
                  }
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         qualifiedVariable$RuleMemoStart = startIndex;
         qualifiedVariable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qualifiedVariable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qualifiedVariable$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         qualifiedVariable$RuleMemoStart = startIndex;
         qualifiedVariable$RuleMemoEnd = -1;
         qualifiedVariable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroFunctionCall : (Macro ParParameters)
   protected boolean macroFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroFunctionCall$RuleMemoStart == index) {
         if (macroFunctionCall$RuleMemoStart <= macroFunctionCall$RuleMemoEnd) {
            index = macroFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_FUNCTION_CALL, macroFunctionCall$RuleMemoStart, macroFunctionCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (macroFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(macroFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Macro ParParameters)
      // Macro
      match = macro$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         macroFunctionCall$RuleMemoStart = startIndex;
         macroFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroFunctionCall$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         macroFunctionCall$RuleMemoStart = startIndex;
         macroFunctionCall$RuleMemoEnd = -1;
         macroFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParParameters : ('(' OptionalSpacing (('...' OptionalSpacing) | OptionalParametersList) ')' OptionalSpacing)
   protected boolean parParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parParameters$RuleMemoStart == index) {
         if (parParameters$RuleMemoStart <= parParameters$RuleMemoEnd) {
            index = parParameters$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS, parParameters$RuleMemoStart, parParameters$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parParameters$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parParameters$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing (('...' OptionalSpacing) | OptionalParametersList) ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (('...' OptionalSpacing) | OptionalParametersList)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('...' OptionalSpacing)
            // '...'
            match = stringMatcher("...", 3);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OptionalParametersList
               match = optionalParametersList$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parParameters$RuleMemoStart = startIndex;
         parParameters$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parParameters$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parParameters$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parParameters$RuleMemoStart = startIndex;
         parParameters$RuleMemoEnd = -1;
         parParameters$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SimpleFunctionCall : (Identifier ParParameters)
   protected boolean simpleFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (simpleFunctionCall$RuleMemoStart == index) {
         if (simpleFunctionCall$RuleMemoStart <= simpleFunctionCall$RuleMemoEnd) {
            index = simpleFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, simpleFunctionCall$RuleMemoStart, simpleFunctionCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (simpleFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(simpleFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier ParParameters)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         simpleFunctionCall$RuleMemoStart = startIndex;
         simpleFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            simpleFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            simpleFunctionCall$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         simpleFunctionCall$RuleMemoStart = startIndex;
         simpleFunctionCall$RuleMemoEnd = -1;
         simpleFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnySimpleFunctionCall : (AnyIdentifier ParParameters)
   protected boolean anySimpleFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anySimpleFunctionCall$RuleMemoStart == index) {
         if (anySimpleFunctionCall$RuleMemoStart <= anySimpleFunctionCall$RuleMemoEnd) {
            index = anySimpleFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, anySimpleFunctionCall$RuleMemoStart, anySimpleFunctionCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (anySimpleFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anySimpleFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier ParParameters)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         anySimpleFunctionCall$RuleMemoStart = startIndex;
         anySimpleFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anySimpleFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anySimpleFunctionCall$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anySimpleFunctionCall$RuleMemoStart = startIndex;
         anySimpleFunctionCall$RuleMemoEnd = -1;
         anySimpleFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IgnoreRestOfLine : (TestNoAlpha ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?)
   protected boolean ignoreRestOfLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreRestOfLine$RuleMemoStart == index) {
         if (ignoreRestOfLine$RuleMemoStart <= ignoreRestOfLine$RuleMemoEnd) {
            index = ignoreRestOfLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_REST_OF_LINE, ignoreRestOfLine$RuleMemoStart, ignoreRestOfLine$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (ignoreRestOfLine$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignoreRestOfLine$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (TestNoAlpha ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?)
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'a'-'z'
      match = buffer.matchCharRange(index, 'a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = buffer.matchCharRange(index, 'A', 'Z');
         if (! match) {
            // '0'-'9'
            match = buffer.matchCharRange(index, '0', '9');
            if (! match) {
               // '_'
               match = buffer.matchChar(index, '_');
            }
         }
      }
      match = ! match;
      if (match) {
         // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*
         Node lastNode_3;
         int lastIndex_3;
         do {
            lastNode_3 = currentNode;
            lastIndex_3 = index;
            // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // ('\n' OptionalSpacing)
            // '\n'
            match = charMatcher('\n');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               index = lastIndex_5;
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               // ('\r' OptionalSpacing)
               // '\r'
               match = charMatcher('\r');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_5;
                  lastNode_5.setSibling(null);
                  currentNode = lastNode_5;
                  // <EOI>
                  match = eoi();
                  if (! match) {
                     index = lastIndex_5;
                     lastNode_5.setSibling(null);
                     currentNode = lastNode_5;
                  }
               }
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         } while(match);
         lastNode_3.setSibling(null);
         currentNode = lastNode_3;
         index = lastIndex_3;
         match = true;
      }
      if (match) {
         ignoreRestOfLine$RuleMemoStart = startIndex;
         ignoreRestOfLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreRestOfLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_REST_OF_LINE, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreRestOfLine$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ignoreRestOfLine$RuleMemoStart = startIndex;
         ignoreRestOfLine$RuleMemoEnd = -1;
         ignoreRestOfLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfInLine : (IIFKeyword '(' OptionalSpacing Condition ',' OptionalSpacing Expression? ',' OptionalSpacing Expression? ')' OptionalSpacing)
   protected boolean ifInLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifInLine$RuleMemoStart == index) {
         if (ifInLine$RuleMemoStart <= ifInLine$RuleMemoEnd) {
            index = ifInLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_IN_LINE, ifInLine$RuleMemoStart, ifInLine$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifInLine$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifInLine$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IIFKeyword '(' OptionalSpacing Condition ',' OptionalSpacing Expression? ',' OptionalSpacing Expression? ')' OptionalSpacing)
      // ("iif" | "if")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
      if (match) {
         ++index;
         // ("if" | "f")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case 'i':
            case 'I': {
               ++index;
               // "f"
               if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                  ++index;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
               if (match) {
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Expression?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // Expression
                        match = expression$Rule();
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                        if (match) {
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // Expression?
                                 Node lastNode_3 = currentNode;
                                 int lastIndex_3 = index;
                                 // Expression
                                 match = expression$Rule();
                                 if (! match) {
                                    lastNode_3.setSibling(null);
                                    currentNode = lastNode_3;
                                    index = lastIndex_3;
                                    match = true;
                                 }
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         ifInLine$RuleMemoStart = startIndex;
         ifInLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifInLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_IN_LINE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifInLine$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifInLine$RuleMemoStart = startIndex;
         ifInLine$RuleMemoEnd = -1;
         ifInLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfBegin : ("if" TestNoAlpha OptionalSpacing Condition)
   protected boolean ifBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifBegin$RuleMemoStart == index) {
         if (ifBegin$RuleMemoStart <= ifBegin$RuleMemoEnd) {
            index = ifBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_BEGIN, ifBegin$RuleMemoStart, ifBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("if" TestNoAlpha OptionalSpacing Condition)
      // "if"
      match = ignoreCaseStringMatcher("if", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         ifBegin$RuleMemoStart = startIndex;
         ifBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifBegin$RuleMemoStart = startIndex;
         ifBegin$RuleMemoEnd = -1;
         ifBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Condition : Expression
   protected boolean condition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (condition$RuleMemoStart == index) {
         if (condition$RuleMemoStart <= condition$RuleMemoEnd) {
            index = condition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION, condition$RuleMemoStart, condition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (condition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(condition$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Expression
      match = expression$Rule();
      if (match) {
         condition$RuleMemoStart = startIndex;
         condition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            condition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            condition$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         condition$RuleMemoStart = startIndex;
         condition$RuleMemoEnd = -1;
         condition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfEnd : (("endif" | "endi") IgnoreRestOfLine)
   protected boolean ifEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifEnd$RuleMemoStart == index) {
         if (ifEnd$RuleMemoStart <= ifEnd$RuleMemoEnd) {
            index = ifEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_END, ifEnd$RuleMemoStart, ifEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("endif" | "endi") IgnoreRestOfLine)
      // ("endif" | "endi")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
      if (match) {
         ++index;
         // ("ndif" | "ndi")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("dif" | "di")
            match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
            if (match) {
               ++index;
               // ("if" | "i")
               match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
               if (match) {
                  ++index;
                  // ("f" | <EMPTY>)
                  match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         ifEnd$RuleMemoStart = startIndex;
         ifEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifEnd$RuleMemoStart = startIndex;
         ifEnd$RuleMemoEnd = -1;
         ifEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndKeyword : ("end" IgnoreRestOfLine)
   protected boolean endKeyword$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endKeyword$RuleMemoStart == index) {
         if (endKeyword$RuleMemoStart <= endKeyword$RuleMemoEnd) {
            index = endKeyword$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_KEYWORD, endKeyword$RuleMemoStart, endKeyword$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endKeyword$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endKeyword$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" IgnoreRestOfLine)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         endKeyword$RuleMemoStart = startIndex;
         endKeyword$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endKeyword$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_KEYWORD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endKeyword$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endKeyword$RuleMemoStart = startIndex;
         endKeyword$RuleMemoEnd = -1;
         endKeyword$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoWhileBegin : (("do" TestNoAlpha OptionalSpacing)? ("while" | "whil") TestNoAlpha OptionalSpacing Condition)
   protected boolean doWhileBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doWhileBegin$RuleMemoStart == index) {
         if (doWhileBegin$RuleMemoStart <= doWhileBegin$RuleMemoEnd) {
            index = doWhileBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_BEGIN, doWhileBegin$RuleMemoStart, doWhileBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doWhileBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doWhileBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("do" TestNoAlpha OptionalSpacing)? ("while" | "whil") TestNoAlpha OptionalSpacing Condition)
      // ("do" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("do" TestNoAlpha OptionalSpacing)
      // "do"
      match = ignoreCaseStringMatcher("do", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ("while" | "whil")
         int startIndex_3 = index;
         match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
         if (match) {
            ++index;
            // ("hile" | "hil")
            match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
            if (match) {
               ++index;
               // ("ile" | "il")
               match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
               if (match) {
                  ++index;
                  // ("le" | "l")
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_3;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Condition
                  match = condition$Rule();
               }
            }
         }
      }
      if (match) {
         doWhileBegin$RuleMemoStart = startIndex;
         doWhileBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doWhileBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doWhileBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         doWhileBegin$RuleMemoStart = startIndex;
         doWhileBegin$RuleMemoEnd = -1;
         doWhileBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoWhileEnd : ((("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing) | (("enddo" | "endd") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
   protected boolean doWhileEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doWhileEnd$RuleMemoStart == index) {
         if (doWhileEnd$RuleMemoStart <= doWhileEnd$RuleMemoEnd) {
            index = doWhileEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_END, doWhileEnd$RuleMemoStart, doWhileEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doWhileEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doWhileEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing) | (("enddo" | "endd") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
      // (("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing) | (("enddo" | "endd") TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "do"
               match = ignoreCaseStringMatcher("do", 2);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (("enddo" | "endd") TestNoAlpha OptionalSpacing)
         // ("enddo" | "endd")
         int startIndex_4 = index;
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("nddo" | "ndd")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("ddo" | "dd")
               match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
               if (match) {
                  ++index;
                  // ("do" | "d")
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // ("o" | <EMPTY>)
                     match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_4;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         doWhileEnd$RuleMemoStart = startIndex;
         doWhileEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doWhileEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doWhileEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         doWhileEnd$RuleMemoStart = startIndex;
         doWhileEnd$RuleMemoEnd = -1;
         doWhileEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForNextBegin : ("for" TestNoAlpha OptionalSpacing ForIndexInitialization "to" TestNoAlpha OptionalSpacing Expression Step)
   protected boolean forNextBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forNextBegin$RuleMemoStart == index) {
         if (forNextBegin$RuleMemoStart <= forNextBegin$RuleMemoEnd) {
            index = forNextBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_BEGIN, forNextBegin$RuleMemoStart, forNextBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forNextBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forNextBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing ForIndexInitialization "to" TestNoAlpha OptionalSpacing Expression Step)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ForIndexInitialization
               match = forIndexInitialization$Rule();
               if (match) {
                  // "to"
                  match = ignoreCaseStringMatcher("to", 2);
                  if (match) {
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                     // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                        if (! match) {
                           // '0'-'9'
                           match = buffer.matchCharRange(index, '0', '9');
                           if (! match) {
                              // '_'
                              match = buffer.matchChar(index, '_');
                           }
                        }
                     }
                     match = ! match;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Expression
                           match = expression$Rule();
                           if (match) {
                              // Step
                              match = step$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forNextBegin$RuleMemoStart = startIndex;
         forNextBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forNextBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forNextBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         forNextBegin$RuleMemoStart = startIndex;
         forNextBegin$RuleMemoEnd = -1;
         forNextBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForNextEnd : ((("end" "for") | "next" | "endfor" | "endfo" | "endf") IgnoreRestOfLine)
   protected boolean forNextEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forNextEnd$RuleMemoStart == index) {
         if (forNextEnd$RuleMemoStart <= forNextEnd$RuleMemoEnd) {
            index = forNextEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_END, forNextEnd$RuleMemoStart, forNextEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forNextEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forNextEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("end" "for") | "next" | "endfor" | "endfo" | "endf") IgnoreRestOfLine)
      // (("end" "for") | "next" | "endfor" | "endfo" | "endf")
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("end" "for")
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // "for"
         match = ignoreCaseStringMatcher("for", 3);
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // "next"
         match = ignoreCaseStringMatcher("next", 4);
         if (! match) {
            // "endfor"
            match = ignoreCaseStringMatcher("endfor", 6);
            if (! match) {
               // "endfo"
               match = ignoreCaseStringMatcher("endfo", 5);
               if (! match) {
                  // "endf"
                  match = ignoreCaseStringMatcher("endf", 4);
               }
            }
         }
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         forNextEnd$RuleMemoStart = startIndex;
         forNextEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forNextEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forNextEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         forNextEnd$RuleMemoStart = startIndex;
         forNextEnd$RuleMemoEnd = -1;
         forNextEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginSequenceBegin : (BeginSequenceKeyword WithCodeBlock)
   protected boolean beginSequenceBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginSequenceBegin$RuleMemoStart == index) {
         if (beginSequenceBegin$RuleMemoStart <= beginSequenceBegin$RuleMemoEnd) {
            index = beginSequenceBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_BEGIN, beginSequenceBegin$RuleMemoStart, beginSequenceBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (beginSequenceBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(beginSequenceBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (BeginSequenceKeyword WithCodeBlock)
      // BeginSequenceKeyword
      match = beginSequenceKeyword$Rule();
      if (match) {
         // WithCodeBlock
         match = withCodeBlock$Rule();
      }
      if (match) {
         beginSequenceBegin$RuleMemoStart = startIndex;
         beginSequenceBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginSequenceBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginSequenceBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         beginSequenceBegin$RuleMemoStart = startIndex;
         beginSequenceBegin$RuleMemoEnd = -1;
         beginSequenceBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseBegin : ("do" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
   protected boolean doCaseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseBegin$RuleMemoStart == index) {
         if (doCaseBegin$RuleMemoStart <= doCaseBegin$RuleMemoEnd) {
            index = doCaseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_BEGIN, doCaseBegin$RuleMemoStart, doCaseBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doCaseBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doCaseBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("do" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
      // "do"
      match = ignoreCaseStringMatcher("do", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "case"
               match = ignoreCaseStringMatcher("case", 4);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         doCaseBegin$RuleMemoStart = startIndex;
         doCaseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         doCaseBegin$RuleMemoStart = startIndex;
         doCaseBegin$RuleMemoEnd = -1;
         doCaseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseEnd : ((("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing) | (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
   protected boolean doCaseEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseEnd$RuleMemoStart == index) {
         if (doCaseEnd$RuleMemoStart <= doCaseEnd$RuleMemoEnd) {
            index = doCaseEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_END, doCaseEnd$RuleMemoStart, doCaseEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doCaseEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doCaseEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing) | (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
      // (("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing) | (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "case"
               match = ignoreCaseStringMatcher("case", 4);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing)
         // ("endcase" | "endcas" | "endca" | "endc")
         int startIndex_4 = index;
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("ndcase" | "ndcas" | "ndca" | "ndc")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("dcase" | "dcas" | "dca" | "dc")
               match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
               if (match) {
                  ++index;
                  // ("case" | "cas" | "ca" | "c")
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("ase" | "as" | "a" | <EMPTY>)
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("se" | "s" | <EMPTY>)
                        match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                        if (match) {
                           ++index;
                           // ("e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_4;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         doCaseEnd$RuleMemoStart = startIndex;
         doCaseEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         doCaseEnd$RuleMemoStart = startIndex;
         doCaseEnd$RuleMemoEnd = -1;
         doCaseEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForEachBegin : ("for" TestNoAlpha OptionalSpacing "each" TestNoAlpha OptionalSpacing Variable "in" TestNoAlpha OptionalSpacing Expression)
   protected boolean forEachBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forEachBegin$RuleMemoStart == index) {
         if (forEachBegin$RuleMemoStart <= forEachBegin$RuleMemoEnd) {
            index = forEachBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_BEGIN, forEachBegin$RuleMemoStart, forEachBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forEachBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forEachBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing "each" TestNoAlpha OptionalSpacing Variable "in" TestNoAlpha OptionalSpacing Expression)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "each"
               match = ignoreCaseStringMatcher("each", 4);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Variable
                        match = variable$Rule();
                        if (match) {
                           // "in"
                           match = ignoreCaseStringMatcher("in", 2);
                           if (match) {
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // 'a'-'z'
                              match = buffer.matchCharRange(index, 'a', 'z');
                              if (! match) {
                                 // 'A'-'Z'
                                 match = buffer.matchCharRange(index, 'A', 'Z');
                                 if (! match) {
                                    // '0'-'9'
                                    match = buffer.matchCharRange(index, '0', '9');
                                    if (! match) {
                                       // '_'
                                       match = buffer.matchChar(index, '_');
                                    }
                                 }
                              }
                              match = ! match;
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // Expression
                                    match = expression$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forEachBegin$RuleMemoStart = startIndex;
         forEachBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forEachBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forEachBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         forEachBegin$RuleMemoStart = startIndex;
         forEachBegin$RuleMemoEnd = -1;
         forEachBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchBegin : (("switch" | "switc" | "swit") TestNoAlpha OptionalSpacing Expression)
   protected boolean switchBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchBegin$RuleMemoStart == index) {
         if (switchBegin$RuleMemoStart <= switchBegin$RuleMemoEnd) {
            index = switchBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_BEGIN, switchBegin$RuleMemoStart, switchBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (switchBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(switchBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("switch" | "switc" | "swit") TestNoAlpha OptionalSpacing Expression)
      // ("switch" | "switc" | "swit")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
      if (match) {
         ++index;
         // ("witch" | "witc" | "wit")
         match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
         if (match) {
            ++index;
            // ("itch" | "itc" | "it")
            match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
            if (match) {
               ++index;
               // ("tch" | "tc" | "t")
               match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
               if (match) {
                  ++index;
                  // ("ch" | "c" | <EMPTY>)
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // ("h" | <EMPTY>)
                     match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         switchBegin$RuleMemoStart = startIndex;
         switchBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         switchBegin$RuleMemoStart = startIndex;
         switchBegin$RuleMemoEnd = -1;
         switchBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchEnd : ("end" TestNoAlpha OptionalSpacing "switch" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean switchEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchEnd$RuleMemoStart == index) {
         if (switchEnd$RuleMemoStart <= switchEnd$RuleMemoEnd) {
            index = switchEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_END, switchEnd$RuleMemoStart, switchEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (switchEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(switchEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "switch" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "switch"
               match = ignoreCaseStringMatcher("switch", 6);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // IgnoreRestOfLine
                        match = ignoreRestOfLine$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         switchEnd$RuleMemoStart = startIndex;
         switchEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         switchEnd$RuleMemoStart = startIndex;
         switchEnd$RuleMemoEnd = -1;
         switchEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TryCatchBegin : ("try" TestNoAlpha OptionalSpacing)
   protected boolean tryCatchBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (tryCatchBegin$RuleMemoStart == index) {
         if (tryCatchBegin$RuleMemoStart <= tryCatchBegin$RuleMemoEnd) {
            index = tryCatchBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_BEGIN, tryCatchBegin$RuleMemoStart, tryCatchBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tryCatchBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tryCatchBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("try" TestNoAlpha OptionalSpacing)
      // "try"
      match = ignoreCaseStringMatcher("try", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         tryCatchBegin$RuleMemoStart = startIndex;
         tryCatchBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tryCatchBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tryCatchBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         tryCatchBegin$RuleMemoStart = startIndex;
         tryCatchBegin$RuleMemoEnd = -1;
         tryCatchBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TryCatchEnd : ("end" TestNoAlpha OptionalSpacing "try" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean tryCatchEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (tryCatchEnd$RuleMemoStart == index) {
         if (tryCatchEnd$RuleMemoStart <= tryCatchEnd$RuleMemoEnd) {
            index = tryCatchEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_END, tryCatchEnd$RuleMemoStart, tryCatchEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tryCatchEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tryCatchEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "try" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "try"
               match = ignoreCaseStringMatcher("try", 3);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // IgnoreRestOfLine
                        match = ignoreRestOfLine$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         tryCatchEnd$RuleMemoStart = startIndex;
         tryCatchEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tryCatchEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tryCatchEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         tryCatchEnd$RuleMemoStart = startIndex;
         tryCatchEnd$RuleMemoEnd = -1;
         tryCatchEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FinallyBlockBegin : ("finally" TestNoAlpha OptionalSpacing)
   protected boolean finallyBlockBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (finallyBlockBegin$RuleMemoStart == index) {
         if (finallyBlockBegin$RuleMemoStart <= finallyBlockBegin$RuleMemoEnd) {
            index = finallyBlockBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FINALLY_BLOCK_BEGIN, finallyBlockBegin$RuleMemoStart, finallyBlockBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (finallyBlockBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(finallyBlockBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("finally" TestNoAlpha OptionalSpacing)
      // "finally"
      match = ignoreCaseStringMatcher("finally", 7);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         finallyBlockBegin$RuleMemoStart = startIndex;
         finallyBlockBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            finallyBlockBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FINALLY_BLOCK_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            finallyBlockBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         finallyBlockBegin$RuleMemoStart = startIndex;
         finallyBlockBegin$RuleMemoEnd = -1;
         finallyBlockBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Return : (("return" | "retur" | "retu") TestNoAlpha OptionalSpacing ExpressionAsType?)
   protected boolean return$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (return$RuleMemoStart == index) {
         if (return$RuleMemoStart <= return$RuleMemoEnd) {
            index = return$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RETURN, return$RuleMemoStart, return$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (return$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(return$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("return" | "retur" | "retu") TestNoAlpha OptionalSpacing ExpressionAsType?)
      // ("return" | "retur" | "retu")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eturn" | "etur" | "etu")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("turn" | "tur" | "tu")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("urn" | "ur" | "u")
               match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
               if (match) {
                  ++index;
                  // ("rn" | "r" | <EMPTY>)
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ExpressionAsType?
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ExpressionAsType
               match = expressionAsType$Rule();
               if (! match) {
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  match = true;
               }
            }
         }
      }
      if (match) {
         return$RuleMemoStart = startIndex;
         return$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            return$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RETURN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            return$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         return$RuleMemoStart = startIndex;
         return$RuleMemoEnd = -1;
         return$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Break : (("break" | "brea") TestNoAlpha OptionalSpacing Expression?)
   protected boolean break$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (break$RuleMemoStart == index) {
         if (break$RuleMemoStart <= break$RuleMemoEnd) {
            index = break$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BREAK, break$RuleMemoStart, break$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (break$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(break$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("break" | "brea") TestNoAlpha OptionalSpacing Expression?)
      // ("break" | "brea")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
      if (match) {
         ++index;
         // ("reak" | "rea")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("eak" | "ea")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("ak" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("k" | <EMPTY>)
                  match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // Expression
               match = expression$Rule();
               if (! match) {
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  match = true;
               }
            }
         }
      }
      if (match) {
         break$RuleMemoStart = startIndex;
         break$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            break$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BREAK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            break$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         break$RuleMemoStart = startIndex;
         break$RuleMemoEnd = -1;
         break$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassMemberDeclaration : ('_HB_MEMBER' TestNoAlpha OptionalSpacing (MethodDeclaration | AttributeListDeclaration))
   protected boolean classMemberDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classMemberDeclaration$RuleMemoStart == index) {
         if (classMemberDeclaration$RuleMemoStart <= classMemberDeclaration$RuleMemoEnd) {
            index = classMemberDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_MEMBER_DECLARATION, classMemberDeclaration$RuleMemoStart, classMemberDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (classMemberDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(classMemberDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('_HB_MEMBER' TestNoAlpha OptionalSpacing (MethodDeclaration | AttributeListDeclaration))
      // '_HB_MEMBER'
      match = stringMatcher("_HB_MEMBER", 10);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (MethodDeclaration | AttributeListDeclaration)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               switch(buffer.getChar(index)) {
                  case '{': {
                     // AttributeListDeclaration
                     match = attributeListDeclaration$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z': {
                     // MethodDeclaration
                     match = methodDeclaration$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         classMemberDeclaration$RuleMemoStart = startIndex;
         classMemberDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classMemberDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_MEMBER_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classMemberDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         classMemberDeclaration$RuleMemoStart = startIndex;
         classMemberDeclaration$RuleMemoEnd = -1;
         classMemberDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PublicVariableDeclaration : (("public" | "publi" | "publ") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean publicVariableDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (publicVariableDeclaration$RuleMemoStart == index) {
         if (publicVariableDeclaration$RuleMemoStart <= publicVariableDeclaration$RuleMemoEnd) {
            index = publicVariableDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PUBLIC_VARIABLE_DECLARATION, publicVariableDeclaration$RuleMemoStart, publicVariableDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (publicVariableDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(publicVariableDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("public" | "publi" | "publ") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("public" | "publi" | "publ")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
      if (match) {
         ++index;
         // ("ublic" | "ubli" | "ubl")
         match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
         if (match) {
            ++index;
            // ("blic" | "bli" | "bl")
            match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
            if (match) {
               ++index;
               // ("lic" | "li" | "l")
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("ic" | "i" | <EMPTY>)
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("c" | <EMPTY>)
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         publicVariableDeclaration$RuleMemoStart = startIndex;
         publicVariableDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            publicVariableDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PUBLIC_VARIABLE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            publicVariableDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         publicVariableDeclaration$RuleMemoStart = startIndex;
         publicVariableDeclaration$RuleMemoEnd = -1;
         publicVariableDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrivateVariableDeclaration : (("private" | "privat" | "priva" | "priv") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean privateVariableDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (privateVariableDeclaration$RuleMemoStart == index) {
         if (privateVariableDeclaration$RuleMemoStart <= privateVariableDeclaration$RuleMemoEnd) {
            index = privateVariableDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIVATE_VARIABLE_DECLARATION, privateVariableDeclaration$RuleMemoStart, privateVariableDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (privateVariableDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(privateVariableDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("private" | "privat" | "priva" | "priv") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("private" | "privat" | "priva" | "priv")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P');
      if (match) {
         ++index;
         // ("rivate" | "rivat" | "riva" | "riv")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("ivate" | "ivat" | "iva" | "iv")
            match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
            if (match) {
               ++index;
               // ("vate" | "vat" | "va" | "v")
               match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
               if (match) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         privateVariableDeclaration$RuleMemoStart = startIndex;
         privateVariableDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            privateVariableDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIVATE_VARIABLE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            privateVariableDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         privateVariableDeclaration$RuleMemoStart = startIndex;
         privateVariableDeclaration$RuleMemoEnd = -1;
         privateVariableDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //External : (("external" | "externa" | "extern" | "exter" | "exte") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean external$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (external$RuleMemoStart == index) {
         if (external$RuleMemoStart <= external$RuleMemoEnd) {
            index = external$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXTERNAL, external$RuleMemoStart, external$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (external$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(external$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("external" | "externa" | "extern" | "exter" | "exte") TestNoAlpha OptionalSpacing IdentifierList)
      // ("external" | "externa" | "extern" | "exter" | "exte")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
      if (match) {
         ++index;
         // ("xternal" | "xterna" | "xtern" | "xter" | "xte")
         match = buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X');
         if (match) {
            ++index;
            // ("ternal" | "terna" | "tern" | "ter" | "te")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("ernal" | "erna" | "ern" | "er" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("rnal" | "rna" | "rn" | "r" | <EMPTY>)
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("nal" | "na" | "n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("al" | "a" | <EMPTY>)
                        match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                        if (match) {
                           ++index;
                           // ("l" | <EMPTY>)
                           match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         external$RuleMemoStart = startIndex;
         external$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            external$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXTERNAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            external$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         external$RuleMemoStart = startIndex;
         external$RuleMemoEnd = -1;
         external$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Announce : (("announce" | "announc" | "announ" | "annou" | "anno") TestNoAlpha OptionalSpacing Identifier)
   protected boolean announce$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (announce$RuleMemoStart == index) {
         if (announce$RuleMemoStart <= announce$RuleMemoEnd) {
            index = announce$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANNOUNCE, announce$RuleMemoStart, announce$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (announce$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(announce$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("announce" | "announc" | "announ" | "annou" | "anno") TestNoAlpha OptionalSpacing Identifier)
      // ("announce" | "announc" | "announ" | "annou" | "anno")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("nnounce" | "nnounc" | "nnoun" | "nnou" | "nno")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("nounce" | "nounc" | "noun" | "nou" | "no")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("ounce" | "ounc" | "oun" | "ou" | "o")
               match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
               if (match) {
                  ++index;
                  // ("unce" | "unc" | "un" | "u" | <EMPTY>)
                  match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                  if (match) {
                     ++index;
                     // ("nce" | "nc" | "n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("ce" | "c" | <EMPTY>)
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // ("e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Identifier
               match = identifier$Rule();
            }
         }
      }
      if (match) {
         announce$RuleMemoStart = startIndex;
         announce$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            announce$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANNOUNCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            announce$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         announce$RuleMemoStart = startIndex;
         announce$RuleMemoEnd = -1;
         announce$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Request : (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean request$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (request$RuleMemoStart == index) {
         if (request$RuleMemoStart <= request$RuleMemoEnd) {
            index = request$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST, request$RuleMemoStart, request$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (request$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(request$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing IdentifierList)
      // ("request" | "reques" | "reque" | "requ")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("equest" | "eques" | "eque" | "equ")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("quest" | "ques" | "que" | "qu")
            match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
            if (match) {
               ++index;
               // ("uest" | "ues" | "ue" | "u")
               match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
               if (match) {
                  ++index;
                  // ("est" | "es" | "e" | <EMPTY>)
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("st" | "s" | <EMPTY>)
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // ("t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         request$RuleMemoStart = startIndex;
         request$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            request$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            request$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         request$RuleMemoStart = startIndex;
         request$RuleMemoEnd = -1;
         request$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Throw : ("throw" TestNoAlpha OptionalSpacing '(' OptionalSpacing Expression ')' OptionalSpacing)
   protected boolean throw$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (throw$RuleMemoStart == index) {
         if (throw$RuleMemoStart <= throw$RuleMemoEnd) {
            index = throw$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.THROW, throw$RuleMemoStart, throw$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (throw$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(throw$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("throw" TestNoAlpha OptionalSpacing '(' OptionalSpacing Expression ')' OptionalSpacing)
      // "throw"
      match = ignoreCaseStringMatcher("throw", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Expression
                     match = expression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         throw$RuleMemoStart = startIndex;
         throw$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            throw$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.THROW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            throw$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         throw$RuleMemoStart = startIndex;
         throw$RuleMemoEnd = -1;
         throw$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StatementAssignmentExpression : (LeftValue AssignOperator (ValueByReference | Expression))
   protected boolean statementAssignmentExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (statementAssignmentExpression$RuleMemoStart == index) {
         if (statementAssignmentExpression$RuleMemoStart <= statementAssignmentExpression$RuleMemoEnd) {
            index = statementAssignmentExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT_ASSIGNMENT_EXPRESSION, statementAssignmentExpression$RuleMemoStart, statementAssignmentExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (statementAssignmentExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(statementAssignmentExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LeftValue AssignOperator (ValueByReference | Expression))
      // LeftValue
      match = leftValue$Rule();
      if (match) {
         // AssignOperator
         match = assignOperator$Rule();
         if (match) {
            // (ValueByReference | Expression)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '&':
               case '\'':
               case '(':
               case '+':
               case '-':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{': {
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
                  break;
               }
               case '@': {
                  // ValueByReference
                  match = valueByReference$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         }
      }
      if (match) {
         statementAssignmentExpression$RuleMemoStart = startIndex;
         statementAssignmentExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            statementAssignmentExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT_ASSIGNMENT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            statementAssignmentExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         statementAssignmentExpression$RuleMemoStart = startIndex;
         statementAssignmentExpression$RuleMemoEnd = -1;
         statementAssignmentExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SelfExpression : ('::' OptionalSpacing PrimaryExpression)
   protected boolean selfExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (selfExpression$RuleMemoStart == index) {
         if (selfExpression$RuleMemoStart <= selfExpression$RuleMemoEnd) {
            index = selfExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELF_EXPRESSION, selfExpression$RuleMemoStart, selfExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selfExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selfExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('::' OptionalSpacing PrimaryExpression)
      // '::'
      match = stringMatcher("::", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PrimaryExpression
            match = primaryExpression$Rule();
         }
      }
      if (match) {
         selfExpression$RuleMemoStart = startIndex;
         selfExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selfExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELF_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selfExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         selfExpression$RuleMemoStart = startIndex;
         selfExpression$RuleMemoEnd = -1;
         selfExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedMacro : (AliasIdentifier '->' OptionalSpacing Macro)
   protected boolean aliasedMacro$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedMacro$RuleMemoStart == index) {
         if (aliasedMacro$RuleMemoStart <= aliasedMacro$RuleMemoEnd) {
            index = aliasedMacro$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_MACRO, aliasedMacro$RuleMemoStart, aliasedMacro$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasedMacro$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasedMacro$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing Macro)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Macro
               match = macro$Rule();
            }
         }
      }
      if (match) {
         aliasedMacro$RuleMemoStart = startIndex;
         aliasedMacro$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedMacro$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_MACRO, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedMacro$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         aliasedMacro$RuleMemoStart = startIndex;
         aliasedMacro$RuleMemoEnd = -1;
         aliasedMacro$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QualifiedExpression : (AtomicExpression (':' OptionalSpacing MemberCall)+)
   protected boolean qualifiedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qualifiedExpression$RuleMemoStart == index) {
         if (qualifiedExpression$RuleMemoStart <= qualifiedExpression$RuleMemoEnd) {
            index = qualifiedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_EXPRESSION, qualifiedExpression$RuleMemoStart, qualifiedExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (qualifiedExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(qualifiedExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AtomicExpression (':' OptionalSpacing MemberCall)+)
      // AtomicExpression
      match = atomicExpression$Rule();
      if (match) {
         // (':' OptionalSpacing MemberCall)+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (':' OptionalSpacing MemberCall)
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // MemberCall
               match = memberCall$Rule();
            }
         }
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // (':' OptionalSpacing MemberCall)
               // ':'
               match = charMatcher(':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // MemberCall
                     match = memberCall$Rule();
                  }
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         qualifiedExpression$RuleMemoStart = startIndex;
         qualifiedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qualifiedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qualifiedExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         qualifiedExpression$RuleMemoStart = startIndex;
         qualifiedExpression$RuleMemoEnd = -1;
         qualifiedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemberCall : (ArrayAccess | MacroFunctionCall | AnySimpleFunctionCall | Variable)
   protected boolean memberCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ArrayAccess | MacroFunctionCall | AnySimpleFunctionCall | Variable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '(':
         case '[':
         case '{': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MacroFunctionCall
               match = macroFunctionCall$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MacroFunctionCall
               match = macroFunctionCall$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AnySimpleFunctionCall
                  match = anySimpleFunctionCall$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // Variable
                     match = variable$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeywordsFunctionCall : ((("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing) ParParameters)
   protected boolean keywordsFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keywordsFunctionCall$RuleMemoStart == index) {
         if (keywordsFunctionCall$RuleMemoStart <= keywordsFunctionCall$RuleMemoEnd) {
            index = keywordsFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYWORDS_FUNCTION_CALL, keywordsFunctionCall$RuleMemoStart, keywordsFunctionCall$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (keywordsFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(keywordsFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing) ParParameters)
      // (("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing)
      // ("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // ("unction" | "unctio" | "uncti" | "ield" | "unct" | "iel" | "unc")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I': {
                  ++index;
                  // ("eld" | "el")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ld" | "l")
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("d" | <EMPTY>)
                        match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("nction" | "nctio" | "ncti" | "nct" | "nc")
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // ("ction" | "ctio" | "cti" | "ct" | "c")
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("ion" | "io" | "i" | <EMPTY>)
                           match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                           if (match) {
                              ++index;
                              // ("on" | "o" | <EMPTY>)
                              match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                              if (match) {
                                 ++index;
                                 // ("n" | <EMPTY>)
                                 match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'x':
         case 'X': {
            ++index;
            // ("translate" | "translat" | "transla" | "command" | "transl" | "comman" | "trans" | "comma" | "tran" | "comm" | "tra" | "com")
            switch(buffer.getChar(index)) {
               case 'c':
               case 'C': {
                  ++index;
                  // ("ommand" | "omman" | "omma" | "omm" | "om")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("mmand" | "mman" | "mma" | "mm" | "m")
                     match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                     if (match) {
                        ++index;
                        // ("mand" | "man" | "ma" | "m" | <EMPTY>)
                        match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                        if (match) {
                           ++index;
                           // ("and" | "an" | "a" | <EMPTY>)
                           match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                           if (match) {
                              ++index;
                              // ("nd" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("d" | <EMPTY>)
                                 match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 't':
               case 'T': {
                  ++index;
                  // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
                        match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                        if (match) {
                           ++index;
                           // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                           match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                           if (match) {
                              ++index;
                              // ("late" | "lat" | "la" | "l" | <EMPTY>)
                              match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                              if (match) {
                                 ++index;
                                 // ("ate" | "at" | "a" | <EMPTY>)
                                 match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                                 if (match) {
                                    ++index;
                                    // ("te" | "t" | <EMPTY>)
                                    match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                                    if (match) {
                                       ++index;
                                       // ("e" | <EMPTY>)
                                       match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                       if (match) {
                                          ++index;
                                          // <EMPTY>
                                          match = true;
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'i':
         case 'I': {
            ++index;
            // "nit"
            if (match = ignoreCaseStringTest("nit", 3)) {
               index += 3;
            }
            break;
         }
         case 'l':
         case 'L': {
            ++index;
            // "oop"
            if (match = ignoreCaseStringTest("oop", 3)) {
               index += 3;
            }
            break;
         }
         case 'o':
         case 'O': {
            ++index;
            // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
               match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
               if (match) {
                  ++index;
                  // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                        match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
                        if (match) {
                           ++index;
                           // ("ise" | "is" | "i" | <EMPTY>)
                           match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                           if (match) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // ("rocedure" | "rocedur" | "rocedu" | "roced" | "ublic" | "roce" | "ubli" | "roc" | "ubl")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                           match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                           if (match) {
                              ++index;
                              // ("ure" | "ur" | "u" | <EMPTY>)
                              match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                              if (match) {
                                 ++index;
                                 // ("re" | "r" | <EMPTY>)
                                 match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("blic" | "bli" | "bl")
                  match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                  if (match) {
                     ++index;
                     // ("lic" | "li" | "l")
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'b':
         case 'B': {
            ++index;
            // ("egin" | "reak" | "rea")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("eak" | "ea")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ak" | "a")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("k" | <EMPTY>)
                        match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "gin"
                  if (match = ignoreCaseStringTest("gin", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            ++index;
            // ("ecover" | "ecove" | "ecov" | "eco")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("cover" | "cove" | "cov" | "co")
               match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
               if (match) {
                  ++index;
                  // ("over" | "ove" | "ov" | "o")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("ver" | "ve" | "v" | <EMPTY>)
                     match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
                     if (match) {
                        ++index;
                        // ("er" | "e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("r" | <EMPTY>)
                           match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // ("ommand" | "omman" | "lass" | "omma" | "las" | "omm")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("mmand" | "mman" | "mma" | "mm")
                  match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                  if (match) {
                     ++index;
                     // ("mand" | "man" | "ma" | "m")
                     match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                     if (match) {
                        ++index;
                        // ("and" | "an" | "a" | <EMPTY>)
                        match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                        if (match) {
                           ++index;
                           // ("nd" | "n" | <EMPTY>)
                           match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                           if (match) {
                              ++index;
                              // ("d" | <EMPTY>)
                              match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // ("ass" | "as")
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("ss" | "s")
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // ("s" | <EMPTY>)
                        match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // ("equence" | "equenc" | "equen" | "eque" | "equ" | "tep")
            switch(buffer.getChar(index)) {
               case 't':
               case 'T': {
                  ++index;
                  // "ep"
                  if (match = ignoreCaseStringTest("ep", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("quence" | "quenc" | "quen" | "que" | "qu")
                  match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
                  if (match) {
                     ++index;
                     // ("uence" | "uenc" | "uen" | "ue" | "u")
                     match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                     if (match) {
                        ++index;
                        // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("nce" | "nc" | "n" | <EMPTY>)
                           match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                           if (match) {
                              ++index;
                              // ("ce" | "c" | <EMPTY>)
                              match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // ("eclare" | "efault" | "eclar" | "efine" | "ecla" | "efin" | "ecl" | "efi" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("clare" | "fault" | "clar" | "fine" | "cla" | "fin" | "cl" | "fi")
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F': {
                        ++index;
                        // ("ault" | "ine" | "in" | "i")
                        switch(buffer.getChar(index)) {
                           case 'a':
                           case 'A': {
                              ++index;
                              // "ult"
                              if (match = ignoreCaseStringTest("ult", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           case 'i':
                           case 'I': {
                              ++index;
                              // ("ne" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // ("lare" | "lar" | "la" | "l")
                        match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                        if (match) {
                           ++index;
                           // ("are" | "ar" | "a" | <EMPTY>)
                           match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                           if (match) {
                              ++index;
                              // ("re" | "r" | <EMPTY>)
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an")
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                        match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                        if (match) {
                           ++index;
                           // ("late" | "lat" | "la" | "l" | <EMPTY>)
                           match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                           if (match) {
                              ++index;
                              // ("ate" | "at" | "a" | <EMPTY>)
                              match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                              if (match) {
                                 ++index;
                                 // ("te" | "t" | <EMPTY>)
                                 match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // ("xternal" | "xterna" | "xtern" | "xter" | "lse" | "ach" | "xit" | "xte")
            switch(buffer.getChar(index)) {
               case 'x':
               case 'X': {
                  ++index;
                  // ("ternal" | "terna" | "tern" | "ter" | "it" | "te")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "t"
                        if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // ("ernal" | "erna" | "ern" | "er" | "e")
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("rnal" | "rna" | "rn" | "r" | <EMPTY>)
                           match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                           if (match) {
                              ++index;
                              // ("nal" | "na" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("al" | "a" | <EMPTY>)
                                 match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                                 if (match) {
                                    ++index;
                                    // ("l" | <EMPTY>)
                                    match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "ch"
                  if (match = ignoreCaseStringTest("ch", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         keywordsFunctionCall$RuleMemoStart = startIndex;
         keywordsFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keywordsFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYWORDS_FUNCTION_CALL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keywordsFunctionCall$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         keywordsFunctionCall$RuleMemoStart = startIndex;
         keywordsFunctionCall$RuleMemoEnd = -1;
         keywordsFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MethodDeclaration : (Identifier ParParametersDeclaration)
   protected boolean methodDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodDeclaration$RuleMemoStart == index) {
         if (methodDeclaration$RuleMemoStart <= methodDeclaration$RuleMemoEnd) {
            index = methodDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DECLARATION, methodDeclaration$RuleMemoStart, methodDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (methodDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(methodDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier ParParametersDeclaration)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // ParParametersDeclaration
         match = parParametersDeclaration$Rule();
      }
      if (match) {
         methodDeclaration$RuleMemoStart = startIndex;
         methodDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         methodDeclaration$RuleMemoStart = startIndex;
         methodDeclaration$RuleMemoEnd = -1;
         methodDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParParametersDeclaration : ('(' OptionalSpacing ParametersDeclaration ')' OptionalSpacing)
   protected boolean parParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parParametersDeclaration$RuleMemoStart == index) {
         if (parParametersDeclaration$RuleMemoStart <= parParametersDeclaration$RuleMemoEnd) {
            index = parParametersDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS_DECLARATION, parParametersDeclaration$RuleMemoStart, parParametersDeclaration$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parParametersDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parParametersDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ParametersDeclaration ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ParametersDeclaration
            match = parametersDeclaration$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parParametersDeclaration$RuleMemoStart = startIndex;
         parParametersDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parParametersDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS_DECLARATION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parParametersDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parParametersDeclaration$RuleMemoStart = startIndex;
         parParametersDeclaration$RuleMemoEnd = -1;
         parParametersDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AttributeListDeclaration : ('{' OptionalSpacing IdentifierList '}' OptionalSpacing)
   protected boolean attributeListDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (attributeListDeclaration$RuleMemoStart == index) {
         if (attributeListDeclaration$RuleMemoStart <= attributeListDeclaration$RuleMemoEnd) {
            index = attributeListDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATTRIBUTE_LIST_DECLARATION, attributeListDeclaration$RuleMemoStart, attributeListDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (attributeListDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(attributeListDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('{' OptionalSpacing IdentifierList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IdentifierList
            match = identifierList$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         attributeListDeclaration$RuleMemoStart = startIndex;
         attributeListDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            attributeListDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATTRIBUTE_LIST_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            attributeListDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         attributeListDeclaration$RuleMemoStart = startIndex;
         attributeListDeclaration$RuleMemoEnd = -1;
         attributeListDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroPrefix : (Letter | Digit | '_')*
   protected boolean macroPrefix$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (Letter | Digit | '_')*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (Letter | Digit | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ('a'-'z' | 'A'-'Z')
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
         }
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // '_'
               match = charMatcher('_');
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      currentRuleIsAtomic = lastRuleIsAtomic;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_PREFIX, startIndex, index, true, false);
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //MacroSufix : ('.' (Letter | Digit | '_')*)
   protected boolean macroSufix$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('.' (Letter | Digit | '_')*)
      // '.'
      match = charMatcher('.');
      if (match) {
         // (Letter | Digit | '_')*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (Letter | Digit | '_')
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ('a'-'z' | 'A'-'Z')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // '_'
                  match = charMatcher('_');
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_SUFIX, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroVar : (MacroPrefix '&' OptionalSpacing MacroVarName MacroSufix? OptionalSpacing)
   protected boolean macroVar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroVar$RuleMemoStart == index) {
         if (macroVar$RuleMemoStart <= macroVar$RuleMemoEnd) {
            index = macroVar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_VAR, macroVar$RuleMemoStart, macroVar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (macroVar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(macroVar$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MacroPrefix '&' OptionalSpacing MacroVarName MacroSufix? OptionalSpacing)
      // MacroPrefix
      match = macroPrefix$Rule();
      if (match) {
         // '&'
         match = charMatcher('&');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // MacroVarName
               match = macroVarName$Rule();
               if (match) {
                  // MacroSufix?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // MacroSufix
                  match = macroSufix$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         macroVar$RuleMemoStart = startIndex;
         macroVar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroVar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_VAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroVar$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         macroVar$RuleMemoStart = startIndex;
         macroVar$RuleMemoEnd = -1;
         macroVar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroVarName : IdentifierPattern
   protected boolean macroVarName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroExpression : ('&' OptionalSpacing ParenthesesExpressionList)
   protected boolean macroExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroExpression$RuleMemoStart == index) {
         if (macroExpression$RuleMemoStart <= macroExpression$RuleMemoEnd) {
            index = macroExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_EXPRESSION, macroExpression$RuleMemoStart, macroExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (macroExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(macroExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('&' OptionalSpacing ParenthesesExpressionList)
      // '&'
      match = charMatcher('&');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ParenthesesExpressionList
            match = parenthesesExpressionList$Rule();
         }
      }
      if (match) {
         macroExpression$RuleMemoStart = startIndex;
         macroExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         macroExpression$RuleMemoStart = startIndex;
         macroExpression$RuleMemoEnd = -1;
         macroExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionReference : (AnyIdentifier '(' OptionalSpacing ')' OptionalSpacing)
   protected boolean functionReference$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionReference$RuleMemoStart == index) {
         if (functionReference$RuleMemoStart <= functionReference$RuleMemoEnd) {
            index = functionReference$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_REFERENCE, functionReference$RuleMemoStart, functionReference$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionReference$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionReference$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier '(' OptionalSpacing ')' OptionalSpacing)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         functionReference$RuleMemoStart = startIndex;
         functionReference$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionReference$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_REFERENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionReference$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         functionReference$RuleMemoStart = startIndex;
         functionReference$RuleMemoEnd = -1;
         functionReference$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ValueByReference : ('@' OptionalSpacing (FunctionReference | AliasedField | QualifiedVariable | Variable))
   protected boolean valueByReference$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (valueByReference$RuleMemoStart == index) {
         if (valueByReference$RuleMemoStart <= valueByReference$RuleMemoEnd) {
            index = valueByReference$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUE_BY_REFERENCE, valueByReference$RuleMemoStart, valueByReference$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (valueByReference$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valueByReference$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing (FunctionReference | AliasedField | QualifiedVariable | Variable))
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (FunctionReference | AliasedField | QualifiedVariable | Variable)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '&':
               case '7':
               case '8':
               case '(':
               case '9': {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
                  break;
               }
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z': {
                  // FunctionReference
                  match = functionReference$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedField
                     match = aliasedField$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // QualifiedVariable
                        match = qualifiedVariable$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Variable
                           match = variable$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         }
      }
      if (match) {
         valueByReference$RuleMemoStart = startIndex;
         valueByReference$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valueByReference$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUE_BY_REFERENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valueByReference$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         valueByReference$RuleMemoStart = startIndex;
         valueByReference$RuleMemoEnd = -1;
         valueByReference$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedField : (AliasIdentifier '->' OptionalSpacing AnyIdentifier)
   protected boolean aliasedField$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedField$RuleMemoStart == index) {
         if (aliasedField$RuleMemoStart <= aliasedField$RuleMemoEnd) {
            index = aliasedField$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD, aliasedField$RuleMemoStart, aliasedField$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasedField$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasedField$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing AnyIdentifier)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         aliasedField$RuleMemoStart = startIndex;
         aliasedField$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedField$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedField$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         aliasedField$RuleMemoStart = startIndex;
         aliasedField$RuleMemoEnd = -1;
         aliasedField$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Parameter : (ValueByReference | Expression | ')'& | ','&)
   protected boolean parameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parameter$RuleMemoStart == index) {
         if (parameter$RuleMemoStart <= parameter$RuleMemoEnd) {
            index = parameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER, parameter$RuleMemoStart, parameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ValueByReference | Expression | ')'& | ','&)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ValueByReference
      match = valueByReference$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // Expression
         match = expression$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ')'&
            // ')'
            match = buffer.matchChar(index, ')');
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ','&
               // ','
               match = buffer.matchChar(index, ',');
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         parameter$RuleMemoStart = startIndex;
         parameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parameter$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parameter$RuleMemoStart = startIndex;
         parameter$RuleMemoEnd = -1;
         parameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaParameter : (',' OptionalSpacing Parameter)
   protected boolean commaParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (',' OptionalSpacing Parameter)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Parameter
            match = parameter$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_PARAMETER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParameterCommaList : CommaParameter*
   protected boolean parameterCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaParameter*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // CommaParameter
         match = commaParameter$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ParametersList : (Parameter ParameterCommaList)
   protected boolean parametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parametersList$RuleMemoStart == index) {
         if (parametersList$RuleMemoStart <= parametersList$RuleMemoEnd) {
            index = parametersList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_LIST, parametersList$RuleMemoStart, parametersList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parametersList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parametersList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Parameter ParameterCommaList)
      // Parameter
      match = parameter$Rule();
      if (match) {
         // ParameterCommaList
         match = parameterCommaList$Rule();
      }
      if (match) {
         parametersList$RuleMemoStart = startIndex;
         parametersList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parametersList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parametersList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parametersList$RuleMemoStart = startIndex;
         parametersList$RuleMemoEnd = -1;
         parametersList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalParametersList : ParametersList?
   protected boolean optionalParametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalParametersList$RuleMemoStart == index) {
         if (optionalParametersList$RuleMemoStart <= optionalParametersList$RuleMemoEnd) {
            index = optionalParametersList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_PARAMETERS_LIST, optionalParametersList$RuleMemoStart, optionalParametersList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalParametersList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalParametersList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ParametersList?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ParametersList
      match = parametersList$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         optionalParametersList$RuleMemoStart = startIndex;
         optionalParametersList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalParametersList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_PARAMETERS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalParametersList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalParametersList$RuleMemoStart = startIndex;
         optionalParametersList$RuleMemoEnd = -1;
         optionalParametersList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseIfBegin : (("elseif" | "elsei") TestNoAlpha OptionalSpacing Condition)
   protected boolean elseIfBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseIfBegin$RuleMemoStart == index) {
         if (elseIfBegin$RuleMemoStart <= elseIfBegin$RuleMemoEnd) {
            index = elseIfBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_IF_BEGIN, elseIfBegin$RuleMemoStart, elseIfBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (elseIfBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(elseIfBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("elseif" | "elsei") TestNoAlpha OptionalSpacing Condition)
      // ("elseif" | "elsei")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
      if (match) {
         ++index;
         // ("lseif" | "lsei")
         match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
         if (match) {
            ++index;
            // ("seif" | "sei")
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("eif" | "ei")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("if" | "i")
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("f" | <EMPTY>)
                     match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         elseIfBegin$RuleMemoStart = startIndex;
         elseIfBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseIfBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_IF_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseIfBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         elseIfBegin$RuleMemoStart = startIndex;
         elseIfBegin$RuleMemoEnd = -1;
         elseIfBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseBegin : ("else" TestNoAlpha OptionalSpacing)
   protected boolean elseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseBegin$RuleMemoStart == index) {
         if (elseBegin$RuleMemoStart <= elseBegin$RuleMemoEnd) {
            index = elseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_BEGIN, elseBegin$RuleMemoStart, elseBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (elseBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(elseBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         elseBegin$RuleMemoStart = startIndex;
         elseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         elseBegin$RuleMemoStart = startIndex;
         elseBegin$RuleMemoEnd = -1;
         elseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OtherwiseBegin : (("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe") TestNoAlpha OptionalSpacing)
   protected boolean otherwiseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (otherwiseBegin$RuleMemoStart == index) {
         if (otherwiseBegin$RuleMemoStart <= otherwiseBegin$RuleMemoEnd) {
            index = otherwiseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OTHERWISE_BEGIN, otherwiseBegin$RuleMemoStart, otherwiseBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (otherwiseBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(otherwiseBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe") TestNoAlpha OptionalSpacing)
      // ("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
      if (match) {
         ++index;
         // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
         match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
         if (match) {
            ++index;
            // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
            match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
            if (match) {
               ++index;
               // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                     match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
                     if (match) {
                        ++index;
                        // ("ise" | "is" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("se" | "s" | <EMPTY>)
                           match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                           if (match) {
                              ++index;
                              // ("e" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         otherwiseBegin$RuleMemoStart = startIndex;
         otherwiseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            otherwiseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OTHERWISE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            otherwiseBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         otherwiseBegin$RuleMemoStart = startIndex;
         otherwiseBegin$RuleMemoEnd = -1;
         otherwiseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseOptionBegin : ("case" TestNoAlpha OptionalSpacing Condition)
   protected boolean doCaseOptionBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseOptionBegin$RuleMemoStart == index) {
         if (doCaseOptionBegin$RuleMemoStart <= doCaseOptionBegin$RuleMemoEnd) {
            index = doCaseOptionBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_OPTION_BEGIN, doCaseOptionBegin$RuleMemoStart, doCaseOptionBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doCaseOptionBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doCaseOptionBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing Condition)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         doCaseOptionBegin$RuleMemoStart = startIndex;
         doCaseOptionBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseOptionBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_OPTION_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseOptionBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         doCaseOptionBegin$RuleMemoStart = startIndex;
         doCaseOptionBegin$RuleMemoEnd = -1;
         doCaseOptionBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StepArgument : ("step" TestNoAlpha OptionalSpacing Expression)
   protected boolean stepArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("step" TestNoAlpha OptionalSpacing Expression)
      // "step"
      match = ignoreCaseStringMatcher("step", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STEP_ARGUMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Step : StepArgument?
   protected boolean step$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // StepArgument?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // StepArgument
      match = stepArgument$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STEP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForIndexInitialization : ((AliasedField | Macro | QualifiedVariable | Variable) AssignmentOperator Expression)
   protected boolean forIndexInitialization$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((AliasedField | Macro | QualifiedVariable | Variable) AssignmentOperator Expression)
      // (AliasedField | Macro | QualifiedVariable | Variable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // AliasedField
            match = aliasedField$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Macro
               match = macro$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // AliasedField
            match = aliasedField$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Macro
               match = macro$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QualifiedVariable
                  match = qualifiedVariable$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // Variable
                     match = variable$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // AliasedField
            match = aliasedField$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // AssignmentOperator
         match = assignmentOperator$Rule();
         if (match) {
            // Expression
            match = expression$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginSequenceKeyword : (("begin" | "begi") TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
   protected boolean beginSequenceKeyword$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("begin" | "begi") TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
      // ("begin" | "begi")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
      if (match) {
         ++index;
         // ("egin" | "egi")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("gin" | "gi")
            match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
            if (match) {
               ++index;
               // ("in" | "i")
               match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
               if (match) {
                  ++index;
                  // ("n" | <EMPTY>)
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ")
               int startIndex_3 = index;
               match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
               if (match) {
                  ++index;
                  // ("equence" | "equenc" | "equen" | "eque" | "equ")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("quence" | "quenc" | "quen" | "que" | "qu")
                     match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
                     if (match) {
                        ++index;
                        // ("uence" | "uenc" | "uen" | "ue" | "u")
                        match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                        if (match) {
                           ++index;
                           // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("nce" | "nc" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("ce" | "c" | <EMPTY>)
                                 match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = startIndex_3;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_KEYWORD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WithOption : ("with" TestNoAlpha OptionalSpacing CodeBlockLiteral)
   protected boolean withOption$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing CodeBlockLiteral)
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CodeBlockLiteral
               match = codeBlockLiteral$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WITH_OPTION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockLiteral : (CodeBlockPattern OptionalSpacing)
   protected boolean codeBlockLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (codeBlockLiteral$RuleMemoStart == index) {
         if (codeBlockLiteral$RuleMemoStart <= codeBlockLiteral$RuleMemoEnd) {
            index = codeBlockLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_LITERAL, codeBlockLiteral$RuleMemoStart, codeBlockLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (codeBlockLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(codeBlockLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (CodeBlockPattern OptionalSpacing)
      // CodeBlockPattern
      match = codeBlockPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         codeBlockLiteral$RuleMemoStart = startIndex;
         codeBlockLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            codeBlockLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            codeBlockLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         codeBlockLiteral$RuleMemoStart = startIndex;
         codeBlockLiteral$RuleMemoEnd = -1;
         codeBlockLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WithCodeBlock : WithOption?
   protected boolean withCodeBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // WithOption?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // WithOption
      match = withOption$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WITH_CODE_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginSequenceEnd : ((("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing) | (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
   protected boolean beginSequenceEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginSequenceEnd$RuleMemoStart == index) {
         if (beginSequenceEnd$RuleMemoStart <= beginSequenceEnd$RuleMemoEnd) {
            index = beginSequenceEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_END, beginSequenceEnd$RuleMemoStart, beginSequenceEnd$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (beginSequenceEnd$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(beginSequenceEnd$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing) | (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing)) IgnoreRestOfLine)
      // (("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing) | (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ")
               int startIndex_3 = index;
               match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
               if (match) {
                  ++index;
                  // ("equence" | "equenc" | "equen" | "eque" | "equ")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("quence" | "quenc" | "quen" | "que" | "qu")
                     match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
                     if (match) {
                        ++index;
                        // ("uence" | "uenc" | "uen" | "ue" | "u")
                        match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                        if (match) {
                           ++index;
                           // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("nce" | "nc" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("ce" | "c" | <EMPTY>)
                                 match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = startIndex_3;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing)
         // ("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends")
         int startIndex_5 = index;
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("ndsequence" | "ndsequenc" | "ndsequen" | "ndseque" | "ndsequ" | "ndseq" | "ndse" | "nds")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("dsequence" | "dsequenc" | "dsequen" | "dseque" | "dsequ" | "dseq" | "dse" | "ds")
               match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
               if (match) {
                  ++index;
                  // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "seq" | "se" | "s")
                  match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                  if (match) {
                     ++index;
                     // ("equence" | "equenc" | "equen" | "eque" | "equ" | "eq" | "e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("quence" | "quenc" | "quen" | "que" | "qu" | "q" | <EMPTY>)
                        match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
                        if (match) {
                           ++index;
                           // ("uence" | "uenc" | "uen" | "ue" | "u" | <EMPTY>)
                           match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                           if (match) {
                              ++index;
                              // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // ("nce" | "nc" | "n" | <EMPTY>)
                                 match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                                 if (match) {
                                    ++index;
                                    // ("ce" | "c" | <EMPTY>)
                                    match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                    if (match) {
                                       ++index;
                                       // ("e" | <EMPTY>)
                                       match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                       if (match) {
                                          ++index;
                                          // <EMPTY>
                                          match = true;
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_5;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_5, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_6 = currentNode;
            int lastIndex_6 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         beginSequenceEnd$RuleMemoStart = startIndex;
         beginSequenceEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginSequenceEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginSequenceEnd$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         beginSequenceEnd$RuleMemoStart = startIndex;
         beginSequenceEnd$RuleMemoEnd = -1;
         beginSequenceEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UsingSpec : (("using" | "usin") TestNoAlpha OptionalSpacing Variable)
   protected boolean usingSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("using" | "usin") TestNoAlpha OptionalSpacing Variable)
      // ("using" | "usin")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
      if (match) {
         ++index;
         // ("sing" | "sin")
         match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
         if (match) {
            ++index;
            // ("ing" | "in")
            match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
            if (match) {
               ++index;
               // ("ng" | "n")
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("g" | <EMPTY>)
                  match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Variable
               match = variable$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USING_SPEC, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UsingIdentifier : UsingSpec?
   protected boolean usingIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // UsingSpec?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // UsingSpec
      match = usingSpec$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USING_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RecoverBegin : (("recover" | "recove" | "recov" | "reco") TestNoAlpha OptionalSpacing UsingIdentifier)
   protected boolean recoverBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (recoverBegin$RuleMemoStart == index) {
         if (recoverBegin$RuleMemoStart <= recoverBegin$RuleMemoEnd) {
            index = recoverBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECOVER_BEGIN, recoverBegin$RuleMemoStart, recoverBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (recoverBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(recoverBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("recover" | "recove" | "recov" | "reco") TestNoAlpha OptionalSpacing UsingIdentifier)
      // ("recover" | "recove" | "recov" | "reco")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("ecover" | "ecove" | "ecov" | "eco")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("cover" | "cove" | "cov" | "co")
            match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
            if (match) {
               ++index;
               // ("over" | "ove" | "ov" | "o")
               match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
               if (match) {
                  ++index;
                  // ("ver" | "ve" | "v" | <EMPTY>)
                  match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
                  if (match) {
                     ++index;
                     // ("er" | "e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("r" | <EMPTY>)
                        match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // UsingIdentifier
               match = usingIdentifier$Rule();
            }
         }
      }
      if (match) {
         recoverBegin$RuleMemoStart = startIndex;
         recoverBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recoverBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECOVER_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recoverBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         recoverBegin$RuleMemoStart = startIndex;
         recoverBegin$RuleMemoEnd = -1;
         recoverBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AlwaysBegin : (("always" | "alway" | "alwa") TestNoAlpha OptionalSpacing)
   protected boolean alwaysBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (alwaysBegin$RuleMemoStart == index) {
         if (alwaysBegin$RuleMemoStart <= alwaysBegin$RuleMemoEnd) {
            index = alwaysBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALWAYS_BEGIN, alwaysBegin$RuleMemoStart, alwaysBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (alwaysBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(alwaysBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("always" | "alway" | "alwa") TestNoAlpha OptionalSpacing)
      // ("always" | "alway" | "alwa")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("lways" | "lway" | "lwa")
         match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
         if (match) {
            ++index;
            // ("ways" | "way" | "wa")
            match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
            if (match) {
               ++index;
               // ("ays" | "ay" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("ys" | "y" | <EMPTY>)
                  match = buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y');
                  if (match) {
                     ++index;
                     // ("s" | <EMPTY>)
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         alwaysBegin$RuleMemoStart = startIndex;
         alwaysBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            alwaysBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALWAYS_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            alwaysBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         alwaysBegin$RuleMemoStart = startIndex;
         alwaysBegin$RuleMemoEnd = -1;
         alwaysBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesSwitchConstant : ('(' OptionalSpacing SwitchConstant ')' OptionalSpacing)
   protected boolean parenthesesSwitchConstant$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesSwitchConstant$RuleMemoStart == index) {
         if (parenthesesSwitchConstant$RuleMemoStart <= parenthesesSwitchConstant$RuleMemoEnd) {
            index = parenthesesSwitchConstant$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_SWITCH_CONSTANT, parenthesesSwitchConstant$RuleMemoStart, parenthesesSwitchConstant$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesSwitchConstant$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesSwitchConstant$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SwitchConstant ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SwitchConstant
            match = switchConstant$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesSwitchConstant$RuleMemoStart = startIndex;
         parenthesesSwitchConstant$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesSwitchConstant$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_SWITCH_CONSTANT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesSwitchConstant$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parenthesesSwitchConstant$RuleMemoStart = startIndex;
         parenthesesSwitchConstant$RuleMemoEnd = -1;
         parenthesesSwitchConstant$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchConstant : (ParenthesesSwitchConstant | LogicalLiteral | StringLiteral | NumberLiteral)
   protected boolean switchConstant$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchConstant$RuleMemoStart == index) {
         if (switchConstant$RuleMemoStart <= switchConstant$RuleMemoEnd) {
            index = switchConstant$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_CONSTANT, switchConstant$RuleMemoStart, switchConstant$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (switchConstant$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(switchConstant$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesSwitchConstant | LogicalLiteral | StringLiteral | NumberLiteral)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case 'e':
         case 'E':
         case '\'':
         case '[': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '.': {
            // LogicalLiteral
            match = logicalLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NumberLiteral
               match = numberLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // ParenthesesSwitchConstant
            match = parenthesesSwitchConstant$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         switchConstant$RuleMemoStart = startIndex;
         switchConstant$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchConstant$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_CONSTANT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchConstant$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         switchConstant$RuleMemoStart = startIndex;
         switchConstant$RuleMemoEnd = -1;
         switchConstant$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalLiteral : (LogicalPattern OptionalSpacing)
   protected boolean logicalLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (logicalLiteral$RuleMemoStart == index) {
         if (logicalLiteral$RuleMemoStart <= logicalLiteral$RuleMemoEnd) {
            index = logicalLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, logicalLiteral$RuleMemoStart, logicalLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (logicalLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(logicalLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LogicalPattern OptionalSpacing)
      // LogicalPattern
      match = logicalPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            logicalLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            logicalLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = -1;
         logicalLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalPattern : ((".T." | ".F." | ".Y." | ".N.") OptionalSpacing)
   protected boolean logicalPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((".T." | ".F." | ".Y." | ".N.") OptionalSpacing)
      // (".T." | ".F." | ".Y." | ".N.")
      int startIndex_1 = index;
      match = buffer.matchChar(index, '.');
      if (match) {
         ++index;
         // ("T." | "F." | "Y." | "N.")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 'n':
            case 'N': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 'y':
            case 'Y': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 't':
            case 'T': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchOptionBegin : ("case" TestNoAlpha OptionalSpacing SwitchConstant)
   protected boolean switchOptionBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchOptionBegin$RuleMemoStart == index) {
         if (switchOptionBegin$RuleMemoStart <= switchOptionBegin$RuleMemoEnd) {
            index = switchOptionBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_OPTION_BEGIN, switchOptionBegin$RuleMemoStart, switchOptionBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (switchOptionBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(switchOptionBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing SwitchConstant)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SwitchConstant
               match = switchConstant$Rule();
            }
         }
      }
      if (match) {
         switchOptionBegin$RuleMemoStart = startIndex;
         switchOptionBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchOptionBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_OPTION_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchOptionBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         switchOptionBegin$RuleMemoStart = startIndex;
         switchOptionBegin$RuleMemoEnd = -1;
         switchOptionBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchDefaultBegin : ("default" TestNoAlpha OptionalSpacing)
   protected boolean switchDefaultBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchDefaultBegin$RuleMemoStart == index) {
         if (switchDefaultBegin$RuleMemoStart <= switchDefaultBegin$RuleMemoEnd) {
            index = switchDefaultBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_DEFAULT_BEGIN, switchDefaultBegin$RuleMemoStart, switchDefaultBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (switchDefaultBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(switchDefaultBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("default" TestNoAlpha OptionalSpacing)
      // "default"
      match = ignoreCaseStringMatcher("default", 7);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         switchDefaultBegin$RuleMemoStart = startIndex;
         switchDefaultBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchDefaultBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_DEFAULT_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchDefaultBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         switchDefaultBegin$RuleMemoStart = startIndex;
         switchDefaultBegin$RuleMemoEnd = -1;
         switchDefaultBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CatchBlockBegin : ("catch" TestNoAlpha OptionalSpacing Variable?)
   protected boolean catchBlockBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (catchBlockBegin$RuleMemoStart == index) {
         if (catchBlockBegin$RuleMemoStart <= catchBlockBegin$RuleMemoEnd) {
            index = catchBlockBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CATCH_BLOCK_BEGIN, catchBlockBegin$RuleMemoStart, catchBlockBegin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (catchBlockBegin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(catchBlockBegin$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("catch" TestNoAlpha OptionalSpacing Variable?)
      // "catch"
      match = ignoreCaseStringMatcher("catch", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Variable?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // Variable
               match = variable$Rule();
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
            }
         }
      }
      if (match) {
         catchBlockBegin$RuleMemoStart = startIndex;
         catchBlockBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            catchBlockBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CATCH_BLOCK_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            catchBlockBegin$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         catchBlockBegin$RuleMemoStart = startIndex;
         catchBlockBegin$RuleMemoEnd = -1;
         catchBlockBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockParameters : VariableDeclarationList
   protected boolean codeBlockParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // VariableDeclarationList
      match = variableDeclarationList$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockPattern : ('{' OptionalSpacing '|' OptionalSpacing CodeBlockParameters? '|' OptionalSpacing ExpressionList '}' OptionalSpacing)
   protected boolean codeBlockPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing '|' OptionalSpacing CodeBlockParameters? '|' OptionalSpacing ExpressionList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '|'
            match = charMatcher('|');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // CodeBlockParameters?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // CodeBlockParameters
                  match = codeBlockParameters$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // '|'
                     match = charMatcher('|');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ExpressionList
                           match = expressionList$Rule();
                           if (match) {
                              // '}'
                              match = charMatcher('}');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayLiteral : (ArrayPattern OptionalSpacing)
   protected boolean arrayLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayLiteral$RuleMemoStart == index) {
         if (arrayLiteral$RuleMemoStart <= arrayLiteral$RuleMemoEnd) {
            index = arrayLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, arrayLiteral$RuleMemoStart, arrayLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (arrayLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(arrayLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ArrayPattern OptionalSpacing)
      // ArrayPattern
      match = arrayPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         arrayLiteral$RuleMemoStart = startIndex;
         arrayLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         arrayLiteral$RuleMemoStart = startIndex;
         arrayLiteral$RuleMemoEnd = -1;
         arrayLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayPattern : ('{' OptionalSpacing ArrayItemList '}' OptionalSpacing)
   protected boolean arrayPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing ArrayItemList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ArrayItemList
            match = arrayItemList$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayItemList : (ArrayItem? (',' OptionalSpacing ArrayItem?)*)
   protected boolean arrayItemList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ArrayItem? (',' OptionalSpacing ArrayItem?)*)
      // ArrayItem?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ArrayItem
      match = arrayItem$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // (',' OptionalSpacing ArrayItem?)*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // (',' OptionalSpacing ArrayItem?)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ArrayItem?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ArrayItem
                  match = arrayItem$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ITEM_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayItem : (Expression | ArrayByRef | AliasedFieldByRef | QualifiedVariableByRef | VariableByRef)
   protected boolean arrayItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayItem$RuleMemoStart == index) {
         if (arrayItem$RuleMemoStart <= arrayItem$RuleMemoEnd) {
            index = arrayItem$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ITEM, arrayItem$RuleMemoStart, arrayItem$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (arrayItem$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(arrayItem$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression | ArrayByRef | AliasedFieldByRef | QualifiedVariableByRef | VariableByRef)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // Expression
            match = expression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '@': {
            // ArrayByRef
            match = arrayByRef$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedFieldByRef
               match = aliasedFieldByRef$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QualifiedVariableByRef
                  match = qualifiedVariableByRef$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // VariableByRef
                     match = variableByRef$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         arrayItem$RuleMemoStart = startIndex;
         arrayItem$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayItem$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ITEM, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayItem$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         arrayItem$RuleMemoStart = startIndex;
         arrayItem$RuleMemoEnd = -1;
         arrayItem$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableByRef : ('@' OptionalSpacing Variable)
   protected boolean variableByRef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variableByRef$RuleMemoStart == index) {
         if (variableByRef$RuleMemoStart <= variableByRef$RuleMemoEnd) {
            index = variableByRef$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_BY_REF, variableByRef$RuleMemoStart, variableByRef$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (variableByRef$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variableByRef$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing Variable)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Variable
            match = variable$Rule();
         }
      }
      if (match) {
         variableByRef$RuleMemoStart = startIndex;
         variableByRef$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableByRef$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_BY_REF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableByRef$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         variableByRef$RuleMemoStart = startIndex;
         variableByRef$RuleMemoEnd = -1;
         variableByRef$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedFieldByRef : ('@' OptionalSpacing AliasedField)
   protected boolean aliasedFieldByRef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedFieldByRef$RuleMemoStart == index) {
         if (aliasedFieldByRef$RuleMemoStart <= aliasedFieldByRef$RuleMemoEnd) {
            index = aliasedFieldByRef$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD_BY_REF, aliasedFieldByRef$RuleMemoStart, aliasedFieldByRef$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasedFieldByRef$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasedFieldByRef$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing AliasedField)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // AliasedField
            match = aliasedField$Rule();
         }
      }
      if (match) {
         aliasedFieldByRef$RuleMemoStart = startIndex;
         aliasedFieldByRef$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedFieldByRef$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD_BY_REF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedFieldByRef$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         aliasedFieldByRef$RuleMemoStart = startIndex;
         aliasedFieldByRef$RuleMemoEnd = -1;
         aliasedFieldByRef$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QualifiedVariableByRef : ('@' OptionalSpacing QualifiedVariable)
   protected boolean qualifiedVariableByRef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qualifiedVariableByRef$RuleMemoStart == index) {
         if (qualifiedVariableByRef$RuleMemoStart <= qualifiedVariableByRef$RuleMemoEnd) {
            index = qualifiedVariableByRef$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE_BY_REF, qualifiedVariableByRef$RuleMemoStart, qualifiedVariableByRef$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (qualifiedVariableByRef$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(qualifiedVariableByRef$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing QualifiedVariable)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // QualifiedVariable
            match = qualifiedVariable$Rule();
         }
      }
      if (match) {
         qualifiedVariableByRef$RuleMemoStart = startIndex;
         qualifiedVariableByRef$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qualifiedVariableByRef$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE_BY_REF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qualifiedVariableByRef$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         qualifiedVariableByRef$RuleMemoStart = startIndex;
         qualifiedVariableByRef$RuleMemoEnd = -1;
         qualifiedVariableByRef$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayByRef : ('@' OptionalSpacing ArrayAccess)
   protected boolean arrayByRef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayByRef$RuleMemoStart == index) {
         if (arrayByRef$RuleMemoStart <= arrayByRef$RuleMemoEnd) {
            index = arrayByRef$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_BY_REF, arrayByRef$RuleMemoStart, arrayByRef$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (arrayByRef$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(arrayByRef$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing ArrayAccess)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ArrayAccess
            match = arrayAccess$Rule();
         }
      }
      if (match) {
         arrayByRef$RuleMemoStart = startIndex;
         arrayByRef$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayByRef$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_BY_REF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayByRef$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         arrayByRef$RuleMemoStart = startIndex;
         arrayByRef$RuleMemoEnd = -1;
         arrayByRef$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItem : (Expression '=>' OptionalSpacing Expression?)
   protected boolean hashItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItem$RuleMemoStart == index) {
         if (hashItem$RuleMemoStart <= hashItem$RuleMemoEnd) {
            index = hashItem$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEM, hashItem$RuleMemoStart, hashItem$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (hashItem$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hashItem$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression '=>' OptionalSpacing Expression?)
      // Expression
      match = expression$Rule();
      if (match) {
         // '=>'
         match = stringMatcher("=>", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Expression
               match = expression$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         hashItem$RuleMemoStart = startIndex;
         hashItem$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashItem$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashItem$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         hashItem$RuleMemoStart = startIndex;
         hashItem$RuleMemoEnd = -1;
         hashItem$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItemsList : (HashItem (',' OptionalSpacing HashItem)*)
   protected boolean hashItemsList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItemsList$RuleMemoStart == index) {
         if (hashItemsList$RuleMemoStart <= hashItemsList$RuleMemoEnd) {
            index = hashItemsList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS_LIST, hashItemsList$RuleMemoStart, hashItemsList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (hashItemsList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hashItemsList$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (HashItem (',' OptionalSpacing HashItem)*)
      // HashItem
      match = hashItem$Rule();
      if (match) {
         // (',' OptionalSpacing HashItem)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing HashItem)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // HashItem
                  match = hashItem$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         hashItemsList$RuleMemoStart = startIndex;
         hashItemsList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashItemsList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashItemsList$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         hashItemsList$RuleMemoStart = startIndex;
         hashItemsList$RuleMemoEnd = -1;
         hashItemsList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItems : HashItemsList?
   protected boolean hashItems$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItems$RuleMemoStart == index) {
         if (hashItems$RuleMemoStart <= hashItems$RuleMemoEnd) {
            index = hashItems$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS, hashItems$RuleMemoStart, hashItems$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (hashItems$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hashItems$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // HashItemsList?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // HashItemsList
      match = hashItemsList$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         hashItems$RuleMemoStart = startIndex;
         hashItems$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashItems$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashItems$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         hashItems$RuleMemoStart = startIndex;
         hashItems$RuleMemoEnd = -1;
         hashItems$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashContent : (('=>' OptionalSpacing) | HashItems)
   protected boolean hashContent$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (('=>' OptionalSpacing) | HashItems)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('=>' OptionalSpacing)
      // '=>'
      match = stringMatcher("=>", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // HashItems
         match = hashItems$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_CONTENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashLiteral : (HashPattern OptionalSpacing)
   protected boolean hashLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashLiteral$RuleMemoStart == index) {
         if (hashLiteral$RuleMemoStart <= hashLiteral$RuleMemoEnd) {
            index = hashLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, hashLiteral$RuleMemoStart, hashLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (hashLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hashLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (HashPattern OptionalSpacing)
      // HashPattern
      match = hashPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         hashLiteral$RuleMemoStart = startIndex;
         hashLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         hashLiteral$RuleMemoStart = startIndex;
         hashLiteral$RuleMemoEnd = -1;
         hashLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashPattern : ('{' OptionalSpacing HashContent '}' OptionalSpacing)
   protected boolean hashPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing HashContent '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // HashContent
            match = hashContent$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NilValue : ("nil" TestNoAlpha OptionalSpacing)
   protected boolean nilValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (nilValue$RuleMemoStart == index) {
         if (nilValue$RuleMemoStart <= nilValue$RuleMemoEnd) {
            index = nilValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.NIL_VALUE, nilValue$RuleMemoStart, nilValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nilValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nilValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("nil" TestNoAlpha OptionalSpacing)
      // "nil"
      match = ignoreCaseStringMatcher("nil", 3);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         nilValue$RuleMemoStart = startIndex;
         nilValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nilValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NIL_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nilValue$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         nilValue$RuleMemoStart = startIndex;
         nilValue$RuleMemoEnd = -1;
         nilValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Literal : (StringLiteral | NumberLiteral | LogicalLiteral | ArrayLiteral | CodeBlockLiteral | HashLiteral | NilValue | DateTimeLiteral)
   protected boolean literal$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (literal$RuleMemoStart == index) {
         if (literal$RuleMemoStart <= literal$RuleMemoEnd) {
            index = literal$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LITERAL, literal$RuleMemoStart, literal$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (literal$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(literal$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (StringLiteral | NumberLiteral | LogicalLiteral | ArrayLiteral | CodeBlockLiteral | HashLiteral | NilValue | DateTimeLiteral)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case 'e':
         case 'E':
         case '\'':
         case '[': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '{': {
            // ArrayLiteral
            match = arrayLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CodeBlockLiteral
               match = codeBlockLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // HashLiteral
                  match = hashLiteral$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // DateTimeLiteral
                     match = dateTimeLiteral$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '.': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // LogicalLiteral
               match = logicalLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'n':
         case 'N': {
            // NilValue
            match = nilValue$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '0': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // DateTimeLiteral
               match = dateTimeLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'd':
         case 'D': {
            // DateTimeLiteral
            match = dateTimeLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            literal$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            literal$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = -1;
         literal$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimeLiteral : (DateTimePattern OptionalSpacing)
   protected boolean dateTimeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dateTimeLiteral$RuleMemoStart == index) {
         if (dateTimeLiteral$RuleMemoStart <= dateTimeLiteral$RuleMemoEnd) {
            index = dateTimeLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, dateTimeLiteral$RuleMemoStart, dateTimeLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (dateTimeLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dateTimeLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (DateTimePattern OptionalSpacing)
      // DateTimePattern
      match = dateTimePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dateTimeLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dateTimeLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = -1;
         dateTimeLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimePattern : (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}'))
   protected boolean dateTimePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('0d' Digit Digit Digit Digit Digit Digit Digit Digit)
      // '0d'
      match = stringMatcher("0d", 2);
      if (match) {
         // '0'-'9'
         match = charRangeMatcher('0', '9');
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (match) {
                     // '0'-'9'
                     match = charRangeMatcher('0', '9');
                     if (match) {
                        // '0'-'9'
                        match = charRangeMatcher('0', '9');
                        if (match) {
                           // '0'-'9'
                           match = charRangeMatcher('0', '9');
                           if (match) {
                              // '0'-'9'
                              match = charRangeMatcher('0', '9');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']')))
         // "d"
         match = ignoreCaseCharMatcher('d');
         if (match) {
            // (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ('"' DatePattern ("T"? TimePattern)? '"')
            // '"'
            match = charMatcher('\"');
            if (match) {
               // DatePattern
               match = datePattern$Rule();
               if (match) {
                  // ("T"? TimePattern)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ("T"? TimePattern)
                  // "T"?
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // "T"
                  match = ignoreCaseCharMatcher('T');
                  if (! match) {
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                     index = lastIndex_4;
                     match = true;
                  }
                  if (match) {
                     // TimePattern
                     match = timePattern$Rule();
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
                  if (match) {
                     // '"'
                     match = charMatcher('\"');
                  }
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // ('\'' DatePattern ("T"? TimePattern)? '\'')
               // '\''
               match = charMatcher('\'');
               if (match) {
                  // DatePattern
                  match = datePattern$Rule();
                  if (match) {
                     // ("T"? TimePattern)?
                     Node lastNode_5 = currentNode;
                     int lastIndex_5 = index;
                     // ("T"? TimePattern)
                     // "T"?
                     Node lastNode_6 = currentNode;
                     int lastIndex_6 = index;
                     // "T"
                     match = ignoreCaseCharMatcher('T');
                     if (! match) {
                        lastNode_6.setSibling(null);
                        currentNode = lastNode_6;
                        index = lastIndex_6;
                        match = true;
                     }
                     if (match) {
                        // TimePattern
                        match = timePattern$Rule();
                     }
                     if (! match) {
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        index = lastIndex_5;
                        match = true;
                     }
                     if (match) {
                        // '\''
                        match = charMatcher('\'');
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ('[' DatePattern ("T"? TimePattern)? ']')
                  // '['
                  match = charMatcher('[');
                  if (match) {
                     // DatePattern
                     match = datePattern$Rule();
                     if (match) {
                        // ("T"? TimePattern)?
                        Node lastNode_7 = currentNode;
                        int lastIndex_7 = index;
                        // ("T"? TimePattern)
                        // "T"?
                        Node lastNode_8 = currentNode;
                        int lastIndex_8 = index;
                        // "T"
                        match = ignoreCaseCharMatcher('T');
                        if (! match) {
                           lastNode_8.setSibling(null);
                           currentNode = lastNode_8;
                           index = lastIndex_8;
                           match = true;
                        }
                        if (match) {
                           // TimePattern
                           match = timePattern$Rule();
                        }
                        if (! match) {
                           lastNode_7.setSibling(null);
                           currentNode = lastNode_7;
                           index = lastIndex_7;
                           match = true;
                        }
                        if (match) {
                           // ']'
                           match = charMatcher(']');
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}')
            // '{'
            match = charMatcher('{');
            if (match) {
               // '^'
               match = charMatcher('^');
               if (match) {
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)?
                  Node lastNode_9 = currentNode;
                  int lastIndex_9 = index;
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (match) {
                     // ('-' | '/')
                     switch(buffer.getChar(index)) {
                        case '-': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        case '/': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // IntegerNumber
                        match = integerNumber$Rule();
                        if (match) {
                           // ('-' | '/')
                           switch(buffer.getChar(index)) {
                              case '-': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              case '/': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                           if (match) {
                              // IntegerNumber
                              match = integerNumber$Rule();
                              if (match) {
                                 // ','?
                                 Node lastNode_10 = currentNode;
                                 int lastIndex_10 = index;
                                 // ','
                                 match = charMatcher(',');
                                 if (! match) {
                                    lastNode_10.setSibling(null);
                                    currentNode = lastNode_10;
                                    index = lastIndex_10;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     lastNode_9.setSibling(null);
                     currentNode = lastNode_9;
                     index = lastIndex_9;
                     match = true;
                  }
                  if (match) {
                     // TimePattern?
                     Node lastNode_11 = currentNode;
                     int lastIndex_11 = index;
                     // TimePattern
                     match = timePattern$Rule();
                     if (! match) {
                        lastNode_11.setSibling(null);
                        currentNode = lastNode_11;
                        index = lastIndex_11;
                        match = true;
                     }
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '}'
                           match = charMatcher('}');
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimeLiteral : (TimePattern OptionalSpacing)
   protected boolean timeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (timeLiteral$RuleMemoStart == index) {
         if (timeLiteral$RuleMemoStart <= timeLiteral$RuleMemoEnd) {
            index = timeLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, timeLiteral$RuleMemoStart, timeLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (timeLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timeLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (TimePattern OptionalSpacing)
      // TimePattern
      match = timePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         timeLiteral$RuleMemoStart = startIndex;
         timeLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timeLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            timeLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         timeLiteral$RuleMemoStart = startIndex;
         timeLiteral$RuleMemoEnd = -1;
         timeLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IntegerNumber : Digit+
   protected boolean integerNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (integerNumber$RuleMemoStart == index) {
         if (integerNumber$RuleMemoStart <= integerNumber$RuleMemoEnd) {
            index = integerNumber$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.INTEGER_NUMBER, integerNumber$RuleMemoStart, integerNumber$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (integerNumber$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(integerNumber$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // Digit+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // '0'-'9'
            match = charRangeMatcher('0', '9');
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integerNumber$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INTEGER_NUMBER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            integerNumber$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = -1;
         integerNumber$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimePattern : (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
   protected boolean timePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (timePattern$RuleMemoStart == index) {
         if (timePattern$RuleMemoStart <= timePattern$RuleMemoEnd) {
            index = timePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, timePattern$RuleMemoStart, timePattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (timePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)
         // ':'
         match = charMatcher(':');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // (':' IntegerNumber)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (':' IntegerNumber)
               // ':'
               match = charMatcher(':');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ('.' IntegerNumber)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ('.' IntegerNumber)
                  // '.'
                  match = charMatcher('.');
                  if (match) {
                     // IntegerNumber
                     match = integerNumber$Rule();
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // ("AM" | "PM")?
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // ("AM" | "PM")
            switch(buffer.getChar(index)) {
               case 'p':
               case 'P': {
                  ++index;
                  // "M"
                  if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                     ++index;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "M"
                  if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                     ++index;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
               index = lastIndex_4;
               match = true;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            timePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = -1;
         timePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DatePattern : (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
   protected boolean datePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (datePattern$RuleMemoStart == index) {
         if (datePattern$RuleMemoStart <= datePattern$RuleMemoEnd) {
            index = datePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_PATTERN, datePattern$RuleMemoStart, datePattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (datePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(datePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // ('-' | '/' | '.')
         switch(buffer.getChar(index)) {
            case '-': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case '.': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case '/': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // ('-' | '/' | '.')
               switch(buffer.getChar(index)) {
                  case '-': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '.': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '/': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            datePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            datePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = -1;
         datePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaOrCloseOpenBracket : ((',' OptionalSpacing) | (']' OptionalSpacing '[' OptionalSpacing))
   protected boolean commaOrCloseOpenBracket$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((',' OptionalSpacing) | (']' OptionalSpacing '[' OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (',' OptionalSpacing)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (']' OptionalSpacing '[' OptionalSpacing)
         // ']'
         match = charMatcher(']');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '['
               match = charMatcher('[');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_OR_CLOSE_OPEN_BRACKET, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaIndexItem : (CommaOrCloseOpenBracket IndexItem)
   protected boolean commaIndexItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (CommaOrCloseOpenBracket IndexItem)
      // CommaOrCloseOpenBracket
      match = commaOrCloseOpenBracket$Rule();
      if (match) {
         // IndexItem
         match = indexItem$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_INDEX_ITEM, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexItemCommaList : CommaIndexItem*
   protected boolean indexItemCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaIndexItem*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // CommaIndexItem
         match = commaIndexItem$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //IndexList : (IndexItem IndexItemCommaList)
   protected boolean indexList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IndexItem IndexItemCommaList)
      // IndexItem
      match = indexItem$Rule();
      if (match) {
         // IndexItemCommaList
         match = indexItemCommaList$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexItem : Expression
   protected boolean indexItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (indexItem$RuleMemoStart == index) {
         if (indexItem$RuleMemoStart <= indexItem$RuleMemoEnd) {
            index = indexItem$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM, indexItem$RuleMemoStart, indexItem$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (indexItem$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(indexItem$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Expression
      match = expression$Rule();
      if (match) {
         indexItem$RuleMemoStart = startIndex;
         indexItem$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            indexItem$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            indexItem$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         indexItem$RuleMemoStart = startIndex;
         indexItem$RuleMemoEnd = -1;
         indexItem$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayIndex : ('[' OptionalSpacing IndexList ']' OptionalSpacing)
   protected boolean arrayIndex$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' OptionalSpacing IndexList ']' OptionalSpacing)
      // '['
      match = charMatcher('[');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IndexList
            match = indexList$Rule();
            if (match) {
               // ']'
               match = charMatcher(']');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_INDEX, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignOperator : (AssignOperatorOnly OptionalSpacing)
   protected boolean assignOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignOperator$RuleMemoStart == index) {
         if (assignOperator$RuleMemoStart <= assignOperator$RuleMemoEnd) {
            index = assignOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, assignOperator$RuleMemoStart, assignOperator$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (assignOperator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(assignOperator$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignOperatorOnly OptionalSpacing)
      // AssignOperatorOnly
      match = assignOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         assignOperator$RuleMemoStart = startIndex;
         assignOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignOperator$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         assignOperator$RuleMemoStart = startIndex;
         assignOperator$RuleMemoEnd = -1;
         assignOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignOperatorOnly : (':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | EqualOperator)
   protected boolean assignOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | EqualOperator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ':='
      match = stringMatcher(":=", 2);
      if (! match) {
         // '+='
         match = stringMatcher("+=", 2);
         if (! match) {
            // '-='
            match = stringMatcher("-=", 2);
            if (! match) {
               // '*='
               match = stringMatcher("*=", 2);
               if (! match) {
                  // '/='
                  match = stringMatcher("/=", 2);
                  if (! match) {
                     // '%='
                     match = stringMatcher("%=", 2);
                     if (! match) {
                        // '^='
                        match = stringMatcher("^=", 2);
                        if (! match) {
                           // ('=' ('>' | '=')!)
                           // '='
                           match = charMatcher('=');
                           if (match) {
                              // ('>' | '=')!
                              // ('>' | '=')
                              int startIndex_2 = index;
                              switch(buffer.getChar(index)) {
                                 case '=': {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 }
                                 case '>': {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 }
                                 default: {
                                    match = false;
                                 }
                              }
                              index = startIndex_2;
                              match = ! match;
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Expression : (AssignmentExpression | OptionalOrExpression)
   protected boolean expression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expression$RuleMemoStart == index) {
         if (expression$RuleMemoStart <= expression$RuleMemoEnd) {
            index = expression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION, expression$RuleMemoStart, expression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (expression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(expression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignmentExpression | OptionalOrExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-': {
            // OptionalOrExpression
            match = optionalOrExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // AssignmentExpression
            match = assignmentExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OptionalOrExpression
               match = optionalOrExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         expression$RuleMemoStart = startIndex;
         expression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            expression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            expression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         expression$RuleMemoStart = startIndex;
         expression$RuleMemoEnd = -1;
         expression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignmentExpression : (LeftValue AssignOperator (ValueByReference | Expression))
   protected boolean assignmentExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignmentExpression$RuleMemoStart == index) {
         if (assignmentExpression$RuleMemoStart <= assignmentExpression$RuleMemoEnd) {
            index = assignmentExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_EXPRESSION, assignmentExpression$RuleMemoStart, assignmentExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (assignmentExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(assignmentExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LeftValue AssignOperator (ValueByReference | Expression))
      // LeftValue
      match = leftValue$Rule();
      if (match) {
         // AssignOperator
         match = assignOperator$Rule();
         if (match) {
            // (ValueByReference | Expression)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '&':
               case '\'':
               case '(':
               case '+':
               case '-':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{': {
                  // Expression
                  match = expression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
                  break;
               }
               case '@': {
                  // ValueByReference
                  match = valueByReference$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         }
      }
      if (match) {
         assignmentExpression$RuleMemoStart = startIndex;
         assignmentExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignmentExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignmentExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         assignmentExpression$RuleMemoStart = startIndex;
         assignmentExpression$RuleMemoEnd = -1;
         assignmentExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalOrExpression : (OrExpression | OptionalAndExpression)
   protected boolean optionalOrExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalOrExpression$RuleMemoStart == index) {
         if (optionalOrExpression$RuleMemoStart <= optionalOrExpression$RuleMemoEnd) {
            index = optionalOrExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_OR_EXPRESSION, optionalOrExpression$RuleMemoStart, optionalOrExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalOrExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalOrExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (OrExpression | OptionalAndExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // OrExpression
            match = orExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OptionalAndExpression
               match = optionalAndExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         optionalOrExpression$RuleMemoStart = startIndex;
         optionalOrExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalOrExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_OR_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalOrExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalOrExpression$RuleMemoStart = startIndex;
         optionalOrExpression$RuleMemoEnd = -1;
         optionalOrExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OrExpression : (OptionalAndExpression ".or." OptionalSpacing OptionalOrExpression)
   protected boolean orExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (orExpression$RuleMemoStart == index) {
         if (orExpression$RuleMemoStart <= orExpression$RuleMemoEnd) {
            index = orExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OR_EXPRESSION, orExpression$RuleMemoStart, orExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (OptionalAndExpression ".or." OptionalSpacing OptionalOrExpression)
      // OptionalAndExpression
      match = optionalAndExpression$Rule();
      if (match) {
         // ".or."
         match = ignoreCaseStringMatcher(".or.", 4);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // OptionalOrExpression
               match = optionalOrExpression$Rule();
            }
         }
      }
      if (match) {
         orExpression$RuleMemoStart = startIndex;
         orExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OR_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         orExpression$RuleMemoStart = startIndex;
         orExpression$RuleMemoEnd = -1;
         orExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalAndExpression : (AndExpression | OptionalRelationalExpression)
   protected boolean optionalAndExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalAndExpression$RuleMemoStart == index) {
         if (optionalAndExpression$RuleMemoStart <= optionalAndExpression$RuleMemoEnd) {
            index = optionalAndExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_AND_EXPRESSION, optionalAndExpression$RuleMemoStart, optionalAndExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalAndExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalAndExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AndExpression | OptionalRelationalExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // AndExpression
            match = andExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OptionalRelationalExpression
               match = optionalRelationalExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         optionalAndExpression$RuleMemoStart = startIndex;
         optionalAndExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalAndExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_AND_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalAndExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalAndExpression$RuleMemoStart = startIndex;
         optionalAndExpression$RuleMemoEnd = -1;
         optionalAndExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AndExpression : (OptionalRelationalExpression ".and." OptionalSpacing OptionalAndExpression)
   protected boolean andExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (andExpression$RuleMemoStart == index) {
         if (andExpression$RuleMemoStart <= andExpression$RuleMemoEnd) {
            index = andExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.AND_EXPRESSION, andExpression$RuleMemoStart, andExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (andExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(andExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (OptionalRelationalExpression ".and." OptionalSpacing OptionalAndExpression)
      // OptionalRelationalExpression
      match = optionalRelationalExpression$Rule();
      if (match) {
         // ".and."
         match = ignoreCaseStringMatcher(".and.", 5);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // OptionalAndExpression
               match = optionalAndExpression$Rule();
            }
         }
      }
      if (match) {
         andExpression$RuleMemoStart = startIndex;
         andExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            andExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AND_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            andExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         andExpression$RuleMemoStart = startIndex;
         andExpression$RuleMemoEnd = -1;
         andExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RelationalOperator : (RelationalOperatorOnly OptionalSpacing)
   protected boolean relationalOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (RelationalOperatorOnly OptionalSpacing)
      // RelationalOperatorOnly
      match = relationalOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELATIONAL_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RelationalOperatorOnly : ('>=' | '<=' | '<>' | '#' | '!=' | '>' | '<' | '==' | '$' | "in" | EqualOperator)
   protected boolean relationalOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('>=' | '<=' | '<>' | '#' | '!=' | '>' | '<' | '==' | '$' | "in" | EqualOperator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '>='
      match = stringMatcher(">=", 2);
      if (! match) {
         // '<='
         match = stringMatcher("<=", 2);
         if (! match) {
            // '<>'
            match = stringMatcher("<>", 2);
            if (! match) {
               // '#'
               match = charMatcher('#');
               if (! match) {
                  // '!='
                  match = stringMatcher("!=", 2);
                  if (! match) {
                     // '>'
                     match = charMatcher('>');
                     if (! match) {
                        // '<'
                        match = charMatcher('<');
                        if (! match) {
                           // '=='
                           match = stringMatcher("==", 2);
                           if (! match) {
                              // '$'
                              match = charMatcher('$');
                              if (! match) {
                                 // "in"
                                 match = ignoreCaseStringMatcher("in", 2);
                                 if (! match) {
                                    // ('=' ('>' | '=')!)
                                    // '='
                                    match = charMatcher('=');
                                    if (match) {
                                       // ('>' | '=')!
                                       // ('>' | '=')
                                       int startIndex_2 = index;
                                       switch(buffer.getChar(index)) {
                                          case '=': {
                                             ++index;
                                             // <EMPTY>
                                             match = true;
                                             break;
                                          }
                                          case '>': {
                                             ++index;
                                             // <EMPTY>
                                             match = true;
                                             break;
                                          }
                                          default: {
                                             match = false;
                                          }
                                       }
                                       index = startIndex_2;
                                       match = ! match;
                                    }
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELATIONAL_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalRelationalExpression : (RelationalExpression | OptionalMathExpression)
   protected boolean optionalRelationalExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalRelationalExpression$RuleMemoStart == index) {
         if (optionalRelationalExpression$RuleMemoStart <= optionalRelationalExpression$RuleMemoEnd) {
            index = optionalRelationalExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_RELATIONAL_EXPRESSION, optionalRelationalExpression$RuleMemoStart, optionalRelationalExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalRelationalExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalRelationalExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (RelationalExpression | OptionalMathExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // RelationalExpression
            match = relationalExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OptionalMathExpression
               match = optionalMathExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         optionalRelationalExpression$RuleMemoStart = startIndex;
         optionalRelationalExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalRelationalExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_RELATIONAL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalRelationalExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalRelationalExpression$RuleMemoStart = startIndex;
         optionalRelationalExpression$RuleMemoEnd = -1;
         optionalRelationalExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RelationalExpression : (PrimaryExpression RelationalOperator OptionalRelationalExpression)
   protected boolean relationalExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (relationalExpression$RuleMemoStart == index) {
         if (relationalExpression$RuleMemoStart <= relationalExpression$RuleMemoEnd) {
            index = relationalExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELATIONAL_EXPRESSION, relationalExpression$RuleMemoStart, relationalExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (relationalExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(relationalExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrimaryExpression RelationalOperator OptionalRelationalExpression)
      // PrimaryExpression
      match = primaryExpression$Rule();
      if (match) {
         // RelationalOperator
         match = relationalOperator$Rule();
         if (match) {
            // OptionalRelationalExpression
            match = optionalRelationalExpression$Rule();
         }
      }
      if (match) {
         relationalExpression$RuleMemoStart = startIndex;
         relationalExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            relationalExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELATIONAL_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            relationalExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         relationalExpression$RuleMemoStart = startIndex;
         relationalExpression$RuleMemoEnd = -1;
         relationalExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathOperator : (MathOperatorOnly OptionalSpacing)
   protected boolean mathOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (MathOperatorOnly OptionalSpacing)
      // MathOperatorOnly
      match = mathOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathOperatorOnly : (PlusSign | MinusSign | '**' | '*' | '/' | '%' | '^^' | '^' | '|' | '&' | '<<' | '>>')
   protected boolean mathOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (PlusSign | MinusSign | '**' | '*' | '/' | '%' | '^^' | '^' | '|' | '&' | '<<' | '>>')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('+' '+'!)
      // '+'
      match = charMatcher('+');
      if (match) {
         // '+'!
         // '+'
         match = buffer.matchChar(index, '+');
         match = ! match;
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('-' '-'!)
         // '-'
         match = charMatcher('-');
         if (match) {
            // '-'!
            // '-'
            match = buffer.matchChar(index, '-');
            match = ! match;
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // '**'
            match = stringMatcher("**", 2);
            if (! match) {
               // '*'
               match = charMatcher('*');
               if (! match) {
                  // '/'
                  match = charMatcher('/');
                  if (! match) {
                     // '%'
                     match = charMatcher('%');
                     if (! match) {
                        // '^^'
                        match = stringMatcher("^^", 2);
                        if (! match) {
                           // '^'
                           match = charMatcher('^');
                           if (! match) {
                              // '|'
                              match = charMatcher('|');
                              if (! match) {
                                 // '&'
                                 match = charMatcher('&');
                                 if (! match) {
                                    // '<<'
                                    match = stringMatcher("<<", 2);
                                    if (! match) {
                                       // '>>'
                                       match = stringMatcher(">>", 2);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMathExpression : (MathExpression | PrimaryExpression)
   protected boolean optionalMathExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalMathExpression$RuleMemoStart == index) {
         if (optionalMathExpression$RuleMemoStart <= optionalMathExpression$RuleMemoEnd) {
            index = optionalMathExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_MATH_EXPRESSION, optionalMathExpression$RuleMemoStart, optionalMathExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalMathExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalMathExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MathExpression | PrimaryExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // MathExpression
            match = mathExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PrimaryExpression
               match = primaryExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         optionalMathExpression$RuleMemoStart = startIndex;
         optionalMathExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalMathExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_MATH_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalMathExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalMathExpression$RuleMemoStart = startIndex;
         optionalMathExpression$RuleMemoEnd = -1;
         optionalMathExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathExpression : (PrimaryExpression MathOperator OptionalRelationalExpression)
   protected boolean mathExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (mathExpression$RuleMemoStart == index) {
         if (mathExpression$RuleMemoStart <= mathExpression$RuleMemoEnd) {
            index = mathExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_EXPRESSION, mathExpression$RuleMemoStart, mathExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (mathExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(mathExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrimaryExpression MathOperator OptionalRelationalExpression)
      // PrimaryExpression
      match = primaryExpression$Rule();
      if (match) {
         // MathOperator
         match = mathOperator$Rule();
         if (match) {
            // OptionalRelationalExpression
            match = optionalRelationalExpression$Rule();
         }
      }
      if (match) {
         mathExpression$RuleMemoStart = startIndex;
         mathExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            mathExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            mathExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         mathExpression$RuleMemoStart = startIndex;
         mathExpression$RuleMemoEnd = -1;
         mathExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixedExpression : (PrefixOperator Expression)
   protected boolean prefixedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (prefixedExpression$RuleMemoStart == index) {
         if (prefixedExpression$RuleMemoStart <= prefixedExpression$RuleMemoEnd) {
            index = prefixedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIXED_EXPRESSION, prefixedExpression$RuleMemoStart, prefixedExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (prefixedExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(prefixedExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrefixOperator Expression)
      // PrefixOperator
      match = prefixOperator$Rule();
      if (match) {
         // Expression
         match = expression$Rule();
      }
      if (match) {
         prefixedExpression$RuleMemoStart = startIndex;
         prefixedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            prefixedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIXED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            prefixedExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         prefixedExpression$RuleMemoStart = startIndex;
         prefixedExpression$RuleMemoEnd = -1;
         prefixedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixedExpression : ((QualifiedExpression | AtomicExpression) PostfixOperator+)
   protected boolean postfixedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (postfixedExpression$RuleMemoStart == index) {
         if (postfixedExpression$RuleMemoStart <= postfixedExpression$RuleMemoEnd) {
            index = postfixedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIXED_EXPRESSION, postfixedExpression$RuleMemoStart, postfixedExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (postfixedExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(postfixedExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((QualifiedExpression | AtomicExpression) PostfixOperator+)
      // (QualifiedExpression | AtomicExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AtomicExpression
               match = atomicExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // PostfixOperator+
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // PostfixOperator
         match = postfixOperator$Rule();
         if (match) {
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // PostfixOperator
               match = postfixOperator$Rule();
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         } else {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
         }
      }
      if (match) {
         postfixedExpression$RuleMemoStart = startIndex;
         postfixedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            postfixedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIXED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            postfixedExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         postfixedExpression$RuleMemoStart = startIndex;
         postfixedExpression$RuleMemoEnd = -1;
         postfixedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrimaryExpression : (PrefixedExpression | PostfixedExpression | QualifiedExpression | AtomicExpression)
   protected boolean primaryExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (primaryExpression$RuleMemoStart == index) {
         if (primaryExpression$RuleMemoStart <= primaryExpression$RuleMemoEnd) {
            index = primaryExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIMARY_EXPRESSION, primaryExpression$RuleMemoStart, primaryExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (primaryExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(primaryExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrefixedExpression | PostfixedExpression | QualifiedExpression | AtomicExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-': {
            // PrefixedExpression
            match = prefixedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '.': {
            // PrefixedExpression
            match = prefixedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QualifiedExpression
                  match = qualifiedExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AtomicExpression
                     match = atomicExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{': {
            // PostfixedExpression
            match = postfixedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // QualifiedExpression
               match = qualifiedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AtomicExpression
                  match = atomicExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         primaryExpression$RuleMemoStart = startIndex;
         primaryExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            primaryExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIMARY_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            primaryExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         primaryExpression$RuleMemoStart = startIndex;
         primaryExpression$RuleMemoEnd = -1;
         primaryExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixOperator : (PrefixOperatorOnly OptionalSpacing)
   protected boolean prefixOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (PrefixOperatorOnly OptionalSpacing)
      // PrefixOperatorOnly
      match = prefixOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIX_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixOperatorOnly : ('++' | '--' | NotOperator | PlusSign | MinusSign)
   protected boolean prefixOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('++' | '--' | NotOperator | PlusSign | MinusSign)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '++'
      match = stringMatcher("++", 2);
      if (! match) {
         // '--'
         match = stringMatcher("--", 2);
         if (! match) {
            // (".not." | ('!' '='!))
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ".not."
            match = ignoreCaseStringMatcher(".not.", 5);
            if (! match) {
               // ('!' '='!)
               // '!'
               match = charMatcher('!');
               if (match) {
                  // '='!
                  // '='
                  match = buffer.matchChar(index, '=');
                  match = ! match;
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('+' '+'!)
               // '+'
               match = charMatcher('+');
               if (match) {
                  // '+'!
                  // '+'
                  match = buffer.matchChar(index, '+');
                  match = ! match;
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('-' '-'!)
                  // '-'
                  match = charMatcher('-');
                  if (match) {
                     // '-'!
                     // '-'
                     match = buffer.matchChar(index, '-');
                     match = ! match;
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIX_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixOperator : (PostfixOperatorOnly OptionalSpacing)
   protected boolean postfixOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (PostfixOperatorOnly OptionalSpacing)
      // PostfixOperatorOnly
      match = postfixOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIX_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixOperatorOnly : ('++' | '--')
   protected boolean postfixOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('++' | '--')
      switch(buffer.getChar(index)) {
         case '+': {
            ++index;
            // '+'
            if (match = buffer.matchChar(index, '+')) {
               ++index;
            }
            break;
         }
         case '-': {
            ++index;
            // '-'
            if (match = buffer.matchChar(index, '-')) {
               ++index;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIX_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AtomicExpression : (SelfExpression | ArrayAccess | AliasedExpression | AliasedField | AliasedMacro | Literal | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | ParenthesesExpressionList | KeyboardCall | ClearTypehead | Variable)
   protected boolean atomicExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (atomicExpression$RuleMemoStart == index) {
         if (atomicExpression$RuleMemoStart <= atomicExpression$RuleMemoEnd) {
            index = atomicExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATOMIC_EXPRESSION, atomicExpression$RuleMemoStart, atomicExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (atomicExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(atomicExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SelfExpression | ArrayAccess | AliasedExpression | AliasedField | AliasedMacro | Literal | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | ParenthesesExpressionList | KeyboardCall | ClearTypehead | Variable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'K':
         case 'k': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // KeyboardCall
                                 match = keyboardCall$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Variable
                                    match = variable$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '\'':
         case '[':
         case '{': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '.': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Literal
                        match = literal$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'B':
         case 'F':
         case 'G':
         case 'H':
         case 'J':
         case 'L':
         case 'M':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'f':
         case 'g':
         case 'h':
         case 'j':
         case 'l':
         case 'm':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Variable
                                 match = variable$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // ClearTypehead
                                 match = clearTypehead$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Variable
                                    match = variable$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'D':
         case 'd':
         case 'E':
         case 'e':
         case 'N':
         case 'n': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Literal
                        match = literal$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AnySimpleFunctionCall
                              match = anySimpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Variable
                                    match = variable$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '&': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Macro
                           match = macro$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ParenthesesExpressionList
                        match = parenthesesExpressionList$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'I':
         case 'i': {
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IfInLine
                        match = ifInLine$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // AnySimpleFunctionCall
                              match = anySimpleFunctionCall$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // Variable
                                    match = variable$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case ':': {
            // SelfExpression
            match = selfExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         atomicExpression$RuleMemoStart = startIndex;
         atomicExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            atomicExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATOMIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            atomicExpression$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         atomicExpression$RuleMemoStart = startIndex;
         atomicExpression$RuleMemoEnd = -1;
         atomicExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeyboardCall : ("keyboard" TestNoAlpha OptionalSpacing Expression)
   protected boolean keyboardCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keyboardCall$RuleMemoStart == index) {
         if (keyboardCall$RuleMemoStart <= keyboardCall$RuleMemoEnd) {
            index = keyboardCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CALL, keyboardCall$RuleMemoStart, keyboardCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (keyboardCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(keyboardCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("keyboard" TestNoAlpha OptionalSpacing Expression)
      // "keyboard"
      match = ignoreCaseStringMatcher("keyboard", 8);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         keyboardCall$RuleMemoStart = startIndex;
         keyboardCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keyboardCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keyboardCall$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         keyboardCall$RuleMemoStart = startIndex;
         keyboardCall$RuleMemoEnd = -1;
         keyboardCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClearTypehead : ("clear" TestNoAlpha OptionalSpacing "typeahead" TestNoAlpha OptionalSpacing)
   protected boolean clearTypehead$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clearTypehead$RuleMemoStart == index) {
         if (clearTypehead$RuleMemoStart <= clearTypehead$RuleMemoEnd) {
            index = clearTypehead$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_TYPEHEAD, clearTypehead$RuleMemoStart, clearTypehead$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clearTypehead$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clearTypehead$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("clear" TestNoAlpha OptionalSpacing "typeahead" TestNoAlpha OptionalSpacing)
      // "clear"
      match = ignoreCaseStringMatcher("clear", 5);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "typeahead"
               match = ignoreCaseStringMatcher("typeahead", 9);
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         clearTypehead$RuleMemoStart = startIndex;
         clearTypehead$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clearTypehead$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_TYPEHEAD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clearTypehead$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         clearTypehead$RuleMemoStart = startIndex;
         clearTypehead$RuleMemoEnd = -1;
         clearTypehead$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayAccess : ((ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable) ArrayIndex)
   protected boolean arrayAccess$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayAccess$RuleMemoStart == index) {
         if (arrayAccess$RuleMemoStart <= arrayAccess$RuleMemoEnd) {
            index = arrayAccess$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ACCESS, arrayAccess$RuleMemoStart, arrayAccess$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (arrayAccess$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(arrayAccess$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable) ArrayIndex)
      // (ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '[': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '{': {
            // ArrayLiteral
            match = arrayLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // HashLiteral
               match = hashLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // MacroFunctionCall
                     match = macroFunctionCall$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Macro
                        match = macro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'F':
         case 'G':
         case 'H':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'f':
         case 'g':
         case 'h':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // MacroFunctionCall
                     match = macroFunctionCall$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // AnySimpleFunctionCall
                        match = anySimpleFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Macro
                           match = macro$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Variable
                              match = variable$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'E':
         case 'e': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Variable
                                 match = variable$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'I':
         case 'i': {
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // IfInLine
                     match = ifInLine$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Variable
                                 match = variable$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // ArrayIndex
         match = arrayIndex$Rule();
      }
      if (match) {
         arrayAccess$RuleMemoStart = startIndex;
         arrayAccess$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayAccess$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ACCESS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayAccess$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         arrayAccess$RuleMemoStart = startIndex;
         arrayAccess$RuleMemoEnd = -1;
         arrayAccess$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LeftValue : (SelfExpression | QualifiedExpression | ArrayAccess | AliasedField | AliasedMacro | Macro | Variable | ParenthesesLeftValue)
   protected boolean leftValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (leftValue$RuleMemoStart == index) {
         if (leftValue$RuleMemoStart <= leftValue$RuleMemoEnd) {
            index = leftValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LEFT_VALUE, leftValue$RuleMemoStart, leftValue$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (leftValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(leftValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SelfExpression | QualifiedExpression | ArrayAccess | AliasedField | AliasedMacro | Macro | Variable | ParenthesesLeftValue)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '[':
         case '{': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '.': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Macro
                        match = macro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Macro
                        match = macro$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Variable
                           match = variable$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ParenthesesLeftValue
                        match = parenthesesLeftValue$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case ':': {
            // SelfExpression
            match = selfExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // QualifiedExpression
               match = qualifiedExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            leftValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LEFT_VALUE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            leftValue$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = -1;
         leftValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesLeftValue : ('(' OptionalSpacing LeftValue ')' OptionalSpacing)
   protected boolean parenthesesLeftValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesLeftValue$RuleMemoStart == index) {
         if (parenthesesLeftValue$RuleMemoStart <= parenthesesLeftValue$RuleMemoEnd) {
            index = parenthesesLeftValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_LEFT_VALUE, parenthesesLeftValue$RuleMemoStart, parenthesesLeftValue$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesLeftValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesLeftValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing LeftValue ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // LeftValue
            match = leftValue$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesLeftValue$RuleMemoStart = startIndex;
         parenthesesLeftValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesLeftValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_LEFT_VALUE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesLeftValue$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parenthesesLeftValue$RuleMemoStart = startIndex;
         parenthesesLeftValue$RuleMemoEnd = -1;
         parenthesesLeftValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Dump : ('#' Whitespace? "pragma" Whitespace "begindump" DumpBody EndDump)
   protected boolean dump$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dump$RuleMemoStart == index) {
         if (dump$RuleMemoStart <= dump$RuleMemoEnd) {
            index = dump$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DUMP, dump$RuleMemoStart, dump$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dump$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dump$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' Whitespace? "pragma" Whitespace "begindump" DumpBody EndDump)
      // '#'
      match = charMatcher('#');
      if (match) {
         // Whitespace?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Whitespace
         match = whitespace$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "pragma"
            match = ignoreCaseStringMatcher("pragma", 6);
            if (match) {
               // Whitespace
               match = whitespace$Rule();
               if (match) {
                  // "begindump"
                  match = ignoreCaseStringMatcher("begindump", 9);
                  if (match) {
                     // DumpBody
                     match = dumpBody$Rule();
                     if (match) {
                        // EndDump
                        match = endDump$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         dump$RuleMemoStart = startIndex;
         dump$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dump$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DUMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dump$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dump$RuleMemoStart = startIndex;
         dump$RuleMemoEnd = -1;
         dump$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DumpBody : (EndDump! .)*
   protected boolean dumpBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (EndDump! .)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (EndDump! .)
         // EndDump!
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         boolean lastAtomic_2 = currentRuleIsAtomic;
         // EndDump
         match = endDump$Rule();
         currentRuleIsAtomic = lastAtomic_2;
         index = lastIndex_2;
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher();
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      currentRuleIsAtomic = lastRuleIsAtomic;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.DUMP_BODY, startIndex, index, true, false);
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //EndDump : ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing "enddump" TestNoAlpha OptionalSpacing)
   protected boolean endDump$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endDump$RuleMemoStart == index) {
         if (endDump$RuleMemoStart <= endDump$RuleMemoEnd) {
            index = endDump$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_DUMP, endDump$RuleMemoStart, endDump$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endDump$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endDump$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing "enddump" TestNoAlpha OptionalSpacing)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "pragma"
            match = ignoreCaseStringMatcher("pragma", 6);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "enddump"
                     match = ignoreCaseStringMatcher("enddump", 7);
                     if (match) {
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // 'a'-'z'
                        match = buffer.matchCharRange(index, 'a', 'z');
                        if (! match) {
                           // 'A'-'Z'
                           match = buffer.matchCharRange(index, 'A', 'Z');
                           if (! match) {
                              // '0'-'9'
                              match = buffer.matchCharRange(index, '0', '9');
                              if (! match) {
                                 // '_'
                                 match = buffer.matchChar(index, '_');
                              }
                           }
                        }
                        match = ! match;
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         endDump$RuleMemoStart = startIndex;
         endDump$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endDump$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_DUMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endDump$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endDump$RuleMemoStart = startIndex;
         endDump$RuleMemoEnd = -1;
         endDump$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParameterDeclaration : (Identifier AsType)
   protected boolean parameterDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parameterDeclaration$RuleMemoStart == index) {
         if (parameterDeclaration$RuleMemoStart <= parameterDeclaration$RuleMemoEnd) {
            index = parameterDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_DECLARATION, parameterDeclaration$RuleMemoStart, parameterDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parameterDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parameterDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier AsType)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // AsType
         match = asType$Rule();
      }
      if (match) {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parameterDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parameterDeclaration$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = -1;
         parameterDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersDeclaration : (ParametersDeclarationList | ('...' OptionalSpacing) | ')'&)
   protected boolean parametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ParametersDeclarationList | ('...' OptionalSpacing) | ')'&)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ParametersDeclarationList
      match = parametersDeclarationList$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('...' OptionalSpacing)
         // '...'
         match = stringMatcher("...", 3);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ')'&
            // ')'
            match = buffer.matchChar(index, ')');
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionModifiers : (("static" | "stati" | "stat" | "init" | "exit") TestNoAlpha OptionalSpacing)
   protected boolean functionModifiers$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("static" | "stati" | "stat" | "init" | "exit") TestNoAlpha OptionalSpacing)
      // ("static" | "stati" | "stat" | "init" | "exit")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'i':
         case 'I': {
            ++index;
            // "nit"
            if (match = ignoreCaseStringTest("nit", 3)) {
               index += 3;
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // ("tatic" | "tati" | "tat")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("atic" | "ati" | "at")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("tic" | "ti" | "t")
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("ic" | "i" | <EMPTY>)
                     match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                     if (match) {
                        ++index;
                        // ("c" | <EMPTY>)
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // "xit"
            if (match = ignoreCaseStringTest("xit", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIERS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionModifier : FunctionModifiers?
   protected boolean functionModifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionModifier$RuleMemoStart == index) {
         if (functionModifier$RuleMemoStart <= functionModifier$RuleMemoEnd) {
            index = functionModifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIER, functionModifier$RuleMemoStart, functionModifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionModifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionModifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // FunctionModifiers?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // FunctionModifiers
      match = functionModifiers$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         functionModifier$RuleMemoStart = startIndex;
         functionModifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionModifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionModifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         functionModifier$RuleMemoStart = startIndex;
         functionModifier$RuleMemoEnd = -1;
         functionModifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StringLiteral : (StringPattern OptionalSpacing)
   protected boolean stringLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (stringLiteral$RuleMemoStart == index) {
         if (stringLiteral$RuleMemoStart <= stringLiteral$RuleMemoEnd) {
            index = stringLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, stringLiteral$RuleMemoStart, stringLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (stringLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stringLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (StringPattern OptionalSpacing)
      // StringPattern
      match = stringPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stringLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stringLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = -1;
         stringLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StringPattern : (('"' (('\n' | '"')! .)* '"') | ('\'' (('\n' | '\'')! .)* '\'') | ('[' (('\n' | ']')! .)* ']') | ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"'))
   protected boolean stringPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('"' (('\n' | '"')! .)* '"') | ('\'' (('\n' | '\'')! .)* '\'') | ('[' (('\n' | ']')! .)* ']') | ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('"' (('\n' | '"')! .)* '"')
      // '"'
      match = charMatcher('\"');
      if (match) {
         // (('\n' | '"')! .)*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // (('\n' | '"')! .)
            // ('\n' | '"')!
            // ('\n' | '"')
            int startIndex_3 = index;
            switch(buffer.getChar(index)) {
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_3;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         // '"'
         match = charMatcher('\"');
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('\'' (('\n' | '\'')! .)* '\'')
         // '\''
         match = charMatcher('\'');
         if (match) {
            // (('\n' | '\'')! .)*
            Node lastNode_4;
            int lastIndex_4;
            do {
               lastNode_4 = currentNode;
               lastIndex_4 = index;
               // (('\n' | '\'')! .)
               // ('\n' | '\'')!
               // ('\n' | '\'')
               int startIndex_5 = index;
               switch(buffer.getChar(index)) {
                  case '\'': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '\n': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               index = startIndex_5;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
               }
            } while(match);
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            index = lastIndex_4;
            // '\''
            match = charMatcher('\'');
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('[' (('\n' | ']')! .)* ']')
            // '['
            match = charMatcher('[');
            if (match) {
               // (('\n' | ']')! .)*
               Node lastNode_6;
               int lastIndex_6;
               do {
                  lastNode_6 = currentNode;
                  lastIndex_6 = index;
                  // (('\n' | ']')! .)
                  // ('\n' | ']')!
                  // ('\n' | ']')
                  int startIndex_7 = index;
                  switch(buffer.getChar(index)) {
                     case ']': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\n': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  index = startIndex_7;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
               } while(match);
               lastNode_6.setSibling(null);
               currentNode = lastNode_6;
               index = lastIndex_6;
               // ']'
               match = charMatcher(']');
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"')
               // "e"
               match = ignoreCaseCharMatcher('e');
               if (match) {
                  // '"'
                  match = charMatcher('\"');
                  if (match) {
                     // (('\' '\n'! .) | (('\n' | '"')! .))*
                     Node lastNode_8;
                     int lastIndex_8;
                     do {
                        lastNode_8 = currentNode;
                        lastIndex_8 = index;
                        // (('\' '\n'! .) | (('\n' | '"')! .))
                        Node lastNode_9 = currentNode;
                        int lastIndex_9 = index;
                        // ('\' '\n'! .)
                        // '\'
                        match = charMatcher('\\');
                        if (match) {
                           // '\n'!
                           // '\n'
                           match = buffer.matchChar(index, '\n');
                           match = ! match;
                           if (match) {
                              // .
                              match = anyCharMatcher();
                           }
                        }
                        if (! match) {
                           index = lastIndex_9;
                           lastNode_9.setSibling(null);
                           currentNode = lastNode_9;
                           // (('\n' | '"')! .)
                           // ('\n' | '"')!
                           // ('\n' | '"')
                           int startIndex_10 = index;
                           switch(buffer.getChar(index)) {
                              case '\"': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              case '\n': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                           index = startIndex_10;
                           match = ! match;
                           if (match) {
                              // .
                              match = anyCharMatcher();
                           }
                           if (! match) {
                              index = lastIndex_9;
                              lastNode_9.setSibling(null);
                              currentNode = lastNode_9;
                           }
                        }
                     } while(match);
                     lastNode_8.setSibling(null);
                     currentNode = lastNode_8;
                     index = lastIndex_8;
                     // '"'
                     match = charMatcher('\"');
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberLiteral : (NumberPattern EndsNumber)
   protected boolean numberLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (numberLiteral$RuleMemoStart == index) {
         if (numberLiteral$RuleMemoStart <= numberLiteral$RuleMemoEnd) {
            index = numberLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, numberLiteral$RuleMemoStart, numberLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (numberLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numberLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (NumberPattern EndsNumber)
      // NumberPattern
      match = numberPattern$Rule();
      if (match) {
         // (('?' | '&' | '_' | '~')* OptionalSpacing)
         // ('?' | '&' | '_' | '~')*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('?' | '&' | '_' | '~')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '~': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '?': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '_': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '&': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               index = startIndex_2;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
               currentNode = currentNode.getSibling();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numberLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numberLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = -1;
         numberLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberPattern : ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
   protected boolean numberPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (IntegerNumber '.' IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (IntegerNumber '.' Letter!)
         // IntegerNumber
         match = integerNumber$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // Letter!
               // ('a'-'z' | 'A'-'Z')
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
               }
               match = ! match;
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // IntegerNumber
            match = integerNumber$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('.' IntegerNumber)
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArraySubType : ("of" TestNoAlpha OptionalSpacing DataType)
   protected boolean arraySubType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("of" TestNoAlpha OptionalSpacing DataType)
      // "of"
      match = ignoreCaseStringMatcher("of", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DataType
               match = dataType$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_SUB_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DataType : ((("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing) | (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing) | ("date" TestNoAlpha OptionalSpacing) | (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing) | StringLiteral | (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing) | (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing) | ("hash" TestNoAlpha OptionalSpacing) | Array | Class)
   protected boolean dataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dataType$RuleMemoStart == index) {
         if (dataType$RuleMemoStart <= dataType$RuleMemoEnd) {
            index = dataType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATA_TYPE, dataType$RuleMemoStart, dataType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dataType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dataType$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing) | (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing) | ("date" TestNoAlpha OptionalSpacing) | (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing) | StringLiteral | (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing) | (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing) | ("hash" TestNoAlpha OptionalSpacing) | Array | Class)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing)
      // ("character" | "characte" | "charact" | "charac" | "chara" | "char")
      int startIndex_2 = index;
      match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
      if (match) {
         ++index;
         // ("haracter" | "haracte" | "haract" | "harac" | "hara" | "har")
         match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
         if (match) {
            ++index;
            // ("aracter" | "aracte" | "aract" | "arac" | "ara" | "ar")
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("racter" | "racte" | "ract" | "rac" | "ra" | "r")
               match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
               if (match) {
                  ++index;
                  // ("acter" | "acte" | "act" | "ac" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("cter" | "cte" | "ct" | "c" | <EMPTY>)
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("ter" | "te" | "t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("er" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("r" | <EMPTY>)
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing)
         // ("numeric" | "numeri" | "numer" | "nume")
         int startIndex_4 = index;
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("umeric" | "umeri" | "umer" | "ume")
            match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
            if (match) {
               ++index;
               // ("meric" | "meri" | "mer" | "me")
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("eric" | "eri" | "er" | "e")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ric" | "ri" | "r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
         }
         if (! match) {
            index = startIndex_4;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // 'a'-'z'
            match = buffer.matchCharRange(index, 'a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = buffer.matchCharRange(index, 'A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = buffer.matchCharRange(index, '0', '9');
                  if (! match) {
                     // '_'
                     match = buffer.matchChar(index, '_');
                  }
               }
            }
            match = ! match;
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("date" TestNoAlpha OptionalSpacing)
            // "date"
            match = ignoreCaseStringMatcher("date", 4);
            if (match) {
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
               // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
               Node lastNode_6 = currentNode;
               int lastIndex_6 = index;
               // 'a'-'z'
               match = buffer.matchCharRange(index, 'a', 'z');
               if (! match) {
                  // 'A'-'Z'
                  match = buffer.matchCharRange(index, 'A', 'Z');
                  if (! match) {
                     // '0'-'9'
                     match = buffer.matchCharRange(index, '0', '9');
                     if (! match) {
                        // '_'
                        match = buffer.matchChar(index, '_');
                     }
                  }
               }
               match = ! match;
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing)
               // ("logical" | "logica" | "logic" | "logi")
               int startIndex_7 = index;
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("ogical" | "ogica" | "ogic" | "ogi")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("gical" | "gica" | "gic" | "gi")
                     match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
                     if (match) {
                        ++index;
                        // ("ical" | "ica" | "ic" | "i")
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("cal" | "ca" | "c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // ("al" | "a" | <EMPTY>)
                              match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                              if (match) {
                                 ++index;
                                 // ("l" | <EMPTY>)
                                 match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = startIndex_7;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_7, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                  // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                  Node lastNode_8 = currentNode;
                  int lastIndex_8 = index;
                  // 'a'-'z'
                  match = buffer.matchCharRange(index, 'a', 'z');
                  if (! match) {
                     // 'A'-'Z'
                     match = buffer.matchCharRange(index, 'A', 'Z');
                     if (! match) {
                        // '0'-'9'
                        match = buffer.matchCharRange(index, '0', '9');
                        if (! match) {
                           // '_'
                           match = buffer.matchChar(index, '_');
                        }
                     }
                  }
                  match = ! match;
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StringLiteral
                  match = stringLiteral$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing)
                     // ("object" | "objec" | "obje")
                     int startIndex_9 = index;
                     match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                     if (match) {
                        ++index;
                        // ("bject" | "bjec" | "bje")
                        match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                        if (match) {
                           ++index;
                           // ("ject" | "jec" | "je")
                           match = buffer.matchChar(index, 'j') || buffer.matchChar(index, 'J');
                           if (match) {
                              ++index;
                              // ("ect" | "ec" | "e")
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // ("ct" | "c" | <EMPTY>)
                                 match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                 if (match) {
                                    ++index;
                                    // ("t" | <EMPTY>)
                                    match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                     if (! match) {
                        index = startIndex_9;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_9, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                        // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                        Node lastNode_10 = currentNode;
                        int lastIndex_10 = index;
                        // 'a'-'z'
                        match = buffer.matchCharRange(index, 'a', 'z');
                        if (! match) {
                           // 'A'-'Z'
                           match = buffer.matchCharRange(index, 'A', 'Z');
                           if (! match) {
                              // '0'-'9'
                              match = buffer.matchCharRange(index, '0', '9');
                              if (! match) {
                                 // '_'
                                 match = buffer.matchChar(index, '_');
                              }
                           }
                        }
                        match = ! match;
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing)
                        // ("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code")
                        int startIndex_11 = index;
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // ("odeblock" | "odebloc" | "odeblo" | "odebl" | "odeb" | "ode")
                           match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                           if (match) {
                              ++index;
                              // ("deblock" | "debloc" | "deblo" | "debl" | "deb" | "de")
                              match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                              if (match) {
                                 ++index;
                                 // ("eblock" | "ebloc" | "eblo" | "ebl" | "eb" | "e")
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // ("block" | "bloc" | "blo" | "bl" | "b" | <EMPTY>)
                                    match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                                    if (match) {
                                       ++index;
                                       // ("lock" | "loc" | "lo" | "l" | <EMPTY>)
                                       match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                                       if (match) {
                                          ++index;
                                          // ("ock" | "oc" | "o" | <EMPTY>)
                                          match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                                          if (match) {
                                             ++index;
                                             // ("ck" | "c" | <EMPTY>)
                                             match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                             if (match) {
                                                ++index;
                                                // ("k" | <EMPTY>)
                                                match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
                                                if (match) {
                                                   ++index;
                                                   // <EMPTY>
                                                   match = true;
                                                } else {
                                                   match = true;
                                                }
                                             } else {
                                                match = true;
                                             }
                                          } else {
                                             match = true;
                                          }
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 }
                              }
                           }
                        }
                        if (! match) {
                           index = startIndex_11;
                        } else if(! currentRuleIsAtomic) {
                           currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_11, index, false, false));
                           currentNode = currentNode.getSibling();
                        }
                        if (match) {
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                           // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                           Node lastNode_12 = currentNode;
                           int lastIndex_12 = index;
                           // 'a'-'z'
                           match = buffer.matchCharRange(index, 'a', 'z');
                           if (! match) {
                              // 'A'-'Z'
                              match = buffer.matchCharRange(index, 'A', 'Z');
                              if (! match) {
                                 // '0'-'9'
                                 match = buffer.matchCharRange(index, '0', '9');
                                 if (! match) {
                                    // '_'
                                    match = buffer.matchChar(index, '_');
                                 }
                              }
                           }
                           match = ! match;
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("hash" TestNoAlpha OptionalSpacing)
                           // "hash"
                           match = ignoreCaseStringMatcher("hash", 4);
                           if (match) {
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
                              // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
                              Node lastNode_13 = currentNode;
                              int lastIndex_13 = index;
                              // 'a'-'z'
                              match = buffer.matchCharRange(index, 'a', 'z');
                              if (! match) {
                                 // 'A'-'Z'
                                 match = buffer.matchCharRange(index, 'A', 'Z');
                                 if (! match) {
                                    // '0'-'9'
                                    match = buffer.matchCharRange(index, '0', '9');
                                    if (! match) {
                                       // '_'
                                       match = buffer.matchChar(index, '_');
                                    }
                                 }
                              }
                              match = ! match;
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // Array
                              match = array$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // Class
                                 match = class$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         dataType$RuleMemoStart = startIndex;
         dataType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dataType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATA_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dataType$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dataType$RuleMemoStart = startIndex;
         dataType$RuleMemoEnd = -1;
         dataType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayType : ArraySubType?
   protected boolean arrayType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ArraySubType?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ArraySubType
      match = arraySubType$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Array : (("array" | "arra") TestNoAlpha OptionalSpacing ArrayType)
   protected boolean array$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (array$RuleMemoStart == index) {
         if (array$RuleMemoStart <= array$RuleMemoEnd) {
            index = array$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY, array$RuleMemoStart, array$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (array$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(array$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("array" | "arra") TestNoAlpha OptionalSpacing ArrayType)
      // ("array" | "arra")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
      if (match) {
         ++index;
         // ("rray" | "rra")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("ray" | "ra")
            match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
            if (match) {
               ++index;
               // ("ay" | "a")
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("y" | <EMPTY>)
                  match = buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ArrayType
               match = arrayType$Rule();
            }
         }
      }
      if (match) {
         array$RuleMemoStart = startIndex;
         array$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            array$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            array$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         array$RuleMemoStart = startIndex;
         array$RuleMemoEnd = -1;
         array$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Class : (("class" | "clas") TestNoAlpha OptionalSpacing Identifier)
   protected boolean class$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (class$RuleMemoStart == index) {
         if (class$RuleMemoStart <= class$RuleMemoEnd) {
            index = class$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS, class$RuleMemoStart, class$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (class$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(class$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("class" | "clas") TestNoAlpha OptionalSpacing Identifier)
      // ("class" | "clas")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
      if (match) {
         ++index;
         // ("lass" | "las")
         match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
         if (match) {
            ++index;
            // ("ass" | "as")
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("ss" | "s")
               match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
               if (match) {
                  ++index;
                  // ("s" | <EMPTY>)
                  match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Identifier
               match = identifier$Rule();
            }
         }
      }
      if (match) {
         class$RuleMemoStart = startIndex;
         class$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            class$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            class$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         class$RuleMemoStart = startIndex;
         class$RuleMemoEnd = -1;
         class$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AsDataType : ("as" TestNoAlpha OptionalSpacing DataType)
   protected boolean asDataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing DataType)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DataType
               match = dataType$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_DATA_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyIdentifier : (IdentifierPattern OptionalSpacing)
   protected boolean anyIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyIdentifier$RuleMemoStart == index) {
         if (anyIdentifier$RuleMemoStart <= anyIdentifier$RuleMemoEnd) {
            index = anyIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, anyIdentifier$RuleMemoStart, anyIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (anyIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IdentifierPattern OptionalSpacing)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         anyIdentifier$RuleMemoStart = startIndex;
         anyIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyIdentifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anyIdentifier$RuleMemoStart = startIndex;
         anyIdentifier$RuleMemoEnd = -1;
         anyIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Identifier : (Keyword! IdentifierPattern OptionalSpacing)
   protected boolean identifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (identifier$RuleMemoStart == index) {
         if (identifier$RuleMemoStart <= identifier$RuleMemoEnd) {
            index = identifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, identifier$RuleMemoStart, identifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (identifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Keyword! IdentifierPattern OptionalSpacing)
      // Keyword!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // (("announce" | "announc" | "announ" | "annou" | "anno" | "begin" | "begi" | "break" | "brea" | "case" | "catch" | "catc" | "default" | "defaul" | "defau" | "defa" | "each" | "else" | "elseif" | "end" | "endcase" | "endcas" | "endca" | "endc" | "enddo" | "endd" | "endif" | "endi" | "endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends" | "exit" | "extern" | "exter" | "exte" | "field" | "fiel" | "for" | "function" | "functio" | "functi" | "funct" | "func" | "in" | "if" | "iif" | "init" | "local" | "loca" | "loop" | "memvar" | "memva" | "memv" | "next" | "nil" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "return" | "retur" | "retu" | "self" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "static" | "stati" | "stat" | "switch" | "switc" | "swit" | "try" | "using" | "usin" | "while" | "whil") TestNoAlpha)
      // ("announce" | "announc" | "announ" | "annou" | "anno" | "begin" | "begi" | "break" | "brea" | "case" | "catch" | "catc" | "default" | "defaul" | "defau" | "defa" | "each" | "else" | "elseif" | "end" | "endcase" | "endcas" | "endca" | "endc" | "enddo" | "endd" | "endif" | "endi" | "endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends" | "exit" | "extern" | "exter" | "exte" | "field" | "fiel" | "for" | "function" | "functio" | "functi" | "funct" | "func" | "in" | "if" | "iif" | "init" | "local" | "loca" | "loop" | "memvar" | "memva" | "memv" | "next" | "nil" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "return" | "retur" | "retu" | "self" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "static" | "stati" | "stat" | "switch" | "switc" | "swit" | "try" | "using" | "usin" | "while" | "whil")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // ("unction" | "unctio" | "uncti" | "ield" | "unct" | "iel" | "unc" | "or")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "r"
                  if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                     ++index;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // ("eld" | "el")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ld" | "l")
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("d" | <EMPTY>)
                        match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("nction" | "nctio" | "ncti" | "nct" | "nc")
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // ("ction" | "ctio" | "cti" | "ct" | "c")
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("ion" | "io" | "i" | <EMPTY>)
                           match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                           if (match) {
                              ++index;
                              // ("on" | "o" | <EMPTY>)
                              match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                              if (match) {
                                 ++index;
                                 // ("n" | <EMPTY>)
                                 match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'w':
         case 'W': {
            ++index;
            // ("hile" | "hil")
            match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
            if (match) {
               ++index;
               // ("ile" | "il")
               match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
               if (match) {
                  ++index;
                  // ("le" | "l")
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'i':
         case 'I': {
            ++index;
            // ("nit" | "if" | "n" | "f")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("it" | <EMPTY>)
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // "t"
                     if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                        ++index;
                     }
                  } else {
                     match = true;
                  }
                  break;
               }
               case 'f':
               case 'F': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "f"
                  if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                     ++index;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'l':
         case 'L': {
            ++index;
            // ("ocal" | "oca" | "oop")
            match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
            if (match) {
               ++index;
               // ("cal" | "ca" | "op")
               switch(buffer.getChar(index)) {
                  case 'o':
                  case 'O': {
                     ++index;
                     // "p"
                     if (match = buffer.matchIgnoreCaseChar(index, 'p')) {
                        ++index;
                     }
                     break;
                  }
                  case 'c':
                  case 'C': {
                     ++index;
                     // ("al" | "a")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("l" | <EMPTY>)
                        match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // ("emvar" | "emva" | "emv")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("mvar" | "mva" | "mv")
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("var" | "va" | "v")
                  match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
                  if (match) {
                     ++index;
                     // ("ar" | "a" | <EMPTY>)
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("r" | <EMPTY>)
                        match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'n':
         case 'N': {
            ++index;
            // ("ext" | "il")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I': {
                  ++index;
                  // "l"
                  if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                     ++index;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "xt"
                  if (match = ignoreCaseStringTest("xt", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'o':
         case 'O': {
            ++index;
            // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
               match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
               if (match) {
                  ++index;
                  // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                     match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                     if (match) {
                        ++index;
                        // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                        match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
                        if (match) {
                           ++index;
                           // ("ise" | "is" | "i" | <EMPTY>)
                           match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                           if (match) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // ("arameters" | "arameter" | "rocedure" | "aramete" | "rocedur" | "aramet" | "rocedu" | "arame" | "roced" | "ublic" | "aram" | "roce" | "ubli" | "ara" | "roc" | "ubl")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A': {
                  ++index;
                  // ("rameters" | "rameter" | "ramete" | "ramet" | "rame" | "ram" | "ra")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("ameters" | "ameter" | "amete" | "amet" | "ame" | "am" | "a")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("meters" | "meter" | "mete" | "met" | "me" | "m" | <EMPTY>)
                        match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                        if (match) {
                           ++index;
                           // ("eters" | "eter" | "ete" | "et" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("ters" | "ter" | "te" | "t" | <EMPTY>)
                              match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                              if (match) {
                                 ++index;
                                 // ("ers" | "er" | "e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // ("rs" | "r" | <EMPTY>)
                                    match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                                    if (match) {
                                       ++index;
                                       // ("s" | <EMPTY>)
                                       match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                                       if (match) {
                                          ++index;
                                          // <EMPTY>
                                          match = true;
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                           match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                           if (match) {
                              ++index;
                              // ("ure" | "ur" | "u" | <EMPTY>)
                              match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                              if (match) {
                                 ++index;
                                 // ("re" | "r" | <EMPTY>)
                                 match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("blic" | "bli" | "bl")
                  match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                  if (match) {
                     ++index;
                     // ("lic" | "li" | "l")
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // ("nnounce" | "nnounc" | "nnoun" | "nnou" | "nno")
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("nounce" | "nounc" | "noun" | "nou" | "no")
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("ounce" | "ounc" | "oun" | "ou" | "o")
                  match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                  if (match) {
                     ++index;
                     // ("unce" | "unc" | "un" | "u" | <EMPTY>)
                     match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                     if (match) {
                        ++index;
                        // ("nce" | "nc" | "n" | <EMPTY>)
                        match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                        if (match) {
                           ++index;
                           // ("ce" | "c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // ("e" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 'b':
         case 'B': {
            ++index;
            // ("egin" | "reak" | "egi" | "rea")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("eak" | "ea")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ak" | "a")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("k" | <EMPTY>)
                        match = buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("gin" | "gi")
                  match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
                  if (match) {
                     ++index;
                     // ("in" | "i")
                     match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                     if (match) {
                        ++index;
                        // ("n" | <EMPTY>)
                        match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            ++index;
            // ("ecover" | "ecove" | "eturn" | "ecov" | "etur" | "eco" | "etu")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("cover" | "cove" | "turn" | "cov" | "tur" | "co" | "tu")
               switch(buffer.getChar(index)) {
                  case 'c':
                  case 'C': {
                     ++index;
                     // ("over" | "ove" | "ov" | "o")
                     match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                     if (match) {
                        ++index;
                        // ("ver" | "ve" | "v" | <EMPTY>)
                        match = buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V');
                        if (match) {
                           ++index;
                           // ("er" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("r" | <EMPTY>)
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                     break;
                  }
                  case 't':
                  case 'T': {
                     ++index;
                     // ("urn" | "ur" | "u")
                     match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                     if (match) {
                        ++index;
                        // ("rn" | "r" | <EMPTY>)
                        match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                        if (match) {
                           ++index;
                           // ("n" | <EMPTY>)
                           match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // ("atch" | "ase" | "atc")
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("tch" | "se" | "tc")
               switch(buffer.getChar(index)) {
                  case 's':
                  case 'S': {
                     ++index;
                     // "e"
                     if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                        ++index;
                     }
                     break;
                  }
                  case 't':
                  case 'T': {
                     ++index;
                     // ("ch" | "c")
                     match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                     if (match) {
                        ++index;
                        // ("h" | <EMPTY>)
                        match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // ("equence" | "equenc" | "equen" | "tatic" | "witch" | "eque" | "tati" | "witc" | "elf" | "equ" | "tat" | "wit")
            switch(buffer.getChar(index)) {
               case 'w':
               case 'W': {
                  ++index;
                  // ("itch" | "itc" | "it")
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("tch" | "tc" | "t")
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("ch" | "c" | <EMPTY>)
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // ("h" | <EMPTY>)
                           match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 't':
               case 'T': {
                  ++index;
                  // ("atic" | "ati" | "at")
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("tic" | "ti" | "t")
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // ("c" | <EMPTY>)
                           match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("quence" | "quenc" | "quen" | "que" | "lf" | "qu")
                  switch(buffer.getChar(index)) {
                     case 'q':
                     case 'Q': {
                        ++index;
                        // ("uence" | "uenc" | "uen" | "ue" | "u")
                        match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                        if (match) {
                           ++index;
                           // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("nce" | "nc" | "n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // ("ce" | "c" | <EMPTY>)
                                 match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                 if (match) {
                                    ++index;
                                    // ("e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // "f"
                        if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                           ++index;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // ("efault" | "efaul" | "efau" | "efa")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("fault" | "faul" | "fau" | "fa")
               match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
               if (match) {
                  ++index;
                  // ("ault" | "aul" | "au" | "a")
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("ult" | "ul" | "u" | <EMPTY>)
                     match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                     if (match) {
                        ++index;
                        // ("lt" | "l" | <EMPTY>)
                        match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                        if (match) {
                           ++index;
                           // ("t" | <EMPTY>)
                           match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // "ry"
            if (match = ignoreCaseStringTest("ry", 2)) {
               index += 2;
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // ("ndsequence" | "ndsequenc" | "ndsequen" | "ndseque" | "ndcase" | "ndsequ" | "lseif" | "ndcas" | "ndseq" | "xtern" | "ndca" | "nddo" | "ndif" | "ndse" | "xter" | "ach" | "lse" | "ndc" | "ndd" | "ndi" | "nds" | "xit" | "xte" | "nd")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("dsequence" | "dsequenc" | "dsequen" | "dseque" | "dcase" | "dsequ" | "dcas" | "dseq" | "dca" | "ddo" | "dif" | "dse" | "dc" | "dd" | "di" | "ds" | "d")
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // ("sequence" | "sequenc" | "sequen" | "seque" | "case" | "sequ" | "cas" | "seq" | "ca" | "do" | "if" | "se" | "c" | "d" | "i" | "s" | <EMPTY>)
                     switch(buffer.getChar(index)) {
                        case 'i':
                        case 'I': {
                           ++index;
                           // ("f" | <EMPTY>)
                           match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                           break;
                        }
                        case 's':
                        case 'S': {
                           ++index;
                           // ("equence" | "equenc" | "equen" | "eque" | "equ" | "eq" | "e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("quence" | "quenc" | "quen" | "que" | "qu" | "q" | <EMPTY>)
                              match = buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q');
                              if (match) {
                                 ++index;
                                 // ("uence" | "uenc" | "uen" | "ue" | "u" | <EMPTY>)
                                 match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                                 if (match) {
                                    ++index;
                                    // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                                    match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                    if (match) {
                                       ++index;
                                       // ("nce" | "nc" | "n" | <EMPTY>)
                                       match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                                       if (match) {
                                          ++index;
                                          // ("ce" | "c" | <EMPTY>)
                                          match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                                          if (match) {
                                             ++index;
                                             // ("e" | <EMPTY>)
                                             match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                             if (match) {
                                                ++index;
                                                // <EMPTY>
                                                match = true;
                                             } else {
                                                match = true;
                                             }
                                          } else {
                                             match = true;
                                          }
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                           break;
                        }
                        case 'c':
                        case 'C': {
                           ++index;
                           // ("ase" | "as" | "a" | <EMPTY>)
                           match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                           if (match) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                              if (match) {
                                 ++index;
                                 // ("e" | <EMPTY>)
                                 match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                           break;
                        }
                        case 'd':
                        case 'D': {
                           ++index;
                           // ("o" | <EMPTY>)
                           match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                           break;
                        }
                        default: {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'x':
               case 'X': {
                  ++index;
                  // ("tern" | "ter" | "it" | "te")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "t"
                        if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // ("ern" | "er" | "e")
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("rn" | "r" | <EMPTY>)
                           match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                           if (match) {
                              ++index;
                              // ("n" | <EMPTY>)
                              match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "ch"
                  if (match = ignoreCaseStringTest("ch", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // ("seif" | "se")
                  match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                  if (match) {
                     ++index;
                     // ("eif" | "e")
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // ("if" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // "f"
                           if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                              ++index;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'u':
         case 'U': {
            ++index;
            // ("sing" | "sin")
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("ing" | "in")
               match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
               if (match) {
                  ++index;
                  // ("ng" | "n")
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // ("g" | <EMPTY>)
                     match = buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
         // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // 'a'-'z'
         match = buffer.matchCharRange(index, 'a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = buffer.matchCharRange(index, 'A', 'Z');
            if (! match) {
               // '0'-'9'
               match = buffer.matchCharRange(index, '0', '9');
               if (! match) {
                  // '_'
                  match = buffer.matchChar(index, '_');
               }
            }
         }
         match = ! match;
      }
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // IdentifierPattern
         match = identifierPattern$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = -1;
         identifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierPattern : (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
   protected boolean identifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (identifierPattern$RuleMemoStart == index) {
         if (identifierPattern$RuleMemoStart <= identifierPattern$RuleMemoEnd) {
            index = identifierPattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, identifierPattern$RuleMemoStart, identifierPattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifierPattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifierPattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
      // ('A'-'Z' | 'a'-'z' | '_')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'A'-'Z'
      match = charRangeMatcher('A', 'Z');
      if (! match) {
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // '_'
            match = charMatcher('_');
         }
      }
      if (match) {
         // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
            if (! match) {
               // 'a'-'z'
               match = charRangeMatcher('a', 'z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifierPattern$RuleMemoStart = startIndex;
         identifierPattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierPattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            identifierPattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifierPattern$RuleMemoStart = startIndex;
         identifierPattern$RuleMemoEnd = -1;
         identifierPattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Whitespace : (' ' | '\t' | '\f')+
   protected boolean whitespace$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (whitespace$RuleMemoStart == index) {
         if (whitespace$RuleMemoStart <= whitespace$RuleMemoEnd) {
            index = whitespace$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.WHITESPACE, whitespace$RuleMemoStart, whitespace$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (whitespace$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(whitespace$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (' ' | '\t' | '\f')+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (' ' | '\t' | '\f')
      switch(buffer.getChar(index)) {
         case '\f': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ' ': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\t': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (' ' | '\t' | '\f')
            switch(buffer.getChar(index)) {
               case '\f': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case ' ': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\t': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            whitespace$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WHITESPACE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
            whitespace$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = -1;
         whitespace$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineComment : (('//' | '&&') (('\n' | '\r' | <EOI>)! .)*)
   protected boolean lineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (lineComment$RuleMemoStart == index) {
         if (lineComment$RuleMemoStart <= lineComment$RuleMemoEnd) {
            index = lineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_COMMENT, lineComment$RuleMemoStart, lineComment$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (lineComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('//' | '&&') (('\n' | '\r' | <EOI>)! .)*)
      // ('//' | '&&')
      switch(buffer.getChar(index)) {
         case '/': {
            ++index;
            // '/'
            if (match = buffer.matchChar(index, '/')) {
               ++index;
            }
            break;
         }
         case '&': {
            ++index;
            // '&'
            if (match = buffer.matchChar(index, '&')) {
               ++index;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // (('\n' | '\r' | <EOI>)! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | '\r' | <EOI>)! .)
            // ('\n' | '\r' | <EOI>)!
            // ('\n' | '\r' | <EOI>)
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // '\r'
               match = buffer.matchChar(index, '\r');
               if (! match) {
                  // <EOI>
                  match = eoi();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_COMMENT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
            lineComment$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = -1;
         lineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockComment : ('/*' ('*/'! .)* '*/')
   protected boolean blockComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (blockComment$RuleMemoStart == index) {
         if (blockComment$RuleMemoStart <= blockComment$RuleMemoEnd) {
            index = blockComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.BLOCK_COMMENT, blockComment$RuleMemoStart, blockComment$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (blockComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(blockComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('/*' ('*/'! .)* '*/')
      // '/*'
      match = stringMatcher("/*", 2);
      if (match) {
         // ('*/'! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('*/'! .)
            // '*/'!
            // '*/'
            match = stringTest("*/", 2);
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // '*/'
         match = stringMatcher("*/", 2);
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BLOCK_COMMENT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
            blockComment$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = -1;
         blockComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AloneLineComment : ('*' (('\n' | '\r' | <EOI>)! .)*)
   protected boolean aloneLineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (aloneLineComment$RuleMemoStart == index) {
         if (aloneLineComment$RuleMemoStart <= aloneLineComment$RuleMemoEnd) {
            index = aloneLineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALONE_LINE_COMMENT, aloneLineComment$RuleMemoStart, aloneLineComment$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (aloneLineComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aloneLineComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('*' (('\n' | '\r' | <EOI>)! .)*)
      // '*'
      match = charMatcher('*');
      if (match) {
         // (('\n' | '\r' | <EOI>)! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | '\r' | <EOI>)! .)
            // ('\n' | '\r' | <EOI>)!
            // ('\n' | '\r' | <EOI>)
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // '\r'
               match = buffer.matchChar(index, '\r');
               if (! match) {
                  // <EOI>
                  match = eoi();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aloneLineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALONE_LINE_COMMENT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
            aloneLineComment$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = -1;
         aloneLineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndStmt : ('\n' | '\r\n' | ';')
   protected boolean endStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\n' | '\r\n' | ';')
      switch(buffer.getChar(index)) {
         case ';': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\r': {
            ++index;
            // '\n'
            if (match = buffer.matchChar(index, '\n')) {
               ++index;
            }
            break;
         }
         case '\n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_STMT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Spacing : (Whitespace | LineComment | BlockComment | ContinueNL)+
   protected boolean spacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (spacing$RuleMemoStart == index) {
         if (spacing$RuleMemoStart <= spacing$RuleMemoEnd) {
            index = spacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, spacing$RuleMemoStart, spacing$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (spacing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(spacing$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | LineComment | BlockComment | ContinueNL)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (Whitespace | LineComment | BlockComment | ContinueNL)
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      switch(buffer.getChar(index)) {
         case ';': {
            // ContinueNL
            match = continueNL$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case ' ':
         case '\t':
         case '\f': {
            // Whitespace
            match = whitespace$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case '/': {
            // LineComment
            match = lineComment$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // BlockComment
               match = blockComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
            break;
         }
         case '&': {
            // LineComment
            match = lineComment$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (Whitespace | LineComment | BlockComment | ContinueNL)
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            switch(buffer.getChar(index)) {
               case ';': {
                  // ContinueNL
                  match = continueNL$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
                  break;
               }
               case ' ':
               case '\t':
               case '\f': {
                  // Whitespace
                  match = whitespace$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
                  break;
               }
               case '/': {
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     // BlockComment
                     match = blockComment$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                  }
                  break;
               }
               case '&': {
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         spacing$RuleMemoStart = startIndex;
         spacing$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            spacing$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            spacing$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         spacing$RuleMemoStart = startIndex;
         spacing$RuleMemoEnd = -1;
         spacing$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueNL : (';' (Whitespace | LineComment | BlockComment)* NewLine)
   protected boolean continueNL$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueNL$RuleMemoStart == index) {
         if (continueNL$RuleMemoStart <= continueNL$RuleMemoEnd) {
            index = continueNL$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_NL, continueNL$RuleMemoStart, continueNL$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (continueNL$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(continueNL$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (';' (Whitespace | LineComment | BlockComment)* NewLine)
      // ';'
      match = charMatcher(';');
      if (match) {
         // (Whitespace | LineComment | BlockComment)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (Whitespace | LineComment | BlockComment)
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            switch(buffer.getChar(index)) {
               case ' ':
               case '\t':
               case '\f': {
                  // Whitespace
                  match = whitespace$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
                  break;
               }
               case '/': {
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // BlockComment
                     match = blockComment$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
                  break;
               }
               case '&': {
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
         // ('\n' | '\r\n')
         int startIndex_3 = index;
         switch(buffer.getChar(index)) {
            case '\r': {
               ++index;
               // '\n'
               if (match = buffer.matchChar(index, '\n')) {
                  ++index;
               }
               break;
            }
            case '\n': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
            currentNode = currentNode.getSibling();
         }
      }
      if (match) {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueNL$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_NL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueNL$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = -1;
         continueNL$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalSpacing : (Whitespace | LineComment | BlockComment | ContinueNL)*
   protected boolean optionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalSpacing$RuleMemoStart == index) {
         if (optionalSpacing$RuleMemoStart <= optionalSpacing$RuleMemoEnd) {
            index = optionalSpacing$RuleMemoEnd;
            if (! currentRuleIsAtomic && optionalSpacing$RuleMemoEnd > optionalSpacing$RuleMemoStart) {
               currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, optionalSpacing$RuleMemoStart, optionalSpacing$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (optionalSpacing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalSpacing$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | LineComment | BlockComment | ContinueNL)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (Whitespace | LineComment | BlockComment | ContinueNL)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case ';': {
               // ContinueNL
               match = continueNL$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case ' ':
            case '\t':
            case '\f': {
               // Whitespace
               match = whitespace$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '/': {
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // BlockComment
                  match = blockComment$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '&': {
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      optionalSpacing$RuleMemoStart = startIndex;
      optionalSpacing$RuleMemoEnd = index;
      if (currentRuleIsAtomic || index == startIndex) {
         optionalSpacing$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, startIndex, index, false, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         optionalSpacing$RuleMemoFirstNode = currentNode;
      }
      return true;
   }
}
