/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

package org.uggeri.yapp.runtime.java.test;

import org.uggeri.yapp.runtime.java.parser.Parser;
import org.uggeri.yapp.runtime.java.parser.Rule;
import org.uggeri.yapp.runtime.java.parser.RuleProfile;
import org.uggeri.yapp.runtime.java.buffer.InputBuffer;
import org.uggeri.yapp.runtime.java.node.Node;
import org.uggeri.yapp.runtime.java.node.NodeImpl;
import org.uggeri.yapp.runtime.java.parser.ParserError;
import org.uggeri.yapp.runtime.java.trace.TraceParser;
import java.util.Collections;
import java.util.Collection;
import java.util.Arrays;
import java.util.Map;

public class HarbourPPParser implements Parser {

   private int index = 0;

   private InputBuffer buffer;

   private boolean currentRuleIsAtomic = false;

   private Node currentNode = new NodeImpl(null, 0, 0, false, false);

   private int ignore$RuleMemoStart = -1;
   private int ignore$RuleMemoEnd;
   private Node ignore$RuleMemoFirstNode;
   private int whitespace$RuleMemoStart = -1;
   private int whitespace$RuleMemoEnd;
   private Node whitespace$RuleMemoFirstNode;
   private int blockComment$RuleMemoStart = -1;
   private int blockComment$RuleMemoEnd;
   private Node blockComment$RuleMemoFirstNode;
   private int lineComment$RuleMemoStart = -1;
   private int lineComment$RuleMemoEnd;
   private Node lineComment$RuleMemoFirstNode;
   private int continueNL$RuleMemoStart = -1;
   private int continueNL$RuleMemoEnd;
   private Node continueNL$RuleMemoFirstNode;
   private int ignoreOptionalSpacing$RuleMemoStart = -1;
   private int ignoreOptionalSpacing$RuleMemoEnd;
   private Node ignoreOptionalSpacing$RuleMemoFirstNode;
   private int ignoreSpacing$RuleMemoStart = -1;
   private int ignoreSpacing$RuleMemoEnd;
   private Node ignoreSpacing$RuleMemoFirstNode;
   private int directiveStatement$RuleMemoStart = -1;
   private int directiveStatement$RuleMemoEnd;
   private Node directiveStatement$RuleMemoFirstNode;
   private int emptyStatement$RuleMemoStart = -1;
   private int emptyStatement$RuleMemoEnd;
   private Node emptyStatement$RuleMemoFirstNode;
   private int anyStatement$RuleMemoStart = -1;
   private int anyStatement$RuleMemoEnd;
   private Node anyStatement$RuleMemoFirstNode;
   private int newLine$RuleMemoStart = -1;
   private int newLine$RuleMemoEnd;
   private Node newLine$RuleMemoFirstNode;
   private int anyRules$RuleMemoStart = -1;
   private int anyRules$RuleMemoEnd;
   private Node anyRules$RuleMemoFirstNode;
   private int endStmt$RuleMemoStart = -1;
   private int endStmt$RuleMemoEnd;
   private Node endStmt$RuleMemoFirstNode;
   private int directiveMark$RuleMemoStart = -1;
   private int directiveMark$RuleMemoEnd;
   private Node directiveMark$RuleMemoFirstNode;
   private int defineDirective$RuleMemoStart = -1;
   private int defineDirective$RuleMemoEnd;
   private Node defineDirective$RuleMemoFirstNode;
   private int stdOutDirective$RuleMemoStart = -1;
   private int stdOutDirective$RuleMemoEnd;
   private Node stdOutDirective$RuleMemoFirstNode;
   private int commandDirective$RuleMemoStart = -1;
   private int commandDirective$RuleMemoEnd;
   private Node commandDirective$RuleMemoFirstNode;
   private int xCommandDirective$RuleMemoStart = -1;
   private int xCommandDirective$RuleMemoEnd;
   private Node xCommandDirective$RuleMemoFirstNode;
   private int yCommandDirective$RuleMemoStart = -1;
   private int yCommandDirective$RuleMemoEnd;
   private Node yCommandDirective$RuleMemoFirstNode;
   private int translateDirective$RuleMemoStart = -1;
   private int translateDirective$RuleMemoEnd;
   private Node translateDirective$RuleMemoFirstNode;
   private int xTranslateDirective$RuleMemoStart = -1;
   private int xTranslateDirective$RuleMemoEnd;
   private Node xTranslateDirective$RuleMemoFirstNode;
   private int yTranslateDirective$RuleMemoStart = -1;
   private int yTranslateDirective$RuleMemoEnd;
   private Node yTranslateDirective$RuleMemoFirstNode;
   private int ifDefDirective$RuleMemoStart = -1;
   private int ifDefDirective$RuleMemoEnd;
   private Node ifDefDirective$RuleMemoFirstNode;
   private int ifNDefDirective$RuleMemoStart = -1;
   private int ifNDefDirective$RuleMemoEnd;
   private Node ifNDefDirective$RuleMemoFirstNode;
   private int elseDirective$RuleMemoStart = -1;
   private int elseDirective$RuleMemoEnd;
   private Node elseDirective$RuleMemoFirstNode;
   private int elseIfDirective$RuleMemoStart = -1;
   private int elseIfDirective$RuleMemoEnd;
   private Node elseIfDirective$RuleMemoFirstNode;
   private int endIfDirective$RuleMemoStart = -1;
   private int endIfDirective$RuleMemoEnd;
   private Node endIfDirective$RuleMemoFirstNode;
   private int undefDirective$RuleMemoStart = -1;
   private int undefDirective$RuleMemoEnd;
   private Node undefDirective$RuleMemoFirstNode;
   private int errorDirective$RuleMemoStart = -1;
   private int errorDirective$RuleMemoEnd;
   private Node errorDirective$RuleMemoFirstNode;
   private int includeDirective$RuleMemoStart = -1;
   private int includeDirective$RuleMemoEnd;
   private Node includeDirective$RuleMemoFirstNode;
   private int lineDirective$RuleMemoStart = -1;
   private int lineDirective$RuleMemoEnd;
   private Node lineDirective$RuleMemoFirstNode;
   private int uncommandDirective$RuleMemoStart = -1;
   private int uncommandDirective$RuleMemoEnd;
   private Node uncommandDirective$RuleMemoFirstNode;
   private int xUncommandDirective$RuleMemoStart = -1;
   private int xUncommandDirective$RuleMemoEnd;
   private Node xUncommandDirective$RuleMemoFirstNode;
   private int yUncommandDirective$RuleMemoStart = -1;
   private int yUncommandDirective$RuleMemoEnd;
   private Node yUncommandDirective$RuleMemoFirstNode;
   private int untranslateDirective$RuleMemoStart = -1;
   private int untranslateDirective$RuleMemoEnd;
   private Node untranslateDirective$RuleMemoFirstNode;
   private int xUntranslateDirective$RuleMemoStart = -1;
   private int xUntranslateDirective$RuleMemoEnd;
   private Node xUntranslateDirective$RuleMemoFirstNode;
   private int yUntranslateDirective$RuleMemoStart = -1;
   private int yUntranslateDirective$RuleMemoEnd;
   private Node yUntranslateDirective$RuleMemoFirstNode;
   private int dumpBlock$RuleMemoStart = -1;
   private int dumpBlock$RuleMemoEnd;
   private Node dumpBlock$RuleMemoFirstNode;
   private int resultRules$RuleMemoStart = -1;
   private int resultRules$RuleMemoEnd;
   private Node resultRules$RuleMemoFirstNode;
   private int matchPattern$RuleMemoStart = -1;
   private int matchPattern$RuleMemoEnd;
   private Node matchPattern$RuleMemoFirstNode;
   private int resultSep$RuleMemoStart = -1;
   private int resultSep$RuleMemoEnd;
   private Node resultSep$RuleMemoFirstNode;
   private int resultPattern$RuleMemoStart = -1;
   private int resultPattern$RuleMemoEnd;
   private Node resultPattern$RuleMemoFirstNode;
   private int directivePattern$RuleMemoStart = -1;
   private int directivePattern$RuleMemoEnd;
   private Node directivePattern$RuleMemoFirstNode;
   private int undefDirectivePattern$RuleMemoStart = -1;
   private int undefDirectivePattern$RuleMemoEnd;
   private Node undefDirectivePattern$RuleMemoFirstNode;
   private int escapedChar$RuleMemoStart = -1;
   private int escapedChar$RuleMemoEnd;
   private Node escapedChar$RuleMemoFirstNode;
   private int optionalMatchMarker$RuleMemoStart = -1;
   private int optionalMatchMarker$RuleMemoEnd;
   private Node optionalMatchMarker$RuleMemoFirstNode;
   private int matchMarker$RuleMemoStart = -1;
   private int matchMarker$RuleMemoEnd;
   private Node matchMarker$RuleMemoFirstNode;
   private int literal$RuleMemoStart = -1;
   private int literal$RuleMemoEnd;
   private Node literal$RuleMemoFirstNode;
   private int separator$RuleMemoStart = -1;
   private int separator$RuleMemoEnd;
   private Node separator$RuleMemoFirstNode;
   private int idMarker$RuleMemoStart = -1;
   private int idMarker$RuleMemoEnd;
   private Node idMarker$RuleMemoFirstNode;
   private int listMarker$RuleMemoStart = -1;
   private int listMarker$RuleMemoEnd;
   private Node listMarker$RuleMemoFirstNode;
   private int restrictMarker$RuleMemoStart = -1;
   private int restrictMarker$RuleMemoEnd;
   private Node restrictMarker$RuleMemoFirstNode;
   private int wildMarker$RuleMemoStart = -1;
   private int wildMarker$RuleMemoEnd;
   private Node wildMarker$RuleMemoFirstNode;
   private int extendedMarker$RuleMemoStart = -1;
   private int extendedMarker$RuleMemoEnd;
   private Node extendedMarker$RuleMemoFirstNode;
   private int identifierMarker$RuleMemoStart = -1;
   private int identifierMarker$RuleMemoEnd;
   private Node identifierMarker$RuleMemoFirstNode;
   private int restrictValue$RuleMemoStart = -1;
   private int restrictValue$RuleMemoEnd;
   private Node restrictValue$RuleMemoFirstNode;
   private int nullMarker$RuleMemoStart = -1;
   private int nullMarker$RuleMemoEnd;
   private Node nullMarker$RuleMemoFirstNode;
   private int resultMarker$RuleMemoStart = -1;
   private int resultMarker$RuleMemoEnd;
   private Node resultMarker$RuleMemoFirstNode;
   private int dumbStringifyMarker$RuleMemoStart = -1;
   private int dumbStringifyMarker$RuleMemoEnd;
   private Node dumbStringifyMarker$RuleMemoFirstNode;
   private int normalStringifyMarker$RuleMemoStart = -1;
   private int normalStringifyMarker$RuleMemoEnd;
   private Node normalStringifyMarker$RuleMemoFirstNode;
   private int smartStringifyMarker$RuleMemoStart = -1;
   private int smartStringifyMarker$RuleMemoEnd;
   private Node smartStringifyMarker$RuleMemoFirstNode;
   private int blockifyMarker$RuleMemoStart = -1;
   private int blockifyMarker$RuleMemoEnd;
   private Node blockifyMarker$RuleMemoFirstNode;
   private int logifyMarker$RuleMemoStart = -1;
   private int logifyMarker$RuleMemoEnd;
   private Node logifyMarker$RuleMemoFirstNode;
   private int optionalResultMarker$RuleMemoStart = -1;
   private int optionalResultMarker$RuleMemoEnd;
   private Node optionalResultMarker$RuleMemoFirstNode;
   private int discardedRemainingLine$RuleMemoStart = -1;
   private int discardedRemainingLine$RuleMemoEnd;
   private Node discardedRemainingLine$RuleMemoFirstNode;
   private int doubleQuoteString$RuleMemoStart = -1;
   private int doubleQuoteString$RuleMemoEnd;
   private Node doubleQuoteString$RuleMemoFirstNode;
   private int singleQuoteString$RuleMemoStart = -1;
   private int singleQuoteString$RuleMemoEnd;
   private Node singleQuoteString$RuleMemoFirstNode;
   private int endDumpBlock$RuleMemoStart = -1;
   private int endDumpBlock$RuleMemoEnd;
   private Node endDumpBlock$RuleMemoFirstNode;
   private int bracketSequence$RuleMemoStart = -1;
   private int bracketSequence$RuleMemoEnd;
   private Node bracketSequence$RuleMemoFirstNode;
   private int anyRule$RuleMemoStart = -1;
   private int anyRule$RuleMemoEnd;
   private Node anyRule$RuleMemoFirstNode;
   private int bracketString$RuleMemoStart = -1;
   private int bracketString$RuleMemoEnd;
   private Node bracketString$RuleMemoFirstNode;
   private int logicalLiteral$RuleMemoStart = -1;
   private int logicalLiteral$RuleMemoEnd;
   private Node logicalLiteral$RuleMemoFirstNode;
   private int dateTimeLiteral$RuleMemoStart = -1;
   private int dateTimeLiteral$RuleMemoEnd;
   private Node dateTimeLiteral$RuleMemoFirstNode;
   private int numberLiteral$RuleMemoStart = -1;
   private int numberLiteral$RuleMemoEnd;
   private Node numberLiteral$RuleMemoFirstNode;
   private int multiLineDoubleQuoteString$RuleMemoStart = -1;
   private int multiLineDoubleQuoteString$RuleMemoEnd;
   private Node multiLineDoubleQuoteString$RuleMemoFirstNode;
   private int multiLineSingleQuoteString$RuleMemoStart = -1;
   private int multiLineSingleQuoteString$RuleMemoEnd;
   private Node multiLineSingleQuoteString$RuleMemoFirstNode;
   private int breakString$RuleMemoStart = -1;
   private int breakString$RuleMemoEnd;
   private Node breakString$RuleMemoFirstNode;
   private int integerNumber$RuleMemoStart = -1;
   private int integerNumber$RuleMemoEnd;
   private Node integerNumber$RuleMemoFirstNode;
   private int timePattern$RuleMemoStart = -1;
   private int timePattern$RuleMemoEnd;
   private Node timePattern$RuleMemoFirstNode;
   private int datePattern$RuleMemoStart = -1;
   private int datePattern$RuleMemoEnd;
   private Node datePattern$RuleMemoFirstNode;
   private int identifier$RuleMemoStart = -1;
   private int identifier$RuleMemoEnd;
   private Node identifier$RuleMemoFirstNode;

   private int[] newArrayInt(final int size) {
      final int[] array = new int[size];
      Arrays.fill(array, -1);
      return array;
   }

   protected boolean charMatcher(char c) {
      if (buffer.matchChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean ignoreCaseCharMatcher(char c) {
      if (buffer.matchIgnoreCaseChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean stringMatcher(String str, int strLen) {
      if (buffer.matchString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean ignoreCaseStringMatcher(String str, int strLen) {
      if (buffer.matchIgnoreCaseString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialIgnoreCaseStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean charRangeMatcher(char charIni, char charEnd) {
      if (buffer.matchCharRange(index, charIni, charEnd)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean anyCharMatcher() {
      if (buffer.getChar(index) != '\0') {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean eoi() {
      if (buffer.getChar(index) == '\0') {
         return true;
      }
      return false;
   }

   protected boolean charTest(char c) {
      return buffer.getChar(index) == c;
   }

   protected boolean ignoreCaseCharTest(char c) {
      return buffer.matchIgnoreCaseChar(index, c);
   }

   protected boolean stringTest(String str, int strLen) {
      return buffer.matchString(index, str, strLen);
   }

   protected boolean partialStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean ignoreCaseStringTest(String str, int strLen) {
      return buffer.matchIgnoreCaseString(index, str, strLen);
   }

   protected boolean partialIgnoreCaseStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean charRangeTest(char charIni, char charEnd) {
      return buffer.matchCharRange(index, charIni, charEnd);
   }

   protected boolean anyCharTest() {
      return buffer.getChar(index) != '\0';
   }

   protected boolean eoiTest() {
      return buffer.getChar(index) == '\0';
   }
   @Override
   public Map<Rule, RuleProfile> getProfilesMap() {
      return Collections.emptyMap();
   }

   @Override
   public void setProfilesMap(Map<Rule, RuleProfile> profilesMap) {
   }

   @Override
   public Collection<ParserError> getMismatches() {
      return Collections.emptyList();
   }

   @Override
   public void setTraceParser(TraceParser tracePath) {
   }

   @Override
   public void setTrace(boolean trace) {
   }

   private Node lastChild(Node node) {
      Node child = node.getFirstChild();
      if (child != null) {
         while (child.getSibling() != null) {
            child = child.getSibling();
         }
      }
      return child;
   }

   private Node removeNode(Node parent, Node left, Node node) {
      if (node.getFirstChild() != null) {
         if (node.getSibling() != null) {
            lastChild(node).setSibling(node.getSibling());
         }
         if (left == null) {
            parent.setFirstChild(node.getFirstChild());
         } else {
            left.setSibling(node.getFirstChild());
         }
         return node.getFirstChild();
      } else if (left == null) {
         parent.setFirstChild(node.getSibling());
      } else {
         left.setSibling(node.getSibling());
      }
      return node.getSibling();
   }

   private void removeSkipedNodes(Node node) {
      if (node != null) {
         Node leftNode = null;
         Node child = node.getFirstChild();
         while (child != null) {
            if (child.isSkiped()) {
               child = removeNode(node, leftNode, child);
            } else {
               removeSkipedNodes(child);
               leftNode = child;
               child = child.getSibling();
            }
         }
      }
   }

   @Override
   public Node parse(InputBuffer inputBuffer) {
      buffer = inputBuffer;
      if (preProcessor$Rule()) {
         removeSkipedNodes(currentNode);
         return currentNode;
      } else {
         return null;
      }
   }


   //PreProcessor : (Statements <EOI>)
   protected boolean preProcessor$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Statements <EOI>)
      // Statements
      match = statements$Rule();
      if (match) {
         // <EOI>
         match = eoi();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.PRE_PROCESSOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statements : Statement*
   protected boolean statements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Statement*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // Statement
         match = statement$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.STATEMENTS, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //Ignore : (Whitespace | BlockComment | LineComment | ContinueNL)
   protected boolean ignore$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignore$RuleMemoStart == index) {
         if (ignore$RuleMemoStart <= ignore$RuleMemoEnd) {
            index = ignore$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.IGNORE, ignore$RuleMemoStart, ignore$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (ignore$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignore$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | BlockComment | LineComment | ContinueNL)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case ';': {
            // ContinueNL
            match = continueNL$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case ' ':
         case '\t':
         case '\f': {
            // Whitespace
            match = whitespace$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ContinueNL
               match = continueNL$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '/': {
            // BlockComment
            match = blockComment$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '&': {
            // LineComment
            match = lineComment$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         ignore$RuleMemoStart = startIndex;
         ignore$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignore$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IGNORE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignore$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ignore$RuleMemoStart = startIndex;
         ignore$RuleMemoEnd = -1;
         ignore$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Whitespace : Space+
   protected boolean whitespace$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (whitespace$RuleMemoStart == index) {
         if (whitespace$RuleMemoStart <= whitespace$RuleMemoEnd) {
            index = whitespace$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.WHITESPACE, whitespace$RuleMemoStart, whitespace$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (whitespace$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(whitespace$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // Space+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (' ' | '\t' | '\f')
      switch(buffer.getChar(index)) {
         case '\f': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ' ': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\t': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (' ' | '\t' | '\f')
            switch(buffer.getChar(index)) {
               case '\f': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case ' ': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\t': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            whitespace$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.WHITESPACE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            whitespace$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = -1;
         whitespace$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockComment : ('/*' ('*/'! .)* '*/')
   protected boolean blockComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (blockComment$RuleMemoStart == index) {
         if (blockComment$RuleMemoStart <= blockComment$RuleMemoEnd) {
            index = blockComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.BLOCK_COMMENT, blockComment$RuleMemoStart, blockComment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (blockComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(blockComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('/*' ('*/'! .)* '*/')
      // '/*'
      match = stringMatcher("/*", 2);
      if (match) {
         // ('*/'! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('*/'! .)
            // '*/'!
            // '*/'
            match = stringTest("*/", 2);
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // '*/'
         match = stringMatcher("*/", 2);
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.BLOCK_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            blockComment$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = -1;
         blockComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineComment : (('//' | '&&') (('\n' | <EOI>)! .)*)
   protected boolean lineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (lineComment$RuleMemoStart == index) {
         if (lineComment$RuleMemoStart <= lineComment$RuleMemoEnd) {
            index = lineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LINE_COMMENT, lineComment$RuleMemoStart, lineComment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lineComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('//' | '&&') (('\n' | <EOI>)! .)*)
      // ('//' | '&&')
      switch(buffer.getChar(index)) {
         case '/': {
            ++index;
            // '/'
            if (match = buffer.matchChar(index, '/')) {
               ++index;
            }
            break;
         }
         case '&': {
            ++index;
            // '&'
            if (match = buffer.matchChar(index, '&')) {
               ++index;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // (('\n' | <EOI>)! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | <EOI>)! .)
            // ('\n' | <EOI>)!
            // ('\n' | <EOI>)
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // <EOI>
               match = eoi();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            lineComment$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = -1;
         lineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueNL : (Space* ';' (BlockComment | LineComment | Whitespace)* NewLine)
   protected boolean continueNL$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueNL$RuleMemoStart == index) {
         if (continueNL$RuleMemoStart <= continueNL$RuleMemoEnd) {
            index = continueNL$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.CONTINUE_NL, continueNL$RuleMemoStart, continueNL$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (continueNL$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(continueNL$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Space* ';' (BlockComment | LineComment | Whitespace)* NewLine)
      // Space*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (' ' | '\t' | '\f')
         int startIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '\f': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case ' ': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case '\t': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (! match) {
            index = startIndex_2;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, startIndex_2, index, false, false));
            currentNode = currentNode.getSibling();
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      // ';'
      match = charMatcher(';');
      if (match) {
         // (BlockComment | LineComment | Whitespace)*
         Node lastNode_3;
         int lastIndex_3;
         do {
            lastNode_3 = currentNode;
            lastIndex_3 = index;
            // (BlockComment | LineComment | Whitespace)
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            switch(buffer.getChar(index)) {
               case ' ':
               case '\t':
               case '\f': {
                  // Whitespace
                  match = whitespace$Rule();
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                  }
                  break;
               }
               case '/': {
                  // BlockComment
                  match = blockComment$Rule();
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                     // LineComment
                     match = lineComment$Rule();
                     if (! match) {
                        index = lastIndex_4;
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                     }
                  }
                  break;
               }
               case '&': {
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_3.setSibling(null);
         currentNode = lastNode_3;
         index = lastIndex_3;
         // NewLine
         match = newLine$Rule();
      }
      if (match) {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueNL$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.CONTINUE_NL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueNL$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = -1;
         continueNL$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalSpacing : Ignore*
   protected boolean optionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // Ignore
         match = ignore$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //IgnoreOptionalSpacing : Ignore*
   protected boolean ignoreOptionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreOptionalSpacing$RuleMemoStart == index) {
         if (ignoreOptionalSpacing$RuleMemoStart <= ignoreOptionalSpacing$RuleMemoEnd) {
            index = ignoreOptionalSpacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.SPACING, ignoreOptionalSpacing$RuleMemoStart, ignoreOptionalSpacing$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (ignoreOptionalSpacing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignoreOptionalSpacing$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Ignore*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // Ignore
         match = ignore$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      ignoreOptionalSpacing$RuleMemoStart = startIndex;
      ignoreOptionalSpacing$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         ignoreOptionalSpacing$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         ignoreOptionalSpacing$RuleMemoFirstNode = currentNode;
      }
      return true;
   }

   //IgnoreSpacing : Ignore+
   protected boolean ignoreSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreSpacing$RuleMemoStart == index) {
         if (ignoreSpacing$RuleMemoStart <= ignoreSpacing$RuleMemoEnd) {
            index = ignoreSpacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.SPACING, ignoreSpacing$RuleMemoStart, ignoreSpacing$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (ignoreSpacing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignoreSpacing$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Ignore+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Ignore
      match = ignore$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // Ignore
            match = ignore$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         ignoreSpacing$RuleMemoStart = startIndex;
         ignoreSpacing$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreSpacing$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreSpacing$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ignoreSpacing$RuleMemoStart = startIndex;
         ignoreSpacing$RuleMemoEnd = -1;
         ignoreSpacing$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Spacing : Ignore+
   protected boolean spacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Ignore
      match = ignore$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // Ignore
            match = ignore$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statement : (DirectiveStatement | EmptyStatement | AnyStatement)
   protected boolean statement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (DirectiveStatement | EmptyStatement | AnyStatement)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '$':
         case '%':
         case '\'':
         case '(':
         case ')':
         case '+':
         case ',':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '<':
         case '=':
         case '>':
         case '?':
         case '@':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '\\':
         case '^':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{':
         case '|':
         case '}':
         case '~': {
            // AnyStatement
            match = anyStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case ' ':
         case '&':
         case '\t':
         case ';':
         case '\f':
         case '/': {
            // DirectiveStatement
            match = directiveStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // EmptyStatement
               match = emptyStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // AnyStatement
                  match = anyStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case '#': {
            // DirectiveStatement
            match = directiveStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AnyStatement
               match = anyStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\n':
         case '\r': {
            // EmptyStatement
            match = emptyStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '*': {
            // EmptyStatement
            match = emptyStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AnyStatement
               match = anyStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.STATEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirectiveStatement : (IgnoreOptionalSpacing DirectiveMark IgnoreOptionalSpacing (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock) IgnoreOptionalSpacing EndStmt)
   protected boolean directiveStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (directiveStatement$RuleMemoStart == index) {
         if (directiveStatement$RuleMemoStart <= directiveStatement$RuleMemoEnd) {
            index = directiveStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_STATEMENT, directiveStatement$RuleMemoStart, directiveStatement$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (directiveStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(directiveStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IgnoreOptionalSpacing DirectiveMark IgnoreOptionalSpacing (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock) IgnoreOptionalSpacing EndStmt)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // DirectiveMark
         match = directiveMark$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case 'l':
                  case 'L': {
                     // LineDirective
                     match = lineDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'p':
                  case 'P': {
                     // DumpBlock
                     match = dumpBlock$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 's':
                  case 'S': {
                     // StdOutDirective
                     match = stdOutDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'c':
                  case 'C': {
                     // CommandDirective
                     match = commandDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 't':
                  case 'T': {
                     // TranslateDirective
                     match = translateDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'd':
                  case 'D': {
                     // DefineDirective
                     match = defineDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'u':
                  case 'U': {
                     // UndefDirective
                     match = undefDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // UncommandDirective
                        match = uncommandDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // UntranslateDirective
                           match = untranslateDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     break;
                  }
                  case 'e':
                  case 'E': {
                     // ElseDirective
                     match = elseDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ElseIfDirective
                        match = elseIfDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // EndIfDirective
                           match = endIfDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ErrorDirective
                              match = errorDirective$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                     break;
                  }
                  case 'x':
                  case 'X': {
                     // XCommandDirective
                     match = xCommandDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // XTranslateDirective
                        match = xTranslateDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // XUncommandDirective
                           match = xUncommandDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // XUntranslateDirective
                              match = xUntranslateDirective$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                     break;
                  }
                  case 'y':
                  case 'Y': {
                     // YCommandDirective
                     match = yCommandDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // YTranslateDirective
                        match = yTranslateDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // YUncommandDirective
                           match = yUncommandDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // YUntranslateDirective
                              match = yUntranslateDirective$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                     break;
                  }
                  case 'i':
                  case 'I': {
                     // IfDefDirective
                     match = ifDefDirective$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IfNDefDirective
                        match = ifNDefDirective$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IncludeDirective
                           match = includeDirective$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // EndStmt
                     match = endStmt$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         directiveStatement$RuleMemoStart = startIndex;
         directiveStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            directiveStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_STATEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            directiveStatement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         directiveStatement$RuleMemoStart = startIndex;
         directiveStatement$RuleMemoEnd = -1;
         directiveStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EmptyStatement : (Ignore* AloneLineComment? EndEmptyStmt)
   protected boolean emptyStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (emptyStatement$RuleMemoStart == index) {
         if (emptyStatement$RuleMemoStart <= emptyStatement$RuleMemoEnd) {
            index = emptyStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.EMPTY_STATEMENT, emptyStatement$RuleMemoStart, emptyStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (emptyStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(emptyStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Ignore* AloneLineComment? EndEmptyStmt)
      // Ignore*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // Ignore
         match = ignore$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      match = true;
      // AloneLineComment?
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // AloneLineComment
      match = aloneLineComment$Rule();
      if (! match) {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         // EndEmptyStmt
         match = endEmptyStmt$Rule();
      }
      if (match) {
         emptyStatement$RuleMemoStart = startIndex;
         emptyStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            emptyStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.EMPTY_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            emptyStatement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         emptyStatement$RuleMemoStart = startIndex;
         emptyStatement$RuleMemoEnd = -1;
         emptyStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyStatement : (AnyRules EndStmt)
   protected boolean anyStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyStatement$RuleMemoStart == index) {
         if (anyStatement$RuleMemoStart <= anyStatement$RuleMemoEnd) {
            index = anyStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ANY_STATEMENT, anyStatement$RuleMemoStart, anyStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (anyStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyRules EndStmt)
      // AnyRules
      match = anyRules$Rule();
      if (match) {
         // EndStmt
         match = endStmt$Rule();
      }
      if (match) {
         anyStatement$RuleMemoStart = startIndex;
         anyStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyStatement$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anyStatement$RuleMemoStart = startIndex;
         anyStatement$RuleMemoEnd = -1;
         anyStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndEmptyStmt : (NewLine <EMPTY>)
   protected boolean endEmptyStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (NewLine <EMPTY>)
      // NewLine
      match = newLine$Rule();
      if (match) {
         // <EMPTY>
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NewLine : ('\n' | '\r\n')
   protected boolean newLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (newLine$RuleMemoStart == index) {
         if (newLine$RuleMemoStart <= newLine$RuleMemoEnd) {
            index = newLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.NEW_LINE, newLine$RuleMemoStart, newLine$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (newLine$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(newLine$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\n' | '\r\n')
      switch(buffer.getChar(index)) {
         case '\r': {
            ++index;
            // '\n'
            if (match = buffer.matchChar(index, '\n')) {
               ++index;
            }
            break;
         }
         case '\n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         newLine$RuleMemoStart = startIndex;
         newLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            newLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.NEW_LINE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            newLine$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         newLine$RuleMemoStart = startIndex;
         newLine$RuleMemoEnd = -1;
         newLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AloneLineComment : ('*' (('\n' | <EOI>)! .)*)
   protected boolean aloneLineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('*' (('\n' | <EOI>)! .)*)
      // '*'
      match = charMatcher('*');
      if (match) {
         // (('\n' | <EOI>)! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | <EOI>)! .)
            // ('\n' | <EOI>)!
            // ('\n' | <EOI>)
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // <EOI>
               match = eoi();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ALONE_LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyRules : AnyRule+
   protected boolean anyRules$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyRules$RuleMemoStart == index) {
         if (anyRules$RuleMemoStart <= anyRules$RuleMemoEnd) {
            index = anyRules$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULES, anyRules$RuleMemoStart, anyRules$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (anyRules$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyRules$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // AnyRule+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // AnyRule
      match = anyRule$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // AnyRule
            match = anyRule$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         anyRules$RuleMemoStart = startIndex;
         anyRules$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyRules$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULES, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyRules$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anyRules$RuleMemoStart = startIndex;
         anyRules$RuleMemoEnd = -1;
         anyRules$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndStmt : (NewLine | <EOI>)
   protected boolean endStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endStmt$RuleMemoStart == index) {
         if (endStmt$RuleMemoStart <= endStmt$RuleMemoEnd) {
            index = endStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.END_STMT, endStmt$RuleMemoStart, endStmt$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endStmt$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endStmt$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (NewLine | <EOI>)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // NewLine
      match = newLine$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // <EOI>
         match = eoi();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         endStmt$RuleMemoStart = startIndex;
         endStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.END_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endStmt$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endStmt$RuleMemoStart = startIndex;
         endStmt$RuleMemoEnd = -1;
         endStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirectiveMark : (IgnoreOptionalSpacing '#')
   protected boolean directiveMark$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (directiveMark$RuleMemoStart == index) {
         if (directiveMark$RuleMemoStart <= directiveMark$RuleMemoEnd) {
            index = directiveMark$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_MARK, directiveMark$RuleMemoStart, directiveMark$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (directiveMark$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(directiveMark$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IgnoreOptionalSpacing '#')
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // '#'
         match = charMatcher('#');
      }
      if (match) {
         directiveMark$RuleMemoStart = startIndex;
         directiveMark$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            directiveMark$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_MARK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            directiveMark$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         directiveMark$RuleMemoStart = startIndex;
         directiveMark$RuleMemoEnd = -1;
         directiveMark$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineDirective : (Define IgnoreSpacing Identifier DefineParameters? IgnoreOptionalSpacing ResultRules?)
   protected boolean defineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (defineDirective$RuleMemoStart == index) {
         if (defineDirective$RuleMemoStart <= defineDirective$RuleMemoEnd) {
            index = defineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DEFINE_DIRECTIVE, defineDirective$RuleMemoStart, defineDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (defineDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(defineDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Define IgnoreSpacing Identifier DefineParameters? IgnoreOptionalSpacing ResultRules?)
      // Define
      match = define$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // DefineParameters?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // DefineParameters
               match = defineParameters$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // ResultRules?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ResultRules
                     match = resultRules$Rule();
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            defineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            defineDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = -1;
         defineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdOutDirective : (StdOut ResultRules)
   protected boolean stdOutDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (stdOutDirective$RuleMemoStart == index) {
         if (stdOutDirective$RuleMemoStart <= stdOutDirective$RuleMemoEnd) {
            index = stdOutDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.STD_OUT_DIRECTIVE, stdOutDirective$RuleMemoStart, stdOutDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (stdOutDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stdOutDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (StdOut ResultRules)
      // StdOut
      match = stdOut$Rule();
      if (match) {
         // ResultRules
         match = resultRules$Rule();
      }
      if (match) {
         stdOutDirective$RuleMemoStart = startIndex;
         stdOutDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdOutDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.STD_OUT_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdOutDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         stdOutDirective$RuleMemoStart = startIndex;
         stdOutDirective$RuleMemoEnd = -1;
         stdOutDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommandDirective : (Command IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean commandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commandDirective$RuleMemoStart == index) {
         if (commandDirective$RuleMemoStart <= commandDirective$RuleMemoEnd) {
            index = commandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.COMMAND_DIRECTIVE, commandDirective$RuleMemoStart, commandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (commandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(commandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Command IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // Command
      match = command$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // MatchPattern
            match = matchPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ResultSep
                  match = resultSep$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ResultPattern?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ResultPattern
                        match = resultPattern$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.COMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = -1;
         commandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommandDirective : (XCommand directivePattern)
   protected boolean xCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xCommandDirective$RuleMemoStart == index) {
         if (xCommandDirective$RuleMemoStart <= xCommandDirective$RuleMemoEnd) {
            index = xCommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.XCOMMAND_DIRECTIVE, xCommandDirective$RuleMemoStart, xCommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xCommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xCommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (XCommand directivePattern)
      // XCommand
      match = xCommand$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xCommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.XCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xCommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = -1;
         xCommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YCommandDirective : (YCommand IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean yCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yCommandDirective$RuleMemoStart == index) {
         if (yCommandDirective$RuleMemoStart <= yCommandDirective$RuleMemoEnd) {
            index = yCommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.YCOMMAND_DIRECTIVE, yCommandDirective$RuleMemoStart, yCommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yCommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yCommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (YCommand IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // YCommand
      match = yCommand$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // MatchPattern
            match = matchPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ResultSep
                  match = resultSep$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ResultPattern?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ResultPattern
                        match = resultPattern$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         yCommandDirective$RuleMemoStart = startIndex;
         yCommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yCommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.YCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yCommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yCommandDirective$RuleMemoStart = startIndex;
         yCommandDirective$RuleMemoEnd = -1;
         yCommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TranslateDirective : (Translate directivePattern)
   protected boolean translateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (translateDirective$RuleMemoStart == index) {
         if (translateDirective$RuleMemoStart <= translateDirective$RuleMemoEnd) {
            index = translateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.TRANSLATE_DIRECTIVE, translateDirective$RuleMemoStart, translateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (translateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(translateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Translate directivePattern)
      // Translate
      match = translate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            translateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.TRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            translateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = -1;
         translateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslateDirective : (XTranslate directivePattern)
   protected boolean xTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xTranslateDirective$RuleMemoStart == index) {
         if (xTranslateDirective$RuleMemoStart <= xTranslateDirective$RuleMemoEnd) {
            index = xTranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.XTRANSLATE_DIRECTIVE, xTranslateDirective$RuleMemoStart, xTranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xTranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xTranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (XTranslate directivePattern)
      // XTranslate
      match = xTranslate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xTranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.XTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xTranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = -1;
         xTranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YTranslateDirective : (YTranslate directivePattern)
   protected boolean yTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yTranslateDirective$RuleMemoStart == index) {
         if (yTranslateDirective$RuleMemoStart <= yTranslateDirective$RuleMemoEnd) {
            index = yTranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.YTRANSLATE_DIRECTIVE, yTranslateDirective$RuleMemoStart, yTranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yTranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yTranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (YTranslate directivePattern)
      // YTranslate
      match = yTranslate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         yTranslateDirective$RuleMemoStart = startIndex;
         yTranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yTranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.YTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yTranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yTranslateDirective$RuleMemoStart = startIndex;
         yTranslateDirective$RuleMemoEnd = -1;
         yTranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDefDirective : (IfDef IgnoreSpacing Identifier)
   protected boolean ifDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifDefDirective$RuleMemoStart == index) {
         if (ifDefDirective$RuleMemoStart <= ifDefDirective$RuleMemoEnd) {
            index = ifDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.IF_DEF_DIRECTIVE, ifDefDirective$RuleMemoStart, ifDefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifDefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifDefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IfDef IgnoreSpacing Identifier)
      // IfDef
      match = ifDef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_DEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifDefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = -1;
         ifDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDefDirective : (IfNDef IgnoreSpacing Identifier)
   protected boolean ifNDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifNDefDirective$RuleMemoStart == index) {
         if (ifNDefDirective$RuleMemoStart <= ifNDefDirective$RuleMemoEnd) {
            index = ifNDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.IF_NDEF_DIRECTIVE, ifNDefDirective$RuleMemoStart, ifNDefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifNDefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifNDefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IfNDef IgnoreSpacing Identifier)
      // IfNDef
      match = ifNDef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifNDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_NDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifNDefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = -1;
         ifNDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseDirective : ("else" DiscardedRemainingLine)
   protected boolean elseDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (elseDirective$RuleMemoStart == index) {
         if (elseDirective$RuleMemoStart <= elseDirective$RuleMemoEnd) {
            index = elseDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ELSE_DIRECTIVE, elseDirective$RuleMemoStart, elseDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (elseDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(elseDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("else" DiscardedRemainingLine)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_DIRECTIVE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            elseDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = -1;
         elseDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseIfDirective : (ElseIf IgnoreSpacing Identifier)
   protected boolean elseIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseIfDirective$RuleMemoStart == index) {
         if (elseIfDirective$RuleMemoStart <= elseIfDirective$RuleMemoEnd) {
            index = elseIfDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ELSE_IF_DIRECTIVE, elseIfDirective$RuleMemoStart, elseIfDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (elseIfDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(elseIfDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ElseIf IgnoreSpacing Identifier)
      // ElseIf
      match = elseIf$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         elseIfDirective$RuleMemoStart = startIndex;
         elseIfDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseIfDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseIfDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         elseIfDirective$RuleMemoStart = startIndex;
         elseIfDirective$RuleMemoEnd = -1;
         elseIfDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIfDirective : (EndIf DiscardedRemainingLine)
   protected boolean endIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (endIfDirective$RuleMemoStart == index) {
         if (endIfDirective$RuleMemoStart <= endIfDirective$RuleMemoEnd) {
            index = endIfDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.END_IF_DIRECTIVE, endIfDirective$RuleMemoStart, endIfDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endIfDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endIfDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (EndIf DiscardedRemainingLine)
      // EndIf
      match = endIf$Rule();
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endIfDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.END_IF_DIRECTIVE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            endIfDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = -1;
         endIfDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UndefDirective : (Undef IgnoreSpacing Identifier)
   protected boolean undefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (undefDirective$RuleMemoStart == index) {
         if (undefDirective$RuleMemoStart <= undefDirective$RuleMemoEnd) {
            index = undefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE, undefDirective$RuleMemoStart, undefDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (undefDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(undefDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Undef IgnoreSpacing Identifier)
      // Undef
      match = undef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            undefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            undefDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = -1;
         undefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ErrorDirective : ("error" ResultRules)
   protected boolean errorDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (errorDirective$RuleMemoStart == index) {
         if (errorDirective$RuleMemoStart <= errorDirective$RuleMemoEnd) {
            index = errorDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ERROR_DIRECTIVE, errorDirective$RuleMemoStart, errorDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (errorDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(errorDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("error" ResultRules)
      // "error"
      match = ignoreCaseStringMatcher("error", 5);
      if (match) {
         // ResultRules
         match = resultRules$Rule();
      }
      if (match) {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            errorDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ERROR_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            errorDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = -1;
         errorDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeName : (DoubleQuoteString | SingleQuoteString)
   protected boolean includeName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (DoubleQuoteString | SingleQuoteString)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"': {
            // DoubleQuoteString
            match = doubleQuoteString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\'': {
            // SingleQuoteString
            match = singleQuoteString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE_NAME, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeDirective : (Include IgnoreSpacing IncludeName)
   protected boolean includeDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (includeDirective$RuleMemoStart == index) {
         if (includeDirective$RuleMemoStart <= includeDirective$RuleMemoEnd) {
            index = includeDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE_DIRECTIVE, includeDirective$RuleMemoStart, includeDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (includeDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(includeDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Include IgnoreSpacing IncludeName)
      // Include
      match = include$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // IncludeName
            match = includeName$Rule();
         }
      }
      if (match) {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            includeDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            includeDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = -1;
         includeDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineDirective : ("line" DiscardedRemainingLine)
   protected boolean lineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (lineDirective$RuleMemoStart == index) {
         if (lineDirective$RuleMemoStart <= lineDirective$RuleMemoEnd) {
            index = lineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LINE_DIRECTIVE, lineDirective$RuleMemoStart, lineDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lineDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("line" DiscardedRemainingLine)
      // "line"
      match = ignoreCaseStringMatcher("line", 4);
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lineDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = -1;
         lineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UncommandDirective : (Uncommand undefDirectivePattern)
   protected boolean uncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (uncommandDirective$RuleMemoStart == index) {
         if (uncommandDirective$RuleMemoStart <= uncommandDirective$RuleMemoEnd) {
            index = uncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.UNCOMMAND_DIRECTIVE, uncommandDirective$RuleMemoStart, uncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (uncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(uncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Uncommand undefDirectivePattern)
      // Uncommand
      match = uncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         uncommandDirective$RuleMemoStart = startIndex;
         uncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            uncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.UNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            uncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         uncommandDirective$RuleMemoStart = startIndex;
         uncommandDirective$RuleMemoEnd = -1;
         uncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUncommandDirective : (Xuncommand undefDirectivePattern)
   protected boolean xUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xUncommandDirective$RuleMemoStart == index) {
         if (xUncommandDirective$RuleMemoStart <= xUncommandDirective$RuleMemoEnd) {
            index = xUncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.XUNCOMMAND_DIRECTIVE, xUncommandDirective$RuleMemoStart, xUncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xUncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xUncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Xuncommand undefDirectivePattern)
      // Xuncommand
      match = xuncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         xUncommandDirective$RuleMemoStart = startIndex;
         xUncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xUncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xUncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xUncommandDirective$RuleMemoStart = startIndex;
         xUncommandDirective$RuleMemoEnd = -1;
         xUncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUncommandDirective : (Yuncommand undefDirectivePattern)
   protected boolean yUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yUncommandDirective$RuleMemoStart == index) {
         if (yUncommandDirective$RuleMemoStart <= yUncommandDirective$RuleMemoEnd) {
            index = yUncommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.YUNCOMMAND_DIRECTIVE, yUncommandDirective$RuleMemoStart, yUncommandDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yUncommandDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yUncommandDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Yuncommand undefDirectivePattern)
      // Yuncommand
      match = yuncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         yUncommandDirective$RuleMemoStart = startIndex;
         yUncommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yUncommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yUncommandDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yUncommandDirective$RuleMemoStart = startIndex;
         yUncommandDirective$RuleMemoEnd = -1;
         yUncommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UntranslateDirective : (Untranslate undefDirectivePattern)
   protected boolean untranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (untranslateDirective$RuleMemoStart == index) {
         if (untranslateDirective$RuleMemoStart <= untranslateDirective$RuleMemoEnd) {
            index = untranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.UNTRANSLATE_DIRECTIVE, untranslateDirective$RuleMemoStart, untranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (untranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(untranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Untranslate undefDirectivePattern)
      // Untranslate
      match = untranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         untranslateDirective$RuleMemoStart = startIndex;
         untranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            untranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.UNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            untranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         untranslateDirective$RuleMemoStart = startIndex;
         untranslateDirective$RuleMemoEnd = -1;
         untranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUntranslateDirective : (Xuntranslate undefDirectivePattern)
   protected boolean xUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xUntranslateDirective$RuleMemoStart == index) {
         if (xUntranslateDirective$RuleMemoStart <= xUntranslateDirective$RuleMemoEnd) {
            index = xUntranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.XUNTRANSLATE_DIRECTIVE, xUntranslateDirective$RuleMemoStart, xUntranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xUntranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xUntranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Xuntranslate undefDirectivePattern)
      // Xuntranslate
      match = xuntranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         xUntranslateDirective$RuleMemoStart = startIndex;
         xUntranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xUntranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xUntranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         xUntranslateDirective$RuleMemoStart = startIndex;
         xUntranslateDirective$RuleMemoEnd = -1;
         xUntranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUntranslateDirective : (Yuntranslate undefDirectivePattern)
   protected boolean yUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (yUntranslateDirective$RuleMemoStart == index) {
         if (yUntranslateDirective$RuleMemoStart <= yUntranslateDirective$RuleMemoEnd) {
            index = yUntranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.YUNTRANSLATE_DIRECTIVE, yUntranslateDirective$RuleMemoStart, yUntranslateDirective$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (yUntranslateDirective$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(yUntranslateDirective$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Yuntranslate undefDirectivePattern)
      // Yuntranslate
      match = yuntranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         yUntranslateDirective$RuleMemoStart = startIndex;
         yUntranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            yUntranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            yUntranslateDirective$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         yUntranslateDirective$RuleMemoStart = startIndex;
         yUntranslateDirective$RuleMemoEnd = -1;
         yUntranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DumpBlock : (BeginDumpBlock EndStmt ((EndDumpBlock | <EOI>)! .)* EndDumpBlock)
   protected boolean dumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dumpBlock$RuleMemoStart == index) {
         if (dumpBlock$RuleMemoStart <= dumpBlock$RuleMemoEnd) {
            index = dumpBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DUMP_BLOCK, dumpBlock$RuleMemoStart, dumpBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dumpBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dumpBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (BeginDumpBlock EndStmt ((EndDumpBlock | <EOI>)! .)* EndDumpBlock)
      // BeginDumpBlock
      match = beginDumpBlock$Rule();
      if (match) {
         // EndStmt
         match = endStmt$Rule();
         if (match) {
            // ((EndDumpBlock | <EOI>)! .)*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // ((EndDumpBlock | <EOI>)! .)
               // (EndDumpBlock | <EOI>)!
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               boolean lastAtomic_2 = currentRuleIsAtomic;
               // (EndDumpBlock | <EOI>)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // EndDumpBlock
               match = endDumpBlock$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // <EOI>
                  match = eoi();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               currentRuleIsAtomic = lastAtomic_2;
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            // EndDumpBlock
            match = endDumpBlock$Rule();
         }
      }
      if (match) {
         dumpBlock$RuleMemoStart = startIndex;
         dumpBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dumpBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dumpBlock$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dumpBlock$RuleMemoStart = startIndex;
         dumpBlock$RuleMemoEnd = -1;
         dumpBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Define : ("defi" ("ne" | "n")?)
   protected boolean define$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("defi" ("ne" | "n")?)
      // "defi"
      match = ignoreCaseStringMatcher("defi", 4);
      if (match) {
         // ("ne" | "n")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ne" | "n")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("e" | <EMPTY>)
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineParameters : ('(' IgnoreOptionalSpacing ParametersList? ')')
   protected boolean defineParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('(' IgnoreOptionalSpacing ParametersList? ')')
      // '('
      match = charMatcher('(');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // ParametersList?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ParametersList
            match = parametersList$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // ')'
               match = charMatcher(')');
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultRules : AnyRules
   protected boolean resultRules$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (resultRules$RuleMemoStart == index) {
         if (resultRules$RuleMemoStart <= resultRules$RuleMemoEnd) {
            index = resultRules$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESULT_RULES, resultRules$RuleMemoStart, resultRules$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (resultRules$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(resultRules$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // AnyRules
      match = anyRules$Rule();
      if (match) {
         resultRules$RuleMemoStart = startIndex;
         resultRules$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            resultRules$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_RULES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            resultRules$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         resultRules$RuleMemoStart = startIndex;
         resultRules$RuleMemoEnd = -1;
         resultRules$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersList : (Identifier (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)* IgnoreOptionalSpacing)
   protected boolean parametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Identifier (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)* IgnoreOptionalSpacing)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ','
               match = charMatcher(',');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // Identifier
                     match = identifier$Rule();
                  }
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.PARAMETERS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdOut : ("stdo" ("ut" | "u")?)
   protected boolean stdOut$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("stdo" ("ut" | "u")?)
      // "stdo"
      match = ignoreCaseStringMatcher("stdo", 4);
      if (match) {
         // ("ut" | "u")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ut" | "u")
         match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
         if (match) {
            ++index;
            // ("t" | <EMPTY>)
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.STD_OUT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Command : ("comm" ("and" | "an" | "a")?)
   protected boolean command$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("comm" ("and" | "an" | "a")?)
      // "comm"
      match = ignoreCaseStringMatcher("comm", 4);
      if (match) {
         // ("and" | "an" | "a")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("and" | "an" | "a")
         match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
         if (match) {
            ++index;
            // ("nd" | "n" | <EMPTY>)
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("d" | <EMPTY>)
               match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
               if (match) {
                  ++index;
                  // <EMPTY>
                  match = true;
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.COMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchPattern : MatchChunk+
   protected boolean matchPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (matchPattern$RuleMemoStart == index) {
         if (matchPattern$RuleMemoStart <= matchPattern$RuleMemoEnd) {
            index = matchPattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.MATCH_PATTERN, matchPattern$RuleMemoStart, matchPattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (matchPattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(matchPattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // MatchChunk+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // MatchChunk
      match = matchChunk$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // MatchChunk
            match = matchChunk$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         matchPattern$RuleMemoStart = startIndex;
         matchPattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            matchPattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            matchPattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         matchPattern$RuleMemoStart = startIndex;
         matchPattern$RuleMemoEnd = -1;
         matchPattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultSep : ('=' IgnoreOptionalSpacing '>')
   protected boolean resultSep$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (resultSep$RuleMemoStart == index) {
         if (resultSep$RuleMemoStart <= resultSep$RuleMemoEnd) {
            index = resultSep$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESULT_SEP, resultSep$RuleMemoStart, resultSep$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (resultSep$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(resultSep$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('=' IgnoreOptionalSpacing '>')
      // '='
      match = charMatcher('=');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '>'
            match = charMatcher('>');
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         resultSep$RuleMemoStart = startIndex;
         resultSep$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            resultSep$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_SEP, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            resultSep$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         resultSep$RuleMemoStart = startIndex;
         resultSep$RuleMemoEnd = -1;
         resultSep$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultPattern : ResultChunk+
   protected boolean resultPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (resultPattern$RuleMemoStart == index) {
         if (resultPattern$RuleMemoStart <= resultPattern$RuleMemoEnd) {
            index = resultPattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESULT_PATTERN, resultPattern$RuleMemoStart, resultPattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (resultPattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(resultPattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ResultChunk+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ResultChunk
      match = resultChunk$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ResultChunk
            match = resultChunk$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         resultPattern$RuleMemoStart = startIndex;
         resultPattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            resultPattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            resultPattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         resultPattern$RuleMemoStart = startIndex;
         resultPattern$RuleMemoEnd = -1;
         resultPattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YCommand : ("ycom" ("mand" | "man" | "ma" | "m")?)
   protected boolean yCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ycom" ("mand" | "man" | "ma" | "m")?)
      // "ycom"
      match = ignoreCaseStringMatcher("ycom", 4);
      if (match) {
         // ("mand" | "man" | "ma" | "m")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("mand" | "man" | "ma" | "m")
         match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
         if (match) {
            ++index;
            // ("and" | "an" | "a" | <EMPTY>)
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("nd" | "n" | <EMPTY>)
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("d" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YCOMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //directivePattern : (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean directivePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (directivePattern$RuleMemoStart == index) {
         if (directivePattern$RuleMemoStart <= directivePattern$RuleMemoEnd) {
            index = directivePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_PATTERN, directivePattern$RuleMemoStart, directivePattern$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (directivePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(directivePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // MatchPattern
         match = matchPattern$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ResultSep
               match = resultSep$Rule();
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // ResultPattern?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // ResultPattern
                     match = resultPattern$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         directivePattern$RuleMemoStart = startIndex;
         directivePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            directivePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_PATTERN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            directivePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         directivePattern$RuleMemoStart = startIndex;
         directivePattern$RuleMemoEnd = -1;
         directivePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //undefDirectivePattern : (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing)
   protected boolean undefDirectivePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (undefDirectivePattern$RuleMemoStart == index) {
         if (undefDirectivePattern$RuleMemoStart <= undefDirectivePattern$RuleMemoEnd) {
            index = undefDirectivePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE_PATTERN, undefDirectivePattern$RuleMemoStart, undefDirectivePattern$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (undefDirectivePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(undefDirectivePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // MatchPattern
         match = matchPattern$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
         }
      }
      if (match) {
         undefDirectivePattern$RuleMemoStart = startIndex;
         undefDirectivePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            undefDirectivePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE_PATTERN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            undefDirectivePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         undefDirectivePattern$RuleMemoStart = startIndex;
         undefDirectivePattern$RuleMemoEnd = -1;
         undefDirectivePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Uncommand : ("unco" ("mmand" | "mman" | "mma" | "mm" | "m")?)
   protected boolean uncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("unco" ("mmand" | "mman" | "mma" | "mm" | "m")?)
      // "unco"
      match = ignoreCaseStringMatcher("unco", 4);
      if (match) {
         // ("mmand" | "mman" | "mma" | "mm" | "m")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("mmand" | "mman" | "mma" | "mm" | "m")
         match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
         if (match) {
            ++index;
            // ("mand" | "man" | "ma" | "m" | <EMPTY>)
            match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
            if (match) {
               ++index;
               // ("and" | "an" | "a" | <EMPTY>)
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("nd" | "n" | <EMPTY>)
                  match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                  if (match) {
                     ++index;
                     // ("d" | <EMPTY>)
                     match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNCOMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Xuncommand : ("xunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
   protected boolean xuncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
      // "xunc"
      match = ignoreCaseStringMatcher("xunc", 4);
      if (match) {
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("mmand" | "mman" | "mma" | "mm" | "m" | <EMPTY>)
            match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
            if (match) {
               ++index;
               // ("mand" | "man" | "ma" | "m" | <EMPTY>)
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("and" | "an" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("nd" | "n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("d" | <EMPTY>)
                        match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNCOMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Yuncommand : ("yunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
   protected boolean yuncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("yunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
      // "yunc"
      match = ignoreCaseStringMatcher("yunc", 4);
      if (match) {
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")
         match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
         if (match) {
            ++index;
            // ("mmand" | "mman" | "mma" | "mm" | "m" | <EMPTY>)
            match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
            if (match) {
               ++index;
               // ("mand" | "man" | "ma" | "m" | <EMPTY>)
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("and" | "an" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("nd" | "n" | <EMPTY>)
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("d" | <EMPTY>)
                        match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNCOMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommand : ("xcom" ("mand" | "man" | "ma" | "m")?)
   protected boolean xCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xcom" ("mand" | "man" | "ma" | "m")?)
      // "xcom"
      match = ignoreCaseStringMatcher("xcom", 4);
      if (match) {
         // ("mand" | "man" | "ma" | "m")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("mand" | "man" | "ma" | "m")
         match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
         if (match) {
            ++index;
            // ("and" | "an" | "a" | <EMPTY>)
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("nd" | "n" | <EMPTY>)
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("d" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XCOMMAND, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Untranslate : ("untr" ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?)
   protected boolean untranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("untr" ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?)
      // "untr"
      match = ignoreCaseStringMatcher("untr", 4);
      if (match) {
         // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")
         match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
         if (match) {
            ++index;
            // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
            match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
            if (match) {
               ++index;
               // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
               match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
               if (match) {
                  ++index;
                  // ("late" | "lat" | "la" | "l" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // ("ate" | "at" | "a" | <EMPTY>)
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("te" | "t" | <EMPTY>)
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("e" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNTRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Xuntranslate : ("xunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
   protected boolean xuntranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
      // "xunt"
      match = ignoreCaseStringMatcher("xunt", 4);
      if (match) {
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a" | <EMPTY>)
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                  match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                  if (match) {
                     ++index;
                     // ("late" | "lat" | "la" | "l" | <EMPTY>)
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("ate" | "at" | "a" | <EMPTY>)
                        match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                        if (match) {
                           ++index;
                           // ("te" | "t" | <EMPTY>)
                           match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                           if (match) {
                              ++index;
                              // ("e" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNTRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Yuntranslate : ("yunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
   protected boolean yuntranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("yunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
      // "yunt"
      match = ignoreCaseStringMatcher("yunt", 4);
      if (match) {
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")
         match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
         if (match) {
            ++index;
            // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a" | <EMPTY>)
            match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
            if (match) {
               ++index;
               // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
               match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
               if (match) {
                  ++index;
                  // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                  match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                  if (match) {
                     ++index;
                     // ("late" | "lat" | "la" | "l" | <EMPTY>)
                     match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                     if (match) {
                        ++index;
                        // ("ate" | "at" | "a" | <EMPTY>)
                        match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                        if (match) {
                           ++index;
                           // ("te" | "t" | <EMPTY>)
                           match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                           if (match) {
                              ++index;
                              // ("e" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNTRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Translate : ("tran" ("slate" | "slat" | "sla" | "sl" | "s")?)
   protected boolean translate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("tran" ("slate" | "slat" | "sla" | "sl" | "s")?)
      // "tran"
      match = ignoreCaseStringMatcher("tran", 4);
      if (match) {
         // ("slate" | "slat" | "sla" | "sl" | "s")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("slate" | "slat" | "sla" | "sl" | "s")
         match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
         if (match) {
            ++index;
            // ("late" | "lat" | "la" | "l" | <EMPTY>)
            match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
            if (match) {
               ++index;
               // ("ate" | "at" | "a" | <EMPTY>)
               match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
               if (match) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                  if (match) {
                     ++index;
                     // ("e" | <EMPTY>)
                     match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.TRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YTranslate : ("ytra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
   protected boolean yTranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ytra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
      // "ytra"
      match = ignoreCaseStringMatcher("ytra", 4);
      if (match) {
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("late" | "lat" | "la" | "l" | <EMPTY>)
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YTRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslate : ("xtra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
   protected boolean xTranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xtra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
      // "xtra"
      match = ignoreCaseStringMatcher("xtra", 4);
      if (match) {
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
         match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
         if (match) {
            ++index;
            // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
            match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
            if (match) {
               ++index;
               // ("late" | "lat" | "la" | "l" | <EMPTY>)
               match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
               if (match) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                  if (match) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                     if (match) {
                        ++index;
                        // ("e" | <EMPTY>)
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XTRANSLATE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EscapedChar : ('\' ('\n'! .))
   protected boolean escapedChar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (escapedChar$RuleMemoStart == index) {
         if (escapedChar$RuleMemoStart <= escapedChar$RuleMemoEnd) {
            index = escapedChar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ESCAPED_CHAR, escapedChar$RuleMemoStart, escapedChar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (escapedChar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(escapedChar$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\' ('\n'! .))
      // '\'
      match = charMatcher('\\');
      if (match) {
         // ('\n'! .)
         // '\n'!
         // '\n'
         match = buffer.matchChar(index, '\n');
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher();
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         escapedChar$RuleMemoStart = startIndex;
         escapedChar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            escapedChar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ESCAPED_CHAR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            escapedChar$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         escapedChar$RuleMemoStart = startIndex;
         escapedChar$RuleMemoEnd = -1;
         escapedChar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarker : ('[' IgnoreOptionalSpacing OptionalMatchMarkerPattern IgnoreOptionalSpacing ']')
   protected boolean optionalMatchMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalMatchMarker$RuleMemoStart == index) {
         if (optionalMatchMarker$RuleMemoStart <= optionalMatchMarker$RuleMemoEnd) {
            index = optionalMatchMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_MATCH_MARKER, optionalMatchMarker$RuleMemoStart, optionalMatchMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (optionalMatchMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalMatchMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('[' IgnoreOptionalSpacing OptionalMatchMarkerPattern IgnoreOptionalSpacing ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // OptionalMatchMarkerPattern
            match = optionalMatchMarkerPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ']'
                  match = charMatcher(']');
               }
            }
         }
      }
      if (match) {
         optionalMatchMarker$RuleMemoStart = startIndex;
         optionalMatchMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalMatchMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_MATCH_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalMatchMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalMatchMarker$RuleMemoStart = startIndex;
         optionalMatchMarker$RuleMemoEnd = -1;
         optionalMatchMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarkerPattern : OptionalMatchMarkerChunk+
   protected boolean optionalMatchMarkerPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // OptionalMatchMarkerChunk+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // OptionalMatchMarkerChunk
      match = optionalMatchMarkerChunk$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // OptionalMatchMarkerChunk
            match = optionalMatchMarkerChunk$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarkerChunk : (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator))
   protected boolean optionalMatchMarkerChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator))
      // ResultSep!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // ResultSep
      match = resultSep$Rule();
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '@':
            case '!':
            case '#':
            case '$':
            case '%':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case ':':
            case '|':
            case '=':
            case '}':
            case '>':
            case '^':
            case '~':
            case '?': {
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '[': {
               // OptionalMatchMarker
               match = optionalMatchMarker$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '<': {
               // MatchMarker
               match = matchMarker$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '\\': {
               // EscapedChar
               match = escapedChar$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '\"':
            case '\'':
            case '{':
            case '.': {
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '&':
            case ';':
            case '/': {
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '_': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9': {
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'A':
            case 'B':
            case 'C':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case 'a':
            case 'b':
            case 'c':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'D':
            case 'd': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case ' ':
            case '\t':
            case '\f': {
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_MATCH_MARKER_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchMarker : (IdMarker | ListMarker | RestrictMarker | WildMarker | ExtendedMarker | IdentifierMarker)
   protected boolean matchMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (matchMarker$RuleMemoStart == index) {
         if (matchMarker$RuleMemoStart <= matchMarker$RuleMemoEnd) {
            index = matchMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.MATCH_MARKER, matchMarker$RuleMemoStart, matchMarker$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (matchMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(matchMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IdMarker | ListMarker | RestrictMarker | WildMarker | ExtendedMarker | IdentifierMarker)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '<': {
            // IdMarker
            match = idMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ListMarker
               match = listMarker$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RestrictMarker
                  match = restrictMarker$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // WildMarker
                     match = wildMarker$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ExtendedMarker
                        match = extendedMarker$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IdentifierMarker
                           match = identifierMarker$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         matchMarker$RuleMemoStart = startIndex;
         matchMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            matchMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_MARKER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            matchMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         matchMarker$RuleMemoStart = startIndex;
         matchMarker$RuleMemoEnd = -1;
         matchMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Literal : (LogicalLiteral | DoubleQuoteString | SingleQuoteString | DateTimeLiteral | NumberLiteral | MultiLineDoubleQuoteString | MultiLineSingleQuoteString)
   protected boolean literal$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (literal$RuleMemoStart == index) {
         if (literal$RuleMemoStart <= literal$RuleMemoEnd) {
            index = literal$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LITERAL, literal$RuleMemoStart, literal$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (literal$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(literal$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LogicalLiteral | DoubleQuoteString | SingleQuoteString | DateTimeLiteral | NumberLiteral | MultiLineDoubleQuoteString | MultiLineSingleQuoteString)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'd':
         case 'D':
         case '{': {
            // DateTimeLiteral
            match = dateTimeLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '.': {
            // LogicalLiteral
            match = logicalLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NumberLiteral
               match = numberLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '0': {
            // DateTimeLiteral
            match = dateTimeLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NumberLiteral
               match = numberLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"': {
            // DoubleQuoteString
            match = doubleQuoteString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MultiLineDoubleQuoteString
               match = multiLineDoubleQuoteString$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\'': {
            // SingleQuoteString
            match = singleQuoteString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MultiLineSingleQuoteString
               match = multiLineSingleQuoteString$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            literal$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            literal$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = -1;
         literal$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Separator : (".or." | ".and." | ".not." | ':=' | '==' | '!=' | '>=' | '<=' | '->' | '++' | '--' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '**' | '^^' | '<<' | '>>' | '::' | '<>' | '...' | '&&' | '||' | '^^' | '**=' | '$' | ',' | '>' | '+' | '*' | '!' | '-' | '/' | '(' | ')' | ':' | '{' | '}' | '%' | '\' | '?' | '~' | '.' | '@' | '|' | '&' | '=' | '^' | '#' | ';' | '<' | '[' | '"' | '\'' | '_')
   protected boolean separator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (separator$RuleMemoStart == index) {
         if (separator$RuleMemoStart <= separator$RuleMemoEnd) {
            index = separator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.SEPARATOR, separator$RuleMemoStart, separator$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (separator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(separator$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (".or." | ".and." | ".not." | ':=' | '==' | '!=' | '>=' | '<=' | '->' | '++' | '--' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '**' | '^^' | '<<' | '>>' | '::' | '<>' | '...' | '&&' | '||' | '^^' | '**=' | '$' | ',' | '>' | '+' | '*' | '!' | '-' | '/' | '(' | ')' | ':' | '{' | '}' | '%' | '\' | '?' | '~' | '.' | '@' | '|' | '&' | '=' | '^' | '#' | ';' | '<' | '[' | '"' | '\'' | '_')
      switch(buffer.getChar(index)) {
         case '+': {
            ++index;
            // ('+' | '=' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '+': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case ',': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '-': {
            ++index;
            // ('>' | '-' | '=' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '-': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '>': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '.': {
            ++index;
            // ("and." | "not." | "or." | '..' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // "ot."
                  if (match = ignoreCaseStringTest("ot.", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'o':
               case 'O': {
                  ++index;
                  // "r."
                  if (match = ignoreCaseStringTest("r.", 2)) {
                     index += 2;
                  }
                  break;
               }
               case '.': {
                  ++index;
                  // '.'
                  if (match = buffer.matchChar(index, '.')) {
                     ++index;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "nd."
                  if (match = ignoreCaseStringTest("nd.", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '/': {
            ++index;
            // ('=' | <EMPTY>)
            match = buffer.matchChar(index, '=');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case ':': {
            ++index;
            // ('=' | ':' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case ':': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '{': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ';': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '<': {
            ++index;
            // ('=' | '<' | '>' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '<': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '>': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '|': {
            ++index;
            // ('|' | <EMPTY>)
            match = buffer.matchChar(index, '|');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case '=': {
            ++index;
            // ('=' | <EMPTY>)
            match = buffer.matchChar(index, '=');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case '}': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '>': {
            ++index;
            // ('=' | '>' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '>': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '~': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '?': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '@': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '[': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\\': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '^': {
            ++index;
            // ('=' | '^' | '^' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '^': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         case '_': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '!': {
            ++index;
            // ('=' | <EMPTY>)
            match = buffer.matchChar(index, '=');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case '\"': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '#': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '$': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '%': {
            ++index;
            // ('=' | <EMPTY>)
            match = buffer.matchChar(index, '=');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case '&': {
            ++index;
            // ('&' | <EMPTY>)
            match = buffer.matchChar(index, '&');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         }
         case '\'': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '(': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ')': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '*': {
            ++index;
            // ('*=' | '=' | '*' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '*': {
                  ++index;
                  // ('=' | <EMPTY>)
                  match = buffer.matchChar(index, '=');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
                  break;
               }
               default: {
                  match = true;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            separator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.SEPARATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            separator$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = -1;
         separator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchChunk : (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator))
   protected boolean matchChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator))
      // ResultSep!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // ResultSep
      match = resultSep$Rule();
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // OptionalMatchMarker
         match = optionalMatchMarker$Rule();
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            // MatchMarker
            match = matchMarker$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        // EscapedChar
                        match = escapedChar$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           // ']'
                           match = charMatcher(']');
                           if (! match) {
                              // Separator
                              match = separator$Rule();
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
   protected boolean idMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (idMarker$RuleMemoStart == index) {
         if (idMarker$RuleMemoStart <= idMarker$RuleMemoEnd) {
            index = idMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ID_MARKER, idMarker$RuleMemoStart, idMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (idMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(idMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // '>'
                  match = charMatcher('>');
               }
            }
         }
      }
      if (match) {
         idMarker$RuleMemoStart = startIndex;
         idMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            idMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ID_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            idMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         idMarker$RuleMemoStart = startIndex;
         idMarker$RuleMemoEnd = -1;
         idMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ListMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ',' IgnoreOptionalSpacing '...' IgnoreOptionalSpacing '>')
   protected boolean listMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (listMarker$RuleMemoStart == index) {
         if (listMarker$RuleMemoStart <= listMarker$RuleMemoEnd) {
            index = listMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LIST_MARKER, listMarker$RuleMemoStart, listMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (listMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(listMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ',' IgnoreOptionalSpacing '...' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '...'
                        match = stringMatcher("...", 3);
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         listMarker$RuleMemoStart = startIndex;
         listMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LIST_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         listMarker$RuleMemoStart = startIndex;
         listMarker$RuleMemoEnd = -1;
         listMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ':' IgnoreOptionalSpacing RestrictValues IgnoreOptionalSpacing '>')
   protected boolean restrictMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (restrictMarker$RuleMemoStart == index) {
         if (restrictMarker$RuleMemoStart <= restrictMarker$RuleMemoEnd) {
            index = restrictMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_MARKER, restrictMarker$RuleMemoStart, restrictMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (restrictMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(restrictMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ':' IgnoreOptionalSpacing RestrictValues IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ':'
                  match = charMatcher(':');
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // RestrictValues
                        match = restrictValues$Rule();
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         restrictMarker$RuleMemoStart = startIndex;
         restrictMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            restrictMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            restrictMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         restrictMarker$RuleMemoStart = startIndex;
         restrictMarker$RuleMemoEnd = -1;
         restrictMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WildMarker : ('<' IgnoreOptionalSpacing '*' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '*' IgnoreOptionalSpacing '>')
   protected boolean wildMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (wildMarker$RuleMemoStart == index) {
         if (wildMarker$RuleMemoStart <= wildMarker$RuleMemoEnd) {
            index = wildMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.WILD_MARKER, wildMarker$RuleMemoStart, wildMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (wildMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(wildMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '*' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '*' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '*'
            match = charMatcher('*');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '*'
                        match = charMatcher('*');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         wildMarker$RuleMemoStart = startIndex;
         wildMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            wildMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.WILD_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            wildMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         wildMarker$RuleMemoStart = startIndex;
         wildMarker$RuleMemoEnd = -1;
         wildMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExtendedMarker : ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
   protected boolean extendedMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (extendedMarker$RuleMemoStart == index) {
         if (extendedMarker$RuleMemoStart <= extendedMarker$RuleMemoEnd) {
            index = extendedMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.EXTENDED_MARKER, extendedMarker$RuleMemoStart, extendedMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (extendedMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(extendedMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '('
            match = charMatcher('(');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         extendedMarker$RuleMemoStart = startIndex;
         extendedMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            extendedMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.EXTENDED_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            extendedMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         extendedMarker$RuleMemoStart = startIndex;
         extendedMarker$RuleMemoEnd = -1;
         extendedMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierMarker : ('<' IgnoreOptionalSpacing '!' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '!' IgnoreOptionalSpacing '>')
   protected boolean identifierMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (identifierMarker$RuleMemoStart == index) {
         if (identifierMarker$RuleMemoStart <= identifierMarker$RuleMemoEnd) {
            index = identifierMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER_MARKER, identifierMarker$RuleMemoStart, identifierMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifierMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifierMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '!' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '!' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '!'
            match = charMatcher('!');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '!'
                        match = charMatcher('!');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         identifierMarker$RuleMemoStart = startIndex;
         identifierMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifierMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         identifierMarker$RuleMemoStart = startIndex;
         identifierMarker$RuleMemoEnd = -1;
         identifierMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictValues : (RestrictValue (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*)
   protected boolean restrictValues$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (RestrictValue (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*)
      // RestrictValue
      match = restrictValue$Rule();
      if (match) {
         // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ','
               match = charMatcher(',');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // RestrictValue
                     match = restrictValue$Rule();
                  }
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_VALUES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictValue : (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))+
   protected boolean restrictValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (restrictValue$RuleMemoStart == index) {
         if (restrictValue$RuleMemoStart <= restrictValue$RuleMemoEnd) {
            index = restrictValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_VALUE, restrictValue$RuleMemoStart, restrictValue$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (restrictValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(restrictValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))
      // ('>' | ',')!
      // ('>' | ',')
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case ',': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '>': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      index = startIndex_2;
      match = ! match;
      if (match) {
         // (Identifier | Literal | Ignore | EscapedChar | Separator)
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         switch(buffer.getChar(index)) {
            case '@':
            case '!':
            case '#':
            case '$':
            case '%':
            case '(':
            case ')':
            case '*':
            case '+':
            case ',':
            case '-':
            case ':':
            case '[':
            case '<':
            case '|':
            case '=':
            case '}':
            case '>':
            case '^':
            case '~':
            case '?': {
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
               break;
            }
            case '\\': {
               // EscapedChar
               match = escapedChar$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               break;
            }
            case '\"':
            case '\'':
            case '{':
            case '.': {
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               break;
            }
            case '&':
            case ';':
            case '/': {
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               break;
            }
            case '_': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               break;
            }
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9': {
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
               break;
            }
            case 'A':
            case 'B':
            case 'C':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case 'a':
            case 'b':
            case 'c':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
               break;
            }
            case 'D':
            case 'd': {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               break;
            }
            case ' ':
            case '\t':
            case '\f': {
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))
            // ('>' | ',')!
            // ('>' | ',')
            int startIndex_4 = index;
            switch(buffer.getChar(index)) {
               case ',': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '>': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_4;
            match = ! match;
            if (match) {
               // (Identifier | Literal | Ignore | EscapedChar | Separator)
               Node lastNode_5 = currentNode;
               int lastIndex_5 = index;
               switch(buffer.getChar(index)) {
                  case '@':
                  case '!':
                  case '#':
                  case '$':
                  case '%':
                  case '(':
                  case ')':
                  case '*':
                  case '+':
                  case ',':
                  case '-':
                  case ':':
                  case '[':
                  case '<':
                  case '|':
                  case '=':
                  case '}':
                  case '>':
                  case '^':
                  case '~':
                  case '?': {
                     // Separator
                     match = separator$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                     break;
                  }
                  case '\\': {
                     // EscapedChar
                     match = escapedChar$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        // Separator
                        match = separator$Rule();
                        if (! match) {
                           index = lastIndex_5;
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                        }
                     }
                     break;
                  }
                  case '\"':
                  case '\'':
                  case '{':
                  case '.': {
                     // Literal
                     match = literal$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        // Separator
                        match = separator$Rule();
                        if (! match) {
                           index = lastIndex_5;
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                        }
                     }
                     break;
                  }
                  case '&':
                  case ';':
                  case '/': {
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        // Separator
                        match = separator$Rule();
                        if (! match) {
                           index = lastIndex_5;
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                        }
                     }
                     break;
                  }
                  case '_': {
                     // Identifier
                     match = identifier$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        // Separator
                        match = separator$Rule();
                        if (! match) {
                           index = lastIndex_5;
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                        }
                     }
                     break;
                  }
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9': {
                     // Literal
                     match = literal$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                     break;
                  }
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z': {
                     // Identifier
                     match = identifier$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                     break;
                  }
                  case 'D':
                  case 'd': {
                     // Identifier
                     match = identifier$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        // Literal
                        match = literal$Rule();
                        if (! match) {
                           index = lastIndex_5;
                           lastNode_5.setSibling(null);
                           currentNode = lastNode_5;
                        }
                     }
                     break;
                  }
                  case ' ':
                  case '\t':
                  case '\f': {
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         restrictValue$RuleMemoStart = startIndex;
         restrictValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            restrictValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_VALUE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            restrictValue$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         restrictValue$RuleMemoStart = startIndex;
         restrictValue$RuleMemoEnd = -1;
         restrictValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NullMarker : ('<' IgnoreOptionalSpacing '-' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '-' IgnoreOptionalSpacing '>')
   protected boolean nullMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (nullMarker$RuleMemoStart == index) {
         if (nullMarker$RuleMemoStart <= nullMarker$RuleMemoEnd) {
            index = nullMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.NULL_MARKER, nullMarker$RuleMemoStart, nullMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nullMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nullMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '-' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '-' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '-'
            match = charMatcher('-');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '-'
                        match = charMatcher('-');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         nullMarker$RuleMemoStart = startIndex;
         nullMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nullMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.NULL_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nullMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         nullMarker$RuleMemoStart = startIndex;
         nullMarker$RuleMemoEnd = -1;
         nullMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultMarker : (IdMarker | DumbStringifyMarker | NormalStringifyMarker | SmartStringifyMarker | BlockifyMarker | LogifyMarker | NullMarker)
   protected boolean resultMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (resultMarker$RuleMemoStart == index) {
         if (resultMarker$RuleMemoStart <= resultMarker$RuleMemoEnd) {
            index = resultMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.RESULT_MARKER, resultMarker$RuleMemoStart, resultMarker$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (resultMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(resultMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IdMarker | DumbStringifyMarker | NormalStringifyMarker | SmartStringifyMarker | BlockifyMarker | LogifyMarker | NullMarker)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case ' ':
         case '#':
         case '&':
         case '\t':
         case ';':
         case '\f':
         case '/': {
            // DumbStringifyMarker
            match = dumbStringifyMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '<': {
            // IdMarker
            match = idMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NormalStringifyMarker
               match = normalStringifyMarker$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SmartStringifyMarker
                  match = smartStringifyMarker$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // BlockifyMarker
                     match = blockifyMarker$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // LogifyMarker
                        match = logifyMarker$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // NullMarker
                           match = nullMarker$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         resultMarker$RuleMemoStart = startIndex;
         resultMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            resultMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_MARKER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            resultMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         resultMarker$RuleMemoStart = startIndex;
         resultMarker$RuleMemoEnd = -1;
         resultMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DumbStringifyMarker : (DirectiveMark IgnoreOptionalSpacing '<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
   protected boolean dumbStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dumbStringifyMarker$RuleMemoStart == index) {
         if (dumbStringifyMarker$RuleMemoStart <= dumbStringifyMarker$RuleMemoEnd) {
            index = dumbStringifyMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DUMB_STRINGIFY_MARKER, dumbStringifyMarker$RuleMemoStart, dumbStringifyMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dumbStringifyMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dumbStringifyMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (DirectiveMark IgnoreOptionalSpacing '<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
      // DirectiveMark
      match = directiveMark$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '<'
            match = charMatcher('<');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '>'
                        match = charMatcher('>');
                     }
                  }
               }
            }
         }
      }
      if (match) {
         dumbStringifyMarker$RuleMemoStart = startIndex;
         dumbStringifyMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dumbStringifyMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DUMB_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dumbStringifyMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         dumbStringifyMarker$RuleMemoStart = startIndex;
         dumbStringifyMarker$RuleMemoEnd = -1;
         dumbStringifyMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NormalStringifyMarker : ('<' IgnoreOptionalSpacing (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | ('\'' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '\'')) IgnoreOptionalSpacing '>')
   protected boolean normalStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (normalStringifyMarker$RuleMemoStart == index) {
         if (normalStringifyMarker$RuleMemoStart <= normalStringifyMarker$RuleMemoEnd) {
            index = normalStringifyMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.NORMAL_STRINGIFY_MARKER, normalStringifyMarker$RuleMemoStart, normalStringifyMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (normalStringifyMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(normalStringifyMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | ('\'' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '\'')) IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | ('\'' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '\''))
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"')
            // '"'
            match = charMatcher('\"');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '"'
                        match = charMatcher('\"');
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('\'' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '\'')
               // '\''
               match = charMatcher('\'');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // Identifier
                     match = identifier$Rule();
                     if (match) {
                        // IgnoreOptionalSpacing
                        match = ignoreOptionalSpacing$Rule();
                        if (match) {
                           // '\''
                           match = charMatcher('\'');
                        }
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // '>'
                  match = charMatcher('>');
               }
            }
         }
      }
      if (match) {
         normalStringifyMarker$RuleMemoStart = startIndex;
         normalStringifyMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            normalStringifyMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.NORMAL_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            normalStringifyMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         normalStringifyMarker$RuleMemoStart = startIndex;
         normalStringifyMarker$RuleMemoEnd = -1;
         normalStringifyMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SmartStringifyMarker : ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
   protected boolean smartStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (smartStringifyMarker$RuleMemoStart == index) {
         if (smartStringifyMarker$RuleMemoStart <= smartStringifyMarker$RuleMemoEnd) {
            index = smartStringifyMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.SMART_STRINGIFY_MARKER, smartStringifyMarker$RuleMemoStart, smartStringifyMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (smartStringifyMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(smartStringifyMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '('
            match = charMatcher('(');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         smartStringifyMarker$RuleMemoStart = startIndex;
         smartStringifyMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            smartStringifyMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.SMART_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            smartStringifyMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         smartStringifyMarker$RuleMemoStart = startIndex;
         smartStringifyMarker$RuleMemoEnd = -1;
         smartStringifyMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockifyMarker : ('<' IgnoreOptionalSpacing '{' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '}' IgnoreOptionalSpacing '>')
   protected boolean blockifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (blockifyMarker$RuleMemoStart == index) {
         if (blockifyMarker$RuleMemoStart <= blockifyMarker$RuleMemoEnd) {
            index = blockifyMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.BLOCKIFY_MARKER, blockifyMarker$RuleMemoStart, blockifyMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (blockifyMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(blockifyMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '{' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '}' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '{'
            match = charMatcher('{');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '}'
                        match = charMatcher('}');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         blockifyMarker$RuleMemoStart = startIndex;
         blockifyMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockifyMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.BLOCKIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            blockifyMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         blockifyMarker$RuleMemoStart = startIndex;
         blockifyMarker$RuleMemoEnd = -1;
         blockifyMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogifyMarker : ('<' IgnoreOptionalSpacing '.' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '.' IgnoreOptionalSpacing '>')
   protected boolean logifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (logifyMarker$RuleMemoStart == index) {
         if (logifyMarker$RuleMemoStart <= logifyMarker$RuleMemoEnd) {
            index = logifyMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LOGIFY_MARKER, logifyMarker$RuleMemoStart, logifyMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (logifyMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(logifyMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '.' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '.' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '.'
                        match = charMatcher('.');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         logifyMarker$RuleMemoStart = startIndex;
         logifyMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            logifyMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LOGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            logifyMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         logifyMarker$RuleMemoStart = startIndex;
         logifyMarker$RuleMemoEnd = -1;
         logifyMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarker : ('[' IgnoreOptionalSpacing OptionalResultMarkerPattern IgnoreOptionalSpacing ']')
   protected boolean optionalResultMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalResultMarker$RuleMemoStart == index) {
         if (optionalResultMarker$RuleMemoStart <= optionalResultMarker$RuleMemoEnd) {
            index = optionalResultMarker$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_RESULT_MARKER, optionalResultMarker$RuleMemoStart, optionalResultMarker$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (optionalResultMarker$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalResultMarker$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('[' IgnoreOptionalSpacing OptionalResultMarkerPattern IgnoreOptionalSpacing ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // OptionalResultMarkerPattern
            match = optionalResultMarkerPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ']'
                  match = charMatcher(']');
               }
            }
         }
      }
      if (match) {
         optionalResultMarker$RuleMemoStart = startIndex;
         optionalResultMarker$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalResultMarker$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_RESULT_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalResultMarker$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         optionalResultMarker$RuleMemoStart = startIndex;
         optionalResultMarker$RuleMemoEnd = -1;
         optionalResultMarker$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarkerPattern : OptionalResultMarkerChunk+
   protected boolean optionalResultMarkerPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // OptionalResultMarkerChunk+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // OptionalResultMarkerChunk
      match = optionalResultMarkerChunk$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // OptionalResultMarkerChunk
            match = optionalResultMarkerChunk$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarkerChunk : (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
   protected boolean optionalResultMarkerChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '@':
         case '!':
         case '$':
         case '%':
         case '(':
         case ')':
         case '*':
         case '+':
         case ',':
         case '-':
         case ':':
         case '|':
         case '=':
         case '}':
         case '>':
         case '^':
         case '~':
         case '?': {
            // Separator
            match = separator$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '[': {
            // OptionalResultMarker
            match = optionalResultMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '#':
         case '<': {
            // ResultMarker
            match = resultMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\\': {
            // EscapedChar
            match = escapedChar$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\"':
         case '\'':
         case '{':
         case '.': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '&':
         case ';':
         case '/': {
            // ResultMarker
            match = resultMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Separator
                  match = separator$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case '_': {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case 'a':
         case 'b':
         case 'c':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'D':
         case 'd': {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case ' ':
         case '\t':
         case '\f': {
            // ResultMarker
            match = resultMarker$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_RESULT_MARKER_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultChunk : (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
   protected boolean resultChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // OptionalResultMarker
      match = optionalResultMarker$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ResultMarker
         match = resultMarker$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Literal
               match = literal$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Ignore
                  match = ignore$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // EscapedChar
                     match = escapedChar$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ']'
                        match = charMatcher(']');
                        if (! match) {
                           // Separator
                           match = separator$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDef : ("ifde" "f"?)
   protected boolean ifDef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ifde" "f"?)
      // "ifde"
      match = ignoreCaseStringMatcher("ifde", 4);
      if (match) {
         // "f"?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // "f"
         match = ignoreCaseCharMatcher('f');
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_DEF, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDef : ("ifnd" ("ef" | "e")?)
   protected boolean ifNDef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ifnd" ("ef" | "e")?)
      // "ifnd"
      match = ignoreCaseStringMatcher("ifnd", 4);
      if (match) {
         // ("ef" | "e")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ef" | "e")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("f" | <EMPTY>)
            match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_NDEF, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DiscardedRemainingLine : (EndStmt! .)*
   protected boolean discardedRemainingLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (discardedRemainingLine$RuleMemoStart == index) {
         if (discardedRemainingLine$RuleMemoStart <= discardedRemainingLine$RuleMemoEnd) {
            index = discardedRemainingLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DISCARDED_REMAINING_LINE, discardedRemainingLine$RuleMemoStart, discardedRemainingLine$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (discardedRemainingLine$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(discardedRemainingLine$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (EndStmt! .)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (EndStmt! .)
         // EndStmt!
         // EndStmt
         match = endStmt$Rule();
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher();
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      discardedRemainingLine$RuleMemoStart = startIndex;
      discardedRemainingLine$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         discardedRemainingLine$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourPPRuleType.DISCARDED_REMAINING_LINE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         discardedRemainingLine$RuleMemoFirstNode = currentNode;
      }
      return true;
   }

   //ElseIf : ("else" ("if" | "i")?)
   protected boolean elseIf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("else" ("if" | "i")?)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // ("if" | "i")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("if" | "i")
         match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
         if (match) {
            ++index;
            // ("f" | <EMPTY>)
            match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
            if (match) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_IF, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIf : ("endi" "f"?)
   protected boolean endIf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("endi" "f"?)
      // "endi"
      match = ignoreCaseStringMatcher("endi", 4);
      if (match) {
         // "f"?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // "f"
         match = ignoreCaseCharMatcher('f');
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_IF, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Undef : ("unde" "f"?)
   protected boolean undef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("unde" "f"?)
      // "unde"
      match = ignoreCaseStringMatcher("unde", 4);
      if (match) {
         // "f"?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // "f"
         match = ignoreCaseCharMatcher('f');
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Include : ("incl" ("ude" | "ud" | "u")?)
   protected boolean include$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("incl" ("ude" | "ud" | "u")?)
      // "incl"
      match = ignoreCaseStringMatcher("incl", 4);
      if (match) {
         // ("ude" | "ud" | "u")?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("ude" | "ud" | "u")
         match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
         if (match) {
            ++index;
            // ("de" | "d" | <EMPTY>)
            match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
            if (match) {
               ++index;
               // ("e" | <EMPTY>)
               match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
               if (match) {
                  ++index;
                  // <EMPTY>
                  match = true;
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoubleQuoteString : ('"' (('\n' | '"')! .)* '"')
   protected boolean doubleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (doubleQuoteString$RuleMemoStart == index) {
         if (doubleQuoteString$RuleMemoStart <= doubleQuoteString$RuleMemoEnd) {
            index = doubleQuoteString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DOUBLE_QUOTE_STRING, doubleQuoteString$RuleMemoStart, doubleQuoteString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (doubleQuoteString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(doubleQuoteString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('"' (('\n' | '"')! .)* '"')
      // '"'
      match = charMatcher('\"');
      if (match) {
         // (('\n' | '"')! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | '"')! .)
            // ('\n' | '"')!
            // ('\n' | '"')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // '"'
         match = charMatcher('\"');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         doubleQuoteString$RuleMemoStart = startIndex;
         doubleQuoteString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doubleQuoteString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DOUBLE_QUOTE_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            doubleQuoteString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         doubleQuoteString$RuleMemoStart = startIndex;
         doubleQuoteString$RuleMemoEnd = -1;
         doubleQuoteString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SingleQuoteString : ('\'' (('\n' | '\'')! .)* '\'')
   protected boolean singleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (singleQuoteString$RuleMemoStart == index) {
         if (singleQuoteString$RuleMemoStart <= singleQuoteString$RuleMemoEnd) {
            index = singleQuoteString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.SINGLE_QUOTE_STRING, singleQuoteString$RuleMemoStart, singleQuoteString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (singleQuoteString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(singleQuoteString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\'' (('\n' | '\'')! .)* '\'')
      // '\''
      match = charMatcher('\'');
      if (match) {
         // (('\n' | '\'')! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | '\'')! .)
            // ('\n' | '\'')!
            // ('\n' | '\'')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '\'': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // '\''
         match = charMatcher('\'');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         singleQuoteString$RuleMemoStart = startIndex;
         singleQuoteString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            singleQuoteString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.SINGLE_QUOTE_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            singleQuoteString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         singleQuoteString$RuleMemoStart = startIndex;
         singleQuoteString$RuleMemoEnd = -1;
         singleQuoteString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginDumpBlock : ("pragma" IgnoreSpacing "begindump")
   protected boolean beginDumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("pragma" IgnoreSpacing "begindump")
      // "pragma"
      match = ignoreCaseStringMatcher("pragma", 6);
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // "begindump"
            match = ignoreCaseStringMatcher("begindump", 9);
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BEGIN_DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndDumpBlock : ("pragma" IgnoreSpacing "enddump")
   protected boolean endDumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endDumpBlock$RuleMemoStart == index) {
         if (endDumpBlock$RuleMemoStart <= endDumpBlock$RuleMemoEnd) {
            index = endDumpBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.END_DUMP_BLOCK, endDumpBlock$RuleMemoStart, endDumpBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endDumpBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endDumpBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("pragma" IgnoreSpacing "enddump")
      // "pragma"
      match = ignoreCaseStringMatcher("pragma", 6);
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // "enddump"
            match = ignoreCaseStringMatcher("enddump", 7);
         }
      }
      if (match) {
         endDumpBlock$RuleMemoStart = startIndex;
         endDumpBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endDumpBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.END_DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endDumpBlock$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         endDumpBlock$RuleMemoStart = startIndex;
         endDumpBlock$RuleMemoEnd = -1;
         endDumpBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BracketSequence : (('[' (']'! AnyRule)+ ']') | BracketString)
   protected boolean bracketSequence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (bracketSequence$RuleMemoStart == index) {
         if (bracketSequence$RuleMemoStart <= bracketSequence$RuleMemoEnd) {
            index = bracketSequence$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_SEQUENCE, bracketSequence$RuleMemoStart, bracketSequence$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (bracketSequence$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bracketSequence$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (('[' (']'! AnyRule)+ ']') | BracketString)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('[' (']'! AnyRule)+ ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // (']'! AnyRule)+
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // (']'! AnyRule)
         // ']'!
         // ']'
         match = buffer.matchChar(index, ']');
         match = ! match;
         if (match) {
            // AnyRule
            match = anyRule$Rule();
         }
         if (match) {
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // (']'! AnyRule)
               // ']'!
               // ']'
               match = buffer.matchChar(index, ']');
               match = ! match;
               if (match) {
                  // AnyRule
                  match = anyRule$Rule();
               }
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         } else {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
         }
         if (match) {
            // ']'
            match = charMatcher(']');
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // BracketString
         match = bracketString$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         bracketSequence$RuleMemoStart = startIndex;
         bracketSequence$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bracketSequence$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_SEQUENCE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bracketSequence$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         bracketSequence$RuleMemoStart = startIndex;
         bracketSequence$RuleMemoEnd = -1;
         bracketSequence$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyRule : (BracketSequence | Literal | Ignore | Identifier | Separator)
   protected boolean anyRule$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyRule$RuleMemoStart == index) {
         if (anyRule$RuleMemoStart <= anyRule$RuleMemoEnd) {
            index = anyRule$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULE, anyRule$RuleMemoStart, anyRule$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (anyRule$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyRule$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (BracketSequence | Literal | Ignore | Identifier | Separator)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '@':
         case '!':
         case '#':
         case '$':
         case '%':
         case '(':
         case ')':
         case '*':
         case '+':
         case ',':
         case '-':
         case ':':
         case '<':
         case '\\':
         case '|':
         case '=':
         case '}':
         case '>':
         case '^':
         case '~':
         case '?': {
            // Separator
            match = separator$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '[': {
            // BracketSequence
            match = bracketSequence$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\"':
         case '\'':
         case '{':
         case '.': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '&':
         case ';':
         case '/': {
            // Ignore
            match = ignore$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '_': {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Separator
               match = separator$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'A':
         case 'B':
         case 'C':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case 'a':
         case 'b':
         case 'c':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z': {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'D':
         case 'd': {
            // Literal
            match = literal$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case ' ':
         case '\t':
         case '\f': {
            // Ignore
            match = ignore$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         anyRule$RuleMemoStart = startIndex;
         anyRule$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyRule$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyRule$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         anyRule$RuleMemoStart = startIndex;
         anyRule$RuleMemoEnd = -1;
         anyRule$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BracketString : ('[' (('\n' | ']')! .)* ']')
   protected boolean bracketString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (bracketString$RuleMemoStart == index) {
         if (bracketString$RuleMemoStart <= bracketString$RuleMemoEnd) {
            index = bracketString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_STRING, bracketString$RuleMemoStart, bracketString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bracketString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bracketString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('[' (('\n' | ']')! .)* ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // (('\n' | ']')! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (('\n' | ']')! .)
            // ('\n' | ']')!
            // ('\n' | ']')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case ']': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // ']'
         match = charMatcher(']');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         bracketString$RuleMemoStart = startIndex;
         bracketString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bracketString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            bracketString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         bracketString$RuleMemoStart = startIndex;
         bracketString$RuleMemoEnd = -1;
         bracketString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalLiteral : (".T." | ".F." | ".Y." | ".N.")
   protected boolean logicalLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (logicalLiteral$RuleMemoStart == index) {
         if (logicalLiteral$RuleMemoStart <= logicalLiteral$RuleMemoEnd) {
            index = logicalLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.LOGICAL_LITERAL, logicalLiteral$RuleMemoStart, logicalLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (logicalLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(logicalLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (".T." | ".F." | ".Y." | ".N.")
      match = buffer.matchChar(index, '.');
      if (match) {
         ++index;
         // ("T." | "F." | "Y." | "N.")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 'n':
            case 'N': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 'y':
            case 'Y': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            case 't':
            case 'T': {
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            logicalLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.LOGICAL_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            logicalLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = -1;
         logicalLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimeLiteral : (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}'))
   protected boolean dateTimeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (dateTimeLiteral$RuleMemoStart == index) {
         if (dateTimeLiteral$RuleMemoStart <= dateTimeLiteral$RuleMemoEnd) {
            index = dateTimeLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DATE_TIME_LITERAL, dateTimeLiteral$RuleMemoStart, dateTimeLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dateTimeLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dateTimeLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('0d' Digit Digit Digit Digit Digit Digit Digit Digit)
      // '0d'
      match = stringMatcher("0d", 2);
      if (match) {
         // '0'-'9'
         match = charRangeMatcher('0', '9');
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (match) {
                     // '0'-'9'
                     match = charRangeMatcher('0', '9');
                     if (match) {
                        // '0'-'9'
                        match = charRangeMatcher('0', '9');
                        if (match) {
                           // '0'-'9'
                           match = charRangeMatcher('0', '9');
                           if (match) {
                              // '0'-'9'
                              match = charRangeMatcher('0', '9');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("d" (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']')))
         // "d"
         match = ignoreCaseCharMatcher('d');
         if (match) {
            // (('"' DatePattern ("T"? TimePattern)? '"') | ('\'' DatePattern ("T"? TimePattern)? '\'') | ('[' DatePattern ("T"? TimePattern)? ']'))
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ('"' DatePattern ("T"? TimePattern)? '"')
            // '"'
            match = charMatcher('\"');
            if (match) {
               // DatePattern
               match = datePattern$Rule();
               if (match) {
                  // ("T"? TimePattern)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ("T"? TimePattern)
                  // "T"?
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // "T"
                  match = ignoreCaseCharMatcher('T');
                  if (! match) {
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                     index = lastIndex_4;
                     match = true;
                  }
                  if (match) {
                     // TimePattern
                     match = timePattern$Rule();
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
                  if (match) {
                     // '"'
                     match = charMatcher('\"');
                  }
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // ('\'' DatePattern ("T"? TimePattern)? '\'')
               // '\''
               match = charMatcher('\'');
               if (match) {
                  // DatePattern
                  match = datePattern$Rule();
                  if (match) {
                     // ("T"? TimePattern)?
                     Node lastNode_5 = currentNode;
                     int lastIndex_5 = index;
                     // ("T"? TimePattern)
                     // "T"?
                     Node lastNode_6 = currentNode;
                     int lastIndex_6 = index;
                     // "T"
                     match = ignoreCaseCharMatcher('T');
                     if (! match) {
                        lastNode_6.setSibling(null);
                        currentNode = lastNode_6;
                        index = lastIndex_6;
                        match = true;
                     }
                     if (match) {
                        // TimePattern
                        match = timePattern$Rule();
                     }
                     if (! match) {
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        index = lastIndex_5;
                        match = true;
                     }
                     if (match) {
                        // '\''
                        match = charMatcher('\'');
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ('[' DatePattern ("T"? TimePattern)? ']')
                  // '['
                  match = charMatcher('[');
                  if (match) {
                     // DatePattern
                     match = datePattern$Rule();
                     if (match) {
                        // ("T"? TimePattern)?
                        Node lastNode_7 = currentNode;
                        int lastIndex_7 = index;
                        // ("T"? TimePattern)
                        // "T"?
                        Node lastNode_8 = currentNode;
                        int lastIndex_8 = index;
                        // "T"
                        match = ignoreCaseCharMatcher('T');
                        if (! match) {
                           lastNode_8.setSibling(null);
                           currentNode = lastNode_8;
                           index = lastIndex_8;
                           match = true;
                        }
                        if (match) {
                           // TimePattern
                           match = timePattern$Rule();
                        }
                        if (! match) {
                           lastNode_7.setSibling(null);
                           currentNode = lastNode_7;
                           index = lastIndex_7;
                           match = true;
                        }
                        if (match) {
                           // ']'
                           match = charMatcher(']');
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}')
            // '{'
            match = charMatcher('{');
            if (match) {
               // '^'
               match = charMatcher('^');
               if (match) {
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)?
                  Node lastNode_9 = currentNode;
                  int lastIndex_9 = index;
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (match) {
                     // ('-' | '/')
                     switch(buffer.getChar(index)) {
                        case '-': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        case '/': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // IntegerNumber
                        match = integerNumber$Rule();
                        if (match) {
                           // ('-' | '/')
                           switch(buffer.getChar(index)) {
                              case '-': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              case '/': {
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                           if (match) {
                              // IntegerNumber
                              match = integerNumber$Rule();
                              if (match) {
                                 // ','?
                                 Node lastNode_10 = currentNode;
                                 int lastIndex_10 = index;
                                 // ','
                                 match = charMatcher(',');
                                 if (! match) {
                                    lastNode_10.setSibling(null);
                                    currentNode = lastNode_10;
                                    index = lastIndex_10;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     lastNode_9.setSibling(null);
                     currentNode = lastNode_9;
                     index = lastIndex_9;
                     match = true;
                  }
                  if (match) {
                     // TimePattern?
                     Node lastNode_11 = currentNode;
                     int lastIndex_11 = index;
                     // TimePattern
                     match = timePattern$Rule();
                     if (! match) {
                        lastNode_11.setSibling(null);
                        currentNode = lastNode_11;
                        index = lastIndex_11;
                        match = true;
                     }
                     if (match) {
                        // Ignore
                        match = ignore$Rule();
                        if (match) {
                           // '}'
                           match = charMatcher('}');
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dateTimeLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DATE_TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            dateTimeLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = -1;
         dateTimeLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberLiteral : ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
   protected boolean numberLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (numberLiteral$RuleMemoStart == index) {
         if (numberLiteral$RuleMemoStart <= numberLiteral$RuleMemoEnd) {
            index = numberLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.NUMBER_LITERAL, numberLiteral$RuleMemoStart, numberLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (numberLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numberLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (IntegerNumber '.' IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (IntegerNumber '.' Letter!)
         // IntegerNumber
         match = integerNumber$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // Letter!
               // Letter
               match = letter$Rule();
               match = ! match;
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // IntegerNumber
            match = integerNumber$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('.' IntegerNumber)
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numberLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.NUMBER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            numberLiteral$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = -1;
         numberLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultiLineDoubleQuoteString : ('"' (MultilineDoubleQuoteStringSegment BreakString)+ (('\n' | '"')! .)* '"')
   protected boolean multiLineDoubleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (multiLineDoubleQuoteString$RuleMemoStart == index) {
         if (multiLineDoubleQuoteString$RuleMemoStart <= multiLineDoubleQuoteString$RuleMemoEnd) {
            index = multiLineDoubleQuoteString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_DOUBLE_QUOTE_STRING, multiLineDoubleQuoteString$RuleMemoStart, multiLineDoubleQuoteString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multiLineDoubleQuoteString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multiLineDoubleQuoteString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('"' (MultilineDoubleQuoteStringSegment BreakString)+ (('\n' | '"')! .)* '"')
      // '"'
      match = charMatcher('\"');
      if (match) {
         // (MultilineDoubleQuoteStringSegment BreakString)+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (MultilineDoubleQuoteStringSegment BreakString)
         // MultilineDoubleQuoteStringSegment
         match = multilineDoubleQuoteStringSegment$Rule();
         if (match) {
            // BreakString
            match = breakString$Rule();
         }
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // (MultilineDoubleQuoteStringSegment BreakString)
               // MultilineDoubleQuoteStringSegment
               match = multilineDoubleQuoteStringSegment$Rule();
               if (match) {
                  // BreakString
                  match = breakString$Rule();
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
         if (match) {
            // (('\n' | '"')! .)*
            Node lastNode_2;
            int lastIndex_2;
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // (('\n' | '"')! .)
               // ('\n' | '"')!
               // ('\n' | '"')
               int startIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '\"': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '\n': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               index = startIndex_3;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
               }
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            // '"'
            match = charMatcher('\"');
         }
      }
      if (match) {
         multiLineDoubleQuoteString$RuleMemoStart = startIndex;
         multiLineDoubleQuoteString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multiLineDoubleQuoteString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_DOUBLE_QUOTE_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multiLineDoubleQuoteString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         multiLineDoubleQuoteString$RuleMemoStart = startIndex;
         multiLineDoubleQuoteString$RuleMemoEnd = -1;
         multiLineDoubleQuoteString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultiLineSingleQuoteString : ('\'' (MultilineSingleQuoteStringSegment BreakString)+ (('\n' | '\'')! .)* '\'')
   protected boolean multiLineSingleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (multiLineSingleQuoteString$RuleMemoStart == index) {
         if (multiLineSingleQuoteString$RuleMemoStart <= multiLineSingleQuoteString$RuleMemoEnd) {
            index = multiLineSingleQuoteString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_SINGLE_QUOTE_STRING, multiLineSingleQuoteString$RuleMemoStart, multiLineSingleQuoteString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multiLineSingleQuoteString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multiLineSingleQuoteString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('\'' (MultilineSingleQuoteStringSegment BreakString)+ (('\n' | '\'')! .)* '\'')
      // '\''
      match = charMatcher('\'');
      if (match) {
         // (MultilineSingleQuoteStringSegment BreakString)+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (MultilineSingleQuoteStringSegment BreakString)
         // MultilineSingleQuoteStringSegment
         match = multilineSingleQuoteStringSegment$Rule();
         if (match) {
            // BreakString
            match = breakString$Rule();
         }
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // (MultilineSingleQuoteStringSegment BreakString)
               // MultilineSingleQuoteStringSegment
               match = multilineSingleQuoteStringSegment$Rule();
               if (match) {
                  // BreakString
                  match = breakString$Rule();
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
         if (match) {
            // (('\n' | '\'')! .)*
            Node lastNode_2;
            int lastIndex_2;
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // (('\n' | '\'')! .)
               // ('\n' | '\'')!
               // ('\n' | '\'')
               int startIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '\'': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '\n': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               index = startIndex_3;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
               }
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            // '\''
            match = charMatcher('\'');
         }
      }
      if (match) {
         multiLineSingleQuoteString$RuleMemoStart = startIndex;
         multiLineSingleQuoteString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multiLineSingleQuoteString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_SINGLE_QUOTE_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multiLineSingleQuoteString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         multiLineSingleQuoteString$RuleMemoStart = startIndex;
         multiLineSingleQuoteString$RuleMemoEnd = -1;
         multiLineSingleQuoteString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BreakString : (';' (' ' | '\t' | '\f')* NewLine)
   protected boolean breakString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (breakString$RuleMemoStart == index) {
         if (breakString$RuleMemoStart <= breakString$RuleMemoEnd) {
            index = breakString$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.BREAK_STRING, breakString$RuleMemoStart, breakString$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (breakString$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(breakString$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (';' (' ' | '\t' | '\f')* NewLine)
      // ';'
      match = charMatcher(';');
      if (match) {
         // (' ' | '\t' | '\f')*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (' ' | '\t' | '\f')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '\f': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case ' ': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\t': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               index = startIndex_2;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(HarbourPPRuleType.TERMINAL, startIndex_2, index, false, false));
               currentNode = currentNode.getSibling();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // NewLine
         match = newLine$Rule();
      }
      if (match) {
         breakString$RuleMemoStart = startIndex;
         breakString$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            breakString$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.BREAK_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            breakString$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         breakString$RuleMemoStart = startIndex;
         breakString$RuleMemoEnd = -1;
         breakString$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultilineDoubleQuoteStringSegment : ((('\n' | '"') | BreakString)! .)+
   protected boolean multilineDoubleQuoteStringSegment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((('\n' | '"') | BreakString)! .)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ((('\n' | '"') | BreakString)! .)
      // (('\n' | '"') | BreakString)!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' | '"') | BreakString)
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // ('\n' | '"')
      switch(buffer.getChar(index)) {
         case '\"': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = lastIndex_3;
         lastNode_3.setSibling(null);
         currentNode = lastNode_3;
         // BreakString
         match = breakString$Rule();
         if (! match) {
            index = lastIndex_3;
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
         }
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ((('\n' | '"') | BreakString)! .)
            // (('\n' | '"') | BreakString)!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' | '"') | BreakString)
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // ('\n' | '"')
            switch(buffer.getChar(index)) {
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               index = lastIndex_5;
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               // BreakString
               match = breakString$Rule();
               if (! match) {
                  index = lastIndex_5;
                  lastNode_5.setSibling(null);
                  currentNode = lastNode_5;
               }
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTILINE_DOUBLE_QUOTE_STRING_SEGMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultilineSingleQuoteStringSegment : ((('\n' | '\'') | BreakString)! .)+
   protected boolean multilineSingleQuoteStringSegment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((('\n' | '\'') | BreakString)! .)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ((('\n' | '\'') | BreakString)! .)
      // (('\n' | '\'') | BreakString)!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' | '\'') | BreakString)
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // ('\n' | '\'')
      switch(buffer.getChar(index)) {
         case '\'': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = lastIndex_3;
         lastNode_3.setSibling(null);
         currentNode = lastNode_3;
         // BreakString
         match = breakString$Rule();
         if (! match) {
            index = lastIndex_3;
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
         }
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ((('\n' | '\'') | BreakString)! .)
            // (('\n' | '\'') | BreakString)!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' | '\'') | BreakString)
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // ('\n' | '\'')
            switch(buffer.getChar(index)) {
               case '\'': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               index = lastIndex_5;
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               // BreakString
               match = breakString$Rule();
               if (! match) {
                  index = lastIndex_5;
                  lastNode_5.setSibling(null);
                  currentNode = lastNode_5;
               }
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTILINE_SINGLE_QUOTE_STRING_SEGMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Letter : ('a'-'z' | 'A'-'Z')
   protected boolean letter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('a'-'z' | 'A'-'Z')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LETTER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IntegerNumber : Digit+
   protected boolean integerNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (integerNumber$RuleMemoStart == index) {
         if (integerNumber$RuleMemoStart <= integerNumber$RuleMemoEnd) {
            index = integerNumber$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.INTEGER_NUMBER, integerNumber$RuleMemoStart, integerNumber$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (integerNumber$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(integerNumber$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // Digit+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // '0'-'9'
            match = charRangeMatcher('0', '9');
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integerNumber$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.INTEGER_NUMBER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            integerNumber$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = -1;
         integerNumber$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimePattern : (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
   protected boolean timePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (timePattern$RuleMemoStart == index) {
         if (timePattern$RuleMemoStart <= timePattern$RuleMemoEnd) {
            index = timePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.TIME_PATTERN, timePattern$RuleMemoStart, timePattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (timePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)
         // ':'
         match = charMatcher(':');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // (':' IntegerNumber)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (':' IntegerNumber)
               // ':'
               match = charMatcher(':');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ('.' IntegerNumber)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ('.' IntegerNumber)
                  // '.'
                  match = charMatcher('.');
                  if (match) {
                     // IntegerNumber
                     match = integerNumber$Rule();
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // ("AM" | "PM")?
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // ("AM" | "PM")
            switch(buffer.getChar(index)) {
               case 'p':
               case 'P': {
                  ++index;
                  // "M"
                  if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                     ++index;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "M"
                  if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                     ++index;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
               index = lastIndex_4;
               match = true;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.TIME_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            timePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = -1;
         timePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DatePattern : (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
   protected boolean datePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (datePattern$RuleMemoStart == index) {
         if (datePattern$RuleMemoStart <= datePattern$RuleMemoEnd) {
            index = datePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.DATE_PATTERN, datePattern$RuleMemoStart, datePattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (datePattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(datePattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // ('-' | '/' | '.')
         switch(buffer.getChar(index)) {
            case '-': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case '.': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            case '/': {
               ++index;
               // <EMPTY>
               match = true;
               break;
            }
            default: {
               match = false;
            }
         }
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // ('-' | '/' | '.')
               switch(buffer.getChar(index)) {
                  case '-': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '.': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '/': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            datePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.DATE_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            datePattern$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = -1;
         datePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Identifier : (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
   protected boolean identifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (identifier$RuleMemoStart == index) {
         if (identifier$RuleMemoStart <= identifier$RuleMemoEnd) {
            index = identifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER, identifier$RuleMemoStart, identifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
      // ('A'-'Z' | 'a'-'z' | '_')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'A'-'Z'
      match = charRangeMatcher('A', 'Z');
      if (! match) {
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // '_'
            match = charMatcher('_');
         }
      }
      if (match) {
         // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*
         Node lastNode_2;
         int lastIndex_2;
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
            if (! match) {
               // 'a'-'z'
               match = charRangeMatcher('a', 'z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            identifier$RuleMemoFirstNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = -1;
         identifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }
}
