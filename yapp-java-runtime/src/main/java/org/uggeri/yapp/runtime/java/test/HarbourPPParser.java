/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

package org.uggeri.yapp.runtime.java.test;

import org.uggeri.yapp.runtime.java.parser.Parser;
import org.uggeri.yapp.runtime.java.parser.Rule;
import org.uggeri.yapp.runtime.java.parser.RuleProfile;
import org.uggeri.yapp.runtime.java.buffer.InputBuffer;
import org.uggeri.yapp.runtime.java.node.Node;
import org.uggeri.yapp.runtime.java.node.NodeImpl;
import org.uggeri.yapp.runtime.java.parser.ParserError;
import org.uggeri.yapp.runtime.java.trace.TraceParser;
import java.util.Collections;
import java.util.Collection;
import java.util.Arrays;
import java.util.Map;

public class HarbourPPParser implements Parser {

   private int index = 0;

   private InputBuffer buffer;

   private boolean currentRuleIsAtomic = false;

   private Node currentNode = new NodeImpl(null, 0, 0, false, false);

   private int ignore$RuleMemoStart = -1;
   private int ignore$RuleMemoEnd;
   private Node ignore$RuleMemoFirstNode;
   private Node ignore$RuleMemoLastNode;
   private int blockComment$RuleMemoStart = -1;
   private int blockComment$RuleMemoEnd;
   private int continueNL$RuleMemoStart = -1;
   private int continueNL$RuleMemoEnd;
   private Node continueNL$RuleMemoFirstNode;
   private Node continueNL$RuleMemoLastNode;
   private int aloneLineComment$RuleMemoStart = -1;
   private int aloneLineComment$RuleMemoEnd;
   private int integerNumber$RuleMemoStart = -1;
   private int integerNumber$RuleMemoEnd;

   private int[] newArrayInt(final int size) {
      final int[] array = new int[size];
      Arrays.fill(array, -1);
      return array;
   }

   protected boolean charMatcher(char c) {
      if (buffer.matchChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean ignoreCaseCharMatcher(char c) {
      if (buffer.matchIgnoreCaseChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean stringMatcher(String str, int strLen) {
      if (buffer.matchString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean ignoreCaseStringMatcher(String str, int strLen) {
      if (buffer.matchIgnoreCaseString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialIgnoreCaseStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean charRangeMatcher(char charIni, char charEnd) {
      if (buffer.matchCharRange(index, charIni, charEnd)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean anyCharMatcher() {
      if (buffer.getChar(index) != '\0') {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean eoi() {
      if (buffer.getChar(index) == '\0') {
         return true;
      }
      return false;
   }

   protected boolean charTest(char c) {
      return buffer.getChar(index) == c;
   }

   protected boolean ignoreCaseCharTest(char c) {
      return buffer.matchIgnoreCaseChar(index, c);
   }

   protected boolean stringTest(String str, int strLen) {
      return buffer.matchString(index, str, strLen);
   }

   protected boolean partialStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean ignoreCaseStringTest(String str, int strLen) {
      return buffer.matchIgnoreCaseString(index, str, strLen);
   }

   protected boolean partialIgnoreCaseStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean charRangeTest(char charIni, char charEnd) {
      return buffer.matchCharRange(index, charIni, charEnd);
   }

   protected boolean anyCharTest() {
      return buffer.getChar(index) != '\0';
   }

   protected boolean eoiTest() {
      return buffer.getChar(index) == '\0';
   }
   @Override
   public Map<Rule, RuleProfile> getProfilesMap() {
      return Collections.emptyMap();
   }

   @Override
   public void setProfilesMap(Map<Rule, RuleProfile> profilesMap) {
   }

   @Override
   public Collection<ParserError> getMismatches() {
      return Collections.emptyList();
   }

   @Override
   public void setTraceParser(TraceParser tracePath) {
   }

   @Override
   public void setTrace(boolean trace) {
   }

   @Override
   public Node parse(InputBuffer inputBuffer) {
      buffer = inputBuffer;
      if (preProcessor$Rule()) {
         return currentNode;
      } else {
         return null;
      }
   }


   //PreProcessor : (Statements <EOI>)
   protected boolean preProcessor$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Statements <EOI>)
      // Statements
      match = statements$Rule();
      if (match) {
         // <EOI>
         match = eoi();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.PRE_PROCESSOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statements : Statement*
   protected boolean statements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Statement*
      do {
         // Statement
         match = statement$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.STATEMENTS, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //Ignore : (Whitespace | BlockComment | LineComment | ContinueNL)
   protected boolean ignore$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignore$RuleMemoStart == index) {
         if (ignore$RuleMemoStart <= ignore$RuleMemoEnd) {
            index = ignore$RuleMemoEnd;
            if (! currentRuleIsAtomic && ignore$RuleMemoFirstNode != null) {
               lastNode.setSibling(ignore$RuleMemoFirstNode);
               currentNode = ignore$RuleMemoLastNode;
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | BlockComment | LineComment | ContinueNL)
      // Whitespace
      match = whitespace$Rule();
      if (! match) {
         // BlockComment
         match = blockComment$Rule();
         if (! match) {
            // LineComment
            match = lineComment$Rule();
            if (! match) {
               // ContinueNL
               match = continueNL$Rule();
            }
         }
      }
      if (match) {
         ignore$RuleMemoStart = startIndex;
         ignore$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignore$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.IGNORE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignore$RuleMemoFirstNode = currentNode;
            ignore$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ignore$RuleMemoStart = startIndex;
         ignore$RuleMemoEnd = -1;
         ignore$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Whitespace : Space+
   protected boolean whitespace$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // Space+
      // (' ' | '\t' | '\f')
      switch(buffer.getChar(index)) {
         case ' ':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\f':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\t':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (match) {
         do {
            // (' ' | '\t' | '\f')
            switch(buffer.getChar(index)) {
               case ' ':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\f':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\t':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.WHITESPACE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockComment : ('/*' ('*/'! .)* '*/')
   protected boolean blockComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (blockComment$RuleMemoStart == index) {
         if (blockComment$RuleMemoStart <= blockComment$RuleMemoEnd) {
            index = blockComment$RuleMemoEnd;
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('/*' ('*/'! .)* '*/')
      // '/*'
      match = stringMatcher("/*", 2);
      if (match) {
         // ('*/'! .)*
         do {
            // ('*/'! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // '*/'!
            // '*/'
            match = stringTest("*/", 2);
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // '*/'
         match = stringMatcher("*/", 2);
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = index;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BLOCK_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = -1;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineComment : (('//' | '&&') (('\n' | <EOI>)! .)*)
   protected boolean lineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('//' | '&&') (('\n' | <EOI>)! .)*)
      // ('//' | '&&')
      switch(buffer.getChar(index)) {
         case '&':
            ++index;
            // '&'
            if (match = buffer.matchChar(index, '&')) {
               ++index;
            }
            break;
         case '/':
            ++index;
            // '/'
            if (match = buffer.matchChar(index, '/')) {
               ++index;
            }
            break;
         default:
            match = false;
      }
      if (match) {
         // (('\n' | <EOI>)! .)*
         do {
            // (('\n' | <EOI>)! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | <EOI>)!
            // ('\n' | <EOI>)
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // <EOI>
               match = eoi();
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueNL : (Space* ';' (BlockComment | LineComment | Whitespace)* NewLine)
   protected boolean continueNL$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueNL$RuleMemoStart == index) {
         if (continueNL$RuleMemoStart <= continueNL$RuleMemoEnd) {
            index = continueNL$RuleMemoEnd;
            if (! currentRuleIsAtomic && continueNL$RuleMemoFirstNode != null) {
               lastNode.setSibling(continueNL$RuleMemoFirstNode);
               currentNode = continueNL$RuleMemoLastNode;
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Space* ';' (BlockComment | LineComment | Whitespace)* NewLine)
      // Space*
      do {
         // (' ' | '\t' | '\f')
         int startIndex_1 = index;
         switch(buffer.getChar(index)) {
            case ' ':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '\f':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '\t':
               ++index;
               // <EMPTY>
               match = true;
               break;
            default:
               match = false;
         }
         if (! match) {
            index = startIndex_1;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
            currentNode = currentNode.getSibling();
         }
      } while(match);
      // ';'
      match = charMatcher(';');
      if (match) {
         // (BlockComment | LineComment | Whitespace)*
         do {
            // (BlockComment | LineComment | Whitespace)
            // BlockComment
            match = blockComment$Rule();
            if (! match) {
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  // Whitespace
                  match = whitespace$Rule();
               }
            }
         } while(match);
         // NewLine
         match = newLine$Rule();
      }
      if (match) {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueNL$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourPPRuleType.CONTINUE_NL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueNL$RuleMemoFirstNode = currentNode;
            continueNL$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = -1;
         continueNL$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalSpacing : Ignore*
   protected boolean optionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore*
      do {
         // Ignore
         match = ignore$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //IgnoreOptionalSpacing : Ignore*
   protected boolean ignoreOptionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore*
      do {
         // Ignore
         match = ignore$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, false, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //IgnoreSpacing : Ignore+
   protected boolean ignoreSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore+
      // Ignore
      match = ignore$Rule();
      if (match) {
         do {
            // Ignore
            match = ignore$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Spacing : Ignore+
   protected boolean spacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // Ignore+
      // Ignore
      match = ignore$Rule();
      if (match) {
         do {
            // Ignore
            match = ignore$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SPACING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statement : (DirectiveStatement | EmptyStatement | AnyStatement)
   protected boolean statement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (DirectiveStatement | EmptyStatement | AnyStatement)
      // DirectiveStatement
      match = directiveStatement$Rule();
      if (! match) {
         // EmptyStatement
         match = emptyStatement$Rule();
         if (! match) {
            // AnyStatement
            match = anyStatement$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.STATEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirectiveStatement : (IgnoreOptionalSpacing DirectiveMark IgnoreOptionalSpacing (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock) IgnoreOptionalSpacing EndStmt)
   protected boolean directiveStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IgnoreOptionalSpacing DirectiveMark IgnoreOptionalSpacing (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock) IgnoreOptionalSpacing EndStmt)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // DirectiveMark
         match = directiveMark$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // (DefineDirective | StdOutDirective | CommandDirective | XCommandDirective | YCommandDirective | TranslateDirective | XTranslateDirective | YTranslateDirective | IfDefDirective | IfNDefDirective | ElseDirective | ElseIfDirective | EndIfDirective | UndefDirective | ErrorDirective | IncludeDirective | LineDirective | UncommandDirective | XUncommandDirective | YUncommandDirective | UntranslateDirective | XUntranslateDirective | YUntranslateDirective | DumpBlock)
               // DefineDirective
               match = defineDirective$Rule();
               if (! match) {
                  // StdOutDirective
                  match = stdOutDirective$Rule();
                  if (! match) {
                     // CommandDirective
                     match = commandDirective$Rule();
                     if (! match) {
                        // XCommandDirective
                        match = xCommandDirective$Rule();
                        if (! match) {
                           // YCommandDirective
                           match = yCommandDirective$Rule();
                           if (! match) {
                              // TranslateDirective
                              match = translateDirective$Rule();
                              if (! match) {
                                 // XTranslateDirective
                                 match = xTranslateDirective$Rule();
                                 if (! match) {
                                    // YTranslateDirective
                                    match = yTranslateDirective$Rule();
                                    if (! match) {
                                       // IfDefDirective
                                       match = ifDefDirective$Rule();
                                       if (! match) {
                                          // IfNDefDirective
                                          match = ifNDefDirective$Rule();
                                          if (! match) {
                                             // ElseDirective
                                             match = elseDirective$Rule();
                                             if (! match) {
                                                // ElseIfDirective
                                                match = elseIfDirective$Rule();
                                                if (! match) {
                                                   // EndIfDirective
                                                   match = endIfDirective$Rule();
                                                   if (! match) {
                                                      // UndefDirective
                                                      match = undefDirective$Rule();
                                                      if (! match) {
                                                         // ErrorDirective
                                                         match = errorDirective$Rule();
                                                         if (! match) {
                                                            // IncludeDirective
                                                            match = includeDirective$Rule();
                                                            if (! match) {
                                                               // LineDirective
                                                               match = lineDirective$Rule();
                                                               if (! match) {
                                                                  // UncommandDirective
                                                                  match = uncommandDirective$Rule();
                                                                  if (! match) {
                                                                     // XUncommandDirective
                                                                     match = xUncommandDirective$Rule();
                                                                     if (! match) {
                                                                        // YUncommandDirective
                                                                        match = yUncommandDirective$Rule();
                                                                        if (! match) {
                                                                           // UntranslateDirective
                                                                           match = untranslateDirective$Rule();
                                                                           if (! match) {
                                                                              // XUntranslateDirective
                                                                              match = xUntranslateDirective$Rule();
                                                                              if (! match) {
                                                                                 // YUntranslateDirective
                                                                                 match = yUntranslateDirective$Rule();
                                                                                 if (! match) {
                                                                                    // DumpBlock
                                                                                    match = dumpBlock$Rule();
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // EndStmt
                     match = endStmt$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_STATEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EmptyStatement : (Ignore* AloneLineComment? EndEmptyStmt)
   protected boolean emptyStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Ignore* AloneLineComment? EndEmptyStmt)
      // Ignore*
      do {
         // Ignore
         match = ignore$Rule();
      } while(match);
      // AloneLineComment?
      // AloneLineComment
      aloneLineComment$Rule();
      // EndEmptyStmt
      match = endEmptyStmt$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.EMPTY_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyStatement : (AnyRules EndStmt)
   protected boolean anyStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (AnyRules EndStmt)
      // AnyRules
      match = anyRules$Rule();
      if (match) {
         // EndStmt
         match = endStmt$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndEmptyStmt : (NewLine <EMPTY>)
   protected boolean endEmptyStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (NewLine <EMPTY>)
      // NewLine
      match = newLine$Rule();
      if (match) {
         // <EMPTY>
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NewLine : ('\n' | '\r\n')
   protected boolean newLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\n' | '\r\n')
      switch(buffer.getChar(index)) {
         case '\r':
            ++index;
            // '\n'
            if (match = buffer.matchChar(index, '\n')) {
               ++index;
            }
            break;
         case '\n':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.NEW_LINE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AloneLineComment : ('*' (('\n' | <EOI>)! .)*)
   protected boolean aloneLineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (aloneLineComment$RuleMemoStart == index) {
         if (aloneLineComment$RuleMemoStart <= aloneLineComment$RuleMemoEnd) {
            index = aloneLineComment$RuleMemoEnd;
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('*' (('\n' | <EOI>)! .)*)
      // '*'
      match = charMatcher('*');
      if (match) {
         // (('\n' | <EOI>)! .)*
         do {
            // (('\n' | <EOI>)! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | <EOI>)!
            // ('\n' | <EOI>)
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // <EOI>
               match = eoi();
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = index;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ALONE_LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = -1;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyRules : AnyRule+
   protected boolean anyRules$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // AnyRule+
      // AnyRule
      match = anyRule$Rule();
      if (match) {
         do {
            // AnyRule
            match = anyRule$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndStmt : (NewLine | <EOI>)
   protected boolean endStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (NewLine | <EOI>)
      // NewLine
      match = newLine$Rule();
      if (! match) {
         // <EOI>
         match = eoi();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirectiveMark : (IgnoreOptionalSpacing '#')
   protected boolean directiveMark$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IgnoreOptionalSpacing '#')
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // '#'
         match = charMatcher('#');
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_MARK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineDirective : (Define IgnoreSpacing Identifier DefineParameters? IgnoreOptionalSpacing ResultRules?)
   protected boolean defineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Define IgnoreSpacing Identifier DefineParameters? IgnoreOptionalSpacing ResultRules?)
      // Define
      match = define$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // DefineParameters?
               // DefineParameters
               defineParameters$Rule();
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ResultRules?
                  // ResultRules
                  resultRules$Rule();
                  match = true;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdOutDirective : (StdOut ResultRules)
   protected boolean stdOutDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (StdOut ResultRules)
      // StdOut
      match = stdOut$Rule();
      if (match) {
         // ResultRules
         match = resultRules$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.STD_OUT_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommandDirective : (Command IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean commandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Command IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // Command
      match = command$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // MatchPattern
            match = matchPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ResultSep
                  match = resultSep$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ResultPattern?
                        // ResultPattern
                        resultPattern$Rule();
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.COMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommandDirective : (XCommand directivePattern)
   protected boolean xCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (XCommand directivePattern)
      // XCommand
      match = xCommand$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YCommandDirective : (YCommand IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean yCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (YCommand IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // YCommand
      match = yCommand$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // MatchPattern
            match = matchPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ResultSep
                  match = resultSep$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ResultPattern?
                        // ResultPattern
                        resultPattern$Rule();
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TranslateDirective : (Translate directivePattern)
   protected boolean translateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Translate directivePattern)
      // Translate
      match = translate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.TRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslateDirective : (XTranslate directivePattern)
   protected boolean xTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (XTranslate directivePattern)
      // XTranslate
      match = xTranslate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YTranslateDirective : (YTranslate directivePattern)
   protected boolean yTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (YTranslate directivePattern)
      // YTranslate
      match = yTranslate$Rule();
      if (match) {
         // directivePattern
         match = directivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDefDirective : (IfDef IgnoreSpacing Identifier)
   protected boolean ifDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IfDef IgnoreSpacing Identifier)
      // IfDef
      match = ifDef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_DEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDefDirective : (IfNDef IgnoreSpacing Identifier)
   protected boolean ifNDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IfNDef IgnoreSpacing Identifier)
      // IfNDef
      match = ifNDef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_NDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseDirective : ("else" DiscardedRemainingLine)
   protected boolean elseDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("else" DiscardedRemainingLine)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_DIRECTIVE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseIfDirective : (ElseIf IgnoreSpacing Identifier)
   protected boolean elseIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ElseIf IgnoreSpacing Identifier)
      // ElseIf
      match = elseIf$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIfDirective : (EndIf DiscardedRemainingLine)
   protected boolean endIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (EndIf DiscardedRemainingLine)
      // EndIf
      match = endIf$Rule();
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_IF_DIRECTIVE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UndefDirective : (Undef IgnoreSpacing Identifier)
   protected boolean undefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Undef IgnoreSpacing Identifier)
      // Undef
      match = undef$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ErrorDirective : ("error" ResultRules)
   protected boolean errorDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("error" ResultRules)
      // "error"
      match = ignoreCaseStringMatcher("error", 5);
      if (match) {
         // ResultRules
         match = resultRules$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ERROR_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeName : (DoubleQuoteString | SingleQuoteString)
   protected boolean includeName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (DoubleQuoteString | SingleQuoteString)
      // DoubleQuoteString
      match = doubleQuoteString$Rule();
      if (! match) {
         // SingleQuoteString
         match = singleQuoteString$Rule();
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE_NAME, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeDirective : (Include IgnoreSpacing IncludeName)
   protected boolean includeDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Include IgnoreSpacing IncludeName)
      // Include
      match = include$Rule();
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // IncludeName
            match = includeName$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineDirective : ("line" DiscardedRemainingLine)
   protected boolean lineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("line" DiscardedRemainingLine)
      // "line"
      match = ignoreCaseStringMatcher("line", 4);
      if (match) {
         // DiscardedRemainingLine
         match = discardedRemainingLine$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UncommandDirective : (Uncommand undefDirectivePattern)
   protected boolean uncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Uncommand undefDirectivePattern)
      // Uncommand
      match = uncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUncommandDirective : (Xuncommand undefDirectivePattern)
   protected boolean xUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Xuncommand undefDirectivePattern)
      // Xuncommand
      match = xuncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUncommandDirective : (Yuncommand undefDirectivePattern)
   protected boolean yUncommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Yuncommand undefDirectivePattern)
      // Yuncommand
      match = yuncommand$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UntranslateDirective : (Untranslate undefDirectivePattern)
   protected boolean untranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Untranslate undefDirectivePattern)
      // Untranslate
      match = untranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XUntranslateDirective : (Xuntranslate undefDirectivePattern)
   protected boolean xUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Xuntranslate undefDirectivePattern)
      // Xuntranslate
      match = xuntranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YUntranslateDirective : (Yuntranslate undefDirectivePattern)
   protected boolean yUntranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Yuntranslate undefDirectivePattern)
      // Yuntranslate
      match = yuntranslate$Rule();
      if (match) {
         // undefDirectivePattern
         match = undefDirectivePattern$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DumpBlock : (BeginDumpBlock EndStmt ((EndDumpBlock | <EOI>)! .)* EndDumpBlock)
   protected boolean dumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (BeginDumpBlock EndStmt ((EndDumpBlock | <EOI>)! .)* EndDumpBlock)
      // BeginDumpBlock
      match = beginDumpBlock$Rule();
      if (match) {
         // EndStmt
         match = endStmt$Rule();
         if (match) {
            // ((EndDumpBlock | <EOI>)! .)*
            do {
               // ((EndDumpBlock | <EOI>)! .)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // (EndDumpBlock | <EOI>)!
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               boolean lastAtomic_2 = currentRuleIsAtomic;
               // (EndDumpBlock | <EOI>)
               // EndDumpBlock
               match = endDumpBlock$Rule();
               if (! match) {
                  // <EOI>
                  match = eoi();
               }
               currentRuleIsAtomic = lastAtomic_2;
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            } while(match);
            // EndDumpBlock
            match = endDumpBlock$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Define : ("defi" ("ne" | "n")?)
   protected boolean define$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("defi" ("ne" | "n")?)
      // "defi"
      match = ignoreCaseStringMatcher("defi", 4);
      if (match) {
         // ("ne" | "n")?
         // ("ne" | "n")
         if (buffer.matchIgnoreCaseChar(index, 'n')) {
            ++index;
            // ("e" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'e')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineParameters : ('(' IgnoreOptionalSpacing ParametersList? ')')
   protected boolean defineParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('(' IgnoreOptionalSpacing ParametersList? ')')
      // '('
      match = charMatcher('(');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // ParametersList?
            // ParametersList
            parametersList$Rule();
            // ')'
            match = charMatcher(')');
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DEFINE_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultRules : AnyRules
   protected boolean resultRules$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // AnyRules
      match = anyRules$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_RULES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersList : (Identifier (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)* IgnoreOptionalSpacing)
   protected boolean parametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Identifier (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)* IgnoreOptionalSpacing)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)*
         do {
            // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing Identifier)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ','
               match = charMatcher(',');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // Identifier
                     match = identifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.PARAMETERS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdOut : ("stdo" ("ut" | "u")?)
   protected boolean stdOut$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("stdo" ("ut" | "u")?)
      // "stdo"
      match = ignoreCaseStringMatcher("stdo", 4);
      if (match) {
         // ("ut" | "u")?
         // ("ut" | "u")
         if (buffer.matchIgnoreCaseChar(index, 'u')) {
            ++index;
            // ("t" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 't')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.STD_OUT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Command : ("comm" ("and" | "an" | "a")?)
   protected boolean command$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("comm" ("and" | "an" | "a")?)
      // "comm"
      match = ignoreCaseStringMatcher("comm", 4);
      if (match) {
         // ("and" | "an" | "a")?
         // ("and" | "an" | "a")
         if (buffer.matchIgnoreCaseChar(index, 'a')) {
            ++index;
            // ("nd" | "n" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'n')) {
               ++index;
               // "d"
               if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                  ++index;
               }
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.COMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchPattern : MatchChunk+
   protected boolean matchPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // MatchChunk+
      // MatchChunk
      match = matchChunk$Rule();
      if (match) {
         do {
            // MatchChunk
            match = matchChunk$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultSep : ('=' IgnoreOptionalSpacing '>')
   protected boolean resultSep$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('=' IgnoreOptionalSpacing '>')
      // '='
      match = charMatcher('=');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '>'
            match = charMatcher('>');
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_SEP, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultPattern : ResultChunk+
   protected boolean resultPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ResultChunk+
      // ResultChunk
      match = resultChunk$Rule();
      if (match) {
         do {
            // ResultChunk
            match = resultChunk$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YCommand : ("ycom" ("mand" | "man" | "ma" | "m")?)
   protected boolean yCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ycom" ("mand" | "man" | "ma" | "m")?)
      // "ycom"
      match = ignoreCaseStringMatcher("ycom", 4);
      if (match) {
         // ("mand" | "man" | "ma" | "m")?
         // ("mand" | "man" | "ma" | "m")
         if (buffer.matchIgnoreCaseChar(index, 'm')) {
            ++index;
            // ("and" | "an" | "a" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'a')) {
               ++index;
               // ("nd" | "n" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'n')) {
                  ++index;
                  // "d"
                  if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                     ++index;
                  }
                  // <EMPTY>
                  match = true;
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YCOMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //directivePattern : (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
   protected boolean directivePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing ResultSep IgnoreOptionalSpacing ResultPattern?)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // MatchPattern
         match = matchPattern$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ResultSep
               match = resultSep$Rule();
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // ResultPattern?
                     // ResultPattern
                     resultPattern$Rule();
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DIRECTIVE_PATTERN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //undefDirectivePattern : (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing)
   protected boolean undefDirectivePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IgnoreOptionalSpacing MatchPattern IgnoreOptionalSpacing)
      // IgnoreOptionalSpacing
      match = ignoreOptionalSpacing$Rule();
      if (match) {
         // MatchPattern
         match = matchPattern$Rule();
         if (match) {
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF_DIRECTIVE_PATTERN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Uncommand : ("unco" ("mmand" | "mman" | "mma" | "mm" | "m")?)
   protected boolean uncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("unco" ("mmand" | "mman" | "mma" | "mm" | "m")?)
      // "unco"
      match = ignoreCaseStringMatcher("unco", 4);
      if (match) {
         // ("mmand" | "mman" | "mma" | "mm" | "m")?
         // ("mmand" | "mman" | "mma" | "mm" | "m")
         if (buffer.matchIgnoreCaseChar(index, 'm')) {
            ++index;
            // ("mand" | "man" | "ma" | "m" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'm')) {
               ++index;
               // ("and" | "an" | "a" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'a')) {
                  ++index;
                  // ("nd" | "n" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'n')) {
                     ++index;
                     // "d"
                     if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNCOMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Xuncommand : ("xunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
   protected boolean xuncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
      // "xunc"
      match = ignoreCaseStringMatcher("xunc", 4);
      if (match) {
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")
         if (buffer.matchIgnoreCaseChar(index, 'o')) {
            ++index;
            // ("mmand" | "mman" | "mma" | "mm" | "m" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'm')) {
               ++index;
               // ("mand" | "man" | "ma" | "m" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'm')) {
                  ++index;
                  // ("and" | "an" | "a" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'a')) {
                     ++index;
                     // ("nd" | "n" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 'n')) {
                        ++index;
                        // "d"
                        if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNCOMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Yuncommand : ("yunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
   protected boolean yuncommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("yunc" ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?)
      // "yunc"
      match = ignoreCaseStringMatcher("yunc", 4);
      if (match) {
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")?
         // ("ommand" | "omman" | "omma" | "omm" | "om" | "o")
         if (buffer.matchIgnoreCaseChar(index, 'o')) {
            ++index;
            // ("mmand" | "mman" | "mma" | "mm" | "m" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'm')) {
               ++index;
               // ("mand" | "man" | "ma" | "m" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'm')) {
                  ++index;
                  // ("and" | "an" | "a" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'a')) {
                     ++index;
                     // ("nd" | "n" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 'n')) {
                        ++index;
                        // "d"
                        if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNCOMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommand : ("xcom" ("mand" | "man" | "ma" | "m")?)
   protected boolean xCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xcom" ("mand" | "man" | "ma" | "m")?)
      // "xcom"
      match = ignoreCaseStringMatcher("xcom", 4);
      if (match) {
         // ("mand" | "man" | "ma" | "m")?
         // ("mand" | "man" | "ma" | "m")
         if (buffer.matchIgnoreCaseChar(index, 'm')) {
            ++index;
            // ("and" | "an" | "a" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'a')) {
               ++index;
               // ("nd" | "n" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'n')) {
                  ++index;
                  // "d"
                  if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                     ++index;
                  }
                  // <EMPTY>
                  match = true;
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XCOMMAND, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Untranslate : ("untr" ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?)
   protected boolean untranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("untr" ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?)
      // "untr"
      match = ignoreCaseStringMatcher("untr", 4);
      if (match) {
         // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")?
         // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")
         if (buffer.matchIgnoreCaseChar(index, 'a')) {
            ++index;
            // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'n')) {
               ++index;
               // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 's')) {
                  ++index;
                  // ("late" | "lat" | "la" | "l" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'l')) {
                     ++index;
                     // ("ate" | "at" | "a" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 'a')) {
                        ++index;
                        // ("te" | "t" | <EMPTY>)
                        if (buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                           // "e"
                           if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNTRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Xuntranslate : ("xunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
   protected boolean xuntranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
      // "xunt"
      match = ignoreCaseStringMatcher("xunt", 4);
      if (match) {
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")
         if (buffer.matchIgnoreCaseChar(index, 'r')) {
            ++index;
            // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'a')) {
               ++index;
               // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'n')) {
                  ++index;
                  // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 's')) {
                     ++index;
                     // ("late" | "lat" | "la" | "l" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 'l')) {
                        ++index;
                        // ("ate" | "at" | "a" | <EMPTY>)
                        if (buffer.matchIgnoreCaseChar(index, 'a')) {
                           ++index;
                           // ("te" | "t" | <EMPTY>)
                           if (buffer.matchIgnoreCaseChar(index, 't')) {
                              ++index;
                              // "e"
                              if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XUNTRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Yuntranslate : ("yunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
   protected boolean yuntranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("yunt" ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?)
      // "yunt"
      match = ignoreCaseStringMatcher("yunt", 4);
      if (match) {
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")?
         // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra" | "r")
         if (buffer.matchIgnoreCaseChar(index, 'r')) {
            ++index;
            // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'a')) {
               ++index;
               // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'n')) {
                  ++index;
                  // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 's')) {
                     ++index;
                     // ("late" | "lat" | "la" | "l" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 'l')) {
                        ++index;
                        // ("ate" | "at" | "a" | <EMPTY>)
                        if (buffer.matchIgnoreCaseChar(index, 'a')) {
                           ++index;
                           // ("te" | "t" | <EMPTY>)
                           if (buffer.matchIgnoreCaseChar(index, 't')) {
                              ++index;
                              // "e"
                              if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YUNTRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Translate : ("tran" ("slate" | "slat" | "sla" | "sl" | "s")?)
   protected boolean translate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("tran" ("slate" | "slat" | "sla" | "sl" | "s")?)
      // "tran"
      match = ignoreCaseStringMatcher("tran", 4);
      if (match) {
         // ("slate" | "slat" | "sla" | "sl" | "s")?
         // ("slate" | "slat" | "sla" | "sl" | "s")
         if (buffer.matchIgnoreCaseChar(index, 's')) {
            ++index;
            // ("late" | "lat" | "la" | "l" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'l')) {
               ++index;
               // ("ate" | "at" | "a" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'a')) {
                  ++index;
                  // ("te" | "t" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 't')) {
                     ++index;
                     // "e"
                     if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.TRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //YTranslate : ("ytra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
   protected boolean yTranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ytra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
      // "ytra"
      match = ignoreCaseStringMatcher("ytra", 4);
      if (match) {
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
         if (buffer.matchIgnoreCaseChar(index, 'n')) {
            ++index;
            // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 's')) {
               ++index;
               // ("late" | "lat" | "la" | "l" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'l')) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'a')) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 't')) {
                        ++index;
                        // "e"
                        if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.YTRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslate : ("xtra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
   protected boolean xTranslate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("xtra" ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?)
      // "xtra"
      match = ignoreCaseStringMatcher("xtra", 4);
      if (match) {
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")?
         // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
         if (buffer.matchIgnoreCaseChar(index, 'n')) {
            ++index;
            // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 's')) {
               ++index;
               // ("late" | "lat" | "la" | "l" | <EMPTY>)
               if (buffer.matchIgnoreCaseChar(index, 'l')) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  if (buffer.matchIgnoreCaseChar(index, 'a')) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     if (buffer.matchIgnoreCaseChar(index, 't')) {
                        ++index;
                        // "e"
                        if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = true;
               }
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.XTRANSLATE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EscapedChar : ('\' ('\n'! .))
   protected boolean escapedChar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\' ('\n'! .))
      // '\'
      match = charMatcher('\\');
      if (match) {
         // ('\n'! .)
         // '\n'!
         // '\n'
         match = buffer.matchChar(index, '\n');
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher();
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ESCAPED_CHAR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarker : ('[' IgnoreOptionalSpacing OptionalMatchMarkerPattern IgnoreOptionalSpacing ']')
   protected boolean optionalMatchMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' IgnoreOptionalSpacing OptionalMatchMarkerPattern IgnoreOptionalSpacing ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // OptionalMatchMarkerPattern
            match = optionalMatchMarkerPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ']'
                  match = charMatcher(']');
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_MATCH_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarkerPattern : OptionalMatchMarkerChunk+
   protected boolean optionalMatchMarkerPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // OptionalMatchMarkerChunk+
      // OptionalMatchMarkerChunk
      match = optionalMatchMarkerChunk$Rule();
      if (match) {
         do {
            // OptionalMatchMarkerChunk
            match = optionalMatchMarkerChunk$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalMatchMarkerChunk : (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator))
   protected boolean optionalMatchMarkerChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator))
      // ResultSep!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // ResultSep
      match = resultSep$Rule();
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
         // OptionalMatchMarker
         match = optionalMatchMarker$Rule();
         if (! match) {
            // MatchMarker
            match = matchMarker$Rule();
            if (! match) {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        // EscapedChar
                        match = escapedChar$Rule();
                        if (! match) {
                           // Separator
                           match = separator$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_MATCH_MARKER_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchMarker : (IdMarker | ListMarker | RestrictMarker | WildMarker | ExtendedMarker | IdentifierMarker)
   protected boolean matchMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdMarker | ListMarker | RestrictMarker | WildMarker | ExtendedMarker | IdentifierMarker)
      // IdMarker
      match = idMarker$Rule();
      if (! match) {
         // ListMarker
         match = listMarker$Rule();
         if (! match) {
            // RestrictMarker
            match = restrictMarker$Rule();
            if (! match) {
               // WildMarker
               match = wildMarker$Rule();
               if (! match) {
                  // ExtendedMarker
                  match = extendedMarker$Rule();
                  if (! match) {
                     // IdentifierMarker
                     match = identifierMarker$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_MARKER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Literal : (LogicalLiteral | DoubleQuoteString | SingleQuoteString | DateTimeLiteral | NumberLiteral | MultiLineDoubleQuoteString | MultiLineSingleQuoteString)
   protected boolean literal$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (LogicalLiteral | DoubleQuoteString | SingleQuoteString | DateTimeLiteral | NumberLiteral | MultiLineDoubleQuoteString | MultiLineSingleQuoteString)
      // LogicalLiteral
      match = logicalLiteral$Rule();
      if (! match) {
         // DoubleQuoteString
         match = doubleQuoteString$Rule();
         if (! match) {
            // SingleQuoteString
            match = singleQuoteString$Rule();
            if (! match) {
               // DateTimeLiteral
               match = dateTimeLiteral$Rule();
               if (! match) {
                  // NumberLiteral
                  match = numberLiteral$Rule();
                  if (! match) {
                     // MultiLineDoubleQuoteString
                     match = multiLineDoubleQuoteString$Rule();
                     if (! match) {
                        // MultiLineSingleQuoteString
                        match = multiLineSingleQuoteString$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Separator : (".or." | ".and." | ".not." | ':=' | '==' | '!=' | '>=' | '<=' | '->' | '++' | '--' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '**' | '^^' | '<<' | '>>' | '::' | '<>' | '...' | '&&' | '||' | '^^' | '**=' | '$' | ',' | '>' | '+' | '*' | '!' | '-' | '/' | '(' | ')' | ':' | '{' | '}' | '%' | '\' | '?' | '~' | '.' | '@' | '|' | '&' | '=' | '^' | '#' | ';' | '<' | '[' | '"' | ''' | '_')
   protected boolean separator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (".or." | ".and." | ".not." | ':=' | '==' | '!=' | '>=' | '<=' | '->' | '++' | '--' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '**' | '^^' | '<<' | '>>' | '::' | '<>' | '...' | '&&' | '||' | '^^' | '**=' | '$' | ',' | '>' | '+' | '*' | '!' | '-' | '/' | '(' | ')' | ':' | '{' | '}' | '%' | '\' | '?' | '~' | '.' | '@' | '|' | '&' | '=' | '^' | '#' | ';' | '<' | '[' | '"' | ''' | '_')
      switch(buffer.getChar(index)) {
         case '(':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '$':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '>':
            ++index;
            // ('=' | '>' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '>':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '~':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '-':
            ++index;
            // ('>' | '-' | '=' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '>':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '-':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '\\':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ':':
            ++index;
            // ('=' | ':' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case ':':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case ')':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '%':
            ++index;
            // ('=' | <EMPTY>)
            if (buffer.matchChar(index, '=')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '!':
            ++index;
            // ('=' | <EMPTY>)
            if (buffer.matchChar(index, '=')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '?':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '.':
            ++index;
            // ("and." | "not." | "or." | '..' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A':
                  ++index;
                  // "nd."
                  if (match = ignoreCaseStringTest("nd.", 3)) {
                     index += 3;
                  }
                  break;
               case 'o':
               case 'O':
                  ++index;
                  // "r."
                  if (match = ignoreCaseStringTest("r.", 2)) {
                     index += 2;
                  }
                  break;
               case 'n':
               case 'N':
                  ++index;
                  // "ot."
                  if (match = ignoreCaseStringTest("ot.", 3)) {
                     index += 3;
                  }
                  break;
               case '.':
                  ++index;
                  // '.'
                  if (match = buffer.matchChar(index, '.')) {
                     ++index;
                  }
                  break;
               default:
                  match = true;
            }
            break;
         case '{':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ';':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '*':
            ++index;
            // ('*=' | '=' | '*' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '*':
                  ++index;
                  // '='
                  if (match = buffer.matchChar(index, '=')) {
                     ++index;
                  }
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '&':
            ++index;
            // ('&' | <EMPTY>)
            if (buffer.matchChar(index, '&')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '\"':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '@':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '/':
            ++index;
            // ('=' | <EMPTY>)
            if (buffer.matchChar(index, '=')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '^':
            ++index;
            // ('=' | '^' | '^' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '^':
                  ++index;
                  // <EMPTY>
                  match = true;
                  // <EMPTY>
                  match = true;
                  break;
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '<':
            ++index;
            // ('=' | '<' | '>' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '>':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '<':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '|':
            ++index;
            // ('|' | <EMPTY>)
            if (buffer.matchChar(index, '|')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '+':
            ++index;
            // ('+' | '=' | <EMPTY>)
            switch(buffer.getChar(index)) {
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '+':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = true;
            }
            break;
         case '\'':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '#':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '_':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '=':
            ++index;
            // ('=' | <EMPTY>)
            if (buffer.matchChar(index, '=')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
            break;
         case '}':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ',':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '[':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SEPARATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MatchChunk : (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator))
   protected boolean matchChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ResultSep! (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator))
      // ResultSep!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // ResultSep
      match = resultSep$Rule();
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // (OptionalMatchMarker | MatchMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
         // OptionalMatchMarker
         match = optionalMatchMarker$Rule();
         if (! match) {
            // MatchMarker
            match = matchMarker$Rule();
            if (! match) {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        // EscapedChar
                        match = escapedChar$Rule();
                        if (! match) {
                           // ']'
                           match = charMatcher(']');
                           if (! match) {
                              // Separator
                              match = separator$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MATCH_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
   protected boolean idMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // '>'
                  match = charMatcher('>');
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ID_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ListMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ',' IgnoreOptionalSpacing '...' IgnoreOptionalSpacing '>')
   protected boolean listMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ',' IgnoreOptionalSpacing '...' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '...'
                        match = stringMatcher("...", 3);
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LIST_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictMarker : ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ':' IgnoreOptionalSpacing RestrictValues IgnoreOptionalSpacing '>')
   protected boolean restrictMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ':' IgnoreOptionalSpacing RestrictValues IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // Identifier
            match = identifier$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ':'
                  match = charMatcher(':');
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // RestrictValues
                        match = restrictValues$Rule();
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WildMarker : ('<' IgnoreOptionalSpacing '*' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '*' IgnoreOptionalSpacing '>')
   protected boolean wildMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '*' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '*' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '*'
            match = charMatcher('*');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '*'
                        match = charMatcher('*');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.WILD_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExtendedMarker : ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
   protected boolean extendedMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '('
            match = charMatcher('(');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.EXTENDED_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierMarker : ('<' IgnoreOptionalSpacing '!' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '!' IgnoreOptionalSpacing '>')
   protected boolean identifierMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '!' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '!' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '!'
            match = charMatcher('!');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '!'
                        match = charMatcher('!');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictValues : (RestrictValue (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*)
   protected boolean restrictValues$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (RestrictValue (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*)
      // RestrictValue
      match = restrictValue$Rule();
      if (match) {
         // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)*
         do {
            // (IgnoreOptionalSpacing ',' IgnoreOptionalSpacing RestrictValue)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // IgnoreOptionalSpacing
            match = ignoreOptionalSpacing$Rule();
            if (match) {
               // ','
               match = charMatcher(',');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // RestrictValue
                     match = restrictValue$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_VALUES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestrictValue : (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))+
   protected boolean restrictValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))+
      // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('>' | ',')!
      // ('>' | ',')
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case '>':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ',':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      index = startIndex_2;
      match = ! match;
      if (match) {
         // (Identifier | Literal | Ignore | EscapedChar | Separator)
         // Identifier
         match = identifier$Rule();
         if (! match) {
            // Literal
            match = literal$Rule();
            if (! match) {
               // Ignore
               match = ignore$Rule();
               if (! match) {
                  // EscapedChar
                  match = escapedChar$Rule();
                  if (! match) {
                     // Separator
                     match = separator$Rule();
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         do {
            // (('>' | ',')! (Identifier | Literal | Ignore | EscapedChar | Separator))
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // ('>' | ',')!
            // ('>' | ',')
            int startIndex_4 = index;
            switch(buffer.getChar(index)) {
               case '>':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case ',':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            index = startIndex_4;
            match = ! match;
            if (match) {
               // (Identifier | Literal | Ignore | EscapedChar | Separator)
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  // Literal
                  match = literal$Rule();
                  if (! match) {
                     // Ignore
                     match = ignore$Rule();
                     if (! match) {
                        // EscapedChar
                        match = escapedChar$Rule();
                        if (! match) {
                           // Separator
                           match = separator$Rule();
                        }
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESTRICT_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NullMarker : ('<' IgnoreOptionalSpacing '-' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '-' IgnoreOptionalSpacing '>')
   protected boolean nullMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '-' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '-' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '-'
            match = charMatcher('-');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '-'
                        match = charMatcher('-');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.NULL_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultMarker : (IdMarker | DumbStringifyMarker | NormalStringifyMarker | SmartStringifyMarker | BlockifyMarker | LogifyMarker | NullMarker)
   protected boolean resultMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdMarker | DumbStringifyMarker | NormalStringifyMarker | SmartStringifyMarker | BlockifyMarker | LogifyMarker | NullMarker)
      // IdMarker
      match = idMarker$Rule();
      if (! match) {
         // DumbStringifyMarker
         match = dumbStringifyMarker$Rule();
         if (! match) {
            // NormalStringifyMarker
            match = normalStringifyMarker$Rule();
            if (! match) {
               // SmartStringifyMarker
               match = smartStringifyMarker$Rule();
               if (! match) {
                  // BlockifyMarker
                  match = blockifyMarker$Rule();
                  if (! match) {
                     // LogifyMarker
                     match = logifyMarker$Rule();
                     if (! match) {
                        // NullMarker
                        match = nullMarker$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_MARKER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DumbStringifyMarker : (DirectiveMark IgnoreOptionalSpacing '<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
   protected boolean dumbStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (DirectiveMark IgnoreOptionalSpacing '<' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '>')
      // DirectiveMark
      match = directiveMark$Rule();
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '<'
            match = charMatcher('<');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '>'
                        match = charMatcher('>');
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DUMB_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NormalStringifyMarker : ('<' IgnoreOptionalSpacing (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | (''' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ''')) IgnoreOptionalSpacing '>')
   protected boolean normalStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | (''' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ''')) IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // (('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"') | (''' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '''))
            // ('"' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '"')
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // '"'
            match = charMatcher('\"');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '"'
                        match = charMatcher('\"');
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     } else {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
            if (! match) {
               // (''' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ''')
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // '''
               match = charMatcher('\'');
               if (match) {
                  // IgnoreOptionalSpacing
                  match = ignoreOptionalSpacing$Rule();
                  if (match) {
                     // Identifier
                     match = identifier$Rule();
                     if (match) {
                        // IgnoreOptionalSpacing
                        match = ignoreOptionalSpacing$Rule();
                        if (match) {
                           // '''
                           match = charMatcher('\'');
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                        } else {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                        }
                     } else {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
            }
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // '>'
                  match = charMatcher('>');
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.NORMAL_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SmartStringifyMarker : ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
   protected boolean smartStringifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '(' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing ')' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '('
            match = charMatcher('(');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SMART_STRINGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockifyMarker : ('<' IgnoreOptionalSpacing '{' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '}' IgnoreOptionalSpacing '>')
   protected boolean blockifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '{' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '}' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '{'
            match = charMatcher('{');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '}'
                        match = charMatcher('}');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BLOCKIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogifyMarker : ('<' IgnoreOptionalSpacing '.' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '.' IgnoreOptionalSpacing '>')
   protected boolean logifyMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('<' IgnoreOptionalSpacing '.' IgnoreOptionalSpacing Identifier IgnoreOptionalSpacing '.' IgnoreOptionalSpacing '>')
      // '<'
      match = charMatcher('<');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // IgnoreOptionalSpacing
                     match = ignoreOptionalSpacing$Rule();
                     if (match) {
                        // '.'
                        match = charMatcher('.');
                        if (match) {
                           // IgnoreOptionalSpacing
                           match = ignoreOptionalSpacing$Rule();
                           if (match) {
                              // '>'
                              match = charMatcher('>');
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LOGIFY_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarker : ('[' IgnoreOptionalSpacing OptionalResultMarkerPattern IgnoreOptionalSpacing ']')
   protected boolean optionalResultMarker$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' IgnoreOptionalSpacing OptionalResultMarkerPattern IgnoreOptionalSpacing ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // IgnoreOptionalSpacing
         match = ignoreOptionalSpacing$Rule();
         if (match) {
            // OptionalResultMarkerPattern
            match = optionalResultMarkerPattern$Rule();
            if (match) {
               // IgnoreOptionalSpacing
               match = ignoreOptionalSpacing$Rule();
               if (match) {
                  // ']'
                  match = charMatcher(']');
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_RESULT_MARKER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarkerPattern : OptionalResultMarkerChunk+
   protected boolean optionalResultMarkerPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // OptionalResultMarkerChunk+
      // OptionalResultMarkerChunk
      match = optionalResultMarkerChunk$Rule();
      if (match) {
         do {
            // OptionalResultMarkerChunk
            match = optionalResultMarkerChunk$Rule();
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalResultMarkerChunk : (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
   protected boolean optionalResultMarkerChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | Separator)
      // OptionalResultMarker
      match = optionalResultMarker$Rule();
      if (! match) {
         // ResultMarker
         match = resultMarker$Rule();
         if (! match) {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               // Literal
               match = literal$Rule();
               if (! match) {
                  // Ignore
                  match = ignore$Rule();
                  if (! match) {
                     // EscapedChar
                     match = escapedChar$Rule();
                     if (! match) {
                        // Separator
                        match = separator$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.OPTIONAL_RESULT_MARKER_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ResultChunk : (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
   protected boolean resultChunk$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (OptionalResultMarker | ResultMarker | Identifier | Literal | Ignore | EscapedChar | ']' | Separator)
      // OptionalResultMarker
      match = optionalResultMarker$Rule();
      if (! match) {
         // ResultMarker
         match = resultMarker$Rule();
         if (! match) {
            // Identifier
            match = identifier$Rule();
            if (! match) {
               // Literal
               match = literal$Rule();
               if (! match) {
                  // Ignore
                  match = ignore$Rule();
                  if (! match) {
                     // EscapedChar
                     match = escapedChar$Rule();
                     if (! match) {
                        // ']'
                        match = charMatcher(']');
                        if (! match) {
                           // Separator
                           match = separator$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.RESULT_CHUNK, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDef : ("ifde" "f"?)
   protected boolean ifDef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ifde" "f"?)
      // "ifde"
      match = ignoreCaseStringMatcher("ifde", 4);
      if (match) {
         // "f"?
         // "f"
         ignoreCaseCharMatcher('f');
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_DEF, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDef : ("ifnd" ("ef" | "e")?)
   protected boolean ifNDef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("ifnd" ("ef" | "e")?)
      // "ifnd"
      match = ignoreCaseStringMatcher("ifnd", 4);
      if (match) {
         // ("ef" | "e")?
         // ("ef" | "e")
         if (buffer.matchIgnoreCaseChar(index, 'e')) {
            ++index;
            // ("f" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'f')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IF_NDEF, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DiscardedRemainingLine : (EndStmt! .)*
   protected boolean discardedRemainingLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (EndStmt! .)*
      do {
         // (EndStmt! .)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // EndStmt!
         // EndStmt
         match = endStmt$Rule();
         match = ! match;
         if (match) {
            // .
            match = anyCharMatcher();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourPPRuleType.DISCARDED_REMAINING_LINE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ElseIf : ("else" ("if" | "i")?)
   protected boolean elseIf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("else" ("if" | "i")?)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // ("if" | "i")?
         // ("if" | "i")
         if (buffer.matchIgnoreCaseChar(index, 'i')) {
            ++index;
            // ("f" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'f')) {
               ++index;
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ELSE_IF, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIf : ("endi" "f"?)
   protected boolean endIf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("endi" "f"?)
      // "endi"
      match = ignoreCaseStringMatcher("endi", 4);
      if (match) {
         // "f"?
         // "f"
         ignoreCaseCharMatcher('f');
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_IF, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Undef : ("unde" "f"?)
   protected boolean undef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("unde" "f"?)
      // "unde"
      match = ignoreCaseStringMatcher("unde", 4);
      if (match) {
         // "f"?
         // "f"
         ignoreCaseCharMatcher('f');
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.UNDEF, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Include : ("incl" ("ude" | "ud" | "u")?)
   protected boolean include$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("incl" ("ude" | "ud" | "u")?)
      // "incl"
      match = ignoreCaseStringMatcher("incl", 4);
      if (match) {
         // ("ude" | "ud" | "u")?
         // ("ude" | "ud" | "u")
         if (buffer.matchIgnoreCaseChar(index, 'u')) {
            ++index;
            // ("de" | "d" | <EMPTY>)
            if (buffer.matchIgnoreCaseChar(index, 'd')) {
               ++index;
               // "e"
               if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                  ++index;
               }
               // <EMPTY>
               match = true;
            } else {
               match = true;
            }
         } else {
            match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INCLUDE, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoubleQuoteString : ('"' (('\n' | '"')! .)* '"')
   protected boolean doubleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('"' (('\n' | '"')! .)* '"')
      // '"'
      match = charMatcher('\"');
      if (match) {
         // (('\n' | '"')! .)*
         do {
            // (('\n' | '"')! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | '"')!
            // ('\n' | '"')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '\"':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // '"'
         match = charMatcher('\"');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DOUBLE_QUOTE_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SingleQuoteString : (''' (('\n' | ''')! .)* ''')
   protected boolean singleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (''' (('\n' | ''')! .)* ''')
      // '''
      match = charMatcher('\'');
      if (match) {
         // (('\n' | ''')! .)*
         do {
            // (('\n' | ''')! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | ''')!
            // ('\n' | ''')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case '\'':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // '''
         match = charMatcher('\'');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.SINGLE_QUOTE_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginDumpBlock : ("pragma" IgnoreSpacing "begindump")
   protected boolean beginDumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("pragma" IgnoreSpacing "begindump")
      // "pragma"
      match = ignoreCaseStringMatcher("pragma", 6);
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // "begindump"
            match = ignoreCaseStringMatcher("begindump", 9);
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BEGIN_DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndDumpBlock : ("pragma" IgnoreSpacing "enddump")
   protected boolean endDumpBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("pragma" IgnoreSpacing "enddump")
      // "pragma"
      match = ignoreCaseStringMatcher("pragma", 6);
      if (match) {
         // IgnoreSpacing
         match = ignoreSpacing$Rule();
         if (match) {
            // "enddump"
            match = ignoreCaseStringMatcher("enddump", 7);
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.END_DUMP_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BracketSequence : (('[' (']'! AnyRule)+ ']') | BracketString)
   protected boolean bracketSequence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (('[' (']'! AnyRule)+ ']') | BracketString)
      // ('[' (']'! AnyRule)+ ']')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '['
      match = charMatcher('[');
      if (match) {
         // (']'! AnyRule)+
         // (']'! AnyRule)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ']'!
         // ']'
         match = buffer.matchChar(index, ']');
         match = ! match;
         if (match) {
            // AnyRule
            match = anyRule$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
         }
         if (match) {
            do {
               // (']'! AnyRule)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ']'!
               // ']'
               match = buffer.matchChar(index, ']');
               match = ! match;
               if (match) {
                  // AnyRule
                  match = anyRule$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
            } while(match);
            match = true;
         }
         if (match) {
            // ']'
            match = charMatcher(']');
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! match) {
         // BracketString
         match = bracketString$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_SEQUENCE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyRule : (BracketSequence | Literal | Ignore | Identifier | Separator)
   protected boolean anyRule$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (BracketSequence | Literal | Ignore | Identifier | Separator)
      // BracketSequence
      match = bracketSequence$Rule();
      if (! match) {
         // Literal
         match = literal$Rule();
         if (! match) {
            // Ignore
            match = ignore$Rule();
            if (! match) {
               // Identifier
               match = identifier$Rule();
               if (! match) {
                  // Separator
                  match = separator$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.ANY_RULE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BracketString : ('[' (('\n' | ']')! .)* ']')
   protected boolean bracketString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('[' (('\n' | ']')! .)* ']')
      // '['
      match = charMatcher('[');
      if (match) {
         // (('\n' | ']')! .)*
         do {
            // (('\n' | ']')! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | ']')!
            // ('\n' | ']')
            int startIndex_2 = index;
            switch(buffer.getChar(index)) {
               case ']':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            index = startIndex_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // ']'
         match = charMatcher(']');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BRACKET_STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalLiteral : (".T." | ".F." | ".Y." | ".N.")
   protected boolean logicalLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (".T." | ".F." | ".Y." | ".N.")
      if (buffer.matchChar(index, '.')) {
         ++index;
         // ("T." | "F." | "Y." | "N.")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 't':
            case 'T':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 'n':
            case 'N':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 'y':
            case 'Y':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            default:
               match = false;
         }
      } else {
         match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LOGICAL_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimeLiteral : (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}'))
   protected boolean dateTimeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}'))
      // ('0d' Digit Digit Digit Digit Digit Digit Digit Digit)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '0d'
      match = stringMatcher("0d", 2);
      if (match) {
         // '0'-'9'
         match = charRangeMatcher('0', '9');
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (match) {
                     // '0'-'9'
                     match = charRangeMatcher('0', '9');
                     if (match) {
                        // '0'-'9'
                        match = charRangeMatcher('0', '9');
                        if (match) {
                           // '0'-'9'
                           match = charRangeMatcher('0', '9');
                           if (match) {
                              // '0'-'9'
                              match = charRangeMatcher('0', '9');
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           } else {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                           }
                        } else {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                        }
                     } else {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! match) {
         // ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']')))
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // "d"
         match = ignoreCaseCharMatcher('d');
         if (match) {
            // (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))
            // ('"' DatePattern ("T"? TimePattern)? '"')
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // '"'
            match = charMatcher('\"');
            if (match) {
               // DatePattern
               match = datePattern$Rule();
               if (match) {
                  // ("T"? TimePattern)?
                  // ("T"? TimePattern)
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // "T"?
                  // "T"
                  ignoreCaseCharMatcher('T');
                  // TimePattern
                  match = timePattern$Rule();
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                  }
                  // '"'
                  match = charMatcher('\"');
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               } else {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
               }
            }
            if (! match) {
               // (''' DatePattern ("T"? TimePattern)? ''')
               Node lastNode_5 = currentNode;
               int lastIndex_5 = index;
               // '''
               match = charMatcher('\'');
               if (match) {
                  // DatePattern
                  match = datePattern$Rule();
                  if (match) {
                     // ("T"? TimePattern)?
                     // ("T"? TimePattern)
                     Node lastNode_6 = currentNode;
                     int lastIndex_6 = index;
                     // "T"?
                     // "T"
                     ignoreCaseCharMatcher('T');
                     // TimePattern
                     match = timePattern$Rule();
                     if (! match) {
                        index = lastIndex_6;
                        lastNode_6.setSibling(null);
                        currentNode = lastNode_6;
                     }
                     // '''
                     match = charMatcher('\'');
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                  } else {
                     index = lastIndex_5;
                     lastNode_5.setSibling(null);
                  }
               }
               if (! match) {
                  // ('[' DatePattern ("T"? TimePattern)? ']')
                  Node lastNode_7 = currentNode;
                  int lastIndex_7 = index;
                  // '['
                  match = charMatcher('[');
                  if (match) {
                     // DatePattern
                     match = datePattern$Rule();
                     if (match) {
                        // ("T"? TimePattern)?
                        // ("T"? TimePattern)
                        Node lastNode_8 = currentNode;
                        int lastIndex_8 = index;
                        // "T"?
                        // "T"
                        ignoreCaseCharMatcher('T');
                        // TimePattern
                        match = timePattern$Rule();
                        if (! match) {
                           index = lastIndex_8;
                           lastNode_8.setSibling(null);
                           currentNode = lastNode_8;
                        }
                        // ']'
                        match = charMatcher(']');
                        if (! match) {
                           index = lastIndex_7;
                           lastNode_7.setSibling(null);
                           currentNode = lastNode_7;
                        }
                     } else {
                        index = lastIndex_7;
                        lastNode_7.setSibling(null);
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
         }
         if (! match) {
            // ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? Ignore '}')
            Node lastNode_9 = currentNode;
            int lastIndex_9 = index;
            // '{'
            match = charMatcher('{');
            if (match) {
               // '^'
               match = charMatcher('^');
               if (match) {
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)?
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)
                  Node lastNode_10 = currentNode;
                  int lastIndex_10 = index;
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (match) {
                     // ('-' | '/')
                     switch(buffer.getChar(index)) {
                        case '/':
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        case '-':
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        default:
                           match = false;
                     }
                     if (match) {
                        // IntegerNumber
                        match = integerNumber$Rule();
                        if (match) {
                           // ('-' | '/')
                           switch(buffer.getChar(index)) {
                              case '/':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              case '-':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              default:
                                 match = false;
                           }
                           if (match) {
                              // IntegerNumber
                              match = integerNumber$Rule();
                              if (match) {
                                 // ','?
                                 // ','
                                 charMatcher(',');
                                 match = true;
                              } else {
                                 index = lastIndex_10;
                                 lastNode_10.setSibling(null);
                              }
                           } else {
                              index = lastIndex_10;
                              lastNode_10.setSibling(null);
                           }
                        } else {
                           index = lastIndex_10;
                           lastNode_10.setSibling(null);
                        }
                     } else {
                        index = lastIndex_10;
                        lastNode_10.setSibling(null);
                     }
                  }
                  // TimePattern?
                  // TimePattern
                  timePattern$Rule();
                  // Ignore
                  match = ignore$Rule();
                  if (match) {
                     // '}'
                     match = charMatcher('}');
                     if (! match) {
                        index = lastIndex_9;
                        lastNode_9.setSibling(null);
                        currentNode = lastNode_9;
                     }
                  } else {
                     index = lastIndex_9;
                     lastNode_9.setSibling(null);
                  }
               } else {
                  index = lastIndex_9;
                  lastNode_9.setSibling(null);
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DATE_TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberLiteral : ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
   protected boolean numberLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
      // (IntegerNumber '.' IntegerNumber)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! match) {
         // (IntegerNumber '.' Letter!)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // IntegerNumber
         match = integerNumber$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // Letter!
               // Letter
               match = letter$Rule();
               match = ! match;
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            } else {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
            }
         }
         if (! match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (! match) {
               // ('.' IntegerNumber)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.NUMBER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultiLineDoubleQuoteString : ('"' (MultilineDoubleQuoteStringSegment BreakString)+ (('\n' | '"')! .)* '"')
   protected boolean multiLineDoubleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('"' (MultilineDoubleQuoteStringSegment BreakString)+ (('\n' | '"')! .)* '"')
      // '"'
      match = charMatcher('\"');
      if (match) {
         // (MultilineDoubleQuoteStringSegment BreakString)+
         // (MultilineDoubleQuoteStringSegment BreakString)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // MultilineDoubleQuoteStringSegment
         match = multilineDoubleQuoteStringSegment$Rule();
         if (match) {
            // BreakString
            match = breakString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
         if (match) {
            do {
               // (MultilineDoubleQuoteStringSegment BreakString)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // MultilineDoubleQuoteStringSegment
               match = multilineDoubleQuoteStringSegment$Rule();
               if (match) {
                  // BreakString
                  match = breakString$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            } while(match);
            match = true;
         }
         if (match) {
            // (('\n' | '"')! .)*
            do {
               // (('\n' | '"')! .)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ('\n' | '"')!
               // ('\n' | '"')
               int startIndex_4 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '\n':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  default:
                     match = false;
               }
               index = startIndex_4;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
            } while(match);
            // '"'
            match = charMatcher('\"');
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_DOUBLE_QUOTE_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultiLineSingleQuoteString : (''' (MultilineSingleQuoteStringSegment BreakString)+ (('\n' | ''')! .)* ''')
   protected boolean multiLineSingleQuoteString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (''' (MultilineSingleQuoteStringSegment BreakString)+ (('\n' | ''')! .)* ''')
      // '''
      match = charMatcher('\'');
      if (match) {
         // (MultilineSingleQuoteStringSegment BreakString)+
         // (MultilineSingleQuoteStringSegment BreakString)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // MultilineSingleQuoteStringSegment
         match = multilineSingleQuoteStringSegment$Rule();
         if (match) {
            // BreakString
            match = breakString$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
         if (match) {
            do {
               // (MultilineSingleQuoteStringSegment BreakString)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // MultilineSingleQuoteStringSegment
               match = multilineSingleQuoteStringSegment$Rule();
               if (match) {
                  // BreakString
                  match = breakString$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            } while(match);
            match = true;
         }
         if (match) {
            // (('\n' | ''')! .)*
            do {
               // (('\n' | ''')! .)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ('\n' | ''')!
               // ('\n' | ''')
               int startIndex_4 = index;
               switch(buffer.getChar(index)) {
                  case '\'':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '\n':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  default:
                     match = false;
               }
               index = startIndex_4;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
            } while(match);
            // '''
            match = charMatcher('\'');
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTI_LINE_SINGLE_QUOTE_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BreakString : (';' (' ' | '\t' | '\f')* NewLine)
   protected boolean breakString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (';' (' ' | '\t' | '\f')* NewLine)
      // ';'
      match = charMatcher(';');
      if (match) {
         // (' ' | '\t' | '\f')*
         do {
            // (' ' | '\t' | '\f')
            int startIndex_1 = index;
            switch(buffer.getChar(index)) {
               case ' ':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\f':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\t':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            if (! match) {
               index = startIndex_1;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
               currentNode = currentNode.getSibling();
            }
         } while(match);
         // NewLine
         match = newLine$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.BREAK_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultilineDoubleQuoteStringSegment : ((('\n' | '"') | BreakString)! .)+
   protected boolean multilineDoubleQuoteStringSegment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((('\n' | '"') | BreakString)! .)+
      // ((('\n' | '"') | BreakString)! .)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (('\n' | '"') | BreakString)!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' | '"') | BreakString)
      // ('\n' | '"')
      switch(buffer.getChar(index)) {
         case '\"':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\n':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (! match) {
         // BreakString
         match = breakString$Rule();
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         do {
            // ((('\n' | '"') | BreakString)! .)
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // (('\n' | '"') | BreakString)!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' | '"') | BreakString)
            // ('\n' | '"')
            switch(buffer.getChar(index)) {
               case '\"':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            if (! match) {
               // BreakString
               match = breakString$Rule();
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTILINE_DOUBLE_QUOTE_STRING_SEGMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MultilineSingleQuoteStringSegment : ((('\n' | ''') | BreakString)! .)+
   protected boolean multilineSingleQuoteStringSegment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((('\n' | ''') | BreakString)! .)+
      // ((('\n' | ''') | BreakString)! .)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (('\n' | ''') | BreakString)!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' | ''') | BreakString)
      // ('\n' | ''')
      switch(buffer.getChar(index)) {
         case '\'':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\n':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (! match) {
         // BreakString
         match = breakString$Rule();
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         do {
            // ((('\n' | ''') | BreakString)! .)
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // (('\n' | ''') | BreakString)!
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            boolean lastAtomic_4 = currentRuleIsAtomic;
            // (('\n' | ''') | BreakString)
            // ('\n' | ''')
            switch(buffer.getChar(index)) {
               case '\'':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            if (! match) {
               // BreakString
               match = breakString$Rule();
            }
            currentRuleIsAtomic = lastAtomic_4;
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.MULTILINE_SINGLE_QUOTE_STRING_SEGMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Letter : ('a'-'z' | 'A'-'Z')
   protected boolean letter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('a'-'z' | 'A'-'Z')
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.LETTER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IntegerNumber : Digit+
   protected boolean integerNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (integerNumber$RuleMemoStart == index) {
         if (integerNumber$RuleMemoStart <= integerNumber$RuleMemoEnd) {
            index = integerNumber$RuleMemoEnd;
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // Digit+
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         do {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = index;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.INTEGER_NUMBER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = -1;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimePattern : (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
   protected boolean timePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)?
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ':'
         match = charMatcher(':');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // (':' IntegerNumber)?
               // (':' IntegerNumber)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ':'
               match = charMatcher(':');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               match = true;
               // ('.' IntegerNumber)?
               // ('.' IntegerNumber)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               match = true;
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
         match = true;
         // ("AM" | "PM")?
         // ("AM" | "PM")
         switch(buffer.getChar(index)) {
            case 'a':
            case 'A':
               ++index;
               // "M"
               if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                  ++index;
               }
               break;
            case 'p':
            case 'P':
               ++index;
               // "M"
               if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                  ++index;
               }
               break;
            default:
               match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.TIME_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DatePattern : (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
   protected boolean datePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // ('-' | '/' | '.')
         switch(buffer.getChar(index)) {
            case '/':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '.':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '-':
               ++index;
               // <EMPTY>
               match = true;
               break;
            default:
               match = false;
         }
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // ('-' | '/' | '.')
               switch(buffer.getChar(index)) {
                  case '/':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '.':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '-':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  default:
                     match = false;
               }
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.DATE_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Identifier : (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
   protected boolean identifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
      // ('A'-'Z' | 'a'-'z' | '_')
      // 'A'-'Z'
      match = charRangeMatcher('A', 'Z');
      if (! match) {
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // '_'
            match = charMatcher('_');
         }
      }
      if (match) {
         // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*
         do {
            // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
            if (! match) {
               // 'a'-'z'
               match = charRangeMatcher('a', 'z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                  }
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourPPRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }
}
