/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

package org.uggeri.yapp.runtime.java.test;

import org.uggeri.yapp.runtime.java.parser.Parser;
import org.uggeri.yapp.runtime.java.parser.Rule;
import org.uggeri.yapp.runtime.java.parser.RuleProfile;
import org.uggeri.yapp.runtime.java.buffer.InputBuffer;
import org.uggeri.yapp.runtime.java.node.Node;
import org.uggeri.yapp.runtime.java.node.NodeImpl;
import org.uggeri.yapp.runtime.java.parser.ParserError;
import org.uggeri.yapp.runtime.java.trace.TraceParser;
import java.util.Collections;
import java.util.Collection;
import java.util.Arrays;
import java.util.Map;

public class OracleScriptParser implements Parser {

   private int index = 0;

   private InputBuffer buffer;

   private boolean currentRuleIsAtomic = false;

   private Node currentNode = new NodeImpl(null, 0, 0, false, false);

   private int dmlSentence$RuleMemoStart = -1;
   private int dmlSentence$RuleMemoEnd;
   private Node dmlSentence$RuleMemoFirstNode;
   private int waitMode$RuleMemoStart = -1;
   private int waitMode$RuleMemoEnd;
   private Node waitMode$RuleMemoFirstNode;
   private int forceCommit$RuleMemoStart = -1;
   private int forceCommit$RuleMemoEnd;
   private Node forceCommit$RuleMemoFirstNode;
   private int normalCommit$RuleMemoStart = -1;
   private int normalCommit$RuleMemoEnd;
   private Node normalCommit$RuleMemoFirstNode;
   private int commitStatement$RuleMemoStart = -1;
   private int commitStatement$RuleMemoEnd;
   private Node commitStatement$RuleMemoFirstNode;
   private int lockTableStatement$RuleMemoStart = -1;
   private int lockTableStatement$RuleMemoEnd;
   private Node lockTableStatement$RuleMemoFirstNode;
   private int toSavePoint$RuleMemoStart = -1;
   private int toSavePoint$RuleMemoEnd;
   private Node toSavePoint$RuleMemoFirstNode;
   private int forceRollback$RuleMemoStart = -1;
   private int forceRollback$RuleMemoEnd;
   private Node forceRollback$RuleMemoFirstNode;
   private int rollbacklStatement$RuleMemoStart = -1;
   private int rollbacklStatement$RuleMemoEnd;
   private Node rollbacklStatement$RuleMemoFirstNode;
   private int transactionName$RuleMemoStart = -1;
   private int transactionName$RuleMemoEnd;
   private Node transactionName$RuleMemoFirstNode;
   private int useRollbackSegment$RuleMemoStart = -1;
   private int useRollbackSegment$RuleMemoEnd;
   private Node useRollbackSegment$RuleMemoFirstNode;
   private int isolationLevel$RuleMemoStart = -1;
   private int isolationLevel$RuleMemoEnd;
   private Node isolationLevel$RuleMemoFirstNode;
   private int readMode$RuleMemoStart = -1;
   private int readMode$RuleMemoEnd;
   private Node readMode$RuleMemoFirstNode;
   private int setTransactionStatement$RuleMemoStart = -1;
   private int setTransactionStatement$RuleMemoEnd;
   private Node setTransactionStatement$RuleMemoFirstNode;
   private int savepointStatement$RuleMemoStart = -1;
   private int savepointStatement$RuleMemoEnd;
   private Node savepointStatement$RuleMemoFirstNode;
   private int selectStatement$RuleMemoStart = -1;
   private int selectStatement$RuleMemoEnd;
   private Node selectStatement$RuleMemoFirstNode;
   private int mergeUpdateClause$RuleMemoStart = -1;
   private int mergeUpdateClause$RuleMemoEnd;
   private Node mergeUpdateClause$RuleMemoFirstNode;
   private int mergeInsertClause$RuleMemoStart = -1;
   private int mergeInsertClause$RuleMemoEnd;
   private Node mergeInsertClause$RuleMemoFirstNode;
   private int mergeStatement$RuleMemoStart = -1;
   private int mergeStatement$RuleMemoEnd;
   private Node mergeStatement$RuleMemoFirstNode;
   private int blockHint$RuleMemoStart = -1;
   private int blockHint$RuleMemoEnd;
   private Node blockHint$RuleMemoFirstNode;
   private int lineHint$RuleMemoStart = -1;
   private int lineHint$RuleMemoEnd;
   private Node lineHint$RuleMemoFirstNode;
   private int hint$RuleMemoStart = -1;
   private int hint$RuleMemoEnd;
   private Node hint$RuleMemoFirstNode;
   private int listAllFields$RuleMemoStart = -1;
   private int listAllFields$RuleMemoEnd;
   private Node listAllFields$RuleMemoFirstNode;
   private int selectListExpressionElement$RuleMemoStart = -1;
   private int selectListExpressionElement$RuleMemoEnd;
   private Node selectListExpressionElement$RuleMemoFirstNode;
   private int selectListElement$RuleMemoStart = -1;
   private int selectListElement$RuleMemoEnd;
   private Node selectListElement$RuleMemoFirstNode;
   private int listOfSelectListElement$RuleMemoStart = -1;
   private int listOfSelectListElement$RuleMemoEnd;
   private Node listOfSelectListElement$RuleMemoFirstNode;
   private int selectList$RuleMemoStart = -1;
   private int selectList$RuleMemoEnd;
   private Node selectList$RuleMemoFirstNode;
   private int subqueryReadOnlyRestriction$RuleMemoStart = -1;
   private int subqueryReadOnlyRestriction$RuleMemoEnd;
   private Node subqueryReadOnlyRestriction$RuleMemoFirstNode;
   private int subqueryCheckOptionRestriction$RuleMemoStart = -1;
   private int subqueryCheckOptionRestriction$RuleMemoEnd;
   private Node subqueryCheckOptionRestriction$RuleMemoFirstNode;
   private int tableOrView$RuleMemoStart = -1;
   private int tableOrView$RuleMemoEnd;
   private Node tableOrView$RuleMemoFirstNode;
   private int queryTableExpression$RuleMemoStart = -1;
   private int queryTableExpression$RuleMemoEnd;
   private Node queryTableExpression$RuleMemoFirstNode;
   private int dBLink$RuleMemoStart = -1;
   private int dBLink$RuleMemoEnd;
   private Node dBLink$RuleMemoFirstNode;
   private int tableName$RuleMemoStart = -1;
   private int tableName$RuleMemoEnd;
   private Node tableName$RuleMemoFirstNode;
   private int tableCollectionExpression$RuleMemoStart = -1;
   private int tableCollectionExpression$RuleMemoEnd;
   private Node tableCollectionExpression$RuleMemoFirstNode;
   private int sqlMathOperator$RuleMemoStart = -1;
   private int sqlMathOperator$RuleMemoEnd;
   private Node sqlMathOperator$RuleMemoFirstNode;
   private int sqlExpression$RuleMemoStart = -1;
   private int sqlExpression$RuleMemoEnd;
   private Node sqlExpression$RuleMemoFirstNode;
   private int sqlMathExpression$RuleMemoStart = -1;
   private int sqlMathExpression$RuleMemoEnd;
   private Node sqlMathExpression$RuleMemoFirstNode;
   private int parenthesesSqlExpression$RuleMemoStart = -1;
   private int parenthesesSqlExpression$RuleMemoEnd;
   private Node parenthesesSqlExpression$RuleMemoFirstNode;
   private int sqlUnaryExpression$RuleMemoStart = -1;
   private int sqlUnaryExpression$RuleMemoEnd;
   private Node sqlUnaryExpression$RuleMemoFirstNode;
   private int sqlLeftAtomicExpression$RuleMemoStart = -1;
   private int sqlLeftAtomicExpression$RuleMemoEnd;
   private Node sqlLeftAtomicExpression$RuleMemoFirstNode;
   private int dateTimeExpression$RuleMemoStart = -1;
   private int dateTimeExpression$RuleMemoEnd;
   private Node dateTimeExpression$RuleMemoFirstNode;
   private int sqlAtomicExpression$RuleMemoStart = -1;
   private int sqlAtomicExpression$RuleMemoEnd;
   private Node sqlAtomicExpression$RuleMemoFirstNode;
   private int sqlCaseExpression$RuleMemoStart = -1;
   private int sqlCaseExpression$RuleMemoEnd;
   private Node sqlCaseExpression$RuleMemoFirstNode;
   private int sqlSimpleCaseExpression$RuleMemoStart = -1;
   private int sqlSimpleCaseExpression$RuleMemoEnd;
   private Node sqlSimpleCaseExpression$RuleMemoFirstNode;
   private int sqlWhenConditionThen$RuleMemoStart = -1;
   private int sqlWhenConditionThen$RuleMemoEnd;
   private Node sqlWhenConditionThen$RuleMemoFirstNode;
   private int sqlSearchedCaseExpression$RuleMemoStart = -1;
   private int sqlSearchedCaseExpression$RuleMemoEnd;
   private Node sqlSearchedCaseExpression$RuleMemoFirstNode;
   private int rowNum$RuleMemoStart = -1;
   private int rowNum$RuleMemoEnd;
   private Node rowNum$RuleMemoFirstNode;
   private int identifiedRowId$RuleMemoStart = -1;
   private int identifiedRowId$RuleMemoEnd;
   private Node identifiedRowId$RuleMemoFirstNode;
   private int rowIdColumn$RuleMemoStart = -1;
   private int rowIdColumn$RuleMemoEnd;
   private Node rowIdColumn$RuleMemoFirstNode;
   private int level$RuleMemoStart = -1;
   private int level$RuleMemoEnd;
   private Node level$RuleMemoFirstNode;
   private int sqlOuterJoinObject$RuleMemoStart = -1;
   private int sqlOuterJoinObject$RuleMemoEnd;
   private Node sqlOuterJoinObject$RuleMemoFirstNode;
   private int sqlSimpleExpression$RuleMemoStart = -1;
   private int sqlSimpleExpression$RuleMemoEnd;
   private Node sqlSimpleExpression$RuleMemoFirstNode;
   private int sysDate$RuleMemoStart = -1;
   private int sysDate$RuleMemoEnd;
   private Node sysDate$RuleMemoFirstNode;
   private int timeExpression$RuleMemoStart = -1;
   private int timeExpression$RuleMemoEnd;
   private Node timeExpression$RuleMemoFirstNode;
   private int outerJoinSign$RuleMemoStart = -1;
   private int outerJoinSign$RuleMemoEnd;
   private Node outerJoinSign$RuleMemoFirstNode;
   private int orderByFunctionClause$RuleMemoStart = -1;
   private int orderByFunctionClause$RuleMemoEnd;
   private Node orderByFunctionClause$RuleMemoFirstNode;
   private int avg$RuleMemoStart = -1;
   private int avg$RuleMemoEnd;
   private Node avg$RuleMemoFirstNode;
   private int cast$RuleMemoStart = -1;
   private int cast$RuleMemoEnd;
   private Node cast$RuleMemoFirstNode;
   private int chr$RuleMemoStart = -1;
   private int chr$RuleMemoEnd;
   private Node chr$RuleMemoFirstNode;
   private int miningAttributeClause$RuleMemoStart = -1;
   private int miningAttributeClause$RuleMemoEnd;
   private Node miningAttributeClause$RuleMemoFirstNode;
   private int clusterId$RuleMemoStart = -1;
   private int clusterId$RuleMemoEnd;
   private Node clusterId$RuleMemoFirstNode;
   private int clusterProbability$RuleMemoStart = -1;
   private int clusterProbability$RuleMemoEnd;
   private Node clusterProbability$RuleMemoFirstNode;
   private int clusterSet$RuleMemoStart = -1;
   private int clusterSet$RuleMemoEnd;
   private Node clusterSet$RuleMemoFirstNode;
   private int corr$RuleMemoStart = -1;
   private int corr$RuleMemoEnd;
   private Node corr$RuleMemoFirstNode;
   private int distinctExpression$RuleMemoStart = -1;
   private int distinctExpression$RuleMemoEnd;
   private Node distinctExpression$RuleMemoFirstNode;
   private int allExpression$RuleMemoStart = -1;
   private int allExpression$RuleMemoEnd;
   private Node allExpression$RuleMemoFirstNode;
   private int count$RuleMemoStart = -1;
   private int count$RuleMemoEnd;
   private Node count$RuleMemoFirstNode;
   private int covarPop$RuleMemoStart = -1;
   private int covarPop$RuleMemoEnd;
   private Node covarPop$RuleMemoFirstNode;
   private int covarSamp$RuleMemoStart = -1;
   private int covarSamp$RuleMemoEnd;
   private Node covarSamp$RuleMemoFirstNode;
   private int cumeDistAnalytic$RuleMemoStart = -1;
   private int cumeDistAnalytic$RuleMemoEnd;
   private Node cumeDistAnalytic$RuleMemoFirstNode;
   private int cumeDistAggregate$RuleMemoStart = -1;
   private int cumeDistAggregate$RuleMemoEnd;
   private Node cumeDistAggregate$RuleMemoFirstNode;
   private int decompose$RuleMemoStart = -1;
   private int decompose$RuleMemoEnd;
   private Node decompose$RuleMemoFirstNode;
   private int denseRankAggregate$RuleMemoStart = -1;
   private int denseRankAggregate$RuleMemoEnd;
   private Node denseRankAggregate$RuleMemoFirstNode;
   private int denseRankAnalytic$RuleMemoStart = -1;
   private int denseRankAnalytic$RuleMemoEnd;
   private Node denseRankAnalytic$RuleMemoFirstNode;
   private int overParenthesesQueryPartitionClause$RuleMemoStart = -1;
   private int overParenthesesQueryPartitionClause$RuleMemoEnd;
   private Node overParenthesesQueryPartitionClause$RuleMemoFirstNode;
   private int extract$RuleMemoStart = -1;
   private int extract$RuleMemoEnd;
   private Node extract$RuleMemoFirstNode;
   private int featureId$RuleMemoStart = -1;
   private int featureId$RuleMemoEnd;
   private Node featureId$RuleMemoFirstNode;
   private int featureSet$RuleMemoStart = -1;
   private int featureSet$RuleMemoEnd;
   private Node featureSet$RuleMemoFirstNode;
   private int featureValue$RuleMemoStart = -1;
   private int featureValue$RuleMemoEnd;
   private Node featureValue$RuleMemoFirstNode;
   private int ignoreNulls$RuleMemoStart = -1;
   private int ignoreNulls$RuleMemoEnd;
   private Node ignoreNulls$RuleMemoFirstNode;
   private int firstValue$RuleMemoStart = -1;
   private int firstValue$RuleMemoEnd;
   private Node firstValue$RuleMemoFirstNode;
   private int lag$RuleMemoStart = -1;
   private int lag$RuleMemoEnd;
   private Node lag$RuleMemoFirstNode;
   private int lastValue$RuleMemoStart = -1;
   private int lastValue$RuleMemoEnd;
   private Node lastValue$RuleMemoFirstNode;
   private int lead$RuleMemoStart = -1;
   private int lead$RuleMemoEnd;
   private Node lead$RuleMemoFirstNode;
   private int listAgg$RuleMemoStart = -1;
   private int listAgg$RuleMemoEnd;
   private Node listAgg$RuleMemoFirstNode;
   private int max$RuleMemoStart = -1;
   private int max$RuleMemoEnd;
   private Node max$RuleMemoFirstNode;
   private int median$RuleMemoStart = -1;
   private int median$RuleMemoEnd;
   private Node median$RuleMemoFirstNode;
   private int min$RuleMemoStart = -1;
   private int min$RuleMemoEnd;
   private Node min$RuleMemoFirstNode;
   private int nTile$RuleMemoStart = -1;
   private int nTile$RuleMemoEnd;
   private Node nTile$RuleMemoFirstNode;
   private int percentRankAggregate$RuleMemoStart = -1;
   private int percentRankAggregate$RuleMemoEnd;
   private Node percentRankAggregate$RuleMemoFirstNode;
   private int percentRankAnalytic$RuleMemoStart = -1;
   private int percentRankAnalytic$RuleMemoEnd;
   private Node percentRankAnalytic$RuleMemoFirstNode;
   private int percentileCont$RuleMemoStart = -1;
   private int percentileCont$RuleMemoEnd;
   private Node percentileCont$RuleMemoFirstNode;
   private int percentileDisc$RuleMemoStart = -1;
   private int percentileDisc$RuleMemoEnd;
   private Node percentileDisc$RuleMemoFirstNode;
   private int costMatrixClauseValues$RuleMemoStart = -1;
   private int costMatrixClauseValues$RuleMemoEnd;
   private Node costMatrixClauseValues$RuleMemoFirstNode;
   private int costMatrixClauseModel$RuleMemoStart = -1;
   private int costMatrixClauseModel$RuleMemoEnd;
   private Node costMatrixClauseModel$RuleMemoFirstNode;
   private int costMatrixClause$RuleMemoStart = -1;
   private int costMatrixClause$RuleMemoEnd;
   private Node costMatrixClause$RuleMemoFirstNode;
   private int prediction$RuleMemoStart = -1;
   private int prediction$RuleMemoEnd;
   private Node prediction$RuleMemoFirstNode;
   private int predictionBounds$RuleMemoStart = -1;
   private int predictionBounds$RuleMemoEnd;
   private Node predictionBounds$RuleMemoFirstNode;
   private int predictionCost$RuleMemoStart = -1;
   private int predictionCost$RuleMemoEnd;
   private Node predictionCost$RuleMemoFirstNode;
   private int predictionDetails$RuleMemoStart = -1;
   private int predictionDetails$RuleMemoEnd;
   private Node predictionDetails$RuleMemoFirstNode;
   private int predictionProbability$RuleMemoStart = -1;
   private int predictionProbability$RuleMemoEnd;
   private Node predictionProbability$RuleMemoFirstNode;
   private int predictionSet$RuleMemoStart = -1;
   private int predictionSet$RuleMemoEnd;
   private Node predictionSet$RuleMemoFirstNode;
   private int rankAggregate$RuleMemoStart = -1;
   private int rankAggregate$RuleMemoEnd;
   private Node rankAggregate$RuleMemoFirstNode;
   private int rankAnalytic$RuleMemoStart = -1;
   private int rankAnalytic$RuleMemoEnd;
   private Node rankAnalytic$RuleMemoFirstNode;
   private int ratioToReport$RuleMemoStart = -1;
   private int ratioToReport$RuleMemoEnd;
   private Node ratioToReport$RuleMemoFirstNode;
   private int regrLinearFunctions$RuleMemoStart = -1;
   private int regrLinearFunctions$RuleMemoEnd;
   private Node regrLinearFunctions$RuleMemoFirstNode;
   private int rowNumber$RuleMemoStart = -1;
   private int rowNumber$RuleMemoEnd;
   private Node rowNumber$RuleMemoFirstNode;
   private int stdDev$RuleMemoStart = -1;
   private int stdDev$RuleMemoEnd;
   private Node stdDev$RuleMemoFirstNode;
   private int stdDevPop$RuleMemoStart = -1;
   private int stdDevPop$RuleMemoEnd;
   private Node stdDevPop$RuleMemoFirstNode;
   private int stdDevSamp$RuleMemoStart = -1;
   private int stdDevSamp$RuleMemoEnd;
   private Node stdDevSamp$RuleMemoFirstNode;
   private int sum$RuleMemoStart = -1;
   private int sum$RuleMemoEnd;
   private Node sum$RuleMemoFirstNode;
   private int translate$RuleMemoStart = -1;
   private int translate$RuleMemoEnd;
   private Node translate$RuleMemoFirstNode;
   private int treat$RuleMemoStart = -1;
   private int treat$RuleMemoEnd;
   private Node treat$RuleMemoFirstNode;
   private int trim$RuleMemoStart = -1;
   private int trim$RuleMemoEnd;
   private Node trim$RuleMemoFirstNode;
   private int varPop$RuleMemoStart = -1;
   private int varPop$RuleMemoEnd;
   private Node varPop$RuleMemoFirstNode;
   private int varSamp$RuleMemoStart = -1;
   private int varSamp$RuleMemoEnd;
   private Node varSamp$RuleMemoFirstNode;
   private int variance$RuleMemoStart = -1;
   private int variance$RuleMemoEnd;
   private Node variance$RuleMemoFirstNode;
   private int xmlAgg$RuleMemoStart = -1;
   private int xmlAgg$RuleMemoEnd;
   private Node xmlAgg$RuleMemoFirstNode;
   private int xmlCast$RuleMemoStart = -1;
   private int xmlCast$RuleMemoEnd;
   private Node xmlCast$RuleMemoFirstNode;
   private int xmlPar$RuleMemoStart = -1;
   private int xmlPar$RuleMemoEnd;
   private Node xmlPar$RuleMemoFirstNode;
   private int xmlColAttVal$RuleMemoStart = -1;
   private int xmlColAttVal$RuleMemoEnd;
   private Node xmlColAttVal$RuleMemoFirstNode;
   private int xmlElement$RuleMemoStart = -1;
   private int xmlElement$RuleMemoEnd;
   private Node xmlElement$RuleMemoFirstNode;
   private int asAlias$RuleMemoStart = -1;
   private int asAlias$RuleMemoEnd;
   private Node asAlias$RuleMemoFirstNode;
   private int aliasedExpression$RuleMemoStart = -1;
   private int aliasedExpression$RuleMemoEnd;
   private Node aliasedExpression$RuleMemoFirstNode;
   private int xmlPassingClause$RuleMemoStart = -1;
   private int xmlPassingClause$RuleMemoEnd;
   private Node xmlPassingClause$RuleMemoFirstNode;
   private int xmlExists$RuleMemoStart = -1;
   private int xmlExists$RuleMemoEnd;
   private Node xmlExists$RuleMemoFirstNode;
   private int xmlForest$RuleMemoStart = -1;
   private int xmlForest$RuleMemoEnd;
   private Node xmlForest$RuleMemoFirstNode;
   private int xmlParse$RuleMemoStart = -1;
   private int xmlParse$RuleMemoEnd;
   private Node xmlParse$RuleMemoFirstNode;
   private int xmlPI$RuleMemoStart = -1;
   private int xmlPI$RuleMemoEnd;
   private Node xmlPI$RuleMemoFirstNode;
   private int xmlQuery$RuleMemoStart = -1;
   private int xmlQuery$RuleMemoEnd;
   private Node xmlQuery$RuleMemoFirstNode;
   private int xmlRoot$RuleMemoStart = -1;
   private int xmlRoot$RuleMemoEnd;
   private Node xmlRoot$RuleMemoFirstNode;
   private int xmlNamespacesArg$RuleMemoStart = -1;
   private int xmlNamespacesArg$RuleMemoEnd;
   private Node xmlNamespacesArg$RuleMemoFirstNode;
   private int xmlTableColumn$RuleMemoStart = -1;
   private int xmlTableColumn$RuleMemoEnd;
   private Node xmlTableColumn$RuleMemoFirstNode;
   private int xmlTable$RuleMemoStart = -1;
   private int xmlTable$RuleMemoEnd;
   private Node xmlTable$RuleMemoFirstNode;
   private int builtInFunctionCall$RuleMemoStart = -1;
   private int builtInFunctionCall$RuleMemoEnd;
   private Node builtInFunctionCall$RuleMemoFirstNode;
   private int analyticFunctionCall$RuleMemoStart = -1;
   private int analyticFunctionCall$RuleMemoEnd;
   private Node analyticFunctionCall$RuleMemoFirstNode;
   private int sqlIdentifiedFunctionParameter$RuleMemoStart = -1;
   private int sqlIdentifiedFunctionParameter$RuleMemoEnd;
   private Node sqlIdentifiedFunctionParameter$RuleMemoFirstNode;
   private int sqlFunctionParameter$RuleMemoStart = -1;
   private int sqlFunctionParameter$RuleMemoEnd;
   private Node sqlFunctionParameter$RuleMemoFirstNode;
   private int unboundedPreceding$RuleMemoStart = -1;
   private int unboundedPreceding$RuleMemoEnd;
   private Node unboundedPreceding$RuleMemoFirstNode;
   private int unboundedFollowing$RuleMemoStart = -1;
   private int unboundedFollowing$RuleMemoEnd;
   private Node unboundedFollowing$RuleMemoFirstNode;
   private int currentRow$RuleMemoStart = -1;
   private int currentRow$RuleMemoEnd;
   private Node currentRow$RuleMemoFirstNode;
   private int preceding$RuleMemoStart = -1;
   private int preceding$RuleMemoEnd;
   private Node preceding$RuleMemoFirstNode;
   private int following$RuleMemoStart = -1;
   private int following$RuleMemoEnd;
   private Node following$RuleMemoFirstNode;
   private int betweenWindowingClause$RuleMemoStart = -1;
   private int betweenWindowingClause$RuleMemoEnd;
   private Node betweenWindowingClause$RuleMemoFirstNode;
   private int analyticOverClause$RuleMemoStart = -1;
   private int analyticOverClause$RuleMemoEnd;
   private Node analyticOverClause$RuleMemoFirstNode;
   private int modelExpression$RuleMemoStart = -1;
   private int modelExpression$RuleMemoEnd;
   private Node modelExpression$RuleMemoFirstNode;
   private int cursorExpression$RuleMemoStart = -1;
   private int cursorExpression$RuleMemoEnd;
   private Node cursorExpression$RuleMemoFirstNode;
   private int conditionOrExpression$RuleMemoStart = -1;
   private int conditionOrExpression$RuleMemoEnd;
   private Node conditionOrExpression$RuleMemoFirstNode;
   private int cellReferenceArgumentsList$RuleMemoStart = -1;
   private int cellReferenceArgumentsList$RuleMemoEnd;
   private Node cellReferenceArgumentsList$RuleMemoFirstNode;
   private int cellReferenceArgument$RuleMemoStart = -1;
   private int cellReferenceArgument$RuleMemoEnd;
   private Node cellReferenceArgument$RuleMemoFirstNode;
   private int placeHolderExpression$RuleMemoStart = -1;
   private int placeHolderExpression$RuleMemoEnd;
   private Node placeHolderExpression$RuleMemoFirstNode;
   private int typeConstructorExpression$RuleMemoStart = -1;
   private int typeConstructorExpression$RuleMemoEnd;
   private Node typeConstructorExpression$RuleMemoFirstNode;
   private int pivotForClause$RuleMemoStart = -1;
   private int pivotForClause$RuleMemoEnd;
   private Node pivotForClause$RuleMemoFirstNode;
   private int anyList$RuleMemoStart = -1;
   private int anyList$RuleMemoEnd;
   private Node anyList$RuleMemoFirstNode;
   private int sqlExpressionList$RuleMemoStart = -1;
   private int sqlExpressionList$RuleMemoEnd;
   private Node sqlExpressionList$RuleMemoFirstNode;
   private int parenthesesSqlExpressionList$RuleMemoStart = -1;
   private int parenthesesSqlExpressionList$RuleMemoEnd;
   private Node parenthesesSqlExpressionList$RuleMemoFirstNode;
   private int pivoInExpressionList$RuleMemoStart = -1;
   private int pivoInExpressionList$RuleMemoEnd;
   private Node pivoInExpressionList$RuleMemoFirstNode;
   private int asOptionalAlias$RuleMemoStart = -1;
   private int asOptionalAlias$RuleMemoEnd;
   private Node asOptionalAlias$RuleMemoFirstNode;
   private int pivotInExpression$RuleMemoStart = -1;
   private int pivotInExpression$RuleMemoEnd;
   private Node pivotInExpression$RuleMemoFirstNode;
   private int includeNulls$RuleMemoStart = -1;
   private int includeNulls$RuleMemoEnd;
   private Node includeNulls$RuleMemoFirstNode;
   private int excludeNulls$RuleMemoStart = -1;
   private int excludeNulls$RuleMemoEnd;
   private Node excludeNulls$RuleMemoFirstNode;
   private int unpivotInElement$RuleMemoStart = -1;
   private int unpivotInElement$RuleMemoEnd;
   private Node unpivotInElement$RuleMemoFirstNode;
   private int sqlLiteralList$RuleMemoStart = -1;
   private int sqlLiteralList$RuleMemoEnd;
   private Node sqlLiteralList$RuleMemoFirstNode;
   private int parenthesesLiteralList$RuleMemoStart = -1;
   private int parenthesesLiteralList$RuleMemoEnd;
   private Node parenthesesLiteralList$RuleMemoFirstNode;
   private int parenthesesLiteralListList$RuleMemoStart = -1;
   private int parenthesesLiteralListList$RuleMemoEnd;
   private Node parenthesesLiteralListList$RuleMemoFirstNode;
   private int schema$RuleMemoStart = -1;
   private int schema$RuleMemoEnd;
   private Node schema$RuleMemoFirstNode;
   private int table$RuleMemoStart = -1;
   private int table$RuleMemoEnd;
   private Node table$RuleMemoFirstNode;
   private int object$RuleMemoStart = -1;
   private int object$RuleMemoEnd;
   private Node object$RuleMemoFirstNode;
   private int column$RuleMemoStart = -1;
   private int column$RuleMemoEnd;
   private Node column$RuleMemoFirstNode;
   private int schemaObjectName$RuleMemoStart = -1;
   private int schemaObjectName$RuleMemoEnd;
   private Node schemaObjectName$RuleMemoFirstNode;
   private int columnName$RuleMemoStart = -1;
   private int columnName$RuleMemoEnd;
   private Node columnName$RuleMemoFirstNode;
   private int columnsList$RuleMemoStart = -1;
   private int columnsList$RuleMemoEnd;
   private Node columnsList$RuleMemoFirstNode;
   private int onlyQueryTableExpression$RuleMemoStart = -1;
   private int onlyQueryTableExpression$RuleMemoEnd;
   private Node onlyQueryTableExpression$RuleMemoFirstNode;
   private int queryTableExpressionPivotClause$RuleMemoStart = -1;
   private int queryTableExpressionPivotClause$RuleMemoEnd;
   private Node queryTableExpressionPivotClause$RuleMemoFirstNode;
   private int queryTableExpressionUnpivotClause$RuleMemoStart = -1;
   private int queryTableExpressionUnpivotClause$RuleMemoEnd;
   private Node queryTableExpressionUnpivotClause$RuleMemoFirstNode;
   private int tableReference$RuleMemoStart = -1;
   private int tableReference$RuleMemoEnd;
   private Node tableReference$RuleMemoFirstNode;
   private int relationalOperator$RuleMemoStart = -1;
   private int relationalOperator$RuleMemoEnd;
   private Node relationalOperator$RuleMemoFirstNode;
   private int sqlCondition$RuleMemoStart = -1;
   private int sqlCondition$RuleMemoEnd;
   private Node sqlCondition$RuleMemoFirstNode;
   private int orCondition$RuleMemoStart = -1;
   private int orCondition$RuleMemoEnd;
   private Node orCondition$RuleMemoFirstNode;
   private int andCondition$RuleMemoStart = -1;
   private int andCondition$RuleMemoEnd;
   private Node andCondition$RuleMemoFirstNode;
   private int notCondition$RuleMemoStart = -1;
   private int notCondition$RuleMemoEnd;
   private Node notCondition$RuleMemoFirstNode;
   private int parenthesesCondition$RuleMemoStart = -1;
   private int parenthesesCondition$RuleMemoEnd;
   private Node parenthesesCondition$RuleMemoFirstNode;
   private int conditionExpression$RuleMemoStart = -1;
   private int conditionExpression$RuleMemoEnd;
   private Node conditionExpression$RuleMemoFirstNode;
   private int existsCondition$RuleMemoStart = -1;
   private int existsCondition$RuleMemoEnd;
   private Node existsCondition$RuleMemoFirstNode;
   private int not$RuleMemoStart = -1;
   private int not$RuleMemoEnd;
   private Node not$RuleMemoFirstNode;
   private int isCondition$RuleMemoStart = -1;
   private int isCondition$RuleMemoEnd;
   private Node isCondition$RuleMemoFirstNode;
   private int prior$RuleMemoStart = -1;
   private int prior$RuleMemoEnd;
   private Node prior$RuleMemoFirstNode;
   private int relationalCondition$RuleMemoStart = -1;
   private int relationalCondition$RuleMemoEnd;
   private Node relationalCondition$RuleMemoFirstNode;
   private int groupConditionCoverageType$RuleMemoStart = -1;
   private int groupConditionCoverageType$RuleMemoEnd;
   private Node groupConditionCoverageType$RuleMemoFirstNode;
   private int equalityGroupCondition$RuleMemoStart = -1;
   private int equalityGroupCondition$RuleMemoEnd;
   private Node equalityGroupCondition$RuleMemoFirstNode;
   private int anyRelationalGroupCondition$RuleMemoStart = -1;
   private int anyRelationalGroupCondition$RuleMemoEnd;
   private Node anyRelationalGroupCondition$RuleMemoFirstNode;
   private int relationalGroupCondition$RuleMemoStart = -1;
   private int relationalGroupCondition$RuleMemoEnd;
   private Node relationalGroupCondition$RuleMemoFirstNode;
   private int inCondition$RuleMemoStart = -1;
   private int inCondition$RuleMemoEnd;
   private Node inCondition$RuleMemoFirstNode;
   private int isASetCondition$RuleMemoStart = -1;
   private int isASetCondition$RuleMemoEnd;
   private Node isASetCondition$RuleMemoFirstNode;
   private int objectIs$RuleMemoStart = -1;
   private int objectIs$RuleMemoEnd;
   private Node objectIs$RuleMemoFirstNode;
   private int isAnyCondition$RuleMemoStart = -1;
   private int isAnyCondition$RuleMemoEnd;
   private Node isAnyCondition$RuleMemoFirstNode;
   private int isEmptyCondition$RuleMemoStart = -1;
   private int isEmptyCondition$RuleMemoEnd;
   private Node isEmptyCondition$RuleMemoFirstNode;
   private int isOfTypeCondition$RuleMemoStart = -1;
   private int isOfTypeCondition$RuleMemoEnd;
   private Node isOfTypeCondition$RuleMemoFirstNode;
   private int isTypeOfObject$RuleMemoStart = -1;
   private int isTypeOfObject$RuleMemoEnd;
   private Node isTypeOfObject$RuleMemoFirstNode;
   private int isPresentCondition$RuleMemoStart = -1;
   private int isPresentCondition$RuleMemoEnd;
   private Node isPresentCondition$RuleMemoFirstNode;
   private int likeCondition$RuleMemoStart = -1;
   private int likeCondition$RuleMemoEnd;
   private Node likeCondition$RuleMemoFirstNode;
   private int regexCondition$RuleMemoStart = -1;
   private int regexCondition$RuleMemoEnd;
   private Node regexCondition$RuleMemoFirstNode;
   private int memberCondition$RuleMemoStart = -1;
   private int memberCondition$RuleMemoEnd;
   private Node memberCondition$RuleMemoFirstNode;
   private int betweenCondition$RuleMemoStart = -1;
   private int betweenCondition$RuleMemoEnd;
   private Node betweenCondition$RuleMemoFirstNode;
   private int subMultiSetCondition$RuleMemoStart = -1;
   private int subMultiSetCondition$RuleMemoEnd;
   private Node subMultiSetCondition$RuleMemoFirstNode;
   private int correlationInteger$RuleMemoStart = -1;
   private int correlationInteger$RuleMemoEnd;
   private Node correlationInteger$RuleMemoFirstNode;
   private int equalsPathCondition$RuleMemoStart = -1;
   private int equalsPathCondition$RuleMemoEnd;
   private Node equalsPathCondition$RuleMemoFirstNode;
   private int underPathCondition$RuleMemoStart = -1;
   private int underPathCondition$RuleMemoEnd;
   private Node underPathCondition$RuleMemoFirstNode;
   private int identifierOrStringLiteral$RuleMemoStart = -1;
   private int identifierOrStringLiteral$RuleMemoEnd;
   private Node identifierOrStringLiteral$RuleMemoFirstNode;
   private int onCondition$RuleMemoStart = -1;
   private int onCondition$RuleMemoEnd;
   private Node onCondition$RuleMemoFirstNode;
   private int using$RuleMemoStart = -1;
   private int using$RuleMemoEnd;
   private Node using$RuleMemoFirstNode;
   private int innerCrossJoinClause$RuleMemoStart = -1;
   private int innerCrossJoinClause$RuleMemoEnd;
   private Node innerCrossJoinClause$RuleMemoFirstNode;
   private int naturalOuterJoin$RuleMemoStart = -1;
   private int naturalOuterJoin$RuleMemoEnd;
   private Node naturalOuterJoin$RuleMemoFirstNode;
   private int normalOuterJoin$RuleMemoStart = -1;
   private int normalOuterJoin$RuleMemoEnd;
   private Node normalOuterJoin$RuleMemoFirstNode;
   private int outerJoinClause$RuleMemoStart = -1;
   private int outerJoinClause$RuleMemoEnd;
   private Node outerJoinClause$RuleMemoFirstNode;
   private int outerJoinType$RuleMemoStart = -1;
   private int outerJoinType$RuleMemoEnd;
   private Node outerJoinType$RuleMemoFirstNode;
   private int queryPartitionClause$RuleMemoStart = -1;
   private int queryPartitionClause$RuleMemoEnd;
   private Node queryPartitionClause$RuleMemoFirstNode;
   private int fromArgument$RuleMemoStart = -1;
   private int fromArgument$RuleMemoEnd;
   private Node fromArgument$RuleMemoFirstNode;
   private int currentOf$RuleMemoStart = -1;
   private int currentOf$RuleMemoEnd;
   private Node currentOf$RuleMemoFirstNode;
   private int whereClause$RuleMemoStart = -1;
   private int whereClause$RuleMemoEnd;
   private Node whereClause$RuleMemoFirstNode;
   private int bulkCollect$RuleMemoStart = -1;
   private int bulkCollect$RuleMemoEnd;
   private Node bulkCollect$RuleMemoFirstNode;
   private int queryBlock$RuleMemoStart = -1;
   private int queryBlock$RuleMemoEnd;
   private Node queryBlock$RuleMemoFirstNode;
   private int enclosedSubquery$RuleMemoStart = -1;
   private int enclosedSubquery$RuleMemoEnd;
   private Node enclosedSubquery$RuleMemoFirstNode;
   private int subquery$RuleMemoStart = -1;
   private int subquery$RuleMemoEnd;
   private Node subquery$RuleMemoFirstNode;
   private int startWithCondition$RuleMemoStart = -1;
   private int startWithCondition$RuleMemoEnd;
   private Node startWithCondition$RuleMemoFirstNode;
   private int connectByCondition$RuleMemoStart = -1;
   private int connectByCondition$RuleMemoEnd;
   private Node connectByCondition$RuleMemoFirstNode;
   private int connectBy$RuleMemoStart = -1;
   private int connectBy$RuleMemoEnd;
   private Node connectBy$RuleMemoFirstNode;
   private int startWith$RuleMemoStart = -1;
   private int startWith$RuleMemoEnd;
   private Node startWith$RuleMemoFirstNode;
   private int groupByArgument$RuleMemoStart = -1;
   private int groupByArgument$RuleMemoEnd;
   private Node groupByArgument$RuleMemoFirstNode;
   private int rollupCubeClause$RuleMemoStart = -1;
   private int rollupCubeClause$RuleMemoEnd;
   private Node rollupCubeClause$RuleMemoFirstNode;
   private int groupingExpressionList$RuleMemoStart = -1;
   private int groupingExpressionList$RuleMemoEnd;
   private Node groupingExpressionList$RuleMemoFirstNode;
   private int groupingSetsClause$RuleMemoStart = -1;
   private int groupingSetsClause$RuleMemoEnd;
   private Node groupingSetsClause$RuleMemoFirstNode;
   private int groupingSetsClauseArgument$RuleMemoStart = -1;
   private int groupingSetsClauseArgument$RuleMemoEnd;
   private Node groupingSetsClauseArgument$RuleMemoFirstNode;
   private int havingClause$RuleMemoStart = -1;
   private int havingClause$RuleMemoEnd;
   private Node havingClause$RuleMemoFirstNode;
   private int cellReferenceOptions$RuleMemoStart = -1;
   private int cellReferenceOptions$RuleMemoEnd;
   private Node cellReferenceOptions$RuleMemoFirstNode;
   private int modelColumnClause$RuleMemoStart = -1;
   private int modelColumnClause$RuleMemoEnd;
   private Node modelColumnClause$RuleMemoFirstNode;
   private int modelColumnList$RuleMemoStart = -1;
   private int modelColumnList$RuleMemoEnd;
   private Node modelColumnList$RuleMemoFirstNode;
   private int modelColumn$RuleMemoStart = -1;
   private int modelColumn$RuleMemoEnd;
   private Node modelColumn$RuleMemoFirstNode;
   private int modelRulesClauseCellAssignment$RuleMemoStart = -1;
   private int modelRulesClauseCellAssignment$RuleMemoEnd;
   private Node modelRulesClauseCellAssignment$RuleMemoFirstNode;
   private int cellAssignmentArgumentsList$RuleMemoStart = -1;
   private int cellAssignmentArgumentsList$RuleMemoEnd;
   private Node cellAssignmentArgumentsList$RuleMemoFirstNode;
   private int cellAssignmentArgument$RuleMemoStart = -1;
   private int cellAssignmentArgument$RuleMemoEnd;
   private Node cellAssignmentArgument$RuleMemoFirstNode;
   private int forIn$RuleMemoStart = -1;
   private int forIn$RuleMemoEnd;
   private Node forIn$RuleMemoFirstNode;
   private int forLike$RuleMemoStart = -1;
   private int forLike$RuleMemoEnd;
   private Node forLike$RuleMemoFirstNode;
   private int singleColumnForLoop$RuleMemoStart = -1;
   private int singleColumnForLoop$RuleMemoEnd;
   private Node singleColumnForLoop$RuleMemoFirstNode;
   private int multiColumnForLoop$RuleMemoStart = -1;
   private int multiColumnForLoop$RuleMemoEnd;
   private Node multiColumnForLoop$RuleMemoFirstNode;
   private int sqlLiteral$RuleMemoStart = -1;
   private int sqlLiteral$RuleMemoEnd;
   private Node sqlLiteral$RuleMemoFirstNode;
   private int nullLiteral$RuleMemoStart = -1;
   private int nullLiteral$RuleMemoEnd;
   private Node nullLiteral$RuleMemoFirstNode;
   private int dateLiteral$RuleMemoStart = -1;
   private int dateLiteral$RuleMemoEnd;
   private Node dateLiteral$RuleMemoFirstNode;
   private int year$RuleMemoStart = -1;
   private int year$RuleMemoEnd;
   private Node year$RuleMemoFirstNode;
   private int month$RuleMemoStart = -1;
   private int month$RuleMemoEnd;
   private Node month$RuleMemoFirstNode;
   private int day$RuleMemoStart = -1;
   private int day$RuleMemoEnd;
   private Node day$RuleMemoFirstNode;
   private int timestampLiteral$RuleMemoStart = -1;
   private int timestampLiteral$RuleMemoEnd;
   private Node timestampLiteral$RuleMemoFirstNode;
   private int stringLiteral$RuleMemoStart = -1;
   private int stringLiteral$RuleMemoEnd;
   private Node stringLiteral$RuleMemoFirstNode;
   private int orderByArgument$RuleMemoStart = -1;
   private int orderByArgument$RuleMemoEnd;
   private Node orderByArgument$RuleMemoFirstNode;
   private int orderByArguments$RuleMemoStart = -1;
   private int orderByArguments$RuleMemoEnd;
   private Node orderByArguments$RuleMemoFirstNode;
   private int orderByClause$RuleMemoStart = -1;
   private int orderByClause$RuleMemoEnd;
   private Node orderByClause$RuleMemoFirstNode;
   private int subqueryFactoringSource$RuleMemoStart = -1;
   private int subqueryFactoringSource$RuleMemoEnd;
   private Node subqueryFactoringSource$RuleMemoFirstNode;
   private int onlyDmlTableExpresionClause$RuleMemoStart = -1;
   private int onlyDmlTableExpresionClause$RuleMemoEnd;
   private Node onlyDmlTableExpresionClause$RuleMemoFirstNode;
   private int updateStatement$RuleMemoStart = -1;
   private int updateStatement$RuleMemoEnd;
   private Node updateStatement$RuleMemoFirstNode;
   private int partitionName$RuleMemoStart = -1;
   private int partitionName$RuleMemoEnd;
   private Node partitionName$RuleMemoFirstNode;
   private int partitionKey$RuleMemoStart = -1;
   private int partitionKey$RuleMemoEnd;
   private Node partitionKey$RuleMemoFirstNode;
   private int tablePartitionName$RuleMemoStart = -1;
   private int tablePartitionName$RuleMemoEnd;
   private Node tablePartitionName$RuleMemoFirstNode;
   private int tableSubPartitionName$RuleMemoStart = -1;
   private int tableSubPartitionName$RuleMemoEnd;
   private Node tableSubPartitionName$RuleMemoFirstNode;
   private int subqueryDmlExpression$RuleMemoStart = -1;
   private int subqueryDmlExpression$RuleMemoEnd;
   private Node subqueryDmlExpression$RuleMemoFirstNode;
   private int dmlTableExpressionClause$RuleMemoStart = -1;
   private int dmlTableExpressionClause$RuleMemoEnd;
   private Node dmlTableExpressionClause$RuleMemoFirstNode;
   private int updateSetClause$RuleMemoStart = -1;
   private int updateSetClause$RuleMemoEnd;
   private Node updateSetClause$RuleMemoFirstNode;
   private int alias$RuleMemoStart = -1;
   private int alias$RuleMemoEnd;
   private Node alias$RuleMemoFirstNode;
   private int objectSetValue$RuleMemoStart = -1;
   private int objectSetValue$RuleMemoEnd;
   private Node objectSetValue$RuleMemoFirstNode;
   private int columnsGroupSetValue$RuleMemoStart = -1;
   private int columnsGroupSetValue$RuleMemoEnd;
   private Node columnsGroupSetValue$RuleMemoFirstNode;
   private int singleColumnSetValue$RuleMemoStart = -1;
   private int singleColumnSetValue$RuleMemoEnd;
   private Node singleColumnSetValue$RuleMemoFirstNode;
   private int columnSetValue$RuleMemoStart = -1;
   private int columnSetValue$RuleMemoEnd;
   private Node columnSetValue$RuleMemoFirstNode;
   private int columnSetValueList$RuleMemoStart = -1;
   private int columnSetValueList$RuleMemoEnd;
   private Node columnSetValueList$RuleMemoFirstNode;
   private int returningClause$RuleMemoStart = -1;
   private int returningClause$RuleMemoEnd;
   private Node returningClause$RuleMemoFirstNode;
   private int bindVariable$RuleMemoStart = -1;
   private int bindVariable$RuleMemoEnd;
   private Node bindVariable$RuleMemoFirstNode;
   private int returnIntoVariable$RuleMemoStart = -1;
   private int returnIntoVariable$RuleMemoEnd;
   private Node returnIntoVariable$RuleMemoFirstNode;
   private int insertStatement$RuleMemoStart = -1;
   private int insertStatement$RuleMemoEnd;
   private Node insertStatement$RuleMemoFirstNode;
   private int values$RuleMemoStart = -1;
   private int values$RuleMemoEnd;
   private Node values$RuleMemoFirstNode;
   private int singleTableInsert$RuleMemoStart = -1;
   private int singleTableInsert$RuleMemoEnd;
   private Node singleTableInsert$RuleMemoFirstNode;
   private int multiIntoClause$RuleMemoStart = -1;
   private int multiIntoClause$RuleMemoEnd;
   private Node multiIntoClause$RuleMemoFirstNode;
   private int multiTableInsert$RuleMemoStart = -1;
   private int multiTableInsert$RuleMemoEnd;
   private Node multiTableInsert$RuleMemoFirstNode;
   private int insertIntoValuesClauseList$RuleMemoStart = -1;
   private int insertIntoValuesClauseList$RuleMemoEnd;
   private Node insertIntoValuesClauseList$RuleMemoFirstNode;
   private int conditionalInsertClause$RuleMemoStart = -1;
   private int conditionalInsertClause$RuleMemoEnd;
   private Node conditionalInsertClause$RuleMemoFirstNode;
   private int insertIntoClause$RuleMemoStart = -1;
   private int insertIntoClause$RuleMemoEnd;
   private Node insertIntoClause$RuleMemoFirstNode;
   private int valueClauseData$RuleMemoStart = -1;
   private int valueClauseData$RuleMemoEnd;
   private Node valueClauseData$RuleMemoFirstNode;
   private int valuesClauseList$RuleMemoStart = -1;
   private int valuesClauseList$RuleMemoEnd;
   private Node valuesClauseList$RuleMemoFirstNode;
   private int valuesClause$RuleMemoStart = -1;
   private int valuesClause$RuleMemoEnd;
   private Node valuesClause$RuleMemoFirstNode;
   private int errorLogingClause$RuleMemoStart = -1;
   private int errorLogingClause$RuleMemoEnd;
   private Node errorLogingClause$RuleMemoFirstNode;
   private int deleteStatement$RuleMemoStart = -1;
   private int deleteStatement$RuleMemoEnd;
   private Node deleteStatement$RuleMemoFirstNode;
   private int unsignedNumber$RuleMemoStart = -1;
   private int unsignedNumber$RuleMemoEnd;
   private Node unsignedNumber$RuleMemoFirstNode;
   private int sign$RuleMemoStart = -1;
   private int sign$RuleMemoEnd;
   private Node sign$RuleMemoFirstNode;
   private int numberLiteral$RuleMemoStart = -1;
   private int numberLiteral$RuleMemoEnd;
   private Node numberLiteral$RuleMemoFirstNode;
   private int integerLiteral$RuleMemoStart = -1;
   private int integerLiteral$RuleMemoEnd;
   private Node integerLiteral$RuleMemoFirstNode;
   private int integerPattern$RuleMemoStart = -1;
   private int integerPattern$RuleMemoEnd;
   private Node integerPattern$RuleMemoFirstNode;
   private int size$RuleMemoStart = -1;
   private int size$RuleMemoEnd;
   private Node size$RuleMemoFirstNode;
   private int charSetDefinition$RuleMemoStart = -1;
   private int charSetDefinition$RuleMemoEnd;
   private Node charSetDefinition$RuleMemoFirstNode;
   private int charSize$RuleMemoStart = -1;
   private int charSize$RuleMemoEnd;
   private Node charSize$RuleMemoFirstNode;
   private int varChar2$RuleMemoStart = -1;
   private int varChar2$RuleMemoEnd;
   private Node varChar2$RuleMemoFirstNode;
   private int varChar$RuleMemoStart = -1;
   private int varChar$RuleMemoEnd;
   private Node varChar$RuleMemoFirstNode;
   private int char$RuleMemoStart = -1;
   private int char$RuleMemoEnd;
   private Node char$RuleMemoFirstNode;
   private int numberSize$RuleMemoStart = -1;
   private int numberSize$RuleMemoEnd;
   private Node numberSize$RuleMemoFirstNode;
   private int number$RuleMemoStart = -1;
   private int number$RuleMemoEnd;
   private Node number$RuleMemoFirstNode;
   private int float$RuleMemoStart = -1;
   private int float$RuleMemoEnd;
   private Node float$RuleMemoFirstNode;
   private int timestamp$RuleMemoStart = -1;
   private int timestamp$RuleMemoEnd;
   private Node timestamp$RuleMemoFirstNode;
   private int intervalDayToSecondLiteral$RuleMemoStart = -1;
   private int intervalDayToSecondLiteral$RuleMemoEnd;
   private Node intervalDayToSecondLiteral$RuleMemoFirstNode;
   private int intervalDayToSecond$RuleMemoStart = -1;
   private int intervalDayToSecond$RuleMemoEnd;
   private Node intervalDayToSecond$RuleMemoFirstNode;
   private int intervalYearToMonthLeadingTrailing$RuleMemoStart = -1;
   private int intervalYearToMonthLeadingTrailing$RuleMemoEnd;
   private Node intervalYearToMonthLeadingTrailing$RuleMemoFirstNode;
   private int intervalYearToMonthLiteral$RuleMemoStart = -1;
   private int intervalYearToMonthLiteral$RuleMemoEnd;
   private Node intervalYearToMonthLiteral$RuleMemoFirstNode;
   private int intervalYearToMonth$RuleMemoStart = -1;
   private int intervalYearToMonth$RuleMemoEnd;
   private Node intervalYearToMonth$RuleMemoFirstNode;
   private int time$RuleMemoStart = -1;
   private int time$RuleMemoEnd;
   private Node time$RuleMemoFirstNode;
   private int refXml$RuleMemoStart = -1;
   private int refXml$RuleMemoEnd;
   private Node refXml$RuleMemoFirstNode;
   private int nChar$RuleMemoStart = -1;
   private int nChar$RuleMemoEnd;
   private Node nChar$RuleMemoFirstNode;
   private int nVarChar2$RuleMemoStart = -1;
   private int nVarChar2$RuleMemoEnd;
   private Node nVarChar2$RuleMemoFirstNode;
   private int longRaw$RuleMemoStart = -1;
   private int longRaw$RuleMemoEnd;
   private Node longRaw$RuleMemoFirstNode;
   private int raw$RuleMemoStart = -1;
   private int raw$RuleMemoEnd;
   private Node raw$RuleMemoFirstNode;
   private int cLob$RuleMemoStart = -1;
   private int cLob$RuleMemoEnd;
   private Node cLob$RuleMemoFirstNode;
   private int uRowId$RuleMemoStart = -1;
   private int uRowId$RuleMemoEnd;
   private Node uRowId$RuleMemoFirstNode;
   private int binaryFloat$RuleMemoStart = -1;
   private int binaryFloat$RuleMemoEnd;
   private Node binaryFloat$RuleMemoFirstNode;
   private int binaryDouble$RuleMemoStart = -1;
   private int binaryDouble$RuleMemoEnd;
   private Node binaryDouble$RuleMemoFirstNode;
   private int date$RuleMemoStart = -1;
   private int date$RuleMemoEnd;
   private Node date$RuleMemoFirstNode;
   private int bLob$RuleMemoStart = -1;
   private int bLob$RuleMemoEnd;
   private Node bLob$RuleMemoFirstNode;
   private int nCLob$RuleMemoStart = -1;
   private int nCLob$RuleMemoEnd;
   private Node nCLob$RuleMemoFirstNode;
   private int bFile$RuleMemoStart = -1;
   private int bFile$RuleMemoEnd;
   private Node bFile$RuleMemoFirstNode;
   private int rowId$RuleMemoStart = -1;
   private int rowId$RuleMemoEnd;
   private Node rowId$RuleMemoFirstNode;
   private int sqlDataType$RuleMemoStart = -1;
   private int sqlDataType$RuleMemoEnd;
   private Node sqlDataType$RuleMemoFirstNode;
   private int sqlParameters$RuleMemoStart = -1;
   private int sqlParameters$RuleMemoEnd;
   private Node sqlParameters$RuleMemoFirstNode;
   private int sqlQualifiedIdentifierRemote$RuleMemoStart = -1;
   private int sqlQualifiedIdentifierRemote$RuleMemoEnd;
   private Node sqlQualifiedIdentifierRemote$RuleMemoFirstNode;
   private int sqlSimpleIdentifierRemote$RuleMemoStart = -1;
   private int sqlSimpleIdentifierRemote$RuleMemoEnd;
   private Node sqlSimpleIdentifierRemote$RuleMemoFirstNode;
   private int sqlAttributes$RuleMemoStart = -1;
   private int sqlAttributes$RuleMemoEnd;
   private Node sqlAttributes$RuleMemoFirstNode;
   private int sqlQualifiedIdentifier$RuleMemoStart = -1;
   private int sqlQualifiedIdentifier$RuleMemoEnd;
   private Node sqlQualifiedIdentifier$RuleMemoFirstNode;
   private int sqlAnyParameterizedIdentifier$RuleMemoStart = -1;
   private int sqlAnyParameterizedIdentifier$RuleMemoEnd;
   private Node sqlAnyParameterizedIdentifier$RuleMemoFirstNode;
   private int sqlSimpleIdentifier$RuleMemoStart = -1;
   private int sqlSimpleIdentifier$RuleMemoEnd;
   private Node sqlSimpleIdentifier$RuleMemoFirstNode;
   private int sqlParameterizedIdentifier$RuleMemoStart = -1;
   private int sqlParameterizedIdentifier$RuleMemoEnd;
   private Node sqlParameterizedIdentifier$RuleMemoFirstNode;
   private int sqlObjectIdentifier$RuleMemoStart = -1;
   private int sqlObjectIdentifier$RuleMemoEnd;
   private Node sqlObjectIdentifier$RuleMemoFirstNode;
   private int sqlIdentifier$RuleMemoStart = -1;
   private int sqlIdentifier$RuleMemoEnd;
   private Node sqlIdentifier$RuleMemoFirstNode;
   private int sqlAnyIdentifier$RuleMemoStart = -1;
   private int sqlAnyIdentifier$RuleMemoEnd;
   private Node sqlAnyIdentifier$RuleMemoFirstNode;
   private int testNoAlpha$RuleMemoStart = -1;
   private int testNoAlpha$RuleMemoEnd;
   private Node testNoAlpha$RuleMemoFirstNode;
   private int optionalSpacing$RuleMemoStart = -1;
   private int optionalSpacing$RuleMemoEnd;
   private Node optionalSpacing$RuleMemoFirstNode;
   private int sqlObjectIdentifierList$RuleMemoStart = -1;
   private int sqlObjectIdentifierList$RuleMemoEnd;
   private Node sqlObjectIdentifierList$RuleMemoFirstNode;
   private int sqlIdentifierList$RuleMemoStart = -1;
   private int sqlIdentifierList$RuleMemoEnd;
   private Node sqlIdentifierList$RuleMemoFirstNode;
   private int spaces$RuleMemoStart = -1;
   private int spaces$RuleMemoEnd;
   private Node spaces$RuleMemoFirstNode;
   private int blockComment$RuleMemoStart = -1;
   private int blockComment$RuleMemoEnd;
   private Node blockComment$RuleMemoFirstNode;
   private int lineComment$RuleMemoStart = -1;
   private int lineComment$RuleMemoEnd;
   private Node lineComment$RuleMemoFirstNode;
   private int plSqlSource$RuleMemoStart = -1;
   private int plSqlSource$RuleMemoEnd;
   private Node plSqlSource$RuleMemoFirstNode;
   private int plSqlExpression$RuleMemoStart = -1;
   private int plSqlExpression$RuleMemoEnd;
   private Node plSqlExpression$RuleMemoFirstNode;
   private int optionalAndExpression$RuleMemoStart = -1;
   private int optionalAndExpression$RuleMemoEnd;
   private Node optionalAndExpression$RuleMemoFirstNode;
   private int logicalExpression$RuleMemoStart = -1;
   private int logicalExpression$RuleMemoEnd;
   private Node logicalExpression$RuleMemoFirstNode;
   private int notExpression$RuleMemoStart = -1;
   private int notExpression$RuleMemoEnd;
   private Node notExpression$RuleMemoFirstNode;
   private int relationalExpression$RuleMemoStart = -1;
   private int relationalExpression$RuleMemoEnd;
   private Node relationalExpression$RuleMemoFirstNode;
   private int comparisonExpression$RuleMemoStart = -1;
   private int comparisonExpression$RuleMemoEnd;
   private Node comparisonExpression$RuleMemoFirstNode;
   private int inExpression$RuleMemoStart = -1;
   private int inExpression$RuleMemoEnd;
   private Node inExpression$RuleMemoFirstNode;
   private int betweenExpression$RuleMemoStart = -1;
   private int betweenExpression$RuleMemoEnd;
   private Node betweenExpression$RuleMemoFirstNode;
   private int likeExpression$RuleMemoStart = -1;
   private int likeExpression$RuleMemoEnd;
   private Node likeExpression$RuleMemoFirstNode;
   private int isNullExpression$RuleMemoStart = -1;
   private int isNullExpression$RuleMemoEnd;
   private Node isNullExpression$RuleMemoFirstNode;
   private int numericExpression$RuleMemoStart = -1;
   private int numericExpression$RuleMemoEnd;
   private Node numericExpression$RuleMemoFirstNode;
   private int plSqlMathExpression$RuleMemoStart = -1;
   private int plSqlMathExpression$RuleMemoEnd;
   private Node plSqlMathExpression$RuleMemoFirstNode;
   private int plSqlUnaryExpression$RuleMemoStart = -1;
   private int plSqlUnaryExpression$RuleMemoEnd;
   private Node plSqlUnaryExpression$RuleMemoFirstNode;
   private int plSqlParenthesesExpression$RuleMemoStart = -1;
   private int plSqlParenthesesExpression$RuleMemoEnd;
   private Node plSqlParenthesesExpression$RuleMemoFirstNode;
   private int sqlCursorAttribute$RuleMemoStart = -1;
   private int sqlCursorAttribute$RuleMemoEnd;
   private Node sqlCursorAttribute$RuleMemoFirstNode;
   private int plSqlObjectCursor$RuleMemoStart = -1;
   private int plSqlObjectCursor$RuleMemoEnd;
   private Node plSqlObjectCursor$RuleMemoFirstNode;
   private int plSqlObjectCollection$RuleMemoStart = -1;
   private int plSqlObjectCollection$RuleMemoEnd;
   private Node plSqlObjectCollection$RuleMemoFirstNode;
   private int hostVariableCursor$RuleMemoStart = -1;
   private int hostVariableCursor$RuleMemoEnd;
   private Node hostVariableCursor$RuleMemoFirstNode;
   private int plSqlAtomicExpression$RuleMemoStart = -1;
   private int plSqlAtomicExpression$RuleMemoEnd;
   private Node plSqlAtomicExpression$RuleMemoFirstNode;
   private int plSqlCaseExpression$RuleMemoStart = -1;
   private int plSqlCaseExpression$RuleMemoEnd;
   private Node plSqlCaseExpression$RuleMemoFirstNode;
   private int cursorAttribute$RuleMemoStart = -1;
   private int cursorAttribute$RuleMemoEnd;
   private Node cursorAttribute$RuleMemoFirstNode;
   private int isAsKeyword$RuleMemoStart = -1;
   private int isAsKeyword$RuleMemoEnd;
   private Node isAsKeyword$RuleMemoFirstNode;
   private int declarationSection$RuleMemoStart = -1;
   private int declarationSection$RuleMemoEnd;
   private Node declarationSection$RuleMemoFirstNode;
   private int endBlock$RuleMemoStart = -1;
   private int endBlock$RuleMemoEnd;
   private Node endBlock$RuleMemoFirstNode;
   private int createPackageBody$RuleMemoStart = -1;
   private int createPackageBody$RuleMemoEnd;
   private Node createPackageBody$RuleMemoFirstNode;
   private int authIdCurrentUser$RuleMemoStart = -1;
   private int authIdCurrentUser$RuleMemoEnd;
   private Node authIdCurrentUser$RuleMemoFirstNode;
   private int authIdDefiner$RuleMemoStart = -1;
   private int authIdDefiner$RuleMemoEnd;
   private Node authIdDefiner$RuleMemoFirstNode;
   private int invokerRights$RuleMemoStart = -1;
   private int invokerRights$RuleMemoEnd;
   private Node invokerRights$RuleMemoFirstNode;
   private int createPackage$RuleMemoStart = -1;
   private int createPackage$RuleMemoEnd;
   private Node createPackage$RuleMemoFirstNode;
   private int externalCParameter$RuleMemoStart = -1;
   private int externalCParameter$RuleMemoEnd;
   private Node externalCParameter$RuleMemoFirstNode;
   private int callJavaSpec$RuleMemoStart = -1;
   private int callJavaSpec$RuleMemoEnd;
   private Node callJavaSpec$RuleMemoFirstNode;
   private int callCSpec$RuleMemoStart = -1;
   private int callCSpec$RuleMemoEnd;
   private Node callCSpec$RuleMemoFirstNode;
   private int callSpec$RuleMemoStart = -1;
   private int callSpec$RuleMemoEnd;
   private Node callSpec$RuleMemoFirstNode;
   private int pragmaOrStatement$RuleMemoStart = -1;
   private int pragmaOrStatement$RuleMemoEnd;
   private Node pragmaOrStatement$RuleMemoFirstNode;
   private int plSqlBody$RuleMemoStart = -1;
   private int plSqlBody$RuleMemoEnd;
   private Node plSqlBody$RuleMemoFirstNode;
   private int functionBody$RuleMemoStart = -1;
   private int functionBody$RuleMemoEnd;
   private Node functionBody$RuleMemoFirstNode;
   private int callSpecOrFunctionBody$RuleMemoStart = -1;
   private int callSpecOrFunctionBody$RuleMemoEnd;
   private Node callSpecOrFunctionBody$RuleMemoFirstNode;
   private int createFunction$RuleMemoStart = -1;
   private int createFunction$RuleMemoEnd;
   private Node createFunction$RuleMemoFirstNode;
   private int functionDefinition$RuleMemoStart = -1;
   private int functionDefinition$RuleMemoEnd;
   private Node functionDefinition$RuleMemoFirstNode;
   private int createProcedure$RuleMemoStart = -1;
   private int createProcedure$RuleMemoEnd;
   private Node createProcedure$RuleMemoFirstNode;
   private int procedureDefinition$RuleMemoStart = -1;
   private int procedureDefinition$RuleMemoEnd;
   private Node procedureDefinition$RuleMemoFirstNode;
   private int createOrReplace$RuleMemoStart = -1;
   private int createOrReplace$RuleMemoEnd;
   private Node createOrReplace$RuleMemoFirstNode;
   private int itemList1$RuleMemoStart = -1;
   private int itemList1$RuleMemoEnd;
   private Node itemList1$RuleMemoFirstNode;
   private int itemList2$RuleMemoStart = -1;
   private int itemList2$RuleMemoEnd;
   private Node itemList2$RuleMemoFirstNode;
   private int declareSection$RuleMemoStart = -1;
   private int declareSection$RuleMemoEnd;
   private Node declareSection$RuleMemoFirstNode;
   private int typeDefinition$RuleMemoStart = -1;
   private int typeDefinition$RuleMemoEnd;
   private Node typeDefinition$RuleMemoFirstNode;
   private int null$RuleMemoStart = -1;
   private int null$RuleMemoEnd;
   private Node null$RuleMemoFirstNode;
   private int notNull$RuleMemoStart = -1;
   private int notNull$RuleMemoEnd;
   private Node notNull$RuleMemoFirstNode;
   private int nullable$RuleMemoStart = -1;
   private int nullable$RuleMemoEnd;
   private Node nullable$RuleMemoFirstNode;
   private int subtypeDefinition$RuleMemoStart = -1;
   private int subtypeDefinition$RuleMemoEnd;
   private Node subtypeDefinition$RuleMemoFirstNode;
   private int recordTypeDefinition$RuleMemoStart = -1;
   private int recordTypeDefinition$RuleMemoEnd;
   private Node recordTypeDefinition$RuleMemoFirstNode;
   private int defaultValue$RuleMemoStart = -1;
   private int defaultValue$RuleMemoEnd;
   private Node defaultValue$RuleMemoFirstNode;
   private int recordFieldDeclaration$RuleMemoStart = -1;
   private int recordFieldDeclaration$RuleMemoEnd;
   private Node recordFieldDeclaration$RuleMemoFirstNode;
   private int collectionTypeDefinition$RuleMemoStart = -1;
   private int collectionTypeDefinition$RuleMemoEnd;
   private Node collectionTypeDefinition$RuleMemoFirstNode;
   private int associativeArrayTypeDefinition$RuleMemoStart = -1;
   private int associativeArrayTypeDefinition$RuleMemoEnd;
   private Node associativeArrayTypeDefinition$RuleMemoFirstNode;
   private int varrayTypeDefinition$RuleMemoStart = -1;
   private int varrayTypeDefinition$RuleMemoEnd;
   private Node varrayTypeDefinition$RuleMemoFirstNode;
   private int nestedTableTypeDefinition$RuleMemoStart = -1;
   private int nestedTableTypeDefinition$RuleMemoEnd;
   private Node nestedTableTypeDefinition$RuleMemoFirstNode;
   private int refCursorTypeDefinition$RuleMemoStart = -1;
   private int refCursorTypeDefinition$RuleMemoEnd;
   private Node refCursorTypeDefinition$RuleMemoFirstNode;
   private int numeric$RuleMemoStart = -1;
   private int numeric$RuleMemoEnd;
   private Node numeric$RuleMemoFirstNode;
   private int smallIntPrecision$RuleMemoStart = -1;
   private int smallIntPrecision$RuleMemoEnd;
   private Node smallIntPrecision$RuleMemoFirstNode;
   private int character$RuleMemoStart = -1;
   private int character$RuleMemoEnd;
   private Node character$RuleMemoFirstNode;
   private int nVarChar$RuleMemoStart = -1;
   private int nVarChar$RuleMemoEnd;
   private Node nVarChar$RuleMemoFirstNode;
   private int nationalCharacter$RuleMemoStart = -1;
   private int nationalCharacter$RuleMemoEnd;
   private Node nationalCharacter$RuleMemoFirstNode;
   private int integer$RuleMemoStart = -1;
   private int integer$RuleMemoEnd;
   private Node integer$RuleMemoFirstNode;
   private int int$RuleMemoStart = -1;
   private int int$RuleMemoEnd;
   private Node int$RuleMemoFirstNode;
   private int smallInt$RuleMemoStart = -1;
   private int smallInt$RuleMemoEnd;
   private Node smallInt$RuleMemoFirstNode;
   private int real$RuleMemoStart = -1;
   private int real$RuleMemoEnd;
   private Node real$RuleMemoFirstNode;
   private int binaryInteger$RuleMemoStart = -1;
   private int binaryInteger$RuleMemoEnd;
   private Node binaryInteger$RuleMemoFirstNode;
   private int natural$RuleMemoStart = -1;
   private int natural$RuleMemoEnd;
   private Node natural$RuleMemoFirstNode;
   private int positive$RuleMemoStart = -1;
   private int positive$RuleMemoEnd;
   private Node positive$RuleMemoFirstNode;
   private int boolean$RuleMemoStart = -1;
   private int boolean$RuleMemoEnd;
   private Node boolean$RuleMemoFirstNode;
   private int pls_Integer$RuleMemoStart = -1;
   private int pls_Integer$RuleMemoEnd;
   private Node pls_Integer$RuleMemoFirstNode;
   private int plSqlDataType$RuleMemoStart = -1;
   private int plSqlDataType$RuleMemoEnd;
   private Node plSqlDataType$RuleMemoFirstNode;
   private int rowType$RuleMemoStart = -1;
   private int rowType$RuleMemoEnd;
   private Node rowType$RuleMemoFirstNode;
   private int type$RuleMemoStart = -1;
   private int type$RuleMemoEnd;
   private Node type$RuleMemoFirstNode;
   private int cursorRef$RuleMemoStart = -1;
   private int cursorRef$RuleMemoEnd;
   private Node cursorRef$RuleMemoFirstNode;
   private int userType$RuleMemoStart = -1;
   private int userType$RuleMemoEnd;
   private Node userType$RuleMemoFirstNode;
   private int typeSpec$RuleMemoStart = -1;
   private int typeSpec$RuleMemoEnd;
   private Node typeSpec$RuleMemoFirstNode;
   private int out$RuleMemoStart = -1;
   private int out$RuleMemoEnd;
   private Node out$RuleMemoFirstNode;
   private int parameterDeclaration$RuleMemoStart = -1;
   private int parameterDeclaration$RuleMemoEnd;
   private Node parameterDeclaration$RuleMemoFirstNode;
   private int cursorDeclaration$RuleMemoStart = -1;
   private int cursorDeclaration$RuleMemoEnd;
   private Node cursorDeclaration$RuleMemoFirstNode;
   private int itemDeclaration$RuleMemoStart = -1;
   private int itemDeclaration$RuleMemoEnd;
   private Node itemDeclaration$RuleMemoFirstNode;
   private int exceptionDeclaration$RuleMemoStart = -1;
   private int exceptionDeclaration$RuleMemoEnd;
   private Node exceptionDeclaration$RuleMemoFirstNode;
   private int constantDeclaration$RuleMemoStart = -1;
   private int constantDeclaration$RuleMemoEnd;
   private Node constantDeclaration$RuleMemoFirstNode;
   private int variableDeclaration$RuleMemoStart = -1;
   private int variableDeclaration$RuleMemoEnd;
   private Node variableDeclaration$RuleMemoFirstNode;
   private int resultCache$RuleMemoStart = -1;
   private int resultCache$RuleMemoEnd;
   private Node resultCache$RuleMemoFirstNode;
   private int functionDeclaration$RuleMemoStart = -1;
   private int functionDeclaration$RuleMemoEnd;
   private Node functionDeclaration$RuleMemoFirstNode;
   private int functionModifier$RuleMemoStart = -1;
   private int functionModifier$RuleMemoEnd;
   private Node functionModifier$RuleMemoFirstNode;
   private int procedureDeclaration$RuleMemoStart = -1;
   private int procedureDeclaration$RuleMemoEnd;
   private Node procedureDeclaration$RuleMemoFirstNode;
   private int pragma$RuleMemoStart = -1;
   private int pragma$RuleMemoEnd;
   private Node pragma$RuleMemoFirstNode;
   private int pragmaParams$RuleMemoStart = -1;
   private int pragmaParams$RuleMemoEnd;
   private Node pragmaParams$RuleMemoFirstNode;
   private int pragmaParam$RuleMemoStart = -1;
   private int pragmaParam$RuleMemoEnd;
   private Node pragmaParam$RuleMemoFirstNode;
   private int labels$RuleMemoStart = -1;
   private int labels$RuleMemoEnd;
   private Node labels$RuleMemoFirstNode;
   private int plSqlStatement$RuleMemoStart = -1;
   private int plSqlStatement$RuleMemoEnd;
   private Node plSqlStatement$RuleMemoFirstNode;
   private int hostVariable$RuleMemoStart = -1;
   private int hostVariable$RuleMemoEnd;
   private Node hostVariable$RuleMemoFirstNode;
   private int leftValue$RuleMemoStart = -1;
   private int leftValue$RuleMemoEnd;
   private Node leftValue$RuleMemoFirstNode;
   private int assignStatement$RuleMemoStart = -1;
   private int assignStatement$RuleMemoEnd;
   private Node assignStatement$RuleMemoFirstNode;
   private int namedParameter$RuleMemoStart = -1;
   private int namedParameter$RuleMemoEnd;
   private Node namedParameter$RuleMemoFirstNode;
   private int plSqlFunctionParameter$RuleMemoStart = -1;
   private int plSqlFunctionParameter$RuleMemoEnd;
   private Node plSqlFunctionParameter$RuleMemoFirstNode;
   private int plSqlParameters$RuleMemoStart = -1;
   private int plSqlParameters$RuleMemoEnd;
   private Node plSqlParameters$RuleMemoFirstNode;
   private int caseStatement$RuleMemoStart = -1;
   private int caseStatement$RuleMemoEnd;
   private Node caseStatement$RuleMemoFirstNode;
   private int continueStatement$RuleMemoStart = -1;
   private int continueStatement$RuleMemoEnd;
   private Node continueStatement$RuleMemoFirstNode;
   private int closeStatement$RuleMemoStart = -1;
   private int closeStatement$RuleMemoEnd;
   private Node closeStatement$RuleMemoFirstNode;
   private int basicLoopStatement$RuleMemoStart = -1;
   private int basicLoopStatement$RuleMemoEnd;
   private Node basicLoopStatement$RuleMemoFirstNode;
   private int executeImmediateStatement$RuleMemoStart = -1;
   private int executeImmediateStatement$RuleMemoEnd;
   private Node executeImmediateStatement$RuleMemoFirstNode;
   private int intoClause$RuleMemoStart = -1;
   private int intoClause$RuleMemoEnd;
   private Node intoClause$RuleMemoFirstNode;
   private int bulkCollectIntoClause$RuleMemoStart = -1;
   private int bulkCollectIntoClause$RuleMemoEnd;
   private Node bulkCollectIntoClause$RuleMemoFirstNode;
   private int usingParameter$RuleMemoStart = -1;
   private int usingParameter$RuleMemoEnd;
   private Node usingParameter$RuleMemoFirstNode;
   private int usingClause$RuleMemoStart = -1;
   private int usingClause$RuleMemoEnd;
   private Node usingClause$RuleMemoFirstNode;
   private int dynamicReturningClause$RuleMemoStart = -1;
   private int dynamicReturningClause$RuleMemoEnd;
   private Node dynamicReturningClause$RuleMemoFirstNode;
   private int exitStatement$RuleMemoStart = -1;
   private int exitStatement$RuleMemoEnd;
   private Node exitStatement$RuleMemoFirstNode;
   private int fetchStatement$RuleMemoStart = -1;
   private int fetchStatement$RuleMemoEnd;
   private Node fetchStatement$RuleMemoFirstNode;
   private int forLoopStatement$RuleMemoStart = -1;
   private int forLoopStatement$RuleMemoEnd;
   private Node forLoopStatement$RuleMemoFirstNode;
   private int rangeBounds$RuleMemoStart = -1;
   private int rangeBounds$RuleMemoEnd;
   private Node rangeBounds$RuleMemoFirstNode;
   private int cursorBounds$RuleMemoStart = -1;
   private int cursorBounds$RuleMemoEnd;
   private Node cursorBounds$RuleMemoFirstNode;
   private int selectBounds$RuleMemoStart = -1;
   private int selectBounds$RuleMemoEnd;
   private Node selectBounds$RuleMemoFirstNode;
   private int forAllStatement$RuleMemoStart = -1;
   private int forAllStatement$RuleMemoEnd;
   private Node forAllStatement$RuleMemoFirstNode;
   private int range$RuleMemoStart = -1;
   private int range$RuleMemoEnd;
   private Node range$RuleMemoFirstNode;
   private int betweenBounds$RuleMemoStart = -1;
   private int betweenBounds$RuleMemoEnd;
   private Node betweenBounds$RuleMemoFirstNode;
   private int indicesOfCollection$RuleMemoStart = -1;
   private int indicesOfCollection$RuleMemoEnd;
   private Node indicesOfCollection$RuleMemoFirstNode;
   private int valuesOfIndexCollection$RuleMemoStart = -1;
   private int valuesOfIndexCollection$RuleMemoEnd;
   private Node valuesOfIndexCollection$RuleMemoFirstNode;
   private int gotoStatement$RuleMemoStart = -1;
   private int gotoStatement$RuleMemoEnd;
   private Node gotoStatement$RuleMemoFirstNode;
   private int plSqlStatements$RuleMemoStart = -1;
   private int plSqlStatements$RuleMemoEnd;
   private Node plSqlStatements$RuleMemoFirstNode;
   private int ifStatement$RuleMemoStart = -1;
   private int ifStatement$RuleMemoEnd;
   private Node ifStatement$RuleMemoFirstNode;
   private int nullStatement$RuleMemoStart = -1;
   private int nullStatement$RuleMemoEnd;
   private Node nullStatement$RuleMemoFirstNode;
   private int openStatement$RuleMemoStart = -1;
   private int openStatement$RuleMemoEnd;
   private Node openStatement$RuleMemoFirstNode;
   private int anonymousPlSqlBlock$RuleMemoStart = -1;
   private int anonymousPlSqlBlock$RuleMemoEnd;
   private Node anonymousPlSqlBlock$RuleMemoFirstNode;
   private int plSqlBlock$RuleMemoStart = -1;
   private int plSqlBlock$RuleMemoEnd;
   private Node plSqlBlock$RuleMemoFirstNode;
   private int raiseStatement$RuleMemoStart = -1;
   private int raiseStatement$RuleMemoEnd;
   private Node raiseStatement$RuleMemoFirstNode;
   private int returnStatement$RuleMemoStart = -1;
   private int returnStatement$RuleMemoEnd;
   private Node returnStatement$RuleMemoFirstNode;
   private int whileLoopStatement$RuleMemoStart = -1;
   private int whileLoopStatement$RuleMemoEnd;
   private Node whileLoopStatement$RuleMemoFirstNode;
   private int pipeRowStatement$RuleMemoStart = -1;
   private int pipeRowStatement$RuleMemoEnd;
   private Node pipeRowStatement$RuleMemoFirstNode;
   private int sqlStatement$RuleMemoStart = -1;
   private int sqlStatement$RuleMemoEnd;
   private Node sqlStatement$RuleMemoFirstNode;
   private int plSqlExpressionList$RuleMemoStart = -1;
   private int plSqlExpressionList$RuleMemoEnd;
   private Node plSqlExpressionList$RuleMemoFirstNode;
   private int multipleHandlerIdentifier$RuleMemoStart = -1;
   private int multipleHandlerIdentifier$RuleMemoEnd;
   private Node multipleHandlerIdentifier$RuleMemoFirstNode;
   private int parametersDeclaration$RuleMemoStart = -1;
   private int parametersDeclaration$RuleMemoEnd;
   private Node parametersDeclaration$RuleMemoFirstNode;
   private int returnType$RuleMemoStart = -1;
   private int returnType$RuleMemoEnd;
   private Node returnType$RuleMemoFirstNode;
   private int functionHeading$RuleMemoStart = -1;
   private int functionHeading$RuleMemoEnd;
   private Node functionHeading$RuleMemoFirstNode;
   private int procedureHeading$RuleMemoStart = -1;
   private int procedureHeading$RuleMemoEnd;
   private Node procedureHeading$RuleMemoFirstNode;
   private int booleanLiteral$RuleMemoStart = -1;
   private int booleanLiteral$RuleMemoEnd;
   private Node booleanLiteral$RuleMemoFirstNode;
   private int plSqlLiteral$RuleMemoStart = -1;
   private int plSqlLiteral$RuleMemoEnd;
   private Node plSqlLiteral$RuleMemoFirstNode;
   private int plSqlQualifiedIdentifierRemote$RuleMemoStart = -1;
   private int plSqlQualifiedIdentifierRemote$RuleMemoEnd;
   private Node plSqlQualifiedIdentifierRemote$RuleMemoFirstNode;
   private int plSqlSimpleIdentifierRemote$RuleMemoStart = -1;
   private int plSqlSimpleIdentifierRemote$RuleMemoEnd;
   private Node plSqlSimpleIdentifierRemote$RuleMemoFirstNode;
   private int plSqlAttributes$RuleMemoStart = -1;
   private int plSqlAttributes$RuleMemoEnd;
   private Node plSqlAttributes$RuleMemoFirstNode;
   private int plSqlQualifiedIdentifier$RuleMemoStart = -1;
   private int plSqlQualifiedIdentifier$RuleMemoEnd;
   private Node plSqlQualifiedIdentifier$RuleMemoFirstNode;
   private int plSqlAnyParameterizedIdentifier$RuleMemoStart = -1;
   private int plSqlAnyParameterizedIdentifier$RuleMemoEnd;
   private Node plSqlAnyParameterizedIdentifier$RuleMemoFirstNode;
   private int plSqlSimpleIdentifier$RuleMemoStart = -1;
   private int plSqlSimpleIdentifier$RuleMemoEnd;
   private Node plSqlSimpleIdentifier$RuleMemoFirstNode;
   private int plSqlParameterizedIdentifier$RuleMemoStart = -1;
   private int plSqlParameterizedIdentifier$RuleMemoEnd;
   private Node plSqlParameterizedIdentifier$RuleMemoFirstNode;
   private int plSqlObjectIdentifier$RuleMemoStart = -1;
   private int plSqlObjectIdentifier$RuleMemoEnd;
   private Node plSqlObjectIdentifier$RuleMemoFirstNode;
   private int plSqlIdentifier$RuleMemoStart = -1;
   private int plSqlIdentifier$RuleMemoEnd;
   private Node plSqlIdentifier$RuleMemoFirstNode;
   private int plSqlAnyIdentifier$RuleMemoStart = -1;
   private int plSqlAnyIdentifier$RuleMemoEnd;
   private Node plSqlAnyIdentifier$RuleMemoFirstNode;

   private int[] newArrayInt(final int size) {
      final int[] array = new int[size];
      Arrays.fill(array, -1);
      return array;
   }

   protected boolean charMatcher(char c) {
      if (trace) {
         tracePath.enterRule(buffer, "" + '\'' + c + '\'', index);
      }
      if (buffer.matchChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean ignoreCaseCharMatcher(char c) {
      if (trace) {
         tracePath.enterRule(buffer, "" + '\'' + c + '\'', index);
      }
      if (buffer.matchIgnoreCaseChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean stringMatcher(String str, int strLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      if (buffer.matchString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean partialStringMatcher(String str, int strLen, int minLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               if (trace) {
                  tracePath.exitRule(buffer, index, false);
               }
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   protected boolean ignoreCaseStringMatcher(String str, int strLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      if (buffer.matchIgnoreCaseString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean partialIgnoreCaseStringMatcher(String str, int strLen, int minLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               if (trace) {
                  tracePath.exitRule(buffer, index, false);
               }
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   protected boolean charRangeMatcher(char charIni, char charEnd) {
      if (trace) {
         tracePath.enterRule(buffer, "" + '[' + charIni + '-' + charEnd + ']', index);
      }
      if (buffer.matchCharRange(index, charIni, charEnd)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean anyCharMatcher() {
      if (trace) {
         tracePath.enterRule(buffer, "ANY", index);
      }
      if (buffer.getChar(index) != '\0') {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean eoi() {
      if (trace) {
         tracePath.enterRule(buffer, "EOI", index);
      }
      if (buffer.getChar(index) == '\0') {
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, false);
      }
      return false;
   }

   protected boolean charTest(char c) {
      return buffer.getChar(index) == c;
   }

   protected boolean ignoreCaseCharTest(char c) {
      return buffer.matchIgnoreCaseChar(index, c);
   }

   protected boolean stringTest(String str, int strLen) {
      return buffer.matchString(index, str, strLen);
   }

   protected boolean partialStringTest(String str, int strLen, int minLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean ignoreCaseStringTest(String str, int strLen) {
      return buffer.matchIgnoreCaseString(index, str, strLen);
   }

   protected boolean partialIgnoreCaseStringTest(String str, int strLen, int minLen) {
      if (trace) {
         tracePath.enterRule(buffer, '\'' + str + '\'', index);
      }
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean charRangeTest(char charIni, char charEnd) {
      return buffer.matchCharRange(index, charIni, charEnd);
   }

   protected boolean anyCharTest() {
      return buffer.getChar(index) != '\0';
   }

   protected boolean eoiTest() {
      return buffer.getChar(index) == '\0';
   }
   @Override
   public Map<Rule, RuleProfile> getProfilesMap() {
      return Collections.emptyMap();
   }

   @Override
   public void setProfilesMap(Map<Rule, RuleProfile> profilesMap) {
   }

   @Override
   public Collection<ParserError> getMismatches() {
      return Collections.emptyList();
   }

   private TraceParser tracePath;

   private boolean trace = false;

   @Override
   public void setTraceParser(TraceParser tracePath) {
      this.tracePath = tracePath;
   }

   @Override
   public void setTrace(boolean trace) {
      this.trace = trace;
   }

   private Node lastChild(Node node) {
      Node child = node.getFirstChild();
      if (child != null) {
         while (child.getSibling() != null) {
            child = child.getSibling();
         }
      }
      return child;
   }

   private Node removeNode(Node parent, Node left, Node node) {
      if (node.getFirstChild() != null) {
         if (node.getSibling() != null) {
            lastChild(node).setSibling(node.getSibling());
         }
         if (left == null) {
            parent.setFirstChild(node.getFirstChild());
         } else {
            left.setSibling(node.getFirstChild());
         }
         return node.getFirstChild();
      } else if (left == null) {
         parent.setFirstChild(node.getSibling());
      } else {
         left.setSibling(node.getSibling());
      }
      return node.getSibling();
   }

   private void removeSkipedNodes(Node node) {
      if (node != null) {
         Node leftNode = null;
         Node child = node.getFirstChild();
         while (child != null) {
            if (child.isSkiped()) {
               child = removeNode(node, leftNode, child);
            } else {
               removeSkipedNodes(child);
               leftNode = child;
               child = child.getSibling();
            }
         }
      }
   }

   @Override
   public Node parse(InputBuffer inputBuffer) {
      buffer = inputBuffer;
      if (script$Rule()) {
         removeSkipedNodes(currentNode);
         return currentNode;
      } else {
         return null;
      }
   }


   //SqlSentence : (OptionalSpacing DmlSentence OptionalSpacing <EOI>)
   protected boolean sqlSentence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSentence", index);
      }
      startIndex = index;
      // (OptionalSpacing DmlSentence OptionalSpacing <EOI>)
      // OptionalSpacing
      match = optionalSpacing$Rule();
      if (match) {
         // DmlSentence
         match = dmlSentence$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // <EOI>
               match = eoi();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_SENTENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DmlSentence : (SelectStatement | UpdateStatement | InsertStatement | DeleteStatement | CommitStatement | MergeStatement | LockTableStatement | RollbacklStatement | SavepointStatement | SetTransactionStatement)
   protected boolean dmlSentence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DmlSentence", index);
      }
      if (dmlSentence$RuleMemoStart == index) {
         if (dmlSentence$RuleMemoStart <= dmlSentence$RuleMemoEnd) {
            index = dmlSentence$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DML_SENTENCE, dmlSentence$RuleMemoStart, dmlSentence$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dmlSentence$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dmlSentence$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SelectStatement | UpdateStatement | InsertStatement | DeleteStatement | CommitStatement | MergeStatement | LockTableStatement | RollbacklStatement | SavepointStatement | SetTransactionStatement)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'l':
         case 'L': {
            // LockTableStatement
            match = lockTableStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'm':
         case 'M': {
            // MergeStatement
            match = mergeStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'r':
         case 'R': {
            // RollbacklStatement
            match = rollbacklStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 's':
         case 'S': {
            // SelectStatement
            match = selectStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SavepointStatement
               match = savepointStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SetTransactionStatement
                  match = setTransactionStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            // CommitStatement
            match = commitStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'd':
         case 'D': {
            // DeleteStatement
            match = deleteStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'u':
         case 'U': {
            // UpdateStatement
            match = updateStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'w':
         case 'W':
         case '(': {
            // SelectStatement
            match = selectStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'i':
         case 'I': {
            // InsertStatement
            match = insertStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         dmlSentence$RuleMemoStart = startIndex;
         dmlSentence$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dmlSentence$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DML_SENTENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dmlSentence$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dmlSentence$RuleMemoStart = startIndex;
         dmlSentence$RuleMemoEnd = -1;
         dmlSentence$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WaitMode : (("wait" | "nowait") TestNoAlpha OptionalSpacing)
   protected boolean waitMode$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WaitMode", index);
      }
      if (waitMode$RuleMemoStart == index) {
         if (waitMode$RuleMemoStart <= waitMode$RuleMemoEnd) {
            index = waitMode$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.WAIT_MODE, waitMode$RuleMemoStart, waitMode$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (waitMode$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(waitMode$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("wait" | "nowait") TestNoAlpha OptionalSpacing)
      // ("wait" | "nowait")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'n':
         case 'N': {
            ++index;
            // "owait"
            if (match = ignoreCaseStringTest("owait", 5)) {
               index += 5;
            }
            break;
         }
         case 'w':
         case 'W': {
            ++index;
            // "ait"
            if (match = ignoreCaseStringTest("ait", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         waitMode$RuleMemoStart = startIndex;
         waitMode$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            waitMode$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.WAIT_MODE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            waitMode$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         waitMode$RuleMemoStart = startIndex;
         waitMode$RuleMemoEnd = -1;
         waitMode$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CommitComment : ("comment" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean commitComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CommitComment", index);
      }
      startIndex = index;
      // ("comment" TestNoAlpha OptionalSpacing StringLiteral)
      // "comment"
      match = ignoreCaseStringMatcher("comment", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COMMIT_COMMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WriteMode : ("write" TestNoAlpha OptionalSpacing WaitMode? (("immediate" | "batch") TestNoAlpha OptionalSpacing)?)
   protected boolean writeMode$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WriteMode", index);
      }
      startIndex = index;
      // ("write" TestNoAlpha OptionalSpacing WaitMode? (("immediate" | "batch") TestNoAlpha OptionalSpacing)?)
      // "write"
      match = ignoreCaseStringMatcher("write", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // WaitMode?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // WaitMode
               match = waitMode$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // (("immediate" | "batch") TestNoAlpha OptionalSpacing)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // (("immediate" | "batch") TestNoAlpha OptionalSpacing)
                  // ("immediate" | "batch")
                  int startIndex_3 = index;
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "mmediate"
                        if (match = ignoreCaseStringTest("mmediate", 8)) {
                           index += 8;
                        }
                        break;
                     }
                     case 'b':
                     case 'B': {
                        ++index;
                        // "atch"
                        if (match = ignoreCaseStringTest("atch", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  if (! match) {
                     index = startIndex_3;
                  } else if(! currentRuleIsAtomic) {
                     currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                     currentNode = currentNode.getSibling();
                  }
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.WRITE_MODE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForceCommit : ("force" TestNoAlpha OptionalSpacing ((StringLiteral (',' OptionalSpacing IntegerLiteral)?) | ("corrupt_xid" TestNoAlpha OptionalSpacing StringLiteral) | ("corrupt_xid_all" TestNoAlpha OptionalSpacing)))
   protected boolean forceCommit$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForceCommit", index);
      }
      if (forceCommit$RuleMemoStart == index) {
         if (forceCommit$RuleMemoStart <= forceCommit$RuleMemoEnd) {
            index = forceCommit$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FORCE_COMMIT, forceCommit$RuleMemoStart, forceCommit$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forceCommit$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forceCommit$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("force" TestNoAlpha OptionalSpacing ((StringLiteral (',' OptionalSpacing IntegerLiteral)?) | ("corrupt_xid" TestNoAlpha OptionalSpacing StringLiteral) | ("corrupt_xid_all" TestNoAlpha OptionalSpacing)))
      // "force"
      match = ignoreCaseStringMatcher("force", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ((StringLiteral (',' OptionalSpacing IntegerLiteral)?) | ("corrupt_xid" TestNoAlpha OptionalSpacing StringLiteral) | ("corrupt_xid_all" TestNoAlpha OptionalSpacing))
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // (StringLiteral (',' OptionalSpacing IntegerLiteral)?)
               // StringLiteral
               match = stringLiteral$Rule();
               if (match) {
                  // (',' OptionalSpacing IntegerLiteral)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // (',' OptionalSpacing IntegerLiteral)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // IntegerLiteral
                        match = integerLiteral$Rule();
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("corrupt_xid" TestNoAlpha OptionalSpacing StringLiteral)
                  // "corrupt_xid"
                  match = ignoreCaseStringMatcher("corrupt_xid", 11);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // StringLiteral
                           match = stringLiteral$Rule();
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("corrupt_xid_all" TestNoAlpha OptionalSpacing)
                     // "corrupt_xid_all"
                     match = ignoreCaseStringMatcher("corrupt_xid_all", 15);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forceCommit$RuleMemoStart = startIndex;
         forceCommit$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forceCommit$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FORCE_COMMIT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forceCommit$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forceCommit$RuleMemoStart = startIndex;
         forceCommit$RuleMemoEnd = -1;
         forceCommit$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NormalCommit : (CommitComment? WriteMode?)
   protected boolean normalCommit$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NormalCommit", index);
      }
      if (normalCommit$RuleMemoStart == index) {
         if (normalCommit$RuleMemoStart <= normalCommit$RuleMemoEnd) {
            index = normalCommit$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NORMAL_COMMIT, normalCommit$RuleMemoStart, normalCommit$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (normalCommit$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(normalCommit$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CommitComment? WriteMode?)
      // CommitComment?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // CommitComment
      match = commitComment$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // WriteMode?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // WriteMode
         match = writeMode$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (match) {
         normalCommit$RuleMemoStart = startIndex;
         normalCommit$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            normalCommit$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NORMAL_COMMIT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            normalCommit$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         normalCommit$RuleMemoStart = startIndex;
         normalCommit$RuleMemoEnd = -1;
         normalCommit$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CommitOptions : (NormalCommit | ForceCommit)
   protected boolean commitOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CommitOptions", index);
      }
      startIndex = index;
      // (NormalCommit | ForceCommit)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'c':
         case 'C':
         case 'w':
         case 'W': {
            // NormalCommit
            match = normalCommit$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'f':
         case 'F': {
            // ForceCommit
            match = forceCommit$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COMMIT_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CommitStatement : ("commit" TestNoAlpha OptionalSpacing ("work" TestNoAlpha OptionalSpacing)? CommitOptions?)
   protected boolean commitStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CommitStatement", index);
      }
      if (commitStatement$RuleMemoStart == index) {
         if (commitStatement$RuleMemoStart <= commitStatement$RuleMemoEnd) {
            index = commitStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COMMIT_STATEMENT, commitStatement$RuleMemoStart, commitStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (commitStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(commitStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("commit" TestNoAlpha OptionalSpacing ("work" TestNoAlpha OptionalSpacing)? CommitOptions?)
      // "commit"
      match = ignoreCaseStringMatcher("commit", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("work" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("work" TestNoAlpha OptionalSpacing)
               // "work"
               match = ignoreCaseStringMatcher("work", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // CommitOptions?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // CommitOptions
                  match = commitOptions$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         commitStatement$RuleMemoStart = startIndex;
         commitStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commitStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COMMIT_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commitStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         commitStatement$RuleMemoStart = startIndex;
         commitStatement$RuleMemoEnd = -1;
         commitStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LockTableStatement : ("lock" TestNoAlpha OptionalSpacing "table" TestNoAlpha OptionalSpacing (TablePartitionName | TableSubPartitionName | TableName) "in" TestNoAlpha OptionalSpacing LockMode "mode" TestNoAlpha OptionalSpacing WaitMode?)
   protected boolean lockTableStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LockTableStatement", index);
      }
      if (lockTableStatement$RuleMemoStart == index) {
         if (lockTableStatement$RuleMemoStart <= lockTableStatement$RuleMemoEnd) {
            index = lockTableStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LOCK_TABLE_STATEMENT, lockTableStatement$RuleMemoStart, lockTableStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lockTableStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lockTableStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("lock" TestNoAlpha OptionalSpacing "table" TestNoAlpha OptionalSpacing (TablePartitionName | TableSubPartitionName | TableName) "in" TestNoAlpha OptionalSpacing LockMode "mode" TestNoAlpha OptionalSpacing WaitMode?)
      // "lock"
      match = ignoreCaseStringMatcher("lock", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "table"
               match = ignoreCaseStringMatcher("table", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (TablePartitionName | TableSubPartitionName | TableName)
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        switch(buffer.getChar(index)) {
                           case '\"':
                           case '#':
                           case '$':
                           case '0':
                           case '1':
                           case '2':
                           case '3':
                           case '4':
                           case '5':
                           case '6':
                           case '7':
                           case '8':
                           case '9':
                           case 'A':
                           case 'B':
                           case 'C':
                           case 'D':
                           case 'E':
                           case 'F':
                           case 'G':
                           case 'H':
                           case 'I':
                           case 'J':
                           case 'K':
                           case 'L':
                           case 'M':
                           case 'N':
                           case 'O':
                           case 'P':
                           case 'Q':
                           case 'R':
                           case 'S':
                           case 'T':
                           case 'U':
                           case 'V':
                           case 'W':
                           case 'X':
                           case 'Y':
                           case 'Z':
                           case '_':
                           case 'a':
                           case 'b':
                           case 'c':
                           case 'd':
                           case 'e':
                           case 'f':
                           case 'g':
                           case 'h':
                           case 'i':
                           case 'j':
                           case 'k':
                           case 'l':
                           case 'm':
                           case 'n':
                           case 'o':
                           case 'p':
                           case 'q':
                           case 'r':
                           case 's':
                           case 't':
                           case 'u':
                           case 'v':
                           case 'w':
                           case 'x':
                           case 'y':
                           case 'z':
                           case '\u00C1':
                           case '\u00C2':
                           case '\u00C3':
                           case '\u00C4':
                           case '\u00C7':
                           case '\u00C8':
                           case '\u00C9':
                           case '\u00CA':
                           case '\u00CB':
                           case '\u00CC':
                           case '\u00CD':
                           case '\u00CE':
                           case '\u00CF':
                           case '\u00D2':
                           case '\u00D3':
                           case '\u00D4':
                           case '\u00D5':
                           case '\u00D6':
                           case '\u00D9':
                           case '\u00DA':
                           case '\u00DB':
                           case '\u00DC':
                           case '\u00E0':
                           case '\u00E1':
                           case '\u00E2':
                           case '\u00E3':
                           case '\u00E4':
                           case '\u00E7':
                           case '\u00E8':
                           case '\u00E9':
                           case '\u00EA':
                           case '\u00EB':
                           case '\u00EC':
                           case '\u00ED':
                           case '\u00EE':
                           case '\u00EF':
                           case '\u00F2':
                           case '\u00F3':
                           case '\u00F4':
                           case '\u00F5':
                           case '\u00F6':
                           case '\u00F9':
                           case '\u00FA':
                           case '\u00FB':
                           case '\u00FC': {
                              // TablePartitionName
                              match = tablePartitionName$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // TableSubPartitionName
                                 match = tableSubPartitionName$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // TableName
                                    match = tableName$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        if (match) {
                           // "in"
                           match = ignoreCaseStringMatcher("in", 2);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // LockMode
                                    match = lockMode$Rule();
                                    if (match) {
                                       // "mode"
                                       match = ignoreCaseStringMatcher("mode", 4);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // WaitMode?
                                                Node lastNode_2 = currentNode;
                                                int lastIndex_2 = index;
                                                // WaitMode
                                                match = waitMode$Rule();
                                                if (! match) {
                                                   lastNode_2.setSibling(null);
                                                   currentNode = lastNode_2;
                                                   index = lastIndex_2;
                                                   match = true;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lockTableStatement$RuleMemoStart = startIndex;
         lockTableStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lockTableStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LOCK_TABLE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lockTableStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         lockTableStatement$RuleMemoStart = startIndex;
         lockTableStatement$RuleMemoEnd = -1;
         lockTableStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LockMode : (("row" TestNoAlpha OptionalSpacing "share" TestNoAlpha OptionalSpacing) | ("row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing))
   protected boolean lockMode$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LockMode", index);
      }
      startIndex = index;
      // (("row" TestNoAlpha OptionalSpacing "share" TestNoAlpha OptionalSpacing) | ("row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing) | ("share" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("row" TestNoAlpha OptionalSpacing "share" TestNoAlpha OptionalSpacing)
      // "row"
      match = ignoreCaseStringMatcher("row", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "share"
               match = ignoreCaseStringMatcher("share", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing)
         // "row"
         match = ignoreCaseStringMatcher("row", 3);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "exclusive"
                  match = ignoreCaseStringMatcher("exclusive", 9);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("share" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing "exclusive" TestNoAlpha OptionalSpacing)
            // "share"
            match = ignoreCaseStringMatcher("share", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "row"
                     match = ignoreCaseStringMatcher("row", 3);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "exclusive"
                              match = ignoreCaseStringMatcher("exclusive", 9);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("share" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing)
               // "share"
               match = ignoreCaseStringMatcher("share", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "update"
                        match = ignoreCaseStringMatcher("update", 6);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("share" TestNoAlpha OptionalSpacing)
                  // "share"
                  match = ignoreCaseStringMatcher("share", 5);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("exclusive" TestNoAlpha OptionalSpacing)
                     // "exclusive"
                     match = ignoreCaseStringMatcher("exclusive", 9);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.LOCK_MODE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ToSavePoint : ("to" TestNoAlpha OptionalSpacing ("savepoint" TestNoAlpha OptionalSpacing)? SqlAnyIdentifier)
   protected boolean toSavePoint$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ToSavePoint", index);
      }
      if (toSavePoint$RuleMemoStart == index) {
         if (toSavePoint$RuleMemoStart <= toSavePoint$RuleMemoEnd) {
            index = toSavePoint$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TO_SAVE_POINT, toSavePoint$RuleMemoStart, toSavePoint$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (toSavePoint$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(toSavePoint$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("to" TestNoAlpha OptionalSpacing ("savepoint" TestNoAlpha OptionalSpacing)? SqlAnyIdentifier)
      // "to"
      match = ignoreCaseStringMatcher("to", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("savepoint" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("savepoint" TestNoAlpha OptionalSpacing)
               // "savepoint"
               match = ignoreCaseStringMatcher("savepoint", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // SqlAnyIdentifier
                  match = sqlAnyIdentifier$Rule();
               }
            }
         }
      }
      if (match) {
         toSavePoint$RuleMemoStart = startIndex;
         toSavePoint$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            toSavePoint$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TO_SAVE_POINT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            toSavePoint$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         toSavePoint$RuleMemoStart = startIndex;
         toSavePoint$RuleMemoEnd = -1;
         toSavePoint$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForceRollback : ("force" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean forceRollback$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForceRollback", index);
      }
      if (forceRollback$RuleMemoStart == index) {
         if (forceRollback$RuleMemoStart <= forceRollback$RuleMemoEnd) {
            index = forceRollback$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FORCE_ROLLBACK, forceRollback$RuleMemoStart, forceRollback$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forceRollback$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forceRollback$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("force" TestNoAlpha OptionalSpacing StringLiteral)
      // "force"
      match = ignoreCaseStringMatcher("force", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
         }
      }
      if (match) {
         forceRollback$RuleMemoStart = startIndex;
         forceRollback$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forceRollback$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FORCE_ROLLBACK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forceRollback$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forceRollback$RuleMemoStart = startIndex;
         forceRollback$RuleMemoEnd = -1;
         forceRollback$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RollbackOptions : (ToSavePoint | ForceRollback)
   protected boolean rollbackOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RollbackOptions", index);
      }
      startIndex = index;
      // (ToSavePoint | ForceRollback)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 't':
         case 'T': {
            // ToSavePoint
            match = toSavePoint$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'f':
         case 'F': {
            // ForceRollback
            match = forceRollback$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ROLLBACK_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RollbacklStatement : ("rollback" TestNoAlpha OptionalSpacing ("work" TestNoAlpha OptionalSpacing)? RollbackOptions?)
   protected boolean rollbacklStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RollbacklStatement", index);
      }
      if (rollbacklStatement$RuleMemoStart == index) {
         if (rollbacklStatement$RuleMemoStart <= rollbacklStatement$RuleMemoEnd) {
            index = rollbacklStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROLLBACKL_STATEMENT, rollbacklStatement$RuleMemoStart, rollbacklStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rollbacklStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rollbacklStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("rollback" TestNoAlpha OptionalSpacing ("work" TestNoAlpha OptionalSpacing)? RollbackOptions?)
      // "rollback"
      match = ignoreCaseStringMatcher("rollback", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("work" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("work" TestNoAlpha OptionalSpacing)
               // "work"
               match = ignoreCaseStringMatcher("work", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // RollbackOptions?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // RollbackOptions
                  match = rollbackOptions$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         rollbacklStatement$RuleMemoStart = startIndex;
         rollbacklStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rollbacklStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROLLBACKL_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rollbacklStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rollbacklStatement$RuleMemoStart = startIndex;
         rollbacklStatement$RuleMemoEnd = -1;
         rollbacklStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TransactionName : ("name" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean transactionName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TransactionName", index);
      }
      if (transactionName$RuleMemoStart == index) {
         if (transactionName$RuleMemoStart <= transactionName$RuleMemoEnd) {
            index = transactionName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TRANSACTION_NAME, transactionName$RuleMemoStart, transactionName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (transactionName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(transactionName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("name" TestNoAlpha OptionalSpacing StringLiteral)
      // "name"
      match = ignoreCaseStringMatcher("name", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
         }
      }
      if (match) {
         transactionName$RuleMemoStart = startIndex;
         transactionName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            transactionName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TRANSACTION_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            transactionName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         transactionName$RuleMemoStart = startIndex;
         transactionName$RuleMemoEnd = -1;
         transactionName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UseRollbackSegment : ("use" TestNoAlpha OptionalSpacing "rollback" TestNoAlpha OptionalSpacing "segment" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
   protected boolean useRollbackSegment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UseRollbackSegment", index);
      }
      if (useRollbackSegment$RuleMemoStart == index) {
         if (useRollbackSegment$RuleMemoStart <= useRollbackSegment$RuleMemoEnd) {
            index = useRollbackSegment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.USE_ROLLBACK_SEGMENT, useRollbackSegment$RuleMemoStart, useRollbackSegment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (useRollbackSegment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(useRollbackSegment$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("use" TestNoAlpha OptionalSpacing "rollback" TestNoAlpha OptionalSpacing "segment" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // "use"
      match = ignoreCaseStringMatcher("use", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "rollback"
               match = ignoreCaseStringMatcher("rollback", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "segment"
                        match = ignoreCaseStringMatcher("segment", 7);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlAnyIdentifier
                                 match = sqlAnyIdentifier$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         useRollbackSegment$RuleMemoStart = startIndex;
         useRollbackSegment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useRollbackSegment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.USE_ROLLBACK_SEGMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useRollbackSegment$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         useRollbackSegment$RuleMemoStart = startIndex;
         useRollbackSegment$RuleMemoEnd = -1;
         useRollbackSegment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsolationLevel : ("isolation" TestNoAlpha OptionalSpacing "level" TestNoAlpha OptionalSpacing (("serializable" TestNoAlpha OptionalSpacing) | ("read" TestNoAlpha OptionalSpacing "commited" TestNoAlpha OptionalSpacing) | ("ReadCommited" TestNoAlpha OptionalSpacing)))
   protected boolean isolationLevel$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsolationLevel", index);
      }
      if (isolationLevel$RuleMemoStart == index) {
         if (isolationLevel$RuleMemoStart <= isolationLevel$RuleMemoEnd) {
            index = isolationLevel$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ISOLATION_LEVEL, isolationLevel$RuleMemoStart, isolationLevel$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isolationLevel$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isolationLevel$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("isolation" TestNoAlpha OptionalSpacing "level" TestNoAlpha OptionalSpacing (("serializable" TestNoAlpha OptionalSpacing) | ("read" TestNoAlpha OptionalSpacing "commited" TestNoAlpha OptionalSpacing) | ("ReadCommited" TestNoAlpha OptionalSpacing)))
      // "isolation"
      match = ignoreCaseStringMatcher("isolation", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "level"
               match = ignoreCaseStringMatcher("level", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (("serializable" TestNoAlpha OptionalSpacing) | ("read" TestNoAlpha OptionalSpacing "commited" TestNoAlpha OptionalSpacing) | ("ReadCommited" TestNoAlpha OptionalSpacing))
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ("serializable" TestNoAlpha OptionalSpacing)
                        // "serializable"
                        match = ignoreCaseStringMatcher("serializable", 12);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("read" TestNoAlpha OptionalSpacing "commited" TestNoAlpha OptionalSpacing)
                           // "read"
                           match = ignoreCaseStringMatcher("read", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "commited"
                                    match = ignoreCaseStringMatcher("commited", 8);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ("ReadCommited" TestNoAlpha OptionalSpacing)
                              // "ReadCommited"
                              match = ignoreCaseStringMatcher("ReadCommited", 12);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         isolationLevel$RuleMemoStart = startIndex;
         isolationLevel$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isolationLevel$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ISOLATION_LEVEL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isolationLevel$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isolationLevel$RuleMemoStart = startIndex;
         isolationLevel$RuleMemoEnd = -1;
         isolationLevel$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReadMode : (("read" TestNoAlpha OptionalSpacing "only" TestNoAlpha OptionalSpacing) | ("ReadOnly" TestNoAlpha OptionalSpacing) | ("read" TestNoAlpha OptionalSpacing "write" TestNoAlpha OptionalSpacing) | ("ReadWrite" TestNoAlpha OptionalSpacing))
   protected boolean readMode$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReadMode", index);
      }
      if (readMode$RuleMemoStart == index) {
         if (readMode$RuleMemoStart <= readMode$RuleMemoEnd) {
            index = readMode$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.READ_MODE, readMode$RuleMemoStart, readMode$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (readMode$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(readMode$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("read" TestNoAlpha OptionalSpacing "only" TestNoAlpha OptionalSpacing) | ("ReadOnly" TestNoAlpha OptionalSpacing) | ("read" TestNoAlpha OptionalSpacing "write" TestNoAlpha OptionalSpacing) | ("ReadWrite" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("read" TestNoAlpha OptionalSpacing "only" TestNoAlpha OptionalSpacing)
      // "read"
      match = ignoreCaseStringMatcher("read", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "only"
               match = ignoreCaseStringMatcher("only", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("ReadOnly" TestNoAlpha OptionalSpacing)
         // "ReadOnly"
         match = ignoreCaseStringMatcher("ReadOnly", 8);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("read" TestNoAlpha OptionalSpacing "write" TestNoAlpha OptionalSpacing)
            // "read"
            match = ignoreCaseStringMatcher("read", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "write"
                     match = ignoreCaseStringMatcher("write", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("ReadWrite" TestNoAlpha OptionalSpacing)
               // "ReadWrite"
               match = ignoreCaseStringMatcher("ReadWrite", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         readMode$RuleMemoStart = startIndex;
         readMode$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            readMode$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.READ_MODE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            readMode$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         readMode$RuleMemoStart = startIndex;
         readMode$RuleMemoEnd = -1;
         readMode$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SetTransactionOptions : (((ReadMode | IsolationLevel | UseRollbackSegment) TransactionName?) | TransactionName)
   protected boolean setTransactionOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SetTransactionOptions", index);
      }
      startIndex = index;
      // (((ReadMode | IsolationLevel | UseRollbackSegment) TransactionName?) | TransactionName)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ((ReadMode | IsolationLevel | UseRollbackSegment) TransactionName?)
      // (ReadMode | IsolationLevel | UseRollbackSegment)
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'r':
         case 'R': {
            // ReadMode
            match = readMode$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case 'u':
         case 'U': {
            // UseRollbackSegment
            match = useRollbackSegment$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         case 'i':
         case 'I': {
            // IsolationLevel
            match = isolationLevel$Rule();
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // TransactionName?
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // TransactionName
         match = transactionName$Rule();
         if (! match) {
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
            index = lastIndex_3;
            match = true;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // TransactionName
         match = transactionName$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SET_TRANSACTION_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SetTransactionStatement : ("set" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing SetTransactionOptions)
   protected boolean setTransactionStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SetTransactionStatement", index);
      }
      if (setTransactionStatement$RuleMemoStart == index) {
         if (setTransactionStatement$RuleMemoStart <= setTransactionStatement$RuleMemoEnd) {
            index = setTransactionStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SET_TRANSACTION_STATEMENT, setTransactionStatement$RuleMemoStart, setTransactionStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (setTransactionStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(setTransactionStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("set" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing SetTransactionOptions)
      // "set"
      match = ignoreCaseStringMatcher("set", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SetTransactionOptions
                        match = setTransactionOptions$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         setTransactionStatement$RuleMemoStart = startIndex;
         setTransactionStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            setTransactionStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SET_TRANSACTION_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            setTransactionStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         setTransactionStatement$RuleMemoStart = startIndex;
         setTransactionStatement$RuleMemoEnd = -1;
         setTransactionStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SavepointStatement : ("savepoint" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
   protected boolean savepointStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SavepointStatement", index);
      }
      if (savepointStatement$RuleMemoStart == index) {
         if (savepointStatement$RuleMemoStart <= savepointStatement$RuleMemoEnd) {
            index = savepointStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SAVEPOINT_STATEMENT, savepointStatement$RuleMemoStart, savepointStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (savepointStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(savepointStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("savepoint" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // "savepoint"
      match = ignoreCaseStringMatcher("savepoint", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
            }
         }
      }
      if (match) {
         savepointStatement$RuleMemoStart = startIndex;
         savepointStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            savepointStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SAVEPOINT_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            savepointStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         savepointStatement$RuleMemoStart = startIndex;
         savepointStatement$RuleMemoEnd = -1;
         savepointStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectStatement : (SubqueryFactoringClause? Subquery ForUpdateClause?)
   protected boolean selectStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectStatement", index);
      }
      if (selectStatement$RuleMemoStart == index) {
         if (selectStatement$RuleMemoStart <= selectStatement$RuleMemoEnd) {
            index = selectStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SELECT_STATEMENT, selectStatement$RuleMemoStart, selectStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SubqueryFactoringClause? Subquery ForUpdateClause?)
      // SubqueryFactoringClause?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // SubqueryFactoringClause
      match = subqueryFactoringClause$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // Subquery
         match = subquery$Rule();
         if (match) {
            // ForUpdateClause?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ForUpdateClause
            match = forUpdateClause$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         selectStatement$RuleMemoStart = startIndex;
         selectStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         selectStatement$RuleMemoStart = startIndex;
         selectStatement$RuleMemoEnd = -1;
         selectStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MergeUpdateClause : ("when" TestNoAlpha OptionalSpacing "matched" TestNoAlpha OptionalSpacing "then" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing UpdateSetClause WhereClause? ("delete" TestNoAlpha OptionalSpacing WhereClause)?)
   protected boolean mergeUpdateClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MergeUpdateClause", index);
      }
      if (mergeUpdateClause$RuleMemoStart == index) {
         if (mergeUpdateClause$RuleMemoStart <= mergeUpdateClause$RuleMemoEnd) {
            index = mergeUpdateClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MERGE_UPDATE_CLAUSE, mergeUpdateClause$RuleMemoStart, mergeUpdateClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (mergeUpdateClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(mergeUpdateClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing "matched" TestNoAlpha OptionalSpacing "then" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing UpdateSetClause WhereClause? ("delete" TestNoAlpha OptionalSpacing WhereClause)?)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "matched"
               match = ignoreCaseStringMatcher("matched", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "then"
                        match = ignoreCaseStringMatcher("then", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // "update"
                                 match = ignoreCaseStringMatcher("update", 6);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // UpdateSetClause
                                          match = updateSetClause$Rule();
                                          if (match) {
                                             // WhereClause?
                                             Node lastNode_1 = currentNode;
                                             int lastIndex_1 = index;
                                             // WhereClause
                                             match = whereClause$Rule();
                                             if (! match) {
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                index = lastIndex_1;
                                                match = true;
                                             }
                                             if (match) {
                                                // ("delete" TestNoAlpha OptionalSpacing WhereClause)?
                                                Node lastNode_2 = currentNode;
                                                int lastIndex_2 = index;
                                                // ("delete" TestNoAlpha OptionalSpacing WhereClause)
                                                // "delete"
                                                match = ignoreCaseStringMatcher("delete", 6);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // WhereClause
                                                         match = whereClause$Rule();
                                                      }
                                                   }
                                                }
                                                if (! match) {
                                                   lastNode_2.setSibling(null);
                                                   currentNode = lastNode_2;
                                                   index = lastIndex_2;
                                                   match = true;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         mergeUpdateClause$RuleMemoStart = startIndex;
         mergeUpdateClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            mergeUpdateClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MERGE_UPDATE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            mergeUpdateClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         mergeUpdateClause$RuleMemoStart = startIndex;
         mergeUpdateClause$RuleMemoEnd = -1;
         mergeUpdateClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MergeInsertClause : ("when" TestNoAlpha OptionalSpacing "not" TestNoAlpha OptionalSpacing "matched" TestNoAlpha OptionalSpacing "then" TestNoAlpha OptionalSpacing "insert" TestNoAlpha OptionalSpacing ColumnsList ValuesClause WhereClause?)
   protected boolean mergeInsertClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MergeInsertClause", index);
      }
      if (mergeInsertClause$RuleMemoStart == index) {
         if (mergeInsertClause$RuleMemoStart <= mergeInsertClause$RuleMemoEnd) {
            index = mergeInsertClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MERGE_INSERT_CLAUSE, mergeInsertClause$RuleMemoStart, mergeInsertClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (mergeInsertClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(mergeInsertClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing "not" TestNoAlpha OptionalSpacing "matched" TestNoAlpha OptionalSpacing "then" TestNoAlpha OptionalSpacing "insert" TestNoAlpha OptionalSpacing ColumnsList ValuesClause WhereClause?)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "not"
               match = ignoreCaseStringMatcher("not", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "matched"
                        match = ignoreCaseStringMatcher("matched", 7);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // "then"
                                 match = ignoreCaseStringMatcher("then", 4);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // "insert"
                                          match = ignoreCaseStringMatcher("insert", 6);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // ColumnsList
                                                   match = columnsList$Rule();
                                                   if (match) {
                                                      // ValuesClause
                                                      match = valuesClause$Rule();
                                                      if (match) {
                                                         // WhereClause?
                                                         Node lastNode_1 = currentNode;
                                                         int lastIndex_1 = index;
                                                         // WhereClause
                                                         match = whereClause$Rule();
                                                         if (! match) {
                                                            lastNode_1.setSibling(null);
                                                            currentNode = lastNode_1;
                                                            index = lastIndex_1;
                                                            match = true;
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         mergeInsertClause$RuleMemoStart = startIndex;
         mergeInsertClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            mergeInsertClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MERGE_INSERT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            mergeInsertClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         mergeInsertClause$RuleMemoStart = startIndex;
         mergeInsertClause$RuleMemoEnd = -1;
         mergeInsertClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MergeStatement : ("merge" TestNoAlpha OptionalSpacing Hint? "into" TestNoAlpha OptionalSpacing TableName Alias? "using" TestNoAlpha OptionalSpacing (Subquery | TableName)? Alias? "on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlCondition ')' OptionalSpacing ((MergeUpdateClause MergeInsertClause) | (MergeInsertClause MergeUpdateClause) | MergeInsertClause | MergeUpdateClause)? ErrorLogingClause?)
   protected boolean mergeStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MergeStatement", index);
      }
      if (mergeStatement$RuleMemoStart == index) {
         if (mergeStatement$RuleMemoStart <= mergeStatement$RuleMemoEnd) {
            index = mergeStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MERGE_STATEMENT, mergeStatement$RuleMemoStart, mergeStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (mergeStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(mergeStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("merge" TestNoAlpha OptionalSpacing Hint? "into" TestNoAlpha OptionalSpacing TableName Alias? "using" TestNoAlpha OptionalSpacing (Subquery | TableName)? Alias? "on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlCondition ')' OptionalSpacing ((MergeUpdateClause MergeInsertClause) | (MergeInsertClause MergeUpdateClause) | MergeInsertClause | MergeUpdateClause)? ErrorLogingClause?)
      // "merge"
      match = ignoreCaseStringMatcher("merge", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // "into"
                  match = ignoreCaseStringMatcher("into", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // TableName
                           match = tableName$Rule();
                           if (match) {
                              // Alias?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // Alias
                              match = alias$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                              if (match) {
                                 // "using"
                                 match = ignoreCaseStringMatcher("using", 5);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // (Subquery | TableName)?
                                          Node lastNode_3 = currentNode;
                                          int lastIndex_3 = index;
                                          // (Subquery | TableName)
                                          Node lastNode_4 = currentNode;
                                          int lastIndex_4 = index;
                                          switch(buffer.getChar(index)) {
                                             case '\"':
                                             case '#':
                                             case '$':
                                             case '0':
                                             case '1':
                                             case '2':
                                             case '3':
                                             case '4':
                                             case '5':
                                             case '6':
                                             case '7':
                                             case '8':
                                             case '9':
                                             case 'A':
                                             case 'B':
                                             case 'C':
                                             case 'D':
                                             case 'E':
                                             case 'F':
                                             case 'G':
                                             case 'H':
                                             case 'I':
                                             case 'J':
                                             case 'K':
                                             case 'L':
                                             case 'M':
                                             case 'N':
                                             case 'O':
                                             case 'P':
                                             case 'Q':
                                             case 'R':
                                             case 'T':
                                             case 'U':
                                             case 'V':
                                             case 'W':
                                             case 'X':
                                             case 'Y':
                                             case 'Z':
                                             case '_':
                                             case 'a':
                                             case 'b':
                                             case 'c':
                                             case 'd':
                                             case 'e':
                                             case 'f':
                                             case 'g':
                                             case 'h':
                                             case 'i':
                                             case 'j':
                                             case 'k':
                                             case 'l':
                                             case 'm':
                                             case 'n':
                                             case 'o':
                                             case 'p':
                                             case 'q':
                                             case 'r':
                                             case 't':
                                             case 'u':
                                             case 'v':
                                             case 'w':
                                             case 'x':
                                             case 'y':
                                             case 'z':
                                             case '\u00C1':
                                             case '\u00C2':
                                             case '\u00C3':
                                             case '\u00C4':
                                             case '\u00C7':
                                             case '\u00C8':
                                             case '\u00C9':
                                             case '\u00CA':
                                             case '\u00CB':
                                             case '\u00CC':
                                             case '\u00CD':
                                             case '\u00CE':
                                             case '\u00CF':
                                             case '\u00D2':
                                             case '\u00D3':
                                             case '\u00D4':
                                             case '\u00D5':
                                             case '\u00D6':
                                             case '\u00D9':
                                             case '\u00DA':
                                             case '\u00DB':
                                             case '\u00DC':
                                             case '\u00E0':
                                             case '\u00E1':
                                             case '\u00E2':
                                             case '\u00E3':
                                             case '\u00E4':
                                             case '\u00E7':
                                             case '\u00E8':
                                             case '\u00E9':
                                             case '\u00EA':
                                             case '\u00EB':
                                             case '\u00EC':
                                             case '\u00ED':
                                             case '\u00EE':
                                             case '\u00EF':
                                             case '\u00F2':
                                             case '\u00F3':
                                             case '\u00F4':
                                             case '\u00F5':
                                             case '\u00F6':
                                             case '\u00F9':
                                             case '\u00FA':
                                             case '\u00FB':
                                             case '\u00FC': {
                                                // TableName
                                                match = tableName$Rule();
                                                if (! match) {
                                                   index = lastIndex_4;
                                                   lastNode_4.setSibling(null);
                                                   currentNode = lastNode_4;
                                                }
                                                break;
                                             }
                                             case 'S':
                                             case 's': {
                                                // Subquery
                                                match = subquery$Rule();
                                                if (! match) {
                                                   index = lastIndex_4;
                                                   lastNode_4.setSibling(null);
                                                   currentNode = lastNode_4;
                                                   // TableName
                                                   match = tableName$Rule();
                                                   if (! match) {
                                                      index = lastIndex_4;
                                                      lastNode_4.setSibling(null);
                                                      currentNode = lastNode_4;
                                                   }
                                                }
                                                break;
                                             }
                                             case '(': {
                                                // Subquery
                                                match = subquery$Rule();
                                                if (! match) {
                                                   index = lastIndex_4;
                                                   lastNode_4.setSibling(null);
                                                   currentNode = lastNode_4;
                                                }
                                                break;
                                             }
                                             default: {
                                                match = false;
                                             }
                                          }
                                          if (! match) {
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                             index = lastIndex_3;
                                             match = true;
                                          }
                                          if (match) {
                                             // Alias?
                                             Node lastNode_5 = currentNode;
                                             int lastIndex_5 = index;
                                             // Alias
                                             match = alias$Rule();
                                             if (! match) {
                                                lastNode_5.setSibling(null);
                                                currentNode = lastNode_5;
                                                index = lastIndex_5;
                                                match = true;
                                             }
                                             if (match) {
                                                // "on"
                                                match = ignoreCaseStringMatcher("on", 2);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // '('
                                                         match = charMatcher('(');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // SqlCondition
                                                               match = sqlCondition$Rule();
                                                               if (match) {
                                                                  // ')'
                                                                  match = charMatcher(')');
                                                                  if (match) {
                                                                     // OptionalSpacing
                                                                     match = optionalSpacing$Rule();
                                                                     if (match) {
                                                                        // ((MergeUpdateClause MergeInsertClause) | (MergeInsertClause MergeUpdateClause) | MergeInsertClause | MergeUpdateClause)?
                                                                        Node lastNode_6 = currentNode;
                                                                        int lastIndex_6 = index;
                                                                        // ((MergeUpdateClause MergeInsertClause) | (MergeInsertClause MergeUpdateClause) | MergeInsertClause | MergeUpdateClause)
                                                                        Node lastNode_7 = currentNode;
                                                                        int lastIndex_7 = index;
                                                                        // (MergeUpdateClause MergeInsertClause)
                                                                        // MergeUpdateClause
                                                                        match = mergeUpdateClause$Rule();
                                                                        if (match) {
                                                                           // MergeInsertClause
                                                                           match = mergeInsertClause$Rule();
                                                                        }
                                                                        if (! match) {
                                                                           index = lastIndex_7;
                                                                           lastNode_7.setSibling(null);
                                                                           currentNode = lastNode_7;
                                                                           // (MergeInsertClause MergeUpdateClause)
                                                                           // MergeInsertClause
                                                                           match = mergeInsertClause$Rule();
                                                                           if (match) {
                                                                              // MergeUpdateClause
                                                                              match = mergeUpdateClause$Rule();
                                                                           }
                                                                           if (! match) {
                                                                              index = lastIndex_7;
                                                                              lastNode_7.setSibling(null);
                                                                              currentNode = lastNode_7;
                                                                              // MergeInsertClause
                                                                              match = mergeInsertClause$Rule();
                                                                              if (! match) {
                                                                                 index = lastIndex_7;
                                                                                 lastNode_7.setSibling(null);
                                                                                 currentNode = lastNode_7;
                                                                                 // MergeUpdateClause
                                                                                 match = mergeUpdateClause$Rule();
                                                                                 if (! match) {
                                                                                    index = lastIndex_7;
                                                                                    lastNode_7.setSibling(null);
                                                                                    currentNode = lastNode_7;
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                        if (! match) {
                                                                           lastNode_6.setSibling(null);
                                                                           currentNode = lastNode_6;
                                                                           index = lastIndex_6;
                                                                           match = true;
                                                                        }
                                                                        if (match) {
                                                                           // ErrorLogingClause?
                                                                           Node lastNode_8 = currentNode;
                                                                           int lastIndex_8 = index;
                                                                           // ErrorLogingClause
                                                                           match = errorLogingClause$Rule();
                                                                           if (! match) {
                                                                              lastNode_8.setSibling(null);
                                                                              currentNode = lastNode_8;
                                                                              index = lastIndex_8;
                                                                              match = true;
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         mergeStatement$RuleMemoStart = startIndex;
         mergeStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            mergeStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MERGE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            mergeStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         mergeStatement$RuleMemoStart = startIndex;
         mergeStatement$RuleMemoEnd = -1;
         mergeStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BlockHint : ('/*+' OptionalSpacing ('*/'! . OptionalSpacing)* '*/' OptionalSpacing)
   protected boolean blockHint$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BlockHint", index);
      }
      if (blockHint$RuleMemoStart == index) {
         if (blockHint$RuleMemoStart <= blockHint$RuleMemoEnd) {
            index = blockHint$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BLOCK_HINT, blockHint$RuleMemoStart, blockHint$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (blockHint$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(blockHint$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('/*+' OptionalSpacing ('*/'! . OptionalSpacing)* '*/' OptionalSpacing)
      // '/*+'
      match = stringMatcher("/*+", 3);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ('*/'! . OptionalSpacing)*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // ('*/'! . OptionalSpacing)
               // '*/'!
               // '*/'
               match = stringTest("*/", 2);
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            // '*/'
            match = stringMatcher("*/", 2);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         blockHint$RuleMemoStart = startIndex;
         blockHint$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockHint$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BLOCK_HINT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            blockHint$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         blockHint$RuleMemoStart = startIndex;
         blockHint$RuleMemoEnd = -1;
         blockHint$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LineHint : ('--+' OptionalSpacing ((('\r' | '\n') OptionalSpacing)! . OptionalSpacing)* (('\r\n' | '\r' | '\n') OptionalSpacing))
   protected boolean lineHint$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LineHint", index);
      }
      if (lineHint$RuleMemoStart == index) {
         if (lineHint$RuleMemoStart <= lineHint$RuleMemoEnd) {
            index = lineHint$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LINE_HINT, lineHint$RuleMemoStart, lineHint$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lineHint$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineHint$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('--+' OptionalSpacing ((('\r' | '\n') OptionalSpacing)! . OptionalSpacing)* (('\r\n' | '\r' | '\n') OptionalSpacing))
      // '--+'
      match = stringMatcher("--+", 3);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ((('\r' | '\n') OptionalSpacing)! . OptionalSpacing)*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // ((('\r' | '\n') OptionalSpacing)! . OptionalSpacing)
               // (('\r' | '\n') OptionalSpacing)!
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               boolean lastAtomic_2 = currentRuleIsAtomic;
               // (('\r' | '\n') OptionalSpacing)
               // ('\r' | '\n')
               int startIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '\r': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  case '\n': {
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  index = startIndex_3;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               currentRuleIsAtomic = lastAtomic_2;
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               match = ! match;
               if (match) {
                  // .
                  match = anyCharMatcher();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
            // (('\r\n' | '\r' | '\n') OptionalSpacing)
            // ('\r\n' | '\r' | '\n')
            int startIndex_4 = index;
            switch(buffer.getChar(index)) {
               case '\r': {
                  ++index;
                  // ('\n' | <EMPTY>)
                  match = buffer.matchChar(index, '\n');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         lineHint$RuleMemoStart = startIndex;
         lineHint$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineHint$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LINE_HINT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lineHint$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         lineHint$RuleMemoStart = startIndex;
         lineHint$RuleMemoEnd = -1;
         lineHint$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Hint : (BlockHint | LineHint)
   protected boolean hint$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Hint", index);
      }
      if (hint$RuleMemoStart == index) {
         if (hint$RuleMemoStart <= hint$RuleMemoEnd) {
            index = hint$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.HINT, hint$RuleMemoStart, hint$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (hint$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hint$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BlockHint | LineHint)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '-': {
            // LineHint
            match = lineHint$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '/': {
            // BlockHint
            match = blockHint$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         hint$RuleMemoStart = startIndex;
         hint$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hint$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.HINT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hint$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         hint$RuleMemoStart = startIndex;
         hint$RuleMemoEnd = -1;
         hint$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ListAllFields : (TableName '.' OptionalSpacing '*' OptionalSpacing)
   protected boolean listAllFields$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ListAllFields", index);
      }
      if (listAllFields$RuleMemoStart == index) {
         if (listAllFields$RuleMemoStart <= listAllFields$RuleMemoEnd) {
            index = listAllFields$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LIST_ALL_FIELDS, listAllFields$RuleMemoStart, listAllFields$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (listAllFields$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(listAllFields$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableName '.' OptionalSpacing '*' OptionalSpacing)
      // TableName
      match = tableName$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '*'
               match = charMatcher('*');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         listAllFields$RuleMemoStart = startIndex;
         listAllFields$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listAllFields$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LIST_ALL_FIELDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listAllFields$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         listAllFields$RuleMemoStart = startIndex;
         listAllFields$RuleMemoEnd = -1;
         listAllFields$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectListExpressionElement : (SqlExpression ColumnAlias?)
   protected boolean selectListExpressionElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectListExpressionElement", index);
      }
      if (selectListExpressionElement$RuleMemoStart == index) {
         if (selectListExpressionElement$RuleMemoStart <= selectListExpressionElement$RuleMemoEnd) {
            index = selectListExpressionElement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST_EXPRESSION_ELEMENT, selectListExpressionElement$RuleMemoStart, selectListExpressionElement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectListExpressionElement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectListExpressionElement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression ColumnAlias?)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // ColumnAlias?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ColumnAlias
         match = columnAlias$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         selectListExpressionElement$RuleMemoStart = startIndex;
         selectListExpressionElement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectListExpressionElement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST_EXPRESSION_ELEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectListExpressionElement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         selectListExpressionElement$RuleMemoStart = startIndex;
         selectListExpressionElement$RuleMemoEnd = -1;
         selectListExpressionElement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectListElement : (ListAllFields | SelectListExpressionElement)
   protected boolean selectListElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectListElement", index);
      }
      if (selectListElement$RuleMemoStart == index) {
         if (selectListElement$RuleMemoStart <= selectListElement$RuleMemoEnd) {
            index = selectListElement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST_ELEMENT, selectListElement$RuleMemoStart, selectListElement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectListElement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectListElement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ListAllFields | SelectListExpressionElement)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case '(':
         case ':':
         case '+':
         case '-':
         case '?': {
            // SelectListExpressionElement
            match = selectListExpressionElement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // ListAllFields
            match = listAllFields$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SelectListExpressionElement
               match = selectListExpressionElement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         selectListElement$RuleMemoStart = startIndex;
         selectListElement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectListElement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST_ELEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectListElement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         selectListElement$RuleMemoStart = startIndex;
         selectListElement$RuleMemoEnd = -1;
         selectListElement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnAlias : (("as" TestNoAlpha OptionalSpacing)? SqlIdentifier)
   protected boolean columnAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnAlias", index);
      }
      startIndex = index;
      // (("as" TestNoAlpha OptionalSpacing)? SqlIdentifier)
      // ("as" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("as" TestNoAlpha OptionalSpacing)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // SqlIdentifier
         match = sqlIdentifier$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_ALIAS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CommaSelectListElement : (',' OptionalSpacing SelectListElement)
   protected boolean commaSelectListElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CommaSelectListElement", index);
      }
      startIndex = index;
      // (',' OptionalSpacing SelectListElement)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SelectListElement
            match = selectListElement$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COMMA_SELECT_LIST_ELEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ZeroOrMoreCommaSelectListElement : CommaSelectListElement*
   protected boolean zeroOrMoreCommaSelectListElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ZeroOrMoreCommaSelectListElement", index);
      }
      startIndex = index;
      // CommaSelectListElement*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // CommaSelectListElement
         match = commaSelectListElement$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(OracleScriptRuleType.ZERO_OR_MORE_COMMA_SELECT_LIST_ELEMENT, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //ListOfSelectListElement : (SelectListElement ZeroOrMoreCommaSelectListElement)
   protected boolean listOfSelectListElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ListOfSelectListElement", index);
      }
      if (listOfSelectListElement$RuleMemoStart == index) {
         if (listOfSelectListElement$RuleMemoStart <= listOfSelectListElement$RuleMemoEnd) {
            index = listOfSelectListElement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LIST_OF_SELECT_LIST_ELEMENT, listOfSelectListElement$RuleMemoStart, listOfSelectListElement$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (listOfSelectListElement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(listOfSelectListElement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SelectListElement ZeroOrMoreCommaSelectListElement)
      // SelectListElement
      match = selectListElement$Rule();
      if (match) {
         // ZeroOrMoreCommaSelectListElement
         match = zeroOrMoreCommaSelectListElement$Rule();
      }
      if (match) {
         listOfSelectListElement$RuleMemoStart = startIndex;
         listOfSelectListElement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listOfSelectListElement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LIST_OF_SELECT_LIST_ELEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listOfSelectListElement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         listOfSelectListElement$RuleMemoStart = startIndex;
         listOfSelectListElement$RuleMemoEnd = -1;
         listOfSelectListElement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectList : (('*' OptionalSpacing) | ListOfSelectListElement)
   protected boolean selectList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectList", index);
      }
      if (selectList$RuleMemoStart == index) {
         if (selectList$RuleMemoStart <= selectList$RuleMemoEnd) {
            index = selectList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST, selectList$RuleMemoStart, selectList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (('*' OptionalSpacing) | ListOfSelectListElement)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('*' OptionalSpacing)
      // '*'
      match = charMatcher('*');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ListOfSelectListElement
         match = listOfSelectListElement$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         selectList$RuleMemoStart = startIndex;
         selectList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         selectList$RuleMemoStart = startIndex;
         selectList$RuleMemoEnd = -1;
         selectList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryReadOnlyRestriction : ("read" TestNoAlpha OptionalSpacing "only" TestNoAlpha OptionalSpacing)
   protected boolean subqueryReadOnlyRestriction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryReadOnlyRestriction", index);
      }
      if (subqueryReadOnlyRestriction$RuleMemoStart == index) {
         if (subqueryReadOnlyRestriction$RuleMemoStart <= subqueryReadOnlyRestriction$RuleMemoEnd) {
            index = subqueryReadOnlyRestriction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_READ_ONLY_RESTRICTION, subqueryReadOnlyRestriction$RuleMemoStart, subqueryReadOnlyRestriction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subqueryReadOnlyRestriction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subqueryReadOnlyRestriction$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("read" TestNoAlpha OptionalSpacing "only" TestNoAlpha OptionalSpacing)
      // "read"
      match = ignoreCaseStringMatcher("read", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "only"
               match = ignoreCaseStringMatcher("only", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         subqueryReadOnlyRestriction$RuleMemoStart = startIndex;
         subqueryReadOnlyRestriction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subqueryReadOnlyRestriction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_READ_ONLY_RESTRICTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subqueryReadOnlyRestriction$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subqueryReadOnlyRestriction$RuleMemoStart = startIndex;
         subqueryReadOnlyRestriction$RuleMemoEnd = -1;
         subqueryReadOnlyRestriction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryCheckConstraintName : ("constraint" TestNoAlpha OptionalSpacing SqlAnyIdentifier)?
   protected boolean subqueryCheckConstraintName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryCheckConstraintName", index);
      }
      startIndex = index;
      // ("constraint" TestNoAlpha OptionalSpacing SqlAnyIdentifier)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("constraint" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // "constraint"
      match = ignoreCaseStringMatcher("constraint", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_CHECK_CONSTRAINT_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryCheckOptionRestriction : ("check" TestNoAlpha OptionalSpacing "option" TestNoAlpha OptionalSpacing SubqueryCheckConstraintName)
   protected boolean subqueryCheckOptionRestriction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryCheckOptionRestriction", index);
      }
      if (subqueryCheckOptionRestriction$RuleMemoStart == index) {
         if (subqueryCheckOptionRestriction$RuleMemoStart <= subqueryCheckOptionRestriction$RuleMemoEnd) {
            index = subqueryCheckOptionRestriction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_CHECK_OPTION_RESTRICTION, subqueryCheckOptionRestriction$RuleMemoStart, subqueryCheckOptionRestriction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subqueryCheckOptionRestriction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subqueryCheckOptionRestriction$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("check" TestNoAlpha OptionalSpacing "option" TestNoAlpha OptionalSpacing SubqueryCheckConstraintName)
      // "check"
      match = ignoreCaseStringMatcher("check", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "option"
               match = ignoreCaseStringMatcher("option", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SubqueryCheckConstraintName
                        match = subqueryCheckConstraintName$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         subqueryCheckOptionRestriction$RuleMemoStart = startIndex;
         subqueryCheckOptionRestriction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subqueryCheckOptionRestriction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_CHECK_OPTION_RESTRICTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subqueryCheckOptionRestriction$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subqueryCheckOptionRestriction$RuleMemoStart = startIndex;
         subqueryCheckOptionRestriction$RuleMemoEnd = -1;
         subqueryCheckOptionRestriction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryRestrictionType : (SubqueryReadOnlyRestriction | SubqueryCheckOptionRestriction)
   protected boolean subqueryRestrictionType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryRestrictionType", index);
      }
      startIndex = index;
      // (SubqueryReadOnlyRestriction | SubqueryCheckOptionRestriction)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'r':
         case 'R': {
            // SubqueryReadOnlyRestriction
            match = subqueryReadOnlyRestriction$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'c':
         case 'C': {
            // SubqueryCheckOptionRestriction
            match = subqueryCheckOptionRestriction$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_RESTRICTION_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryRestriction : ("with" TestNoAlpha OptionalSpacing SubqueryRestrictionType)?
   protected boolean subqueryRestriction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryRestriction", index);
      }
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing SubqueryRestrictionType)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("with" TestNoAlpha OptionalSpacing SubqueryRestrictionType)
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SubqueryRestrictionType
               match = subqueryRestrictionType$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_RESTRICTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SampleNumber : ('(' OptionalSpacing UnsignedNumber ')' OptionalSpacing)
   protected boolean sampleNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SampleNumber", index);
      }
      startIndex = index;
      // ('(' OptionalSpacing UnsignedNumber ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // UnsignedNumber
            match = unsignedNumber$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SAMPLE_NUMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Seed : ("seed" TestNoAlpha OptionalSpacing '(' OptionalSpacing IntegerLiteral ')' OptionalSpacing)
   protected boolean seed$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Seed", index);
      }
      startIndex = index;
      // ("seed" TestNoAlpha OptionalSpacing '(' OptionalSpacing IntegerLiteral ')' OptionalSpacing)
      // "seed"
      match = ignoreCaseStringMatcher("seed", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // IntegerLiteral
                     match = integerLiteral$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SEED, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SampleClause : ("sample" TestNoAlpha OptionalSpacing ("block" TestNoAlpha OptionalSpacing)? SampleNumber Seed?)
   protected boolean sampleClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SampleClause", index);
      }
      startIndex = index;
      // ("sample" TestNoAlpha OptionalSpacing ("block" TestNoAlpha OptionalSpacing)? SampleNumber Seed?)
      // "sample"
      match = ignoreCaseStringMatcher("sample", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("block" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("block" TestNoAlpha OptionalSpacing)
               // "block"
               match = ignoreCaseStringMatcher("block", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // SampleNumber
                  match = sampleNumber$Rule();
                  if (match) {
                     // Seed?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // Seed
                     match = seed$Rule();
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SAMPLE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TableOrView : ((TablePartitionName | TableSubPartitionName | TableName) SampleClause?)
   protected boolean tableOrView$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TableOrView", index);
      }
      if (tableOrView$RuleMemoStart == index) {
         if (tableOrView$RuleMemoStart <= tableOrView$RuleMemoEnd) {
            index = tableOrView$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_OR_VIEW, tableOrView$RuleMemoStart, tableOrView$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tableOrView$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tableOrView$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((TablePartitionName | TableSubPartitionName | TableName) SampleClause?)
      // (TablePartitionName | TableSubPartitionName | TableName)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // TablePartitionName
            match = tablePartitionName$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // TableSubPartitionName
               match = tableSubPartitionName$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // TableName
                  match = tableName$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // SampleClause?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // SampleClause
         match = sampleClause$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (match) {
         tableOrView$RuleMemoStart = startIndex;
         tableOrView$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tableOrView$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_OR_VIEW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tableOrView$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tableOrView$RuleMemoStart = startIndex;
         tableOrView$RuleMemoEnd = -1;
         tableOrView$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryTableExpression : (TableOrView | Subquery | TableCollectionExpression)
   protected boolean queryTableExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryTableExpression", index);
      }
      if (queryTableExpression$RuleMemoStart == index) {
         if (queryTableExpression$RuleMemoStart <= queryTableExpression$RuleMemoEnd) {
            index = queryTableExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION, queryTableExpression$RuleMemoStart, queryTableExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (queryTableExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(queryTableExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableOrView | Subquery | TableCollectionExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // TableOrView
            match = tableOrView$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'S':
         case 's': {
            // TableOrView
            match = tableOrView$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Subquery
               match = subquery$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'T':
         case 't': {
            // TableOrView
            match = tableOrView$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // TableCollectionExpression
               match = tableCollectionExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '(': {
            // Subquery
            match = subquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         queryTableExpression$RuleMemoStart = startIndex;
         queryTableExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            queryTableExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            queryTableExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         queryTableExpression$RuleMemoStart = startIndex;
         queryTableExpression$RuleMemoEnd = -1;
         queryTableExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DBLink : ('@' OptionalSpacing SqlAnyIdentifier)
   protected boolean dBLink$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DBLink", index);
      }
      if (dBLink$RuleMemoStart == index) {
         if (dBLink$RuleMemoStart <= dBLink$RuleMemoEnd) {
            index = dBLink$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DBLINK, dBLink$RuleMemoStart, dBLink$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dBLink$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dBLink$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing SqlAnyIdentifier)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlAnyIdentifier
            match = sqlAnyIdentifier$Rule();
         }
      }
      if (match) {
         dBLink$RuleMemoStart = startIndex;
         dBLink$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dBLink$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DBLINK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dBLink$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dBLink$RuleMemoStart = startIndex;
         dBLink$RuleMemoEnd = -1;
         dBLink$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TableName : (SchemaObjectName DBLink?)
   protected boolean tableName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TableName", index);
      }
      if (tableName$RuleMemoStart == index) {
         if (tableName$RuleMemoStart <= tableName$RuleMemoEnd) {
            index = tableName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_NAME, tableName$RuleMemoStart, tableName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tableName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tableName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SchemaObjectName DBLink?)
      // SchemaObjectName
      match = schemaObjectName$Rule();
      if (match) {
         // DBLink?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // DBLink
         match = dBLink$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         tableName$RuleMemoStart = startIndex;
         tableName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tableName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tableName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tableName$RuleMemoStart = startIndex;
         tableName$RuleMemoEnd = -1;
         tableName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlFunctionCallAsIdentifier : (SqlObjectIdentifier "as" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
   protected boolean sqlFunctionCallAsIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlFunctionCallAsIdentifier", index);
      }
      startIndex = index;
      // (SqlObjectIdentifier "as" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // "as"
         match = ignoreCaseStringMatcher("as", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlAnyIdentifier
                  match = sqlAnyIdentifier$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_FUNCTION_CALL_AS_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CollectionExpression : (Subquery | SqlObjectIdentifier)
   protected boolean collectionExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CollectionExpression", index);
      }
      startIndex = index;
      // (Subquery | SqlObjectIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlObjectIdentifier
            match = sqlObjectIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'S':
         case 's': {
            // Subquery
            match = subquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlObjectIdentifier
               match = sqlObjectIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '(': {
            // Subquery
            match = subquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COLLECTION_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TableCollectionExpression : ("table" TestNoAlpha OptionalSpacing '(' OptionalSpacing CollectionExpression ')' OptionalSpacing OuterJoinSign?)
   protected boolean tableCollectionExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TableCollectionExpression", index);
      }
      if (tableCollectionExpression$RuleMemoStart == index) {
         if (tableCollectionExpression$RuleMemoStart <= tableCollectionExpression$RuleMemoEnd) {
            index = tableCollectionExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_COLLECTION_EXPRESSION, tableCollectionExpression$RuleMemoStart, tableCollectionExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tableCollectionExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tableCollectionExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("table" TestNoAlpha OptionalSpacing '(' OptionalSpacing CollectionExpression ')' OptionalSpacing OuterJoinSign?)
      // "table"
      match = ignoreCaseStringMatcher("table", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // CollectionExpression
                     match = collectionExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // OuterJoinSign?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // OuterJoinSign
                              match = outerJoinSign$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         tableCollectionExpression$RuleMemoStart = startIndex;
         tableCollectionExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tableCollectionExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_COLLECTION_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tableCollectionExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tableCollectionExpression$RuleMemoStart = startIndex;
         tableCollectionExpression$RuleMemoEnd = -1;
         tableCollectionExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlMathOperator : (('**' OptionalSpacing) | ('*' OptionalSpacing) | ('/' OptionalSpacing) | ('+' OptionalSpacing) | ('-' OptionalSpacing) | ('|' OptionalSpacing '|' OptionalSpacing) | ("mod" TestNoAlpha OptionalSpacing))
   protected boolean sqlMathOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlMathOperator", index);
      }
      if (sqlMathOperator$RuleMemoStart == index) {
         if (sqlMathOperator$RuleMemoStart <= sqlMathOperator$RuleMemoEnd) {
            index = sqlMathOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_MATH_OPERATOR, sqlMathOperator$RuleMemoStart, sqlMathOperator$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlMathOperator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlMathOperator$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (('**' OptionalSpacing) | ('*' OptionalSpacing) | ('/' OptionalSpacing) | ('+' OptionalSpacing) | ('-' OptionalSpacing) | ('|' OptionalSpacing '|' OptionalSpacing) | ("mod" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('**' OptionalSpacing)
      // '**'
      match = stringMatcher("**", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('*' OptionalSpacing)
         // '*'
         match = charMatcher('*');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('/' OptionalSpacing)
            // '/'
            match = charMatcher('/');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('+' OptionalSpacing)
               // '+'
               match = charMatcher('+');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('-' OptionalSpacing)
                  // '-'
                  match = charMatcher('-');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ('|' OptionalSpacing '|' OptionalSpacing)
                     // '|'
                     match = charMatcher('|');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '|'
                           match = charMatcher('|');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("mod" TestNoAlpha OptionalSpacing)
                        // "mod"
                        match = ignoreCaseStringMatcher("mod", 3);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         sqlMathOperator$RuleMemoStart = startIndex;
         sqlMathOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlMathOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_MATH_OPERATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlMathOperator$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlMathOperator$RuleMemoStart = startIndex;
         sqlMathOperator$RuleMemoEnd = -1;
         sqlMathOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlExpression : (SqlMathExpression | SqlAtomicExpression)
   protected boolean sqlExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlExpression", index);
      }
      if (sqlExpression$RuleMemoStart == index) {
         if (sqlExpression$RuleMemoStart <= sqlExpression$RuleMemoEnd) {
            index = sqlExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_EXPRESSION, sqlExpression$RuleMemoStart, sqlExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlMathExpression | SqlAtomicExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlMathExpression
            match = sqlMathExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlAtomicExpression
               match = sqlAtomicExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlExpression$RuleMemoStart = startIndex;
         sqlExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlExpression$RuleMemoStart = startIndex;
         sqlExpression$RuleMemoEnd = -1;
         sqlExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlMathExpression : (SqlAtomicExpression SqlMathOperator SqlExpression)
   protected boolean sqlMathExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlMathExpression", index);
      }
      if (sqlMathExpression$RuleMemoStart == index) {
         if (sqlMathExpression$RuleMemoStart <= sqlMathExpression$RuleMemoEnd) {
            index = sqlMathExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_MATH_EXPRESSION, sqlMathExpression$RuleMemoStart, sqlMathExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlMathExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlMathExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlAtomicExpression SqlMathOperator SqlExpression)
      // SqlAtomicExpression
      match = sqlAtomicExpression$Rule();
      if (match) {
         // SqlMathOperator
         match = sqlMathOperator$Rule();
         if (match) {
            // SqlExpression
            match = sqlExpression$Rule();
         }
      }
      if (match) {
         sqlMathExpression$RuleMemoStart = startIndex;
         sqlMathExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlMathExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_MATH_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlMathExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlMathExpression$RuleMemoStart = startIndex;
         sqlMathExpression$RuleMemoEnd = -1;
         sqlMathExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesSqlExpression : ('(' OptionalSpacing SqlExpression ')' OptionalSpacing)
   protected boolean parenthesesSqlExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesSqlExpression", index);
      }
      if (parenthesesSqlExpression$RuleMemoStart == index) {
         if (parenthesesSqlExpression$RuleMemoStart <= parenthesesSqlExpression$RuleMemoEnd) {
            index = parenthesesSqlExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_SQL_EXPRESSION, parenthesesSqlExpression$RuleMemoStart, parenthesesSqlExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesSqlExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesSqlExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlExpression ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlExpression
            match = sqlExpression$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesSqlExpression$RuleMemoStart = startIndex;
         parenthesesSqlExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesSqlExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_SQL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesSqlExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parenthesesSqlExpression$RuleMemoStart = startIndex;
         parenthesesSqlExpression$RuleMemoEnd = -1;
         parenthesesSqlExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlUnaryOperator : (('+' OptionalSpacing) | ('-' OptionalSpacing) | ("prior" TestNoAlpha OptionalSpacing) | ("connect_by_root" TestNoAlpha OptionalSpacing))
   protected boolean sqlUnaryOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlUnaryOperator", index);
      }
      startIndex = index;
      // (('+' OptionalSpacing) | ('-' OptionalSpacing) | ("prior" TestNoAlpha OptionalSpacing) | ("connect_by_root" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('+' OptionalSpacing)
      // '+'
      match = charMatcher('+');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('-' OptionalSpacing)
         // '-'
         match = charMatcher('-');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("prior" TestNoAlpha OptionalSpacing)
            // "prior"
            match = ignoreCaseStringMatcher("prior", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("connect_by_root" TestNoAlpha OptionalSpacing)
               // "connect_by_root"
               match = ignoreCaseStringMatcher("connect_by_root", 15);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_UNARY_OPERATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlUnaryExpression : (SqlUnaryOperator SqlLeftAtomicExpression)
   protected boolean sqlUnaryExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlUnaryExpression", index);
      }
      if (sqlUnaryExpression$RuleMemoStart == index) {
         if (sqlUnaryExpression$RuleMemoStart <= sqlUnaryExpression$RuleMemoEnd) {
            index = sqlUnaryExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_UNARY_EXPRESSION, sqlUnaryExpression$RuleMemoStart, sqlUnaryExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlUnaryExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlUnaryExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlUnaryOperator SqlLeftAtomicExpression)
      // SqlUnaryOperator
      match = sqlUnaryOperator$Rule();
      if (match) {
         // SqlLeftAtomicExpression
         match = sqlLeftAtomicExpression$Rule();
      }
      if (match) {
         sqlUnaryExpression$RuleMemoStart = startIndex;
         sqlUnaryExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlUnaryExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_UNARY_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlUnaryExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlUnaryExpression$RuleMemoStart = startIndex;
         sqlUnaryExpression$RuleMemoEnd = -1;
         sqlUnaryExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlLeftAtomicExpression : (ParenthesesSqlExpression | SqlCaseExpression | CursorExpression | PlaceHolderExpression | TypeConstructorExpression | Subquery | BuiltInFunctionCall | SqlSimpleExpression | SysDate | SqlUnaryExpression | ModelExpression)
   protected boolean sqlLeftAtomicExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlLeftAtomicExpression", index);
      }
      if (sqlLeftAtomicExpression$RuleMemoStart == index) {
         if (sqlLeftAtomicExpression$RuleMemoStart <= sqlLeftAtomicExpression$RuleMemoEnd) {
            index = sqlLeftAtomicExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_LEFT_ATOMIC_EXPRESSION, sqlLeftAtomicExpression$RuleMemoStart, sqlLeftAtomicExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlLeftAtomicExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlLeftAtomicExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesSqlExpression | SqlCaseExpression | CursorExpression | PlaceHolderExpression | TypeConstructorExpression | Subquery | BuiltInFunctionCall | SqlSimpleExpression | SysDate | SqlUnaryExpression | ModelExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+':
         case '-': {
            // SqlSimpleExpression
            match = sqlSimpleExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlUnaryExpression
               match = sqlUnaryExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'N':
         case 'n': {
            // TypeConstructorExpression
            match = typeConstructorExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BuiltInFunctionCall
               match = builtInFunctionCall$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlSimpleExpression
                  match = sqlSimpleExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ModelExpression
                     match = modelExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '\u00C1':
         case 'B':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case 'I':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'Q':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case 'U':
         case '\u00D5':
         case '\u00D6':
         case 'W':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case '\u00E1':
         case 'b':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case 'i':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'q':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case 'u':
         case '\u00F5':
         case '\u00F6':
         case 'w':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlSimpleExpression
            match = sqlSimpleExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ModelExpression
               match = modelExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'P':
         case 'p': {
            // BuiltInFunctionCall
            match = builtInFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlSimpleExpression
               match = sqlSimpleExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlUnaryExpression
                  match = sqlUnaryExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ModelExpression
                     match = modelExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'a':
         case 'D':
         case 'd':
         case 'E':
         case 'e':
         case 'F':
         case 'f':
         case 'L':
         case 'l':
         case 'M':
         case 'm':
         case 'R':
         case 'r':
         case 'T':
         case 't':
         case 'V':
         case 'v':
         case 'X':
         case 'x': {
            // BuiltInFunctionCall
            match = builtInFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlSimpleExpression
               match = sqlSimpleExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ModelExpression
                  match = modelExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // SqlCaseExpression
            match = sqlCaseExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CursorExpression
               match = cursorExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // BuiltInFunctionCall
                  match = builtInFunctionCall$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlSimpleExpression
                     match = sqlSimpleExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlUnaryExpression
                        match = sqlUnaryExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ModelExpression
                           match = modelExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'S':
         case 's': {
            // Subquery
            match = subquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BuiltInFunctionCall
               match = builtInFunctionCall$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlSimpleExpression
                  match = sqlSimpleExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SysDate
                     match = sysDate$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ModelExpression
                        match = modelExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case '\'': {
            // SqlSimpleExpression
            match = sqlSimpleExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // ParenthesesSqlExpression
            match = parenthesesSqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Subquery
               match = subquery$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case ':':
         case '?': {
            // PlaceHolderExpression
            match = placeHolderExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlLeftAtomicExpression$RuleMemoStart = startIndex;
         sqlLeftAtomicExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlLeftAtomicExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_LEFT_ATOMIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlLeftAtomicExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlLeftAtomicExpression$RuleMemoStart = startIndex;
         sqlLeftAtomicExpression$RuleMemoEnd = -1;
         sqlLeftAtomicExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DateTimeExpression : (SqlLeftAtomicExpression TimeExpression)
   protected boolean dateTimeExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DateTimeExpression", index);
      }
      if (dateTimeExpression$RuleMemoStart == index) {
         if (dateTimeExpression$RuleMemoStart <= dateTimeExpression$RuleMemoEnd) {
            index = dateTimeExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DATE_TIME_EXPRESSION, dateTimeExpression$RuleMemoStart, dateTimeExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dateTimeExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dateTimeExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlLeftAtomicExpression TimeExpression)
      // SqlLeftAtomicExpression
      match = sqlLeftAtomicExpression$Rule();
      if (match) {
         // TimeExpression
         match = timeExpression$Rule();
      }
      if (match) {
         dateTimeExpression$RuleMemoStart = startIndex;
         dateTimeExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dateTimeExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DATE_TIME_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dateTimeExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dateTimeExpression$RuleMemoStart = startIndex;
         dateTimeExpression$RuleMemoEnd = -1;
         dateTimeExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAtomicExpression : (DateTimeExpression | SqlLeftAtomicExpression)
   protected boolean sqlAtomicExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAtomicExpression", index);
      }
      if (sqlAtomicExpression$RuleMemoStart == index) {
         if (sqlAtomicExpression$RuleMemoStart <= sqlAtomicExpression$RuleMemoEnd) {
            index = sqlAtomicExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_ATOMIC_EXPRESSION, sqlAtomicExpression$RuleMemoStart, sqlAtomicExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlAtomicExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlAtomicExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (DateTimeExpression | SqlLeftAtomicExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // DateTimeExpression
            match = dateTimeExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlLeftAtomicExpression
               match = sqlLeftAtomicExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlAtomicExpression$RuleMemoStart = startIndex;
         sqlAtomicExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlAtomicExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_ATOMIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlAtomicExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlAtomicExpression$RuleMemoStart = startIndex;
         sqlAtomicExpression$RuleMemoEnd = -1;
         sqlAtomicExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlCaseExpression : ("case" TestNoAlpha OptionalSpacing (SqlSearchedCaseExpression | SqlSimpleCaseExpression) SqlCaseExpressionElse? "end" TestNoAlpha OptionalSpacing ("case" TestNoAlpha OptionalSpacing)?)
   protected boolean sqlCaseExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlCaseExpression", index);
      }
      if (sqlCaseExpression$RuleMemoStart == index) {
         if (sqlCaseExpression$RuleMemoStart <= sqlCaseExpression$RuleMemoEnd) {
            index = sqlCaseExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_CASE_EXPRESSION, sqlCaseExpression$RuleMemoStart, sqlCaseExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlCaseExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlCaseExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing (SqlSearchedCaseExpression | SqlSimpleCaseExpression) SqlCaseExpressionElse? "end" TestNoAlpha OptionalSpacing ("case" TestNoAlpha OptionalSpacing)?)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (SqlSearchedCaseExpression | SqlSimpleCaseExpression)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '\'':
                  case '(':
                  case '+':
                  case '-':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case ':':
                  case '?':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // SqlSimpleCaseExpression
                     match = sqlSimpleCaseExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'W':
                  case 'w': {
                     // SqlSearchedCaseExpression
                     match = sqlSearchedCaseExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlSimpleCaseExpression
                        match = sqlSimpleCaseExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // SqlCaseExpressionElse?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // SqlCaseExpressionElse
                  match = sqlCaseExpressionElse$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // "end"
                     match = ignoreCaseStringMatcher("end", 3);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // ("case" TestNoAlpha OptionalSpacing)?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // ("case" TestNoAlpha OptionalSpacing)
                              // "case"
                              match = ignoreCaseStringMatcher("case", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         sqlCaseExpression$RuleMemoStart = startIndex;
         sqlCaseExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlCaseExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_CASE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlCaseExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlCaseExpression$RuleMemoStart = startIndex;
         sqlCaseExpression$RuleMemoEnd = -1;
         sqlCaseExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlWhenExpressionThen : ("when" TestNoAlpha OptionalSpacing SqlExpression "then" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean sqlWhenExpressionThen$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlWhenExpressionThen", index);
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing SqlExpression "then" TestNoAlpha OptionalSpacing SqlExpression)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // SqlExpression
                           match = sqlExpression$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_WHEN_EXPRESSION_THEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlSimpleCaseExpression : (SqlExpression SqlWhenExpressionThen+)
   protected boolean sqlSimpleCaseExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSimpleCaseExpression", index);
      }
      if (sqlSimpleCaseExpression$RuleMemoStart == index) {
         if (sqlSimpleCaseExpression$RuleMemoStart <= sqlSimpleCaseExpression$RuleMemoEnd) {
            index = sqlSimpleCaseExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_CASE_EXPRESSION, sqlSimpleCaseExpression$RuleMemoStart, sqlSimpleCaseExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlSimpleCaseExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlSimpleCaseExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression SqlWhenExpressionThen+)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // SqlWhenExpressionThen+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // SqlWhenExpressionThen
         match = sqlWhenExpressionThen$Rule();
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // SqlWhenExpressionThen
               match = sqlWhenExpressionThen$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         sqlSimpleCaseExpression$RuleMemoStart = startIndex;
         sqlSimpleCaseExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlSimpleCaseExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_CASE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlSimpleCaseExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlSimpleCaseExpression$RuleMemoStart = startIndex;
         sqlSimpleCaseExpression$RuleMemoEnd = -1;
         sqlSimpleCaseExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlWhenConditionThen : ("when" TestNoAlpha OptionalSpacing SqlCondition "then" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean sqlWhenConditionThen$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlWhenConditionThen", index);
      }
      if (sqlWhenConditionThen$RuleMemoStart == index) {
         if (sqlWhenConditionThen$RuleMemoStart <= sqlWhenConditionThen$RuleMemoEnd) {
            index = sqlWhenConditionThen$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_WHEN_CONDITION_THEN, sqlWhenConditionThen$RuleMemoStart, sqlWhenConditionThen$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlWhenConditionThen$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlWhenConditionThen$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing SqlCondition "then" TestNoAlpha OptionalSpacing SqlExpression)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlCondition
               match = sqlCondition$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // SqlExpression
                           match = sqlExpression$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         sqlWhenConditionThen$RuleMemoStart = startIndex;
         sqlWhenConditionThen$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlWhenConditionThen$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_WHEN_CONDITION_THEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlWhenConditionThen$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlWhenConditionThen$RuleMemoStart = startIndex;
         sqlWhenConditionThen$RuleMemoEnd = -1;
         sqlWhenConditionThen$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlSearchedCaseExpression : SqlWhenConditionThen+
   protected boolean sqlSearchedCaseExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSearchedCaseExpression", index);
      }
      if (sqlSearchedCaseExpression$RuleMemoStart == index) {
         if (sqlSearchedCaseExpression$RuleMemoStart <= sqlSearchedCaseExpression$RuleMemoEnd) {
            index = sqlSearchedCaseExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_SEARCHED_CASE_EXPRESSION, sqlSearchedCaseExpression$RuleMemoStart, sqlSearchedCaseExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlSearchedCaseExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlSearchedCaseExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // SqlWhenConditionThen+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // SqlWhenConditionThen
      match = sqlWhenConditionThen$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // SqlWhenConditionThen
            match = sqlWhenConditionThen$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         sqlSearchedCaseExpression$RuleMemoStart = startIndex;
         sqlSearchedCaseExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlSearchedCaseExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_SEARCHED_CASE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlSearchedCaseExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlSearchedCaseExpression$RuleMemoStart = startIndex;
         sqlSearchedCaseExpression$RuleMemoEnd = -1;
         sqlSearchedCaseExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlCaseExpressionElse : ("else" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean sqlCaseExpressionElse$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlCaseExpressionElse", index);
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing SqlExpression)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_CASE_EXPRESSION_ELSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RowNum : ("rownum" TestNoAlpha OptionalSpacing)
   protected boolean rowNum$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RowNum", index);
      }
      if (rowNum$RuleMemoStart == index) {
         if (rowNum$RuleMemoStart <= rowNum$RuleMemoEnd) {
            index = rowNum$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROW_NUM, rowNum$RuleMemoStart, rowNum$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rowNum$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rowNum$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("rownum" TestNoAlpha OptionalSpacing)
      // "rownum"
      match = ignoreCaseStringMatcher("rownum", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         rowNum$RuleMemoStart = startIndex;
         rowNum$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rowNum$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROW_NUM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rowNum$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rowNum$RuleMemoStart = startIndex;
         rowNum$RuleMemoEnd = -1;
         rowNum$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IdentifiedRowId : (TableName '.' OptionalSpacing "rowid" TestNoAlpha OptionalSpacing)
   protected boolean identifiedRowId$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IdentifiedRowId", index);
      }
      if (identifiedRowId$RuleMemoStart == index) {
         if (identifiedRowId$RuleMemoStart <= identifiedRowId$RuleMemoEnd) {
            index = identifiedRowId$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIED_ROW_ID, identifiedRowId$RuleMemoStart, identifiedRowId$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifiedRowId$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifiedRowId$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableName '.' OptionalSpacing "rowid" TestNoAlpha OptionalSpacing)
      // TableName
      match = tableName$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "rowid"
               match = ignoreCaseStringMatcher("rowid", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         identifiedRowId$RuleMemoStart = startIndex;
         identifiedRowId$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifiedRowId$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIED_ROW_ID, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifiedRowId$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         identifiedRowId$RuleMemoStart = startIndex;
         identifiedRowId$RuleMemoEnd = -1;
         identifiedRowId$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RowIdColumn : (IdentifiedRowId | ("rowid" TestNoAlpha OptionalSpacing))
   protected boolean rowIdColumn$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RowIdColumn", index);
      }
      if (rowIdColumn$RuleMemoStart == index) {
         if (rowIdColumn$RuleMemoStart <= rowIdColumn$RuleMemoEnd) {
            index = rowIdColumn$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROW_ID_COLUMN, rowIdColumn$RuleMemoStart, rowIdColumn$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rowIdColumn$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rowIdColumn$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (IdentifiedRowId | ("rowid" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // IdentifiedRowId
      match = identifiedRowId$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("rowid" TestNoAlpha OptionalSpacing)
         // "rowid"
         match = ignoreCaseStringMatcher("rowid", 5);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         rowIdColumn$RuleMemoStart = startIndex;
         rowIdColumn$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rowIdColumn$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROW_ID_COLUMN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rowIdColumn$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rowIdColumn$RuleMemoStart = startIndex;
         rowIdColumn$RuleMemoEnd = -1;
         rowIdColumn$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Level : ("level" TestNoAlpha OptionalSpacing)
   protected boolean level$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Level", index);
      }
      if (level$RuleMemoStart == index) {
         if (level$RuleMemoStart <= level$RuleMemoEnd) {
            index = level$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LEVEL, level$RuleMemoStart, level$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (level$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(level$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("level" TestNoAlpha OptionalSpacing)
      // "level"
      match = ignoreCaseStringMatcher("level", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         level$RuleMemoStart = startIndex;
         level$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            level$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LEVEL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            level$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         level$RuleMemoStart = startIndex;
         level$RuleMemoEnd = -1;
         level$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlOuterJoinObject : (SqlObjectIdentifier OuterJoinSign)
   protected boolean sqlOuterJoinObject$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlOuterJoinObject", index);
      }
      if (sqlOuterJoinObject$RuleMemoStart == index) {
         if (sqlOuterJoinObject$RuleMemoStart <= sqlOuterJoinObject$RuleMemoEnd) {
            index = sqlOuterJoinObject$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_OUTER_JOIN_OBJECT, sqlOuterJoinObject$RuleMemoStart, sqlOuterJoinObject$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlOuterJoinObject$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlOuterJoinObject$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier OuterJoinSign)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // OuterJoinSign
         match = outerJoinSign$Rule();
      }
      if (match) {
         sqlOuterJoinObject$RuleMemoStart = startIndex;
         sqlOuterJoinObject$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlOuterJoinObject$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_OUTER_JOIN_OBJECT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlOuterJoinObject$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlOuterJoinObject$RuleMemoStart = startIndex;
         sqlOuterJoinObject$RuleMemoEnd = -1;
         sqlOuterJoinObject$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlSimpleExpression : (SqlLiteral | RowNum | RowIdColumn | Level | SqlOuterJoinObject | SqlObjectIdentifier)
   protected boolean sqlSimpleExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSimpleExpression", index);
      }
      if (sqlSimpleExpression$RuleMemoStart == index) {
         if (sqlSimpleExpression$RuleMemoStart <= sqlSimpleExpression$RuleMemoEnd) {
            index = sqlSimpleExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_EXPRESSION, sqlSimpleExpression$RuleMemoStart, sqlSimpleExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlSimpleExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlSimpleExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlLiteral | RowNum | RowIdColumn | Level | SqlOuterJoinObject | SqlObjectIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case '+':
         case '-': {
            // SqlLiteral
            match = sqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'L':
         case 'l': {
            // RowIdColumn
            match = rowIdColumn$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Level
               match = level$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlOuterJoinObject
                  match = sqlOuterJoinObject$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'D':
         case 'd':
         case 'I':
         case 'i':
         case 'N':
         case 'n':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case 'T':
         case 't':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // SqlLiteral
            match = sqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RowIdColumn
               match = rowIdColumn$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlOuterJoinObject
                  match = sqlOuterJoinObject$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case 'A':
         case '\u00C1':
         case 'B':
         case '\u00C2':
         case 'C':
         case '\u00C3':
         case '\u00C4':
         case 'E':
         case 'F':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case '\u00CC':
         case 'M':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'P':
         case 'Q':
         case '\u00D2':
         case 'S':
         case '\u00D3':
         case '\u00D4':
         case 'U':
         case '\u00D5':
         case 'V':
         case '\u00D6':
         case 'W':
         case 'X':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case 'a':
         case '\u00E1':
         case 'b':
         case '\u00E2':
         case 'c':
         case '\u00E3':
         case '\u00E4':
         case 'e':
         case 'f':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case '\u00EC':
         case 'm':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'p':
         case 'q':
         case '\u00F2':
         case 's':
         case '\u00F3':
         case '\u00F4':
         case 'u':
         case '\u00F5':
         case 'v':
         case '\u00F6':
         case 'w':
         case 'x':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // RowIdColumn
            match = rowIdColumn$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlOuterJoinObject
               match = sqlOuterJoinObject$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlObjectIdentifier
                  match = sqlObjectIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'R':
         case 'r': {
            // RowNum
            match = rowNum$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RowIdColumn
               match = rowIdColumn$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlOuterJoinObject
                  match = sqlOuterJoinObject$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlSimpleExpression$RuleMemoStart = startIndex;
         sqlSimpleExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlSimpleExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlSimpleExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlSimpleExpression$RuleMemoStart = startIndex;
         sqlSimpleExpression$RuleMemoEnd = -1;
         sqlSimpleExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SysDate : ("sysdate" TestNoAlpha OptionalSpacing)
   protected boolean sysDate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SysDate", index);
      }
      if (sysDate$RuleMemoStart == index) {
         if (sysDate$RuleMemoStart <= sysDate$RuleMemoEnd) {
            index = sysDate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SYS_DATE, sysDate$RuleMemoStart, sysDate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sysDate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sysDate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("sysdate" TestNoAlpha OptionalSpacing)
      // "sysdate"
      match = ignoreCaseStringMatcher("sysdate", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         sysDate$RuleMemoStart = startIndex;
         sysDate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sysDate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SYS_DATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sysDate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sysDate$RuleMemoStart = startIndex;
         sysDate$RuleMemoEnd = -1;
         sysDate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TimeExpression : (("at" TestNoAlpha OptionalSpacing (("local" TestNoAlpha OptionalSpacing) | ("time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression)))) | ("DatetimeExpression" TestNoAlpha OptionalSpacing) | (("day" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)?) | ("year" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)) | ("IntervalExpression" TestNoAlpha OptionalSpacing))
   protected boolean timeExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TimeExpression", index);
      }
      if (timeExpression$RuleMemoStart == index) {
         if (timeExpression$RuleMemoStart <= timeExpression$RuleMemoEnd) {
            index = timeExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TIME_EXPRESSION, timeExpression$RuleMemoStart, timeExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (timeExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timeExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("at" TestNoAlpha OptionalSpacing (("local" TestNoAlpha OptionalSpacing) | ("time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression)))) | ("DatetimeExpression" TestNoAlpha OptionalSpacing) | (("day" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)?) | ("year" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)) | ("IntervalExpression" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("at" TestNoAlpha OptionalSpacing (("local" TestNoAlpha OptionalSpacing) | ("time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression))))
      // "at"
      match = ignoreCaseStringMatcher("at", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("local" TestNoAlpha OptionalSpacing) | ("time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression)))
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ("local" TestNoAlpha OptionalSpacing)
               // "local"
               match = ignoreCaseStringMatcher("local", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ("time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression))
                  // "time"
                  match = ignoreCaseStringMatcher("time", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "zone"
                           match = ignoreCaseStringMatcher("zone", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // (("dbtimezone" TestNoAlpha OptionalSpacing) | ("sessiontimezone" TestNoAlpha OptionalSpacing) | StringLiteral | SqlExpression)
                                    Node lastNode_3 = currentNode;
                                    int lastIndex_3 = index;
                                    // ("dbtimezone" TestNoAlpha OptionalSpacing)
                                    // "dbtimezone"
                                    match = ignoreCaseStringMatcher("dbtimezone", 10);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                    if (! match) {
                                       index = lastIndex_3;
                                       lastNode_3.setSibling(null);
                                       currentNode = lastNode_3;
                                       // ("sessiontimezone" TestNoAlpha OptionalSpacing)
                                       // "sessiontimezone"
                                       match = ignoreCaseStringMatcher("sessiontimezone", 15);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_3;
                                          lastNode_3.setSibling(null);
                                          currentNode = lastNode_3;
                                          // StringLiteral
                                          match = stringLiteral$Rule();
                                          if (! match) {
                                             index = lastIndex_3;
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                             // SqlExpression
                                             match = sqlExpression$Rule();
                                             if (! match) {
                                                index = lastIndex_3;
                                                lastNode_3.setSibling(null);
                                                currentNode = lastNode_3;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("DatetimeExpression" TestNoAlpha OptionalSpacing)
         // "DatetimeExpression"
         match = ignoreCaseStringMatcher("DatetimeExpression", 18);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // (("day" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)?) | ("year" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing))
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // ("day" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)?)
            // "day"
            match = ignoreCaseStringMatcher("day", 3);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // '('
                     match = charMatcher('(');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '0'-'9'
                           match = charRangeMatcher('0', '9');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "to"
                                       match = ignoreCaseStringMatcher("to", 2);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // "second"
                                                match = ignoreCaseStringMatcher("second", 6);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)?
                                                         Node lastNode_5 = currentNode;
                                                         int lastIndex_5 = index;
                                                         // ('(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing)
                                                         // '('
                                                         match = charMatcher('(');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // '0'-'9'
                                                               match = charRangeMatcher('0', '9');
                                                               if (match) {
                                                                  // OptionalSpacing
                                                                  match = optionalSpacing$Rule();
                                                                  if (match) {
                                                                     // ')'
                                                                     match = charMatcher(')');
                                                                     if (match) {
                                                                        // OptionalSpacing
                                                                        match = optionalSpacing$Rule();
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                         if (! match) {
                                                            lastNode_5.setSibling(null);
                                                            currentNode = lastNode_5;
                                                            index = lastIndex_5;
                                                            match = true;
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_4;
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
               // ("year" TestNoAlpha OptionalSpacing '(' OptionalSpacing '0'-'9' OptionalSpacing ')' OptionalSpacing "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)
               // "year"
               match = ignoreCaseStringMatcher("year", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '('
                        match = charMatcher('(');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '0'-'9'
                              match = charRangeMatcher('0', '9');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // "to"
                                          match = ignoreCaseStringMatcher("to", 2);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // "month"
                                                   match = ignoreCaseStringMatcher("month", 5);
                                                   if (match) {
                                                      // TestNoAlpha
                                                      match = testNoAlpha$Rule();
                                                      if (match) {
                                                         // OptionalSpacing
                                                         match = optionalSpacing$Rule();
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_4;
                  lastNode_4.setSibling(null);
                  currentNode = lastNode_4;
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("IntervalExpression" TestNoAlpha OptionalSpacing)
               // "IntervalExpression"
               match = ignoreCaseStringMatcher("IntervalExpression", 18);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         timeExpression$RuleMemoStart = startIndex;
         timeExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timeExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TIME_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            timeExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         timeExpression$RuleMemoStart = startIndex;
         timeExpression$RuleMemoEnd = -1;
         timeExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OuterJoinSign : ('(' OptionalSpacing '+' OptionalSpacing ')' OptionalSpacing)
   protected boolean outerJoinSign$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OuterJoinSign", index);
      }
      if (outerJoinSign$RuleMemoStart == index) {
         if (outerJoinSign$RuleMemoStart <= outerJoinSign$RuleMemoEnd) {
            index = outerJoinSign$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_SIGN, outerJoinSign$RuleMemoStart, outerJoinSign$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (outerJoinSign$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(outerJoinSign$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing '+' OptionalSpacing ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '+'
            match = charMatcher('+');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         outerJoinSign$RuleMemoStart = startIndex;
         outerJoinSign$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            outerJoinSign$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_SIGN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            outerJoinSign$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         outerJoinSign$RuleMemoStart = startIndex;
         outerJoinSign$RuleMemoEnd = -1;
         outerJoinSign$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrderByFunctionClause : ("order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing OrderByArguments)
   protected boolean orderByFunctionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrderByFunctionClause", index);
      }
      if (orderByFunctionClause$RuleMemoStart == index) {
         if (orderByFunctionClause$RuleMemoStart <= orderByFunctionClause$RuleMemoEnd) {
            index = orderByFunctionClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_FUNCTION_CLAUSE, orderByFunctionClause$RuleMemoStart, orderByFunctionClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orderByFunctionClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orderByFunctionClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing OrderByArguments)
      // "order"
      match = ignoreCaseStringMatcher("order", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // OrderByArguments
                        match = orderByArguments$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         orderByFunctionClause$RuleMemoStart = startIndex;
         orderByFunctionClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orderByFunctionClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_FUNCTION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orderByFunctionClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         orderByFunctionClause$RuleMemoStart = startIndex;
         orderByFunctionClause$RuleMemoEnd = -1;
         orderByFunctionClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Avg : ("avg" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean avg$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Avg", index);
      }
      if (avg$RuleMemoStart == index) {
         if (avg$RuleMemoStart <= avg$RuleMemoEnd) {
            index = avg$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AVG, avg$RuleMemoStart, avg$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (avg$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(avg$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("avg" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "avg"
      match = ignoreCaseStringMatcher("avg", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         avg$RuleMemoStart = startIndex;
         avg$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            avg$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AVG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            avg$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         avg$RuleMemoStart = startIndex;
         avg$RuleMemoEnd = -1;
         avg$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Cast : ("cast" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("multiset" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing) | ("MultiSet" TestNoAlpha OptionalSpacing) | SqlExpression) AsDataType ')' OptionalSpacing)
   protected boolean cast$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Cast", index);
      }
      if (cast$RuleMemoStart == index) {
         if (cast$RuleMemoStart <= cast$RuleMemoEnd) {
            index = cast$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CAST, cast$RuleMemoStart, cast$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cast$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cast$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cast" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("multiset" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing) | ("MultiSet" TestNoAlpha OptionalSpacing) | SqlExpression) AsDataType ')' OptionalSpacing)
      // "cast"
      match = ignoreCaseStringMatcher("cast", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("multiset" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing) | ("MultiSet" TestNoAlpha OptionalSpacing) | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // ("multiset" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
                     // "multiset"
                     match = ignoreCaseStringMatcher("multiset", 8);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '('
                              match = charMatcher('(');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // Subquery
                                    match = subquery$Rule();
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("MultiSet" TestNoAlpha OptionalSpacing)
                        // "MultiSet"
                        match = ignoreCaseStringMatcher("MultiSet", 8);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     if (match) {
                        // AsDataType
                        match = asDataType$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cast$RuleMemoStart = startIndex;
         cast$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cast$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CAST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cast$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cast$RuleMemoStart = startIndex;
         cast$RuleMemoEnd = -1;
         cast$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Chr : ("chr" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ("using" TestNoAlpha OptionalSpacing "nchar_cs" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
   protected boolean chr$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Chr", index);
      }
      if (chr$RuleMemoStart == index) {
         if (chr$RuleMemoStart <= chr$RuleMemoEnd) {
            index = chr$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CHR, chr$RuleMemoStart, chr$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (chr$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(chr$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("chr" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ("using" TestNoAlpha OptionalSpacing "nchar_cs" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // "chr"
      match = ignoreCaseStringMatcher("chr", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ("using" TestNoAlpha OptionalSpacing "nchar_cs" TestNoAlpha OptionalSpacing)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ("using" TestNoAlpha OptionalSpacing "nchar_cs" TestNoAlpha OptionalSpacing)
                        // "using"
                        match = ignoreCaseStringMatcher("using", 5);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // "nchar_cs"
                                 match = ignoreCaseStringMatcher("nchar_cs", 8);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         chr$RuleMemoStart = startIndex;
         chr$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            chr$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CHR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            chr$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         chr$RuleMemoStart = startIndex;
         chr$RuleMemoEnd = -1;
         chr$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MiningAttributeClause : ("using" TestNoAlpha OptionalSpacing SelectList)
   protected boolean miningAttributeClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MiningAttributeClause", index);
      }
      if (miningAttributeClause$RuleMemoStart == index) {
         if (miningAttributeClause$RuleMemoStart <= miningAttributeClause$RuleMemoEnd) {
            index = miningAttributeClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MINING_ATTRIBUTE_CLAUSE, miningAttributeClause$RuleMemoStart, miningAttributeClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (miningAttributeClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(miningAttributeClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("using" TestNoAlpha OptionalSpacing SelectList)
      // "using"
      match = ignoreCaseStringMatcher("using", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SelectList
               match = selectList$Rule();
            }
         }
      }
      if (match) {
         miningAttributeClause$RuleMemoStart = startIndex;
         miningAttributeClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            miningAttributeClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MINING_ATTRIBUTE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            miningAttributeClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         miningAttributeClause$RuleMemoStart = startIndex;
         miningAttributeClause$RuleMemoEnd = -1;
         miningAttributeClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ClusterId : ("cluster_id" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
   protected boolean clusterId$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ClusterId", index);
      }
      if (clusterId$RuleMemoStart == index) {
         if (clusterId$RuleMemoStart <= clusterId$RuleMemoEnd) {
            index = clusterId$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_ID, clusterId$RuleMemoStart, clusterId$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clusterId$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clusterId$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cluster_id" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
      // "cluster_id"
      match = ignoreCaseStringMatcher("cluster_id", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // MiningAttributeClause
                        match = miningAttributeClause$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         clusterId$RuleMemoStart = startIndex;
         clusterId$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clusterId$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_ID, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clusterId$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         clusterId$RuleMemoStart = startIndex;
         clusterId$RuleMemoEnd = -1;
         clusterId$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ClusterProbability : ("cluster_probability" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
   protected boolean clusterProbability$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ClusterProbability", index);
      }
      if (clusterProbability$RuleMemoStart == index) {
         if (clusterProbability$RuleMemoStart <= clusterProbability$RuleMemoEnd) {
            index = clusterProbability$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_PROBABILITY, clusterProbability$RuleMemoStart, clusterProbability$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clusterProbability$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clusterProbability$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cluster_probability" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
      // "cluster_probability"
      match = ignoreCaseStringMatcher("cluster_probability", 19);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // MiningAttributeClause
                           match = miningAttributeClause$Rule();
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         clusterProbability$RuleMemoStart = startIndex;
         clusterProbability$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clusterProbability$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_PROBABILITY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clusterProbability$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         clusterProbability$RuleMemoStart = startIndex;
         clusterProbability$RuleMemoEnd = -1;
         clusterProbability$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ClusterSet : ("cluster_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
   protected boolean clusterSet$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ClusterSet", index);
      }
      if (clusterSet$RuleMemoStart == index) {
         if (clusterSet$RuleMemoStart <= clusterSet$RuleMemoEnd) {
            index = clusterSet$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_SET, clusterSet$RuleMemoStart, clusterSet$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (clusterSet$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(clusterSet$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cluster_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
      // "cluster_set"
      match = ignoreCaseStringMatcher("cluster_set", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing SqlExpression)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing SqlExpression)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // MiningAttributeClause
                              match = miningAttributeClause$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         clusterSet$RuleMemoStart = startIndex;
         clusterSet$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clusterSet$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CLUSTER_SET, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clusterSet$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         clusterSet$RuleMemoStart = startIndex;
         clusterSet$RuleMemoEnd = -1;
         clusterSet$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Corr : ("corr" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean corr$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Corr", index);
      }
      if (corr$RuleMemoStart == index) {
         if (corr$RuleMemoStart <= corr$RuleMemoEnd) {
            index = corr$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CORR, corr$RuleMemoStart, corr$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (corr$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(corr$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("corr" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "corr"
      match = ignoreCaseStringMatcher("corr", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // AnalyticOverClause?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // AnalyticOverClause
                                 match = analyticOverClause$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         corr$RuleMemoStart = startIndex;
         corr$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            corr$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CORR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            corr$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         corr$RuleMemoStart = startIndex;
         corr$RuleMemoEnd = -1;
         corr$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DistinctExpression : ("distinct" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean distinctExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DistinctExpression", index);
      }
      if (distinctExpression$RuleMemoStart == index) {
         if (distinctExpression$RuleMemoStart <= distinctExpression$RuleMemoEnd) {
            index = distinctExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DISTINCT_EXPRESSION, distinctExpression$RuleMemoStart, distinctExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (distinctExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(distinctExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("distinct" TestNoAlpha OptionalSpacing SqlExpression)
      // "distinct"
      match = ignoreCaseStringMatcher("distinct", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
            }
         }
      }
      if (match) {
         distinctExpression$RuleMemoStart = startIndex;
         distinctExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            distinctExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DISTINCT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            distinctExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         distinctExpression$RuleMemoStart = startIndex;
         distinctExpression$RuleMemoEnd = -1;
         distinctExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AllExpression : ("all" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean allExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AllExpression", index);
      }
      if (allExpression$RuleMemoStart == index) {
         if (allExpression$RuleMemoStart <= allExpression$RuleMemoEnd) {
            index = allExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ALL_EXPRESSION, allExpression$RuleMemoStart, allExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (allExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(allExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("all" TestNoAlpha OptionalSpacing SqlExpression)
      // "all"
      match = ignoreCaseStringMatcher("all", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
            }
         }
      }
      if (match) {
         allExpression$RuleMemoStart = startIndex;
         allExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            allExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ALL_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            allExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         allExpression$RuleMemoStart = startIndex;
         allExpression$RuleMemoEnd = -1;
         allExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Count : ("count" TestNoAlpha OptionalSpacing '(' OptionalSpacing (('*' OptionalSpacing) | DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean count$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Count", index);
      }
      if (count$RuleMemoStart == index) {
         if (count$RuleMemoStart <= count$RuleMemoEnd) {
            index = count$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COUNT, count$RuleMemoStart, count$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (count$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(count$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("count" TestNoAlpha OptionalSpacing '(' OptionalSpacing (('*' OptionalSpacing) | DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "count"
      match = ignoreCaseStringMatcher("count", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (('*' OptionalSpacing) | DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // ('*' OptionalSpacing)
                     // '*'
                     match = charMatcher('*');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // DistinctExpression
                        match = distinctExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         count$RuleMemoStart = startIndex;
         count$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            count$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COUNT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            count$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         count$RuleMemoStart = startIndex;
         count$RuleMemoEnd = -1;
         count$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CovarPop : ("covar_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean covarPop$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CovarPop", index);
      }
      if (covarPop$RuleMemoStart == index) {
         if (covarPop$RuleMemoStart <= covarPop$RuleMemoEnd) {
            index = covarPop$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COVAR_POP, covarPop$RuleMemoStart, covarPop$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (covarPop$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(covarPop$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("covar_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "covar_pop"
      match = ignoreCaseStringMatcher("covar_pop", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // AnalyticOverClause?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // AnalyticOverClause
                                 match = analyticOverClause$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         covarPop$RuleMemoStart = startIndex;
         covarPop$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            covarPop$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COVAR_POP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            covarPop$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         covarPop$RuleMemoStart = startIndex;
         covarPop$RuleMemoEnd = -1;
         covarPop$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CovarSamp : ("covar_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean covarSamp$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CovarSamp", index);
      }
      if (covarSamp$RuleMemoStart == index) {
         if (covarSamp$RuleMemoStart <= covarSamp$RuleMemoEnd) {
            index = covarSamp$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COVAR_SAMP, covarSamp$RuleMemoStart, covarSamp$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (covarSamp$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(covarSamp$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("covar_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "covar_samp"
      match = ignoreCaseStringMatcher("covar_samp", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // AnalyticOverClause?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // AnalyticOverClause
                                 match = analyticOverClause$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         covarSamp$RuleMemoStart = startIndex;
         covarSamp$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            covarSamp$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COVAR_SAMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            covarSamp$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         covarSamp$RuleMemoStart = startIndex;
         covarSamp$RuleMemoEnd = -1;
         covarSamp$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CumeDistAnalytic : ("cume_dist" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean cumeDistAnalytic$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CumeDistAnalytic", index);
      }
      if (cumeDistAnalytic$RuleMemoStart == index) {
         if (cumeDistAnalytic$RuleMemoStart <= cumeDistAnalytic$RuleMemoEnd) {
            index = cumeDistAnalytic$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CUME_DIST_ANALYTIC, cumeDistAnalytic$RuleMemoStart, cumeDistAnalytic$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cumeDistAnalytic$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cumeDistAnalytic$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cume_dist" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "cume_dist"
      match = ignoreCaseStringMatcher("cume_dist", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "over"
                           match = ignoreCaseStringMatcher("over", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // QueryPartitionClause?
                                          Node lastNode_1 = currentNode;
                                          int lastIndex_1 = index;
                                          // QueryPartitionClause
                                          match = queryPartitionClause$Rule();
                                          if (! match) {
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             match = true;
                                          }
                                          if (match) {
                                             // OrderByClause
                                             match = orderByClause$Rule();
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cumeDistAnalytic$RuleMemoStart = startIndex;
         cumeDistAnalytic$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cumeDistAnalytic$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CUME_DIST_ANALYTIC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cumeDistAnalytic$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cumeDistAnalytic$RuleMemoStart = startIndex;
         cumeDistAnalytic$RuleMemoEnd = -1;
         cumeDistAnalytic$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CumeDistAggregate : ("cume_dist" TestNoAlpha OptionalSpacing SqlParameters "with" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
   protected boolean cumeDistAggregate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CumeDistAggregate", index);
      }
      if (cumeDistAggregate$RuleMemoStart == index) {
         if (cumeDistAggregate$RuleMemoStart <= cumeDistAggregate$RuleMemoEnd) {
            index = cumeDistAggregate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CUME_DIST_AGGREGATE, cumeDistAggregate$RuleMemoStart, cumeDistAggregate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cumeDistAggregate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cumeDistAggregate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cume_dist" TestNoAlpha OptionalSpacing SqlParameters "with" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
      // "cume_dist"
      match = ignoreCaseStringMatcher("cume_dist", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlParameters
               match = sqlParameters$Rule();
               if (match) {
                  // "with"
                  match = ignoreCaseStringMatcher("with", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "group"
                           match = ignoreCaseStringMatcher("group", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // OrderByFunctionClause
                                          match = orderByFunctionClause$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cumeDistAggregate$RuleMemoStart = startIndex;
         cumeDistAggregate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cumeDistAggregate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CUME_DIST_AGGREGATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cumeDistAggregate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cumeDistAggregate$RuleMemoStart = startIndex;
         cumeDistAggregate$RuleMemoEnd = -1;
         cumeDistAggregate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Decompose : ("decompose" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (("canonical" | "compatibility") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
   protected boolean decompose$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Decompose", index);
      }
      if (decompose$RuleMemoStart == index) {
         if (decompose$RuleMemoStart <= decompose$RuleMemoEnd) {
            index = decompose$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DECOMPOSE, decompose$RuleMemoStart, decompose$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (decompose$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(decompose$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("decompose" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (("canonical" | "compatibility") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // "decompose"
      match = ignoreCaseStringMatcher("decompose", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // (("canonical" | "compatibility") TestNoAlpha OptionalSpacing)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (("canonical" | "compatibility") TestNoAlpha OptionalSpacing)
                        // ("canonical" | "compatibility")
                        int startIndex_2 = index;
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // ("ompatibility" | "anonical")
                           switch(buffer.getChar(index)) {
                              case 'o':
                              case 'O': {
                                 ++index;
                                 // "mpatibility"
                                 if (match = ignoreCaseStringTest("mpatibility", 11)) {
                                    index += 11;
                                 }
                                 break;
                              }
                              case 'a':
                              case 'A': {
                                 ++index;
                                 // "nonical"
                                 if (match = ignoreCaseStringTest("nonical", 7)) {
                                    index += 7;
                                 }
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                        }
                        if (! match) {
                           index = startIndex_2;
                        } else if(! currentRuleIsAtomic) {
                           currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                           currentNode = currentNode.getSibling();
                        }
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         decompose$RuleMemoStart = startIndex;
         decompose$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            decompose$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DECOMPOSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            decompose$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         decompose$RuleMemoStart = startIndex;
         decompose$RuleMemoEnd = -1;
         decompose$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DenseRankAggregate : ("dense_rank" TestNoAlpha OptionalSpacing SqlParameters "with" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
   protected boolean denseRankAggregate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DenseRankAggregate", index);
      }
      if (denseRankAggregate$RuleMemoStart == index) {
         if (denseRankAggregate$RuleMemoStart <= denseRankAggregate$RuleMemoEnd) {
            index = denseRankAggregate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DENSE_RANK_AGGREGATE, denseRankAggregate$RuleMemoStart, denseRankAggregate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (denseRankAggregate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(denseRankAggregate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("dense_rank" TestNoAlpha OptionalSpacing SqlParameters "with" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
      // "dense_rank"
      match = ignoreCaseStringMatcher("dense_rank", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlParameters
               match = sqlParameters$Rule();
               if (match) {
                  // "with"
                  match = ignoreCaseStringMatcher("with", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "group"
                           match = ignoreCaseStringMatcher("group", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // OrderByFunctionClause
                                          match = orderByFunctionClause$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         denseRankAggregate$RuleMemoStart = startIndex;
         denseRankAggregate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            denseRankAggregate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DENSE_RANK_AGGREGATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            denseRankAggregate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         denseRankAggregate$RuleMemoStart = startIndex;
         denseRankAggregate$RuleMemoEnd = -1;
         denseRankAggregate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DenseRankAnalytic : ("dense_rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean denseRankAnalytic$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DenseRankAnalytic", index);
      }
      if (denseRankAnalytic$RuleMemoStart == index) {
         if (denseRankAnalytic$RuleMemoStart <= denseRankAnalytic$RuleMemoEnd) {
            index = denseRankAnalytic$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DENSE_RANK_ANALYTIC, denseRankAnalytic$RuleMemoStart, denseRankAnalytic$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (denseRankAnalytic$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(denseRankAnalytic$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("dense_rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "dense_rank"
      match = ignoreCaseStringMatcher("dense_rank", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "over"
                           match = ignoreCaseStringMatcher("over", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // QueryPartitionClause?
                                          Node lastNode_1 = currentNode;
                                          int lastIndex_1 = index;
                                          // QueryPartitionClause
                                          match = queryPartitionClause$Rule();
                                          if (! match) {
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             match = true;
                                          }
                                          if (match) {
                                             // OrderByClause
                                             match = orderByClause$Rule();
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         denseRankAnalytic$RuleMemoStart = startIndex;
         denseRankAnalytic$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            denseRankAnalytic$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DENSE_RANK_ANALYTIC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            denseRankAnalytic$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         denseRankAnalytic$RuleMemoStart = startIndex;
         denseRankAnalytic$RuleMemoEnd = -1;
         denseRankAnalytic$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OverQueryPartitionClause : ("over" TestNoAlpha OptionalSpacing QueryPartitionClause)
   protected boolean overQueryPartitionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OverQueryPartitionClause", index);
      }
      startIndex = index;
      // ("over" TestNoAlpha OptionalSpacing QueryPartitionClause)
      // "over"
      match = ignoreCaseStringMatcher("over", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // QueryPartitionClause
               match = queryPartitionClause$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.OVER_QUERY_PARTITION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OverParenthesesQueryPartitionClause : ("over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause ')' OptionalSpacing)
   protected boolean overParenthesesQueryPartitionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OverParenthesesQueryPartitionClause", index);
      }
      if (overParenthesesQueryPartitionClause$RuleMemoStart == index) {
         if (overParenthesesQueryPartitionClause$RuleMemoStart <= overParenthesesQueryPartitionClause$RuleMemoEnd) {
            index = overParenthesesQueryPartitionClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OVER_PARENTHESES_QUERY_PARTITION_CLAUSE, overParenthesesQueryPartitionClause$RuleMemoStart, overParenthesesQueryPartitionClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (overParenthesesQueryPartitionClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(overParenthesesQueryPartitionClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause ')' OptionalSpacing)
      // "over"
      match = ignoreCaseStringMatcher("over", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // QueryPartitionClause
                     match = queryPartitionClause$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         overParenthesesQueryPartitionClause$RuleMemoStart = startIndex;
         overParenthesesQueryPartitionClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            overParenthesesQueryPartitionClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OVER_PARENTHESES_QUERY_PARTITION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            overParenthesesQueryPartitionClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         overParenthesesQueryPartitionClause$RuleMemoStart = startIndex;
         overParenthesesQueryPartitionClause$RuleMemoEnd = -1;
         overParenthesesQueryPartitionClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DenseRankClause : ("keep" TestNoAlpha OptionalSpacing '(' OptionalSpacing "dense_rank" TestNoAlpha OptionalSpacing (("first" | "last") TestNoAlpha OptionalSpacing) OrderByFunctionClause OverQueryPartitionClause? ')' OptionalSpacing)
   protected boolean denseRankClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DenseRankClause", index);
      }
      startIndex = index;
      // ("keep" TestNoAlpha OptionalSpacing '(' OptionalSpacing "dense_rank" TestNoAlpha OptionalSpacing (("first" | "last") TestNoAlpha OptionalSpacing) OrderByFunctionClause OverQueryPartitionClause? ')' OptionalSpacing)
      // "keep"
      match = ignoreCaseStringMatcher("keep", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "dense_rank"
                     match = ignoreCaseStringMatcher("dense_rank", 10);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // (("first" | "last") TestNoAlpha OptionalSpacing)
                              // ("first" | "last")
                              int startIndex_1 = index;
                              switch(buffer.getChar(index)) {
                                 case 'f':
                                 case 'F': {
                                    ++index;
                                    // "irst"
                                    if (match = ignoreCaseStringTest("irst", 4)) {
                                       index += 4;
                                    }
                                    break;
                                 }
                                 case 'l':
                                 case 'L': {
                                    ++index;
                                    // "ast"
                                    if (match = ignoreCaseStringTest("ast", 3)) {
                                       index += 3;
                                    }
                                    break;
                                 }
                                 default: {
                                    match = false;
                                 }
                              }
                              if (! match) {
                                 index = startIndex_1;
                              } else if(! currentRuleIsAtomic) {
                                 currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                                 currentNode = currentNode.getSibling();
                              }
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (match) {
                                 // OrderByFunctionClause
                                 match = orderByFunctionClause$Rule();
                                 if (match) {
                                    // OverQueryPartitionClause?
                                    Node lastNode_2 = currentNode;
                                    int lastIndex_2 = index;
                                    // OverQueryPartitionClause
                                    match = overQueryPartitionClause$Rule();
                                    if (! match) {
                                       lastNode_2.setSibling(null);
                                       currentNode = lastNode_2;
                                       index = lastIndex_2;
                                       match = true;
                                    }
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.DENSE_RANK_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DataToExtract : (("year" | "month" | "day" | "hour" | "minute" | "second" | "timezone_hour" | "timezone_minute" | "timezone_region" | "timezone_abbr") TestNoAlpha OptionalSpacing)
   protected boolean dataToExtract$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DataToExtract", index);
      }
      startIndex = index;
      // (("year" | "month" | "day" | "hour" | "minute" | "second" | "timezone_hour" | "timezone_minute" | "timezone_region" | "timezone_abbr") TestNoAlpha OptionalSpacing)
      // ("year" | "month" | "day" | "hour" | "minute" | "second" | "timezone_hour" | "timezone_minute" | "timezone_region" | "timezone_abbr")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'h':
         case 'H': {
            ++index;
            // "our"
            if (match = ignoreCaseStringTest("our", 3)) {
               index += 3;
            }
            break;
         }
         case 'y':
         case 'Y': {
            ++index;
            // "ear"
            if (match = ignoreCaseStringTest("ear", 3)) {
               index += 3;
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // "econd"
            if (match = ignoreCaseStringTest("econd", 5)) {
               index += 5;
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // "ay"
            if (match = ignoreCaseStringTest("ay", 2)) {
               index += 2;
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // ("imezone_minute" | "imezone_region" | "imezone_hour" | "imezone_abbr")
            match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
            if (match) {
               ++index;
               // ("mezone_minute" | "mezone_region" | "mezone_hour" | "mezone_abbr")
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("ezone_minute" | "ezone_region" | "ezone_hour" | "ezone_abbr")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("zone_minute" | "zone_region" | "zone_hour" | "zone_abbr")
                     match = buffer.matchChar(index, 'z') || buffer.matchChar(index, 'Z');
                     if (match) {
                        ++index;
                        // ("one_minute" | "one_region" | "one_hour" | "one_abbr")
                        match = buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O');
                        if (match) {
                           ++index;
                           // ("ne_minute" | "ne_region" | "ne_hour" | "ne_abbr")
                           match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                           if (match) {
                              ++index;
                              // ("e_minute" | "e_region" | "e_hour" | "e_abbr")
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // ("_minute" | "_region" | "_hour" | "_abbr")
                                 match = buffer.matchChar(index, '_');
                                 if (match) {
                                    ++index;
                                    // ("minute" | "region" | "hour" | "abbr")
                                    switch(buffer.getChar(index)) {
                                       case 'h':
                                       case 'H': {
                                          ++index;
                                          // "our"
                                          if (match = ignoreCaseStringTest("our", 3)) {
                                             index += 3;
                                          }
                                          break;
                                       }
                                       case 'a':
                                       case 'A': {
                                          ++index;
                                          // "bbr"
                                          if (match = ignoreCaseStringTest("bbr", 3)) {
                                             index += 3;
                                          }
                                          break;
                                       }
                                       case 'r':
                                       case 'R': {
                                          ++index;
                                          // "egion"
                                          if (match = ignoreCaseStringTest("egion", 5)) {
                                             index += 5;
                                          }
                                          break;
                                       }
                                       case 'm':
                                       case 'M': {
                                          ++index;
                                          // "inute"
                                          if (match = ignoreCaseStringTest("inute", 5)) {
                                             index += 5;
                                          }
                                          break;
                                       }
                                       default: {
                                          match = false;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // ("inute" | "onth")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "nth"
                  if (match = ignoreCaseStringTest("nth", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "nute"
                  if (match = ignoreCaseStringTest("nute", 4)) {
                     index += 4;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.DATA_TO_EXTRACT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Extract : ("extract" TestNoAlpha OptionalSpacing '(' OptionalSpacing DataToExtract "from" TestNoAlpha OptionalSpacing SqlExpression ')' OptionalSpacing)
   protected boolean extract$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Extract", index);
      }
      if (extract$RuleMemoStart == index) {
         if (extract$RuleMemoStart <= extract$RuleMemoEnd) {
            index = extract$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXTRACT, extract$RuleMemoStart, extract$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (extract$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(extract$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("extract" TestNoAlpha OptionalSpacing '(' OptionalSpacing DataToExtract "from" TestNoAlpha OptionalSpacing SqlExpression ')' OptionalSpacing)
      // "extract"
      match = ignoreCaseStringMatcher("extract", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // DataToExtract
                     match = dataToExtract$Rule();
                     if (match) {
                        // "from"
                        match = ignoreCaseStringMatcher("from", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         extract$RuleMemoStart = startIndex;
         extract$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            extract$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXTRACT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            extract$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         extract$RuleMemoStart = startIndex;
         extract$RuleMemoEnd = -1;
         extract$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FeatureId : ("feature_id" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier MiningAttributeClause ')' OptionalSpacing)
   protected boolean featureId$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FeatureId", index);
      }
      if (featureId$RuleMemoStart == index) {
         if (featureId$RuleMemoStart <= featureId$RuleMemoEnd) {
            index = featureId$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_ID, featureId$RuleMemoStart, featureId$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (featureId$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(featureId$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("feature_id" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier MiningAttributeClause ')' OptionalSpacing)
      // "feature_id"
      match = ignoreCaseStringMatcher("feature_id", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (match) {
                        // MiningAttributeClause
                        match = miningAttributeClause$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         featureId$RuleMemoStart = startIndex;
         featureId$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            featureId$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_ID, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            featureId$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         featureId$RuleMemoStart = startIndex;
         featureId$RuleMemoEnd = -1;
         featureId$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FeatureSet : ("feature_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
   protected boolean featureSet$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FeatureSet", index);
      }
      if (featureSet$RuleMemoStart == index) {
         if (featureSet$RuleMemoStart <= featureSet$RuleMemoEnd) {
            index = featureSet$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_SET, featureSet$RuleMemoStart, featureSet$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (featureSet$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(featureSet$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("feature_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
      // "feature_set"
      match = ignoreCaseStringMatcher("feature_set", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing SqlExpression)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing SqlExpression)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // MiningAttributeClause
                              match = miningAttributeClause$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         featureSet$RuleMemoStart = startIndex;
         featureSet$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            featureSet$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_SET, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            featureSet$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         featureSet$RuleMemoStart = startIndex;
         featureSet$RuleMemoEnd = -1;
         featureSet$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FeatureValue : ("feature_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
   protected boolean featureValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FeatureValue", index);
      }
      if (featureValue$RuleMemoStart == index) {
         if (featureValue$RuleMemoStart <= featureValue$RuleMemoEnd) {
            index = featureValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_VALUE, featureValue$RuleMemoStart, featureValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (featureValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(featureValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("feature_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
      // "feature_value"
      match = ignoreCaseStringMatcher("feature_value", 13);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // MiningAttributeClause
                           match = miningAttributeClause$Rule();
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         featureValue$RuleMemoStart = startIndex;
         featureValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            featureValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FEATURE_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            featureValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         featureValue$RuleMemoStart = startIndex;
         featureValue$RuleMemoEnd = -1;
         featureValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IgnoreNulls : ("ignore" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
   protected boolean ignoreNulls$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IgnoreNulls", index);
      }
      if (ignoreNulls$RuleMemoStart == index) {
         if (ignoreNulls$RuleMemoStart <= ignoreNulls$RuleMemoEnd) {
            index = ignoreNulls$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IGNORE_NULLS, ignoreNulls$RuleMemoStart, ignoreNulls$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ignoreNulls$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ignoreNulls$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("ignore" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
      // "ignore"
      match = ignoreCaseStringMatcher("ignore", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "nulls"
               match = ignoreCaseStringMatcher("nulls", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         ignoreNulls$RuleMemoStart = startIndex;
         ignoreNulls$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreNulls$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IGNORE_NULLS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreNulls$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         ignoreNulls$RuleMemoStart = startIndex;
         ignoreNulls$RuleMemoEnd = -1;
         ignoreNulls$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FirstValue : ("first_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression IgnoreNulls? ')' OptionalSpacing AnalyticOverClause)
   protected boolean firstValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FirstValue", index);
      }
      if (firstValue$RuleMemoStart == index) {
         if (firstValue$RuleMemoStart <= firstValue$RuleMemoEnd) {
            index = firstValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FIRST_VALUE, firstValue$RuleMemoStart, firstValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (firstValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(firstValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("first_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression IgnoreNulls? ')' OptionalSpacing AnalyticOverClause)
      // "first_value"
      match = ignoreCaseStringMatcher("first_value", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // IgnoreNulls?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // IgnoreNulls
                        match = ignoreNulls$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // AnalyticOverClause
                                 match = analyticOverClause$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         firstValue$RuleMemoStart = startIndex;
         firstValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            firstValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FIRST_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            firstValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         firstValue$RuleMemoStart = startIndex;
         firstValue$RuleMemoEnd = -1;
         firstValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Lag : ("lag" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean lag$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Lag", index);
      }
      if (lag$RuleMemoStart == index) {
         if (lag$RuleMemoStart <= lag$RuleMemoEnd) {
            index = lag$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LAG, lag$RuleMemoStart, lag$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lag$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lag$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("lag" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "lag"
      match = ignoreCaseStringMatcher("lag", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing SqlExpression)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing SqlExpression)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "over"
                                    match = ignoreCaseStringMatcher("over", 4);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // '('
                                             match = charMatcher('(');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // QueryPartitionClause?
                                                   Node lastNode_3 = currentNode;
                                                   int lastIndex_3 = index;
                                                   // QueryPartitionClause
                                                   match = queryPartitionClause$Rule();
                                                   if (! match) {
                                                      lastNode_3.setSibling(null);
                                                      currentNode = lastNode_3;
                                                      index = lastIndex_3;
                                                      match = true;
                                                   }
                                                   if (match) {
                                                      // OrderByClause
                                                      match = orderByClause$Rule();
                                                      if (match) {
                                                         // ')'
                                                         match = charMatcher(')');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lag$RuleMemoStart = startIndex;
         lag$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lag$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LAG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lag$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         lag$RuleMemoStart = startIndex;
         lag$RuleMemoEnd = -1;
         lag$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LastValue : ("last_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression IgnoreNulls? ')' OptionalSpacing AnalyticOverClause)
   protected boolean lastValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LastValue", index);
      }
      if (lastValue$RuleMemoStart == index) {
         if (lastValue$RuleMemoStart <= lastValue$RuleMemoEnd) {
            index = lastValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LAST_VALUE, lastValue$RuleMemoStart, lastValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lastValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lastValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("last_value" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression IgnoreNulls? ')' OptionalSpacing AnalyticOverClause)
      // "last_value"
      match = ignoreCaseStringMatcher("last_value", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // IgnoreNulls?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // IgnoreNulls
                        match = ignoreNulls$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // AnalyticOverClause
                                 match = analyticOverClause$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lastValue$RuleMemoStart = startIndex;
         lastValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lastValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LAST_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lastValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         lastValue$RuleMemoStart = startIndex;
         lastValue$RuleMemoEnd = -1;
         lastValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Lead : ("lead" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing IntegerLiteral)? (',' OptionalSpacing IntegerLiteral)? ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean lead$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Lead", index);
      }
      if (lead$RuleMemoStart == index) {
         if (lead$RuleMemoStart <= lead$RuleMemoEnd) {
            index = lead$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LEAD, lead$RuleMemoStart, lead$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lead$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lead$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("lead" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing IntegerLiteral)? (',' OptionalSpacing IntegerLiteral)? ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "lead"
      match = ignoreCaseStringMatcher("lead", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // (',' OptionalSpacing IntegerLiteral)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing IntegerLiteral)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // IntegerLiteral
                              match = integerLiteral$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing IntegerLiteral)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing IntegerLiteral)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // IntegerLiteral
                                 match = integerLiteral$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "over"
                                    match = ignoreCaseStringMatcher("over", 4);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // '('
                                             match = charMatcher('(');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // QueryPartitionClause?
                                                   Node lastNode_3 = currentNode;
                                                   int lastIndex_3 = index;
                                                   // QueryPartitionClause
                                                   match = queryPartitionClause$Rule();
                                                   if (! match) {
                                                      lastNode_3.setSibling(null);
                                                      currentNode = lastNode_3;
                                                      index = lastIndex_3;
                                                      match = true;
                                                   }
                                                   if (match) {
                                                      // OrderByClause
                                                      match = orderByClause$Rule();
                                                      if (match) {
                                                         // ')'
                                                         match = charMatcher(')');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lead$RuleMemoStart = startIndex;
         lead$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lead$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LEAD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lead$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         lead$RuleMemoStart = startIndex;
         lead$RuleMemoEnd = -1;
         lead$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ListAgg : ("listagg" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing StringLiteral)? ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByClause ')' OptionalSpacing OverQueryPartitionClause?)
   protected boolean listAgg$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ListAgg", index);
      }
      if (listAgg$RuleMemoStart == index) {
         if (listAgg$RuleMemoStart <= listAgg$RuleMemoEnd) {
            index = listAgg$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LIST_AGG, listAgg$RuleMemoStart, listAgg$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (listAgg$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(listAgg$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("listagg" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression (',' OptionalSpacing StringLiteral)? ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByClause ')' OptionalSpacing OverQueryPartitionClause?)
      // "listagg"
      match = ignoreCaseStringMatcher("listagg", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // (',' OptionalSpacing StringLiteral)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing StringLiteral)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // StringLiteral
                              match = stringLiteral$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // "within"
                                 match = ignoreCaseStringMatcher("within", 6);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // "group"
                                          match = ignoreCaseStringMatcher("group", 5);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // '('
                                                   match = charMatcher('(');
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // OrderByClause
                                                         match = orderByClause$Rule();
                                                         if (match) {
                                                            // ')'
                                                            match = charMatcher(')');
                                                            if (match) {
                                                               // OptionalSpacing
                                                               match = optionalSpacing$Rule();
                                                               if (match) {
                                                                  // OverQueryPartitionClause?
                                                                  Node lastNode_2 = currentNode;
                                                                  int lastIndex_2 = index;
                                                                  // OverQueryPartitionClause
                                                                  match = overQueryPartitionClause$Rule();
                                                                  if (! match) {
                                                                     lastNode_2.setSibling(null);
                                                                     currentNode = lastNode_2;
                                                                     index = lastIndex_2;
                                                                     match = true;
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         listAgg$RuleMemoStart = startIndex;
         listAgg$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listAgg$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LIST_AGG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listAgg$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         listAgg$RuleMemoStart = startIndex;
         listAgg$RuleMemoEnd = -1;
         listAgg$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Max : ("max" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean max$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Max", index);
      }
      if (max$RuleMemoStart == index) {
         if (max$RuleMemoStart <= max$RuleMemoEnd) {
            index = max$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MAX, max$RuleMemoStart, max$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (max$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(max$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("max" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "max"
      match = ignoreCaseStringMatcher("max", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         max$RuleMemoStart = startIndex;
         max$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            max$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MAX, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            max$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         max$RuleMemoStart = startIndex;
         max$RuleMemoEnd = -1;
         max$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Median : ("median" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
   protected boolean median$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Median", index);
      }
      if (median$RuleMemoStart == index) {
         if (median$RuleMemoStart <= median$RuleMemoEnd) {
            index = median$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MEDIAN, median$RuleMemoStart, median$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (median$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(median$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("median" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
      // "median"
      match = ignoreCaseStringMatcher("median", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // OverParenthesesQueryPartitionClause?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // OverParenthesesQueryPartitionClause
                              match = overParenthesesQueryPartitionClause$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         median$RuleMemoStart = startIndex;
         median$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            median$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MEDIAN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            median$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         median$RuleMemoStart = startIndex;
         median$RuleMemoEnd = -1;
         median$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Min : ("min" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean min$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Min", index);
      }
      if (min$RuleMemoStart == index) {
         if (min$RuleMemoStart <= min$RuleMemoEnd) {
            index = min$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MIN, min$RuleMemoStart, min$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (min$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(min$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("min" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "min"
      match = ignoreCaseStringMatcher("min", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         min$RuleMemoStart = startIndex;
         min$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            min$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            min$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         min$RuleMemoStart = startIndex;
         min$RuleMemoEnd = -1;
         min$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NTile : ("ntile" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean nTile$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NTile", index);
      }
      if (nTile$RuleMemoStart == index) {
         if (nTile$RuleMemoStart <= nTile$RuleMemoEnd) {
            index = nTile$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NTILE, nTile$RuleMemoStart, nTile$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nTile$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nTile$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("ntile" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "ntile"
      match = ignoreCaseStringMatcher("ntile", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "over"
                              match = ignoreCaseStringMatcher("over", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // '('
                                       match = charMatcher('(');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // QueryPartitionClause?
                                             Node lastNode_1 = currentNode;
                                             int lastIndex_1 = index;
                                             // QueryPartitionClause
                                             match = queryPartitionClause$Rule();
                                             if (! match) {
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                index = lastIndex_1;
                                                match = true;
                                             }
                                             if (match) {
                                                // OrderByClause
                                                match = orderByClause$Rule();
                                                if (match) {
                                                   // ')'
                                                   match = charMatcher(')');
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         nTile$RuleMemoStart = startIndex;
         nTile$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nTile$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NTILE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nTile$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nTile$RuleMemoStart = startIndex;
         nTile$RuleMemoEnd = -1;
         nTile$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PercentRankAggregate : ("percent_rank" TestNoAlpha OptionalSpacing SqlParameters "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
   protected boolean percentRankAggregate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PercentRankAggregate", index);
      }
      if (percentRankAggregate$RuleMemoStart == index) {
         if (percentRankAggregate$RuleMemoStart <= percentRankAggregate$RuleMemoEnd) {
            index = percentRankAggregate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PERCENT_RANK_AGGREGATE, percentRankAggregate$RuleMemoStart, percentRankAggregate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (percentRankAggregate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(percentRankAggregate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("percent_rank" TestNoAlpha OptionalSpacing SqlParameters "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
      // "percent_rank"
      match = ignoreCaseStringMatcher("percent_rank", 12);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlParameters
               match = sqlParameters$Rule();
               if (match) {
                  // "within"
                  match = ignoreCaseStringMatcher("within", 6);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "group"
                           match = ignoreCaseStringMatcher("group", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // OrderByFunctionClause
                                          match = orderByFunctionClause$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         percentRankAggregate$RuleMemoStart = startIndex;
         percentRankAggregate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            percentRankAggregate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PERCENT_RANK_AGGREGATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            percentRankAggregate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         percentRankAggregate$RuleMemoStart = startIndex;
         percentRankAggregate$RuleMemoEnd = -1;
         percentRankAggregate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PercentRankAnalytic : ("percent_rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean percentRankAnalytic$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PercentRankAnalytic", index);
      }
      if (percentRankAnalytic$RuleMemoStart == index) {
         if (percentRankAnalytic$RuleMemoStart <= percentRankAnalytic$RuleMemoEnd) {
            index = percentRankAnalytic$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PERCENT_RANK_ANALYTIC, percentRankAnalytic$RuleMemoStart, percentRankAnalytic$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (percentRankAnalytic$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(percentRankAnalytic$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("percent_rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "percent_rank"
      match = ignoreCaseStringMatcher("percent_rank", 12);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "over"
                           match = ignoreCaseStringMatcher("over", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // QueryPartitionClause?
                                          Node lastNode_1 = currentNode;
                                          int lastIndex_1 = index;
                                          // QueryPartitionClause
                                          match = queryPartitionClause$Rule();
                                          if (! match) {
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             match = true;
                                          }
                                          if (match) {
                                             // OrderByClause
                                             match = orderByClause$Rule();
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         percentRankAnalytic$RuleMemoStart = startIndex;
         percentRankAnalytic$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            percentRankAnalytic$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PERCENT_RANK_ANALYTIC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            percentRankAnalytic$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         percentRankAnalytic$RuleMemoStart = startIndex;
         percentRankAnalytic$RuleMemoEnd = -1;
         percentRankAnalytic$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PercentileCont : ("percentile_cont" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing "order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpression (("asc" | "desc") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
   protected boolean percentileCont$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PercentileCont", index);
      }
      if (percentileCont$RuleMemoStart == index) {
         if (percentileCont$RuleMemoStart <= percentileCont$RuleMemoEnd) {
            index = percentileCont$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PERCENTILE_CONT, percentileCont$RuleMemoStart, percentileCont$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (percentileCont$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(percentileCont$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("percentile_cont" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing "order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpression (("asc" | "desc") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
      // "percentile_cont"
      match = ignoreCaseStringMatcher("percentile_cont", 15);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "within"
                              match = ignoreCaseStringMatcher("within", 6);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "group"
                                       match = ignoreCaseStringMatcher("group", 5);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // '('
                                                match = charMatcher('(');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                   if (match) {
                                                      // "order"
                                                      match = ignoreCaseStringMatcher("order", 5);
                                                      if (match) {
                                                         // TestNoAlpha
                                                         match = testNoAlpha$Rule();
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // "by"
                                                               match = ignoreCaseStringMatcher("by", 2);
                                                               if (match) {
                                                                  // TestNoAlpha
                                                                  match = testNoAlpha$Rule();
                                                                  if (match) {
                                                                     // OptionalSpacing
                                                                     match = optionalSpacing$Rule();
                                                                     if (match) {
                                                                        // SqlExpression
                                                                        match = sqlExpression$Rule();
                                                                        if (match) {
                                                                           // (("asc" | "desc") TestNoAlpha OptionalSpacing)?
                                                                           Node lastNode_1 = currentNode;
                                                                           int lastIndex_1 = index;
                                                                           // (("asc" | "desc") TestNoAlpha OptionalSpacing)
                                                                           // ("asc" | "desc")
                                                                           int startIndex_2 = index;
                                                                           switch(buffer.getChar(index)) {
                                                                              case 'a':
                                                                              case 'A': {
                                                                                 ++index;
                                                                                 // "sc"
                                                                                 if (match = ignoreCaseStringTest("sc", 2)) {
                                                                                    index += 2;
                                                                                 }
                                                                                 break;
                                                                              }
                                                                              case 'd':
                                                                              case 'D': {
                                                                                 ++index;
                                                                                 // "esc"
                                                                                 if (match = ignoreCaseStringTest("esc", 3)) {
                                                                                    index += 3;
                                                                                 }
                                                                                 break;
                                                                              }
                                                                              default: {
                                                                                 match = false;
                                                                              }
                                                                           }
                                                                           if (! match) {
                                                                              index = startIndex_2;
                                                                           } else if(! currentRuleIsAtomic) {
                                                                              currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                                                                              currentNode = currentNode.getSibling();
                                                                           }
                                                                           if (match) {
                                                                              // TestNoAlpha
                                                                              match = testNoAlpha$Rule();
                                                                              if (match) {
                                                                                 // OptionalSpacing
                                                                                 match = optionalSpacing$Rule();
                                                                              }
                                                                           }
                                                                           if (! match) {
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              index = lastIndex_1;
                                                                              match = true;
                                                                           }
                                                                           if (match) {
                                                                              // ')'
                                                                              match = charMatcher(')');
                                                                              if (match) {
                                                                                 // OptionalSpacing
                                                                                 match = optionalSpacing$Rule();
                                                                                 if (match) {
                                                                                    // OverParenthesesQueryPartitionClause?
                                                                                    Node lastNode_3 = currentNode;
                                                                                    int lastIndex_3 = index;
                                                                                    // OverParenthesesQueryPartitionClause
                                                                                    match = overParenthesesQueryPartitionClause$Rule();
                                                                                    if (! match) {
                                                                                       lastNode_3.setSibling(null);
                                                                                       currentNode = lastNode_3;
                                                                                       index = lastIndex_3;
                                                                                       match = true;
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         percentileCont$RuleMemoStart = startIndex;
         percentileCont$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            percentileCont$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PERCENTILE_CONT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            percentileCont$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         percentileCont$RuleMemoStart = startIndex;
         percentileCont$RuleMemoEnd = -1;
         percentileCont$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PercentileDisc : ("percentile_disc" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing "order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpression (("asc" | "desc") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
   protected boolean percentileDisc$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PercentileDisc", index);
      }
      if (percentileDisc$RuleMemoStart == index) {
         if (percentileDisc$RuleMemoStart <= percentileDisc$RuleMemoEnd) {
            index = percentileDisc$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PERCENTILE_DISC, percentileDisc$RuleMemoStart, percentileDisc$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (percentileDisc$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(percentileDisc$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("percentile_disc" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing "order" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpression (("asc" | "desc") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing OverParenthesesQueryPartitionClause?)
      // "percentile_disc"
      match = ignoreCaseStringMatcher("percentile_disc", 15);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "within"
                              match = ignoreCaseStringMatcher("within", 6);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "group"
                                       match = ignoreCaseStringMatcher("group", 5);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // '('
                                                match = charMatcher('(');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                   if (match) {
                                                      // "order"
                                                      match = ignoreCaseStringMatcher("order", 5);
                                                      if (match) {
                                                         // TestNoAlpha
                                                         match = testNoAlpha$Rule();
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // "by"
                                                               match = ignoreCaseStringMatcher("by", 2);
                                                               if (match) {
                                                                  // TestNoAlpha
                                                                  match = testNoAlpha$Rule();
                                                                  if (match) {
                                                                     // OptionalSpacing
                                                                     match = optionalSpacing$Rule();
                                                                     if (match) {
                                                                        // SqlExpression
                                                                        match = sqlExpression$Rule();
                                                                        if (match) {
                                                                           // (("asc" | "desc") TestNoAlpha OptionalSpacing)?
                                                                           Node lastNode_1 = currentNode;
                                                                           int lastIndex_1 = index;
                                                                           // (("asc" | "desc") TestNoAlpha OptionalSpacing)
                                                                           // ("asc" | "desc")
                                                                           int startIndex_2 = index;
                                                                           switch(buffer.getChar(index)) {
                                                                              case 'a':
                                                                              case 'A': {
                                                                                 ++index;
                                                                                 // "sc"
                                                                                 if (match = ignoreCaseStringTest("sc", 2)) {
                                                                                    index += 2;
                                                                                 }
                                                                                 break;
                                                                              }
                                                                              case 'd':
                                                                              case 'D': {
                                                                                 ++index;
                                                                                 // "esc"
                                                                                 if (match = ignoreCaseStringTest("esc", 3)) {
                                                                                    index += 3;
                                                                                 }
                                                                                 break;
                                                                              }
                                                                              default: {
                                                                                 match = false;
                                                                              }
                                                                           }
                                                                           if (! match) {
                                                                              index = startIndex_2;
                                                                           } else if(! currentRuleIsAtomic) {
                                                                              currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                                                                              currentNode = currentNode.getSibling();
                                                                           }
                                                                           if (match) {
                                                                              // TestNoAlpha
                                                                              match = testNoAlpha$Rule();
                                                                              if (match) {
                                                                                 // OptionalSpacing
                                                                                 match = optionalSpacing$Rule();
                                                                              }
                                                                           }
                                                                           if (! match) {
                                                                              lastNode_1.setSibling(null);
                                                                              currentNode = lastNode_1;
                                                                              index = lastIndex_1;
                                                                              match = true;
                                                                           }
                                                                           if (match) {
                                                                              // ')'
                                                                              match = charMatcher(')');
                                                                              if (match) {
                                                                                 // OptionalSpacing
                                                                                 match = optionalSpacing$Rule();
                                                                                 if (match) {
                                                                                    // OverParenthesesQueryPartitionClause?
                                                                                    Node lastNode_3 = currentNode;
                                                                                    int lastIndex_3 = index;
                                                                                    // OverParenthesesQueryPartitionClause
                                                                                    match = overParenthesesQueryPartitionClause$Rule();
                                                                                    if (! match) {
                                                                                       lastNode_3.setSibling(null);
                                                                                       currentNode = lastNode_3;
                                                                                       index = lastIndex_3;
                                                                                       match = true;
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         percentileDisc$RuleMemoStart = startIndex;
         percentileDisc$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            percentileDisc$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PERCENTILE_DISC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            percentileDisc$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         percentileDisc$RuleMemoStart = startIndex;
         percentileDisc$RuleMemoEnd = -1;
         percentileDisc$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CostMatrixClauseValues : ('(' OptionalSpacing SqlExpressionList ')' OptionalSpacing "values" TestNoAlpha OptionalSpacing '(' OptionalSpacing ParenthesesSqlExpressionList ')' OptionalSpacing)
   protected boolean costMatrixClauseValues$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CostMatrixClauseValues", index);
      }
      if (costMatrixClauseValues$RuleMemoStart == index) {
         if (costMatrixClauseValues$RuleMemoStart <= costMatrixClauseValues$RuleMemoEnd) {
            index = costMatrixClauseValues$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE_VALUES, costMatrixClauseValues$RuleMemoStart, costMatrixClauseValues$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (costMatrixClauseValues$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(costMatrixClauseValues$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlExpressionList ')' OptionalSpacing "values" TestNoAlpha OptionalSpacing '(' OptionalSpacing ParenthesesSqlExpressionList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlExpressionList
            match = sqlExpressionList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "values"
                     match = ignoreCaseStringMatcher("values", 6);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '('
                              match = charMatcher('(');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // ParenthesesSqlExpressionList
                                    match = parenthesesSqlExpressionList$Rule();
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         costMatrixClauseValues$RuleMemoStart = startIndex;
         costMatrixClauseValues$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            costMatrixClauseValues$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE_VALUES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            costMatrixClauseValues$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         costMatrixClauseValues$RuleMemoStart = startIndex;
         costMatrixClauseValues$RuleMemoEnd = -1;
         costMatrixClauseValues$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CostMatrixClauseModel : ("model" TestNoAlpha OptionalSpacing ("auto" TestNoAlpha OptionalSpacing)? "Auto" TestNoAlpha OptionalSpacing)
   protected boolean costMatrixClauseModel$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CostMatrixClauseModel", index);
      }
      if (costMatrixClauseModel$RuleMemoStart == index) {
         if (costMatrixClauseModel$RuleMemoStart <= costMatrixClauseModel$RuleMemoEnd) {
            index = costMatrixClauseModel$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE_MODEL, costMatrixClauseModel$RuleMemoStart, costMatrixClauseModel$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (costMatrixClauseModel$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(costMatrixClauseModel$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("model" TestNoAlpha OptionalSpacing ("auto" TestNoAlpha OptionalSpacing)? "Auto" TestNoAlpha OptionalSpacing)
      // "model"
      match = ignoreCaseStringMatcher("model", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("auto" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("auto" TestNoAlpha OptionalSpacing)
               // "auto"
               match = ignoreCaseStringMatcher("auto", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // "Auto"
                  match = ignoreCaseStringMatcher("Auto", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         costMatrixClauseModel$RuleMemoStart = startIndex;
         costMatrixClauseModel$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            costMatrixClauseModel$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE_MODEL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            costMatrixClauseModel$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         costMatrixClauseModel$RuleMemoStart = startIndex;
         costMatrixClauseModel$RuleMemoEnd = -1;
         costMatrixClauseModel$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CostMatrixClause : ("cost" TestNoAlpha OptionalSpacing (CostMatrixClauseModel | CostMatrixClauseValues))
   protected boolean costMatrixClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CostMatrixClause", index);
      }
      if (costMatrixClause$RuleMemoStart == index) {
         if (costMatrixClause$RuleMemoStart <= costMatrixClause$RuleMemoEnd) {
            index = costMatrixClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE, costMatrixClause$RuleMemoStart, costMatrixClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (costMatrixClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(costMatrixClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cost" TestNoAlpha OptionalSpacing (CostMatrixClauseModel | CostMatrixClauseValues))
      // "cost"
      match = ignoreCaseStringMatcher("cost", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (CostMatrixClauseModel | CostMatrixClauseValues)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case 'm':
                  case 'M': {
                     // CostMatrixClauseModel
                     match = costMatrixClauseModel$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case '(': {
                     // CostMatrixClauseValues
                     match = costMatrixClauseValues$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         costMatrixClause$RuleMemoStart = startIndex;
         costMatrixClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            costMatrixClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COST_MATRIX_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            costMatrixClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         costMatrixClause$RuleMemoStart = startIndex;
         costMatrixClause$RuleMemoEnd = -1;
         costMatrixClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Prediction : ("prediction" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName CostMatrixClause? MiningAttributeClause ')' OptionalSpacing)
   protected boolean prediction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Prediction", index);
      }
      if (prediction$RuleMemoStart == index) {
         if (prediction$RuleMemoStart <= prediction$RuleMemoEnd) {
            index = prediction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION, prediction$RuleMemoStart, prediction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (prediction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(prediction$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName CostMatrixClause? MiningAttributeClause ')' OptionalSpacing)
      // "prediction"
      match = ignoreCaseStringMatcher("prediction", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // CostMatrixClause?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // CostMatrixClause
                        match = costMatrixClause$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // MiningAttributeClause
                           match = miningAttributeClause$Rule();
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         prediction$RuleMemoStart = startIndex;
         prediction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            prediction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            prediction$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         prediction$RuleMemoStart = startIndex;
         prediction$RuleMemoEnd = -1;
         prediction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PredictionBounds : ("prediction_bounds" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
   protected boolean predictionBounds$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PredictionBounds", index);
      }
      if (predictionBounds$RuleMemoStart == index) {
         if (predictionBounds$RuleMemoStart <= predictionBounds$RuleMemoEnd) {
            index = predictionBounds$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_BOUNDS, predictionBounds$RuleMemoStart, predictionBounds$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (predictionBounds$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(predictionBounds$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction_bounds" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? MiningAttributeClause ')' OptionalSpacing)
      // "prediction_bounds"
      match = ignoreCaseStringMatcher("prediction_bounds", 17);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing SqlExpression)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing SqlExpression)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // MiningAttributeClause
                              match = miningAttributeClause$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         predictionBounds$RuleMemoStart = startIndex;
         predictionBounds$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            predictionBounds$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_BOUNDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            predictionBounds$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         predictionBounds$RuleMemoStart = startIndex;
         predictionBounds$RuleMemoEnd = -1;
         predictionBounds$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PredictionCost : ("prediction_cost" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? CostMatrixClause MiningAttributeClause ')' OptionalSpacing)
   protected boolean predictionCost$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PredictionCost", index);
      }
      if (predictionCost$RuleMemoStart == index) {
         if (predictionCost$RuleMemoStart <= predictionCost$RuleMemoEnd) {
            index = predictionCost$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_COST, predictionCost$RuleMemoStart, predictionCost$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (predictionCost$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(predictionCost$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction_cost" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? CostMatrixClause MiningAttributeClause ')' OptionalSpacing)
      // "prediction_cost"
      match = ignoreCaseStringMatcher("prediction_cost", 15);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // CostMatrixClause
                           match = costMatrixClause$Rule();
                           if (match) {
                              // MiningAttributeClause
                              match = miningAttributeClause$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         predictionCost$RuleMemoStart = startIndex;
         predictionCost$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            predictionCost$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_COST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            predictionCost$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         predictionCost$RuleMemoStart = startIndex;
         predictionCost$RuleMemoEnd = -1;
         predictionCost$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PredictionDetails : ("prediction_details" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
   protected boolean predictionDetails$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PredictionDetails", index);
      }
      if (predictionDetails$RuleMemoStart == index) {
         if (predictionDetails$RuleMemoStart <= predictionDetails$RuleMemoEnd) {
            index = predictionDetails$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_DETAILS, predictionDetails$RuleMemoStart, predictionDetails$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (predictionDetails$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(predictionDetails$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction_details" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
      // "prediction_details"
      match = ignoreCaseStringMatcher("prediction_details", 18);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // MiningAttributeClause
                        match = miningAttributeClause$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         predictionDetails$RuleMemoStart = startIndex;
         predictionDetails$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            predictionDetails$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_DETAILS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            predictionDetails$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         predictionDetails$RuleMemoStart = startIndex;
         predictionDetails$RuleMemoEnd = -1;
         predictionDetails$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PredictionProbability : ("prediction_probability" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
   protected boolean predictionProbability$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PredictionProbability", index);
      }
      if (predictionProbability$RuleMemoStart == index) {
         if (predictionProbability$RuleMemoStart <= predictionProbability$RuleMemoEnd) {
            index = predictionProbability$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_PROBABILITY, predictionProbability$RuleMemoStart, predictionProbability$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (predictionProbability$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(predictionProbability$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction_probability" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName MiningAttributeClause ')' OptionalSpacing)
      // "prediction_probability"
      match = ignoreCaseStringMatcher("prediction_probability", 22);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // MiningAttributeClause
                        match = miningAttributeClause$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         predictionProbability$RuleMemoStart = startIndex;
         predictionProbability$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            predictionProbability$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_PROBABILITY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            predictionProbability$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         predictionProbability$RuleMemoStart = startIndex;
         predictionProbability$RuleMemoEnd = -1;
         predictionProbability$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PredictionSet : ("prediction_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? CostMatrixClause? MiningAttributeClause ')' OptionalSpacing)
   protected boolean predictionSet$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PredictionSet", index);
      }
      if (predictionSet$RuleMemoStart == index) {
         if (predictionSet$RuleMemoStart <= predictionSet$RuleMemoEnd) {
            index = predictionSet$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_SET, predictionSet$RuleMemoStart, predictionSet$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (predictionSet$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(predictionSet$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prediction_set" TestNoAlpha OptionalSpacing '(' OptionalSpacing SchemaObjectName (',' OptionalSpacing SqlExpression)? (',' OptionalSpacing SqlExpression)? CostMatrixClause? MiningAttributeClause ')' OptionalSpacing)
      // "prediction_set"
      match = ignoreCaseStringMatcher("prediction_set", 14);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SchemaObjectName
                     match = schemaObjectName$Rule();
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // (',' OptionalSpacing SqlExpression)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // (',' OptionalSpacing SqlExpression)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // CostMatrixClause?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // CostMatrixClause
                              match = costMatrixClause$Rule();
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                              if (match) {
                                 // MiningAttributeClause
                                 match = miningAttributeClause$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         predictionSet$RuleMemoStart = startIndex;
         predictionSet$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            predictionSet$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PREDICTION_SET, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            predictionSet$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         predictionSet$RuleMemoStart = startIndex;
         predictionSet$RuleMemoEnd = -1;
         predictionSet$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RankAggregate : ("rank" TestNoAlpha OptionalSpacing SqlParameters "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
   protected boolean rankAggregate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RankAggregate", index);
      }
      if (rankAggregate$RuleMemoStart == index) {
         if (rankAggregate$RuleMemoStart <= rankAggregate$RuleMemoEnd) {
            index = rankAggregate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RANK_AGGREGATE, rankAggregate$RuleMemoStart, rankAggregate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rankAggregate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rankAggregate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("rank" TestNoAlpha OptionalSpacing SqlParameters "within" TestNoAlpha OptionalSpacing "group" TestNoAlpha OptionalSpacing '(' OptionalSpacing OrderByFunctionClause ')' OptionalSpacing)
      // "rank"
      match = ignoreCaseStringMatcher("rank", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlParameters
               match = sqlParameters$Rule();
               if (match) {
                  // "within"
                  match = ignoreCaseStringMatcher("within", 6);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "group"
                           match = ignoreCaseStringMatcher("group", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // OrderByFunctionClause
                                          match = orderByFunctionClause$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         rankAggregate$RuleMemoStart = startIndex;
         rankAggregate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rankAggregate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RANK_AGGREGATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rankAggregate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rankAggregate$RuleMemoStart = startIndex;
         rankAggregate$RuleMemoEnd = -1;
         rankAggregate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RankAnalytic : ("rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean rankAnalytic$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RankAnalytic", index);
      }
      if (rankAnalytic$RuleMemoStart == index) {
         if (rankAnalytic$RuleMemoStart <= rankAnalytic$RuleMemoEnd) {
            index = rankAnalytic$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RANK_ANALYTIC, rankAnalytic$RuleMemoStart, rankAnalytic$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rankAnalytic$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rankAnalytic$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("rank" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "rank"
      match = ignoreCaseStringMatcher("rank", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "over"
                           match = ignoreCaseStringMatcher("over", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // QueryPartitionClause?
                                          Node lastNode_1 = currentNode;
                                          int lastIndex_1 = index;
                                          // QueryPartitionClause
                                          match = queryPartitionClause$Rule();
                                          if (! match) {
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             match = true;
                                          }
                                          if (match) {
                                             // OrderByClause
                                             match = orderByClause$Rule();
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         rankAnalytic$RuleMemoStart = startIndex;
         rankAnalytic$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rankAnalytic$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RANK_ANALYTIC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rankAnalytic$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rankAnalytic$RuleMemoStart = startIndex;
         rankAnalytic$RuleMemoEnd = -1;
         rankAnalytic$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RatioToReport : ("ratio_to_report" TestNoAlpha OptionalSpacing ParenthesesSqlExpression "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? ')' OptionalSpacing)
   protected boolean ratioToReport$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RatioToReport", index);
      }
      if (ratioToReport$RuleMemoStart == index) {
         if (ratioToReport$RuleMemoStart <= ratioToReport$RuleMemoEnd) {
            index = ratioToReport$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RATIO_TO_REPORT, ratioToReport$RuleMemoStart, ratioToReport$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ratioToReport$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ratioToReport$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("ratio_to_report" TestNoAlpha OptionalSpacing ParenthesesSqlExpression "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? ')' OptionalSpacing)
      // "ratio_to_report"
      match = ignoreCaseStringMatcher("ratio_to_report", 15);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ParenthesesSqlExpression
               match = parenthesesSqlExpression$Rule();
               if (match) {
                  // "over"
                  match = ignoreCaseStringMatcher("over", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '('
                           match = charMatcher('(');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // QueryPartitionClause?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // QueryPartitionClause
                                 match = queryPartitionClause$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         ratioToReport$RuleMemoStart = startIndex;
         ratioToReport$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ratioToReport$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RATIO_TO_REPORT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ratioToReport$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         ratioToReport$RuleMemoStart = startIndex;
         ratioToReport$RuleMemoEnd = -1;
         ratioToReport$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RegrLinearFunctions : ((("regr_avg" TestNoAlpha OptionalSpacing) | ("regr_intercept" TestNoAlpha OptionalSpacing) | ("regr_count" TestNoAlpha OptionalSpacing) | ("regr_r2" OptionalSpacing) | ("regr_avgx" TestNoAlpha OptionalSpacing) | ("regr_avgy" TestNoAlpha OptionalSpacing) | ("regr_sxx" TestNoAlpha OptionalSpacing) | ("regr_syy" TestNoAlpha OptionalSpacing) | ("regr_sxy" TestNoAlpha OptionalSpacing)) "FunctionName" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean regrLinearFunctions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RegrLinearFunctions", index);
      }
      if (regrLinearFunctions$RuleMemoStart == index) {
         if (regrLinearFunctions$RuleMemoStart <= regrLinearFunctions$RuleMemoEnd) {
            index = regrLinearFunctions$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.REGR_LINEAR_FUNCTIONS, regrLinearFunctions$RuleMemoStart, regrLinearFunctions$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (regrLinearFunctions$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(regrLinearFunctions$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("regr_avg" TestNoAlpha OptionalSpacing) | ("regr_intercept" TestNoAlpha OptionalSpacing) | ("regr_count" TestNoAlpha OptionalSpacing) | ("regr_r2" OptionalSpacing) | ("regr_avgx" TestNoAlpha OptionalSpacing) | ("regr_avgy" TestNoAlpha OptionalSpacing) | ("regr_sxx" TestNoAlpha OptionalSpacing) | ("regr_syy" TestNoAlpha OptionalSpacing) | ("regr_sxy" TestNoAlpha OptionalSpacing)) "FunctionName" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // (("regr_avg" TestNoAlpha OptionalSpacing) | ("regr_intercept" TestNoAlpha OptionalSpacing) | ("regr_count" TestNoAlpha OptionalSpacing) | ("regr_r2" OptionalSpacing) | ("regr_avgx" TestNoAlpha OptionalSpacing) | ("regr_avgy" TestNoAlpha OptionalSpacing) | ("regr_sxx" TestNoAlpha OptionalSpacing) | ("regr_syy" TestNoAlpha OptionalSpacing) | ("regr_sxy" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("regr_avg" TestNoAlpha OptionalSpacing)
      // "regr_avg"
      match = ignoreCaseStringMatcher("regr_avg", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("regr_intercept" TestNoAlpha OptionalSpacing)
         // "regr_intercept"
         match = ignoreCaseStringMatcher("regr_intercept", 14);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("regr_count" TestNoAlpha OptionalSpacing)
            // "regr_count"
            match = ignoreCaseStringMatcher("regr_count", 10);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("regr_r2" OptionalSpacing)
               // "regr_r2"
               match = ignoreCaseStringMatcher("regr_r2", 7);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("regr_avgx" TestNoAlpha OptionalSpacing)
                  // "regr_avgx"
                  match = ignoreCaseStringMatcher("regr_avgx", 9);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("regr_avgy" TestNoAlpha OptionalSpacing)
                     // "regr_avgy"
                     match = ignoreCaseStringMatcher("regr_avgy", 9);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("regr_sxx" TestNoAlpha OptionalSpacing)
                        // "regr_sxx"
                        match = ignoreCaseStringMatcher("regr_sxx", 8);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("regr_syy" TestNoAlpha OptionalSpacing)
                           // "regr_syy"
                           match = ignoreCaseStringMatcher("regr_syy", 8);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ("regr_sxy" TestNoAlpha OptionalSpacing)
                              // "regr_sxy"
                              match = ignoreCaseStringMatcher("regr_sxy", 8);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         // "FunctionName"
         match = ignoreCaseStringMatcher("FunctionName", 12);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // AnalyticOverClause?
                                          Node lastNode_2 = currentNode;
                                          int lastIndex_2 = index;
                                          // AnalyticOverClause
                                          match = analyticOverClause$Rule();
                                          if (! match) {
                                             lastNode_2.setSibling(null);
                                             currentNode = lastNode_2;
                                             index = lastIndex_2;
                                             match = true;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         regrLinearFunctions$RuleMemoStart = startIndex;
         regrLinearFunctions$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            regrLinearFunctions$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.REGR_LINEAR_FUNCTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            regrLinearFunctions$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         regrLinearFunctions$RuleMemoStart = startIndex;
         regrLinearFunctions$RuleMemoEnd = -1;
         regrLinearFunctions$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RowNumber : ("row_number" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
   protected boolean rowNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RowNumber", index);
      }
      if (rowNumber$RuleMemoStart == index) {
         if (rowNumber$RuleMemoStart <= rowNumber$RuleMemoEnd) {
            index = rowNumber$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROW_NUMBER, rowNumber$RuleMemoStart, rowNumber$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rowNumber$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rowNumber$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("row_number" TestNoAlpha OptionalSpacing '(' OptionalSpacing ')' OptionalSpacing "over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? OrderByClause ')' OptionalSpacing)
      // "row_number"
      match = ignoreCaseStringMatcher("row_number", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "over"
                           match = ignoreCaseStringMatcher("over", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // QueryPartitionClause?
                                          Node lastNode_1 = currentNode;
                                          int lastIndex_1 = index;
                                          // QueryPartitionClause
                                          match = queryPartitionClause$Rule();
                                          if (! match) {
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             match = true;
                                          }
                                          if (match) {
                                             // OrderByClause
                                             match = orderByClause$Rule();
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         rowNumber$RuleMemoStart = startIndex;
         rowNumber$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rowNumber$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROW_NUMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rowNumber$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rowNumber$RuleMemoStart = startIndex;
         rowNumber$RuleMemoEnd = -1;
         rowNumber$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StdDev : ("stddev" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean stdDev$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StdDev", index);
      }
      if (stdDev$RuleMemoStart == index) {
         if (stdDev$RuleMemoStart <= stdDev$RuleMemoEnd) {
            index = stdDev$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV, stdDev$RuleMemoStart, stdDev$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (stdDev$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stdDev$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("stddev" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "stddev"
      match = ignoreCaseStringMatcher("stddev", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         stdDev$RuleMemoStart = startIndex;
         stdDev$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdDev$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdDev$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         stdDev$RuleMemoStart = startIndex;
         stdDev$RuleMemoEnd = -1;
         stdDev$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StdDevPop : ("stddev_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean stdDevPop$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StdDevPop", index);
      }
      if (stdDevPop$RuleMemoStart == index) {
         if (stdDevPop$RuleMemoStart <= stdDevPop$RuleMemoEnd) {
            index = stdDevPop$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV_POP, stdDevPop$RuleMemoStart, stdDevPop$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (stdDevPop$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stdDevPop$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("stddev_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "stddev_pop"
      match = ignoreCaseStringMatcher("stddev_pop", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         stdDevPop$RuleMemoStart = startIndex;
         stdDevPop$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdDevPop$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV_POP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdDevPop$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         stdDevPop$RuleMemoStart = startIndex;
         stdDevPop$RuleMemoEnd = -1;
         stdDevPop$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StdDevSamp : ("stddev_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean stdDevSamp$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StdDevSamp", index);
      }
      if (stdDevSamp$RuleMemoStart == index) {
         if (stdDevSamp$RuleMemoStart <= stdDevSamp$RuleMemoEnd) {
            index = stdDevSamp$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV_SAMP, stdDevSamp$RuleMemoStart, stdDevSamp$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (stdDevSamp$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stdDevSamp$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("stddev_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "stddev_samp"
      match = ignoreCaseStringMatcher("stddev_samp", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         stdDevSamp$RuleMemoStart = startIndex;
         stdDevSamp$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdDevSamp$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.STD_DEV_SAMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdDevSamp$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         stdDevSamp$RuleMemoStart = startIndex;
         stdDevSamp$RuleMemoEnd = -1;
         stdDevSamp$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Sum : ("sum" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean sum$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Sum", index);
      }
      if (sum$RuleMemoStart == index) {
         if (sum$RuleMemoStart <= sum$RuleMemoEnd) {
            index = sum$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUM, sum$RuleMemoStart, sum$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sum$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sum$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("sum" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "sum"
      match = ignoreCaseStringMatcher("sum", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         sum$RuleMemoStart = startIndex;
         sum$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sum$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sum$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sum$RuleMemoStart = startIndex;
         sum$RuleMemoEnd = -1;
         sum$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Translate : ("translate" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "using" TestNoAlpha OptionalSpacing (("char_cs" | "nchar_cs") TestNoAlpha OptionalSpacing) "CharType" TestNoAlpha OptionalSpacing ')' OptionalSpacing)
   protected boolean translate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Translate", index);
      }
      if (translate$RuleMemoStart == index) {
         if (translate$RuleMemoStart <= translate$RuleMemoEnd) {
            index = translate$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TRANSLATE, translate$RuleMemoStart, translate$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (translate$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(translate$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("translate" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "using" TestNoAlpha OptionalSpacing (("char_cs" | "nchar_cs") TestNoAlpha OptionalSpacing) "CharType" TestNoAlpha OptionalSpacing ')' OptionalSpacing)
      // "translate"
      match = ignoreCaseStringMatcher("translate", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // "using"
                        match = ignoreCaseStringMatcher("using", 5);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // (("char_cs" | "nchar_cs") TestNoAlpha OptionalSpacing)
                                 // ("char_cs" | "nchar_cs")
                                 int startIndex_1 = index;
                                 switch(buffer.getChar(index)) {
                                    case 'n':
                                    case 'N': {
                                       ++index;
                                       // "char_cs"
                                       if (match = ignoreCaseStringTest("char_cs", 7)) {
                                          index += 7;
                                       }
                                       break;
                                    }
                                    case 'c':
                                    case 'C': {
                                       ++index;
                                       // "har_cs"
                                       if (match = ignoreCaseStringTest("har_cs", 6)) {
                                          index += 6;
                                       }
                                       break;
                                    }
                                    default: {
                                       match = false;
                                    }
                                 }
                                 if (! match) {
                                    index = startIndex_1;
                                 } else if(! currentRuleIsAtomic) {
                                    currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                                    currentNode = currentNode.getSibling();
                                 }
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                                 if (match) {
                                    // "CharType"
                                    match = ignoreCaseStringMatcher("CharType", 8);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         translate$RuleMemoStart = startIndex;
         translate$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            translate$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TRANSLATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            translate$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         translate$RuleMemoStart = startIndex;
         translate$RuleMemoEnd = -1;
         translate$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Treat : ("treat" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "as" TestNoAlpha OptionalSpacing ("ref" TestNoAlpha OptionalSpacing)? SchemaObjectName ')' OptionalSpacing)
   protected boolean treat$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Treat", index);
      }
      if (treat$RuleMemoStart == index) {
         if (treat$RuleMemoStart <= treat$RuleMemoEnd) {
            index = treat$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TREAT, treat$RuleMemoStart, treat$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (treat$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(treat$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("treat" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "as" TestNoAlpha OptionalSpacing ("ref" TestNoAlpha OptionalSpacing)? SchemaObjectName ')' OptionalSpacing)
      // "treat"
      match = ignoreCaseStringMatcher("treat", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // "as"
                        match = ignoreCaseStringMatcher("as", 2);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // ("ref" TestNoAlpha OptionalSpacing)?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // ("ref" TestNoAlpha OptionalSpacing)
                                 // "ref"
                                 match = ignoreCaseStringMatcher("ref", 3);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                                 if (match) {
                                    // SchemaObjectName
                                    match = schemaObjectName$Rule();
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         treat$RuleMemoStart = startIndex;
         treat$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            treat$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TREAT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            treat$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         treat$RuleMemoStart = startIndex;
         treat$RuleMemoEnd = -1;
         treat$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TrimMode : ((("leading" TestNoAlpha OptionalSpacing SqlExpression) | ("trailing" TestNoAlpha OptionalSpacing SqlExpression) | ("both" TestNoAlpha OptionalSpacing SqlExpression) | ("leading" TestNoAlpha OptionalSpacing) | ("trailing" TestNoAlpha OptionalSpacing) | ("both" TestNoAlpha OptionalSpacing) | SqlExpression) "from" TestNoAlpha OptionalSpacing)
   protected boolean trimMode$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TrimMode", index);
      }
      startIndex = index;
      // ((("leading" TestNoAlpha OptionalSpacing SqlExpression) | ("trailing" TestNoAlpha OptionalSpacing SqlExpression) | ("both" TestNoAlpha OptionalSpacing SqlExpression) | ("leading" TestNoAlpha OptionalSpacing) | ("trailing" TestNoAlpha OptionalSpacing) | ("both" TestNoAlpha OptionalSpacing) | SqlExpression) "from" TestNoAlpha OptionalSpacing)
      // (("leading" TestNoAlpha OptionalSpacing SqlExpression) | ("trailing" TestNoAlpha OptionalSpacing SqlExpression) | ("both" TestNoAlpha OptionalSpacing SqlExpression) | ("leading" TestNoAlpha OptionalSpacing) | ("trailing" TestNoAlpha OptionalSpacing) | ("both" TestNoAlpha OptionalSpacing) | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("leading" TestNoAlpha OptionalSpacing SqlExpression)
      // "leading"
      match = ignoreCaseStringMatcher("leading", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("trailing" TestNoAlpha OptionalSpacing SqlExpression)
         // "trailing"
         match = ignoreCaseStringMatcher("trailing", 8);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlExpression
                  match = sqlExpression$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("both" TestNoAlpha OptionalSpacing SqlExpression)
            // "both"
            match = ignoreCaseStringMatcher("both", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("leading" TestNoAlpha OptionalSpacing)
               // "leading"
               match = ignoreCaseStringMatcher("leading", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("trailing" TestNoAlpha OptionalSpacing)
                  // "trailing"
                  match = ignoreCaseStringMatcher("trailing", 8);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("both" TestNoAlpha OptionalSpacing)
                     // "both"
                     match = ignoreCaseStringMatcher("both", 4);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         // "from"
         match = ignoreCaseStringMatcher("from", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.TRIM_MODE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Trim : ("trim" TestNoAlpha OptionalSpacing '(' OptionalSpacing TrimMode? SqlExpression ')' OptionalSpacing)
   protected boolean trim$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Trim", index);
      }
      if (trim$RuleMemoStart == index) {
         if (trim$RuleMemoStart <= trim$RuleMemoEnd) {
            index = trim$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TRIM, trim$RuleMemoStart, trim$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (trim$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(trim$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("trim" TestNoAlpha OptionalSpacing '(' OptionalSpacing TrimMode? SqlExpression ')' OptionalSpacing)
      // "trim"
      match = ignoreCaseStringMatcher("trim", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // TrimMode?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // TrimMode
                     match = trimMode$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         trim$RuleMemoStart = startIndex;
         trim$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            trim$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TRIM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            trim$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         trim$RuleMemoStart = startIndex;
         trim$RuleMemoEnd = -1;
         trim$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VarPop : ("var_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean varPop$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VarPop", index);
      }
      if (varPop$RuleMemoStart == index) {
         if (varPop$RuleMemoStart <= varPop$RuleMemoEnd) {
            index = varPop$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VAR_POP, varPop$RuleMemoStart, varPop$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (varPop$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(varPop$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("var_pop" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "var_pop"
      match = ignoreCaseStringMatcher("var_pop", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         varPop$RuleMemoStart = startIndex;
         varPop$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            varPop$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VAR_POP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            varPop$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         varPop$RuleMemoStart = startIndex;
         varPop$RuleMemoEnd = -1;
         varPop$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VarSamp : ("var_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
   protected boolean varSamp$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VarSamp", index);
      }
      if (varSamp$RuleMemoStart == index) {
         if (varSamp$RuleMemoStart <= varSamp$RuleMemoEnd) {
            index = varSamp$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VAR_SAMP, varSamp$RuleMemoStart, varSamp$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (varSamp$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(varSamp$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("var_samp" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing AnalyticOverClause?)
      // "var_samp"
      match = ignoreCaseStringMatcher("var_samp", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         varSamp$RuleMemoStart = startIndex;
         varSamp$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            varSamp$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VAR_SAMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            varSamp$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         varSamp$RuleMemoStart = startIndex;
         varSamp$RuleMemoEnd = -1;
         varSamp$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Variance : ("variance" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
   protected boolean variance$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Variance", index);
      }
      if (variance$RuleMemoStart == index) {
         if (variance$RuleMemoStart <= variance$RuleMemoEnd) {
            index = variance$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VARIANCE, variance$RuleMemoStart, variance$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (variance$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variance$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("variance" TestNoAlpha OptionalSpacing '(' OptionalSpacing (DistinctExpression | AllExpression | SqlExpression) ')' OptionalSpacing AnalyticOverClause?)
      // "variance"
      match = ignoreCaseStringMatcher("variance", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (DistinctExpression | AllExpression | SqlExpression)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '(':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlExpression
                           match = sqlExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AllExpression
                           match = allExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'D':
                        case 'd': {
                           // DistinctExpression
                           match = distinctExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AnalyticOverClause?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // AnalyticOverClause
                              match = analyticOverClause$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         variance$RuleMemoStart = startIndex;
         variance$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variance$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VARIANCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variance$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         variance$RuleMemoStart = startIndex;
         variance$RuleMemoEnd = -1;
         variance$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlAgg : ("xmlagg" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression OrderByClause? ')' OptionalSpacing)
   protected boolean xmlAgg$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlAgg", index);
      }
      if (xmlAgg$RuleMemoStart == index) {
         if (xmlAgg$RuleMemoStart <= xmlAgg$RuleMemoEnd) {
            index = xmlAgg$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_AGG, xmlAgg$RuleMemoStart, xmlAgg$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlAgg$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlAgg$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlagg" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression OrderByClause? ')' OptionalSpacing)
      // "xmlagg"
      match = ignoreCaseStringMatcher("xmlagg", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // OrderByClause?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // OrderByClause
                        match = orderByClause$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlAgg$RuleMemoStart = startIndex;
         xmlAgg$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlAgg$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_AGG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlAgg$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlAgg$RuleMemoStart = startIndex;
         xmlAgg$RuleMemoEnd = -1;
         xmlAgg$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlAlias : ("as" TestNoAlpha OptionalSpacing (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | SqlAnyIdentifier))
   protected boolean xmlAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlAlias", index);
      }
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | SqlAnyIdentifier))
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | SqlAnyIdentifier)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("evalname" TestNoAlpha OptionalSpacing SqlExpression)
               // "evalname"
               match = ignoreCaseStringMatcher("evalname", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlAnyIdentifier
                  match = sqlAnyIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_ALIAS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlCast : ("xmlcast" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "as" TestNoAlpha OptionalSpacing SqlDataType ')' OptionalSpacing)
   protected boolean xmlCast$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlCast", index);
      }
      if (xmlCast$RuleMemoStart == index) {
         if (xmlCast$RuleMemoStart <= xmlCast$RuleMemoEnd) {
            index = xmlCast$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_CAST, xmlCast$RuleMemoStart, xmlCast$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlCast$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlCast$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlcast" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression "as" TestNoAlpha OptionalSpacing SqlDataType ')' OptionalSpacing)
      // "xmlcast"
      match = ignoreCaseStringMatcher("xmlcast", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // "as"
                        match = ignoreCaseStringMatcher("as", 2);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlDataType
                                 match = sqlDataType$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlCast$RuleMemoStart = startIndex;
         xmlCast$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlCast$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_CAST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlCast$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlCast$RuleMemoStart = startIndex;
         xmlCast$RuleMemoEnd = -1;
         xmlCast$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlPar : (SqlExpression XmlAlias?)
   protected boolean xmlPar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlPar", index);
      }
      if (xmlPar$RuleMemoStart == index) {
         if (xmlPar$RuleMemoStart <= xmlPar$RuleMemoEnd) {
            index = xmlPar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_PAR, xmlPar$RuleMemoStart, xmlPar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlPar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlPar$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression XmlAlias?)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // XmlAlias?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // XmlAlias
         match = xmlAlias$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         xmlPar$RuleMemoStart = startIndex;
         xmlPar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlPar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_PAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlPar$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlPar$RuleMemoStart = startIndex;
         xmlPar$RuleMemoEnd = -1;
         xmlPar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlColAttVal : ("xmlcolattval" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
   protected boolean xmlColAttVal$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlColAttVal", index);
      }
      if (xmlColAttVal$RuleMemoStart == index) {
         if (xmlColAttVal$RuleMemoStart <= xmlColAttVal$RuleMemoEnd) {
            index = xmlColAttVal$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_COL_ATT_VAL, xmlColAttVal$RuleMemoStart, xmlColAttVal$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlColAttVal$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlColAttVal$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlcolattval" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
      // "xmlcolattval"
      match = ignoreCaseStringMatcher("xmlcolattval", 12);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // XmlPar
                     match = xmlPar$Rule();
                     if (match) {
                        // (',' OptionalSpacing XmlPar)*
                        Node lastNode_1;
                        int lastIndex_1;
                        do {
                           lastNode_1 = currentNode;
                           lastIndex_1 = index;
                           // (',' OptionalSpacing XmlPar)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // XmlPar
                                 match = xmlPar$Rule();
                              }
                           }
                        } while(match);
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlColAttVal$RuleMemoStart = startIndex;
         xmlColAttVal$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlColAttVal$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_COL_ATT_VAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlColAttVal$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlColAttVal$RuleMemoStart = startIndex;
         xmlColAttVal$RuleMemoEnd = -1;
         xmlColAttVal$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlAttributesClause : ("xmlattributes" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)? (("schemacheck" | "noschemacheck") TestNoAlpha OptionalSpacing)? XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
   protected boolean xmlAttributesClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlAttributesClause", index);
      }
      startIndex = index;
      // ("xmlattributes" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)? (("schemacheck" | "noschemacheck") TestNoAlpha OptionalSpacing)? XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
      // "xmlattributes"
      match = ignoreCaseStringMatcher("xmlattributes", 13);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)
                     // ("entityescaping" | "noentityescaping")
                     int startIndex_2 = index;
                     switch(buffer.getChar(index)) {
                        case 'n':
                        case 'N': {
                           ++index;
                           // "oentityescaping"
                           if (match = ignoreCaseStringTest("oentityescaping", 15)) {
                              index += 15;
                           }
                           break;
                        }
                        case 'e':
                        case 'E': {
                           ++index;
                           // "ntityescaping"
                           if (match = ignoreCaseStringTest("ntityescaping", 13)) {
                              index += 13;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (! match) {
                        index = startIndex_2;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // (("schemacheck" | "noschemacheck") TestNoAlpha OptionalSpacing)?
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // (("schemacheck" | "noschemacheck") TestNoAlpha OptionalSpacing)
                        // ("schemacheck" | "noschemacheck")
                        int startIndex_4 = index;
                        switch(buffer.getChar(index)) {
                           case 'n':
                           case 'N': {
                              ++index;
                              // "oschemacheck"
                              if (match = ignoreCaseStringTest("oschemacheck", 12)) {
                                 index += 12;
                              }
                              break;
                           }
                           case 's':
                           case 'S': {
                              ++index;
                              // "chemacheck"
                              if (match = ignoreCaseStringTest("chemacheck", 10)) {
                                 index += 10;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        if (! match) {
                           index = startIndex_4;
                        } else if(! currentRuleIsAtomic) {
                           currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
                           currentNode = currentNode.getSibling();
                        }
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                        if (match) {
                           // XmlPar
                           match = xmlPar$Rule();
                           if (match) {
                              // (',' OptionalSpacing XmlPar)*
                              Node lastNode_5;
                              int lastIndex_5;
                              do {
                                 lastNode_5 = currentNode;
                                 lastIndex_5 = index;
                                 // (',' OptionalSpacing XmlPar)
                                 // ','
                                 match = charMatcher(',');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // XmlPar
                                       match = xmlPar$Rule();
                                    }
                                 }
                              } while(match);
                              lastNode_5.setSibling(null);
                              currentNode = lastNode_5;
                              index = lastIndex_5;
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_ATTRIBUTES_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlElement : ("xmlelement" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)? (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier) (',' OptionalSpacing XmlAttributesClause)? (',' OptionalSpacing SqlExpression AsAlias?)* ')' OptionalSpacing)
   protected boolean xmlElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlElement", index);
      }
      if (xmlElement$RuleMemoStart == index) {
         if (xmlElement$RuleMemoStart <= xmlElement$RuleMemoEnd) {
            index = xmlElement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_ELEMENT, xmlElement$RuleMemoStart, xmlElement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlElement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlElement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlelement" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)? (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier) (',' OptionalSpacing XmlAttributesClause)? (',' OptionalSpacing SqlExpression AsAlias?)* ')' OptionalSpacing)
      // "xmlelement"
      match = ignoreCaseStringMatcher("xmlelement", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // (("entityescaping" | "noentityescaping") TestNoAlpha OptionalSpacing)
                     // ("entityescaping" | "noentityescaping")
                     int startIndex_2 = index;
                     switch(buffer.getChar(index)) {
                        case 'n':
                        case 'N': {
                           ++index;
                           // "oentityescaping"
                           if (match = ignoreCaseStringTest("oentityescaping", 15)) {
                              index += 15;
                           }
                           break;
                        }
                        case 'e':
                        case 'E': {
                           ++index;
                           // "ntityescaping"
                           if (match = ignoreCaseStringTest("ntityescaping", 13)) {
                              index += 13;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (! match) {
                        index = startIndex_2;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier)
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // ("evalname" TestNoAlpha OptionalSpacing SqlExpression)
                        // "evalname"
                        match = ignoreCaseStringMatcher("evalname", 8);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                        }
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           // ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
                           // "name"
                           match = ignoreCaseStringMatcher("name", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // SqlAnyIdentifier
                                    match = sqlAnyIdentifier$Rule();
                                 }
                              }
                           }
                           if (! match) {
                              index = lastIndex_3;
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                              // SqlAnyIdentifier
                              match = sqlAnyIdentifier$Rule();
                              if (! match) {
                                 index = lastIndex_3;
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                              }
                           }
                        }
                        if (match) {
                           // (',' OptionalSpacing XmlAttributesClause)?
                           Node lastNode_4 = currentNode;
                           int lastIndex_4 = index;
                           // (',' OptionalSpacing XmlAttributesClause)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // XmlAttributesClause
                                 match = xmlAttributesClause$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_4.setSibling(null);
                              currentNode = lastNode_4;
                              index = lastIndex_4;
                              match = true;
                           }
                           if (match) {
                              // (',' OptionalSpacing SqlExpression AsAlias?)*
                              Node lastNode_5;
                              int lastIndex_5;
                              do {
                                 lastNode_5 = currentNode;
                                 lastIndex_5 = index;
                                 // (',' OptionalSpacing SqlExpression AsAlias?)
                                 // ','
                                 match = charMatcher(',');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // SqlExpression
                                       match = sqlExpression$Rule();
                                       if (match) {
                                          // AsAlias?
                                          Node lastNode_6 = currentNode;
                                          int lastIndex_6 = index;
                                          // AsAlias
                                          match = asAlias$Rule();
                                          if (! match) {
                                             lastNode_6.setSibling(null);
                                             currentNode = lastNode_6;
                                             index = lastIndex_6;
                                             match = true;
                                          }
                                       }
                                    }
                                 }
                              } while(match);
                              lastNode_5.setSibling(null);
                              currentNode = lastNode_5;
                              index = lastIndex_5;
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlElement$RuleMemoStart = startIndex;
         xmlElement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlElement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_ELEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlElement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlElement$RuleMemoStart = startIndex;
         xmlElement$RuleMemoEnd = -1;
         xmlElement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AsAlias : ("as" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
   protected boolean asAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AsAlias", index);
      }
      if (asAlias$RuleMemoStart == index) {
         if (asAlias$RuleMemoStart <= asAlias$RuleMemoEnd) {
            index = asAlias$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AS_ALIAS, asAlias$RuleMemoStart, asAlias$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (asAlias$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(asAlias$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
            }
         }
      }
      if (match) {
         asAlias$RuleMemoStart = startIndex;
         asAlias$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            asAlias$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AS_ALIAS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            asAlias$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         asAlias$RuleMemoStart = startIndex;
         asAlias$RuleMemoEnd = -1;
         asAlias$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AliasedExpression : (SqlExpression AsAlias?)
   protected boolean aliasedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AliasedExpression", index);
      }
      if (aliasedExpression$RuleMemoStart == index) {
         if (aliasedExpression$RuleMemoStart <= aliasedExpression$RuleMemoEnd) {
            index = aliasedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ALIASED_EXPRESSION, aliasedExpression$RuleMemoStart, aliasedExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (aliasedExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(aliasedExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression AsAlias?)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // AsAlias?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // AsAlias
         match = asAlias$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ALIASED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = -1;
         aliasedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlPassingClause : ("passing" TestNoAlpha OptionalSpacing ("by" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)? AliasedExpression (',' OptionalSpacing AliasedExpression)*)
   protected boolean xmlPassingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlPassingClause", index);
      }
      if (xmlPassingClause$RuleMemoStart == index) {
         if (xmlPassingClause$RuleMemoStart <= xmlPassingClause$RuleMemoEnd) {
            index = xmlPassingClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_PASSING_CLAUSE, xmlPassingClause$RuleMemoStart, xmlPassingClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlPassingClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlPassingClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("passing" TestNoAlpha OptionalSpacing ("by" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)? AliasedExpression (',' OptionalSpacing AliasedExpression)*)
      // "passing"
      match = ignoreCaseStringMatcher("passing", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("by" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("by" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "value"
                        match = ignoreCaseStringMatcher("value", 5);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (match) {
                     // (',' OptionalSpacing AliasedExpression)*
                     Node lastNode_2;
                     int lastIndex_2;
                     do {
                        lastNode_2 = currentNode;
                        lastIndex_2 = index;
                        // (',' OptionalSpacing AliasedExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // AliasedExpression
                              match = aliasedExpression$Rule();
                           }
                        }
                     } while(match);
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xmlPassingClause$RuleMemoStart = startIndex;
         xmlPassingClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlPassingClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_PASSING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlPassingClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlPassingClause$RuleMemoStart = startIndex;
         xmlPassingClause$RuleMemoEnd = -1;
         xmlPassingClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlExists : ("xmlexists" TestNoAlpha OptionalSpacing '(' OptionalSpacing StringLiteral XmlPassingClause? ')' OptionalSpacing)
   protected boolean xmlExists$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlExists", index);
      }
      if (xmlExists$RuleMemoStart == index) {
         if (xmlExists$RuleMemoStart <= xmlExists$RuleMemoEnd) {
            index = xmlExists$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_EXISTS, xmlExists$RuleMemoStart, xmlExists$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlExists$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlExists$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlexists" TestNoAlpha OptionalSpacing '(' OptionalSpacing StringLiteral XmlPassingClause? ')' OptionalSpacing)
      // "xmlexists"
      match = ignoreCaseStringMatcher("xmlexists", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // StringLiteral
                     match = stringLiteral$Rule();
                     if (match) {
                        // XmlPassingClause?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // XmlPassingClause
                        match = xmlPassingClause$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlExists$RuleMemoStart = startIndex;
         xmlExists$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlExists$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_EXISTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlExists$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlExists$RuleMemoStart = startIndex;
         xmlExists$RuleMemoEnd = -1;
         xmlExists$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlForest : ("xmlforest" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
   protected boolean xmlForest$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlForest", index);
      }
      if (xmlForest$RuleMemoStart == index) {
         if (xmlForest$RuleMemoStart <= xmlForest$RuleMemoEnd) {
            index = xmlForest$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_FOREST, xmlForest$RuleMemoStart, xmlForest$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlForest$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlForest$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlforest" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlPar (',' OptionalSpacing XmlPar)* ')' OptionalSpacing)
      // "xmlforest"
      match = ignoreCaseStringMatcher("xmlforest", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // XmlPar
                     match = xmlPar$Rule();
                     if (match) {
                        // (',' OptionalSpacing XmlPar)*
                        Node lastNode_1;
                        int lastIndex_1;
                        do {
                           lastNode_1 = currentNode;
                           lastIndex_1 = index;
                           // (',' OptionalSpacing XmlPar)
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // XmlPar
                                 match = xmlPar$Rule();
                              }
                           }
                        } while(match);
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlForest$RuleMemoStart = startIndex;
         xmlForest$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlForest$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_FOREST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlForest$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlForest$RuleMemoStart = startIndex;
         xmlForest$RuleMemoEnd = -1;
         xmlForest$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlParse : ("xmlparse" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("document" | "content") TestNoAlpha OptionalSpacing) SqlExpression ("wellformed" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
   protected boolean xmlParse$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlParse", index);
      }
      if (xmlParse$RuleMemoStart == index) {
         if (xmlParse$RuleMemoStart <= xmlParse$RuleMemoEnd) {
            index = xmlParse$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_PARSE, xmlParse$RuleMemoStart, xmlParse$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlParse$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlParse$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlparse" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("document" | "content") TestNoAlpha OptionalSpacing) SqlExpression ("wellformed" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // "xmlparse"
      match = ignoreCaseStringMatcher("xmlparse", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("document" | "content") TestNoAlpha OptionalSpacing)
                     // ("document" | "content")
                     int startIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case 'c':
                        case 'C': {
                           ++index;
                           // "ontent"
                           if (match = ignoreCaseStringTest("ontent", 6)) {
                              index += 6;
                           }
                           break;
                        }
                        case 'd':
                        case 'D': {
                           ++index;
                           // "ocument"
                           if (match = ignoreCaseStringTest("ocument", 7)) {
                              index += 7;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (! match) {
                        index = startIndex_1;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // ("wellformed" TestNoAlpha OptionalSpacing)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // ("wellformed" TestNoAlpha OptionalSpacing)
                           // "wellformed"
                           match = ignoreCaseStringMatcher("wellformed", 10);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlParse$RuleMemoStart = startIndex;
         xmlParse$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlParse$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_PARSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlParse$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlParse$RuleMemoStart = startIndex;
         xmlParse$RuleMemoEnd = -1;
         xmlParse$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlPI : ("xmlpi" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier) (',' OptionalSpacing SqlExpression)? ')' OptionalSpacing)
   protected boolean xmlPI$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlPI", index);
      }
      if (xmlPI$RuleMemoStart == index) {
         if (xmlPI$RuleMemoStart <= xmlPI$RuleMemoEnd) {
            index = xmlPI$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_PI, xmlPI$RuleMemoStart, xmlPI$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlPI$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlPI$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlpi" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier) (',' OptionalSpacing SqlExpression)? ')' OptionalSpacing)
      // "xmlpi"
      match = ignoreCaseStringMatcher("xmlpi", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("evalname" TestNoAlpha OptionalSpacing SqlExpression) | ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier) | SqlAnyIdentifier)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // ("evalname" TestNoAlpha OptionalSpacing SqlExpression)
                     // "evalname"
                     match = ignoreCaseStringMatcher("evalname", 8);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("name" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
                        // "name"
                        match = ignoreCaseStringMatcher("name", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlAnyIdentifier
                                 match = sqlAnyIdentifier$Rule();
                              }
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // SqlAnyIdentifier
                           match = sqlAnyIdentifier$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     if (match) {
                        // (',' OptionalSpacing SqlExpression)?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // (',' OptionalSpacing SqlExpression)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlPI$RuleMemoStart = startIndex;
         xmlPI$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlPI$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_PI, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlPI$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlPI$RuleMemoStart = startIndex;
         xmlPI$RuleMemoEnd = -1;
         xmlPI$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlQuery : ("xmlquery" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression XmlPassingClause? "returning" TestNoAlpha OptionalSpacing "content" TestNoAlpha OptionalSpacing ("null" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing "empty" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
   protected boolean xmlQuery$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlQuery", index);
      }
      if (xmlQuery$RuleMemoStart == index) {
         if (xmlQuery$RuleMemoStart <= xmlQuery$RuleMemoEnd) {
            index = xmlQuery$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_QUERY, xmlQuery$RuleMemoStart, xmlQuery$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlQuery$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlQuery$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlquery" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression XmlPassingClause? "returning" TestNoAlpha OptionalSpacing "content" TestNoAlpha OptionalSpacing ("null" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing "empty" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // "xmlquery"
      match = ignoreCaseStringMatcher("xmlquery", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // XmlPassingClause?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // XmlPassingClause
                        match = xmlPassingClause$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // "returning"
                           match = ignoreCaseStringMatcher("returning", 9);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "content"
                                    match = ignoreCaseStringMatcher("content", 7);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // ("null" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing "empty" TestNoAlpha OptionalSpacing)?
                                             Node lastNode_2 = currentNode;
                                             int lastIndex_2 = index;
                                             // ("null" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing "empty" TestNoAlpha OptionalSpacing)
                                             // "null"
                                             match = ignoreCaseStringMatcher("null", 4);
                                             if (match) {
                                                // TestNoAlpha
                                                match = testNoAlpha$Rule();
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                   if (match) {
                                                      // "on"
                                                      match = ignoreCaseStringMatcher("on", 2);
                                                      if (match) {
                                                         // TestNoAlpha
                                                         match = testNoAlpha$Rule();
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // "empty"
                                                               match = ignoreCaseStringMatcher("empty", 5);
                                                               if (match) {
                                                                  // TestNoAlpha
                                                                  match = testNoAlpha$Rule();
                                                                  if (match) {
                                                                     // OptionalSpacing
                                                                     match = optionalSpacing$Rule();
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                             if (! match) {
                                                lastNode_2.setSibling(null);
                                                currentNode = lastNode_2;
                                                index = lastIndex_2;
                                                match = true;
                                             }
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlQuery$RuleMemoStart = startIndex;
         xmlQuery$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlQuery$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_QUERY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlQuery$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlQuery$RuleMemoStart = startIndex;
         xmlQuery$RuleMemoEnd = -1;
         xmlQuery$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlRoot : ("xmlroot" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing "version" TestNoAlpha OptionalSpacing (("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing) | SqlExpression) (',' OptionalSpacing "standalone" TestNoAlpha OptionalSpacing (("yes" TestNoAlpha OptionalSpacing) | ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)))? ')' OptionalSpacing)
   protected boolean xmlRoot$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlRoot", index);
      }
      if (xmlRoot$RuleMemoStart == index) {
         if (xmlRoot$RuleMemoStart <= xmlRoot$RuleMemoEnd) {
            index = xmlRoot$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_ROOT, xmlRoot$RuleMemoStart, xmlRoot$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlRoot$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlRoot$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmlroot" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing "version" TestNoAlpha OptionalSpacing (("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing) | SqlExpression) (',' OptionalSpacing "standalone" TestNoAlpha OptionalSpacing (("yes" TestNoAlpha OptionalSpacing) | ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)))? ')' OptionalSpacing)
      // "xmlroot"
      match = ignoreCaseStringMatcher("xmlroot", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "version"
                              match = ignoreCaseStringMatcher("version", 7);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // (("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing) | SqlExpression)
                                       Node lastNode_1 = currentNode;
                                       int lastIndex_1 = index;
                                       // ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)
                                       // "no"
                                       match = ignoreCaseStringMatcher("no", 2);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // "value"
                                                match = ignoreCaseStringMatcher("value", 5);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // SqlExpression
                                          match = sqlExpression$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                       if (match) {
                                          // (',' OptionalSpacing "standalone" TestNoAlpha OptionalSpacing (("yes" TestNoAlpha OptionalSpacing) | ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)))?
                                          Node lastNode_2 = currentNode;
                                          int lastIndex_2 = index;
                                          // (',' OptionalSpacing "standalone" TestNoAlpha OptionalSpacing (("yes" TestNoAlpha OptionalSpacing) | ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)))
                                          // ','
                                          match = charMatcher(',');
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // "standalone"
                                                match = ignoreCaseStringMatcher("standalone", 10);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // (("yes" TestNoAlpha OptionalSpacing) | ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing))
                                                         Node lastNode_3 = currentNode;
                                                         int lastIndex_3 = index;
                                                         // ("yes" TestNoAlpha OptionalSpacing)
                                                         // "yes"
                                                         match = ignoreCaseStringMatcher("yes", 3);
                                                         if (match) {
                                                            // TestNoAlpha
                                                            match = testNoAlpha$Rule();
                                                            if (match) {
                                                               // OptionalSpacing
                                                               match = optionalSpacing$Rule();
                                                            }
                                                         }
                                                         if (! match) {
                                                            index = lastIndex_3;
                                                            lastNode_3.setSibling(null);
                                                            currentNode = lastNode_3;
                                                            // ("no" TestNoAlpha OptionalSpacing "value" TestNoAlpha OptionalSpacing)
                                                            // "no"
                                                            match = ignoreCaseStringMatcher("no", 2);
                                                            if (match) {
                                                               // TestNoAlpha
                                                               match = testNoAlpha$Rule();
                                                               if (match) {
                                                                  // OptionalSpacing
                                                                  match = optionalSpacing$Rule();
                                                                  if (match) {
                                                                     // "value"
                                                                     match = ignoreCaseStringMatcher("value", 5);
                                                                     if (match) {
                                                                        // TestNoAlpha
                                                                        match = testNoAlpha$Rule();
                                                                        if (match) {
                                                                           // OptionalSpacing
                                                                           match = optionalSpacing$Rule();
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                            if (! match) {
                                                               index = lastIndex_3;
                                                               lastNode_3.setSibling(null);
                                                               currentNode = lastNode_3;
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                          if (! match) {
                                             lastNode_2.setSibling(null);
                                             currentNode = lastNode_2;
                                             index = lastIndex_2;
                                             match = true;
                                          }
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlRoot$RuleMemoStart = startIndex;
         xmlRoot$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlRoot$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_ROOT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlRoot$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlRoot$RuleMemoStart = startIndex;
         xmlRoot$RuleMemoEnd = -1;
         xmlRoot$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AsDataType : ("as" TestNoAlpha OptionalSpacing SqlDataType)
   protected boolean asDataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AsDataType", index);
      }
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing SqlDataType)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlDataType
               match = sqlDataType$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.AS_DATA_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlSerialize : ("xmlparse" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("document" | "content") TestNoAlpha OptionalSpacing) SqlExpression AsDataType? ("encoding" TestNoAlpha OptionalSpacing SqlExpression)? ("version" TestNoAlpha OptionalSpacing StringLiteral)? (("no" TestNoAlpha OptionalSpacing "indent" TestNoAlpha OptionalSpacing) | ("indent" TestNoAlpha OptionalSpacing ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?))? ((("hide" | "show") TestNoAlpha OptionalSpacing) "defaults" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
   protected boolean xmlSerialize$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlSerialize", index);
      }
      startIndex = index;
      // ("xmlparse" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("document" | "content") TestNoAlpha OptionalSpacing) SqlExpression AsDataType? ("encoding" TestNoAlpha OptionalSpacing SqlExpression)? ("version" TestNoAlpha OptionalSpacing StringLiteral)? (("no" TestNoAlpha OptionalSpacing "indent" TestNoAlpha OptionalSpacing) | ("indent" TestNoAlpha OptionalSpacing ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?))? ((("hide" | "show") TestNoAlpha OptionalSpacing) "defaults" TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // "xmlparse"
      match = ignoreCaseStringMatcher("xmlparse", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (("document" | "content") TestNoAlpha OptionalSpacing)
                     // ("document" | "content")
                     int startIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case 'c':
                        case 'C': {
                           ++index;
                           // "ontent"
                           if (match = ignoreCaseStringTest("ontent", 6)) {
                              index += 6;
                           }
                           break;
                        }
                        case 'd':
                        case 'D': {
                           ++index;
                           // "ocument"
                           if (match = ignoreCaseStringTest("ocument", 7)) {
                              index += 7;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (! match) {
                        index = startIndex_1;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // AsDataType?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // AsDataType
                           match = asDataType$Rule();
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // ("encoding" TestNoAlpha OptionalSpacing SqlExpression)?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // ("encoding" TestNoAlpha OptionalSpacing SqlExpression)
                              // "encoding"
                              match = ignoreCaseStringMatcher("encoding", 8);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // SqlExpression
                                       match = sqlExpression$Rule();
                                    }
                                 }
                              }
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                              if (match) {
                                 // ("version" TestNoAlpha OptionalSpacing StringLiteral)?
                                 Node lastNode_4 = currentNode;
                                 int lastIndex_4 = index;
                                 // ("version" TestNoAlpha OptionalSpacing StringLiteral)
                                 // "version"
                                 match = ignoreCaseStringMatcher("version", 7);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // StringLiteral
                                          match = stringLiteral$Rule();
                                       }
                                    }
                                 }
                                 if (! match) {
                                    lastNode_4.setSibling(null);
                                    currentNode = lastNode_4;
                                    index = lastIndex_4;
                                    match = true;
                                 }
                                 if (match) {
                                    // (("no" TestNoAlpha OptionalSpacing "indent" TestNoAlpha OptionalSpacing) | ("indent" TestNoAlpha OptionalSpacing ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?))?
                                    Node lastNode_5 = currentNode;
                                    int lastIndex_5 = index;
                                    // (("no" TestNoAlpha OptionalSpacing "indent" TestNoAlpha OptionalSpacing) | ("indent" TestNoAlpha OptionalSpacing ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?))
                                    Node lastNode_6 = currentNode;
                                    int lastIndex_6 = index;
                                    // ("no" TestNoAlpha OptionalSpacing "indent" TestNoAlpha OptionalSpacing)
                                    // "no"
                                    match = ignoreCaseStringMatcher("no", 2);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // "indent"
                                             match = ignoreCaseStringMatcher("indent", 6);
                                             if (match) {
                                                // TestNoAlpha
                                                match = testNoAlpha$Rule();
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                    if (! match) {
                                       index = lastIndex_6;
                                       lastNode_6.setSibling(null);
                                       currentNode = lastNode_6;
                                       // ("indent" TestNoAlpha OptionalSpacing ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?)
                                       // "indent"
                                       match = ignoreCaseStringMatcher("indent", 6);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)?
                                                Node lastNode_7 = currentNode;
                                                int lastIndex_7 = index;
                                                // ("size" TestNoAlpha OptionalSpacing '=' OptionalSpacing SqlExpression)
                                                // "size"
                                                match = ignoreCaseStringMatcher("size", 4);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // '='
                                                         match = charMatcher('=');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // SqlExpression
                                                               match = sqlExpression$Rule();
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                                if (! match) {
                                                   lastNode_7.setSibling(null);
                                                   currentNode = lastNode_7;
                                                   index = lastIndex_7;
                                                   match = true;
                                                }
                                             }
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_6;
                                          lastNode_6.setSibling(null);
                                          currentNode = lastNode_6;
                                       }
                                    }
                                    if (! match) {
                                       lastNode_5.setSibling(null);
                                       currentNode = lastNode_5;
                                       index = lastIndex_5;
                                       match = true;
                                    }
                                    if (match) {
                                       // ((("hide" | "show") TestNoAlpha OptionalSpacing) "defaults" TestNoAlpha OptionalSpacing)?
                                       Node lastNode_8 = currentNode;
                                       int lastIndex_8 = index;
                                       // ((("hide" | "show") TestNoAlpha OptionalSpacing) "defaults" TestNoAlpha OptionalSpacing)
                                       // (("hide" | "show") TestNoAlpha OptionalSpacing)
                                       // ("hide" | "show")
                                       int startIndex_9 = index;
                                       switch(buffer.getChar(index)) {
                                          case 'h':
                                          case 'H': {
                                             ++index;
                                             // "ide"
                                             if (match = ignoreCaseStringTest("ide", 3)) {
                                                index += 3;
                                             }
                                             break;
                                          }
                                          case 's':
                                          case 'S': {
                                             ++index;
                                             // "how"
                                             if (match = ignoreCaseStringTest("how", 3)) {
                                                index += 3;
                                             }
                                             break;
                                          }
                                          default: {
                                             match = false;
                                          }
                                       }
                                       if (! match) {
                                          index = startIndex_9;
                                       } else if(! currentRuleIsAtomic) {
                                          currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_9, index, false, false));
                                          currentNode = currentNode.getSibling();
                                       }
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                       if (match) {
                                          // "defaults"
                                          match = ignoreCaseStringMatcher("defaults", 8);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                       if (! match) {
                                          lastNode_8.setSibling(null);
                                          currentNode = lastNode_8;
                                          index = lastIndex_8;
                                          match = true;
                                       }
                                       if (match) {
                                          // ')'
                                          match = charMatcher(')');
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_SERIALIZE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlNamespacesArg : (StringLiteral AsAlias)
   protected boolean xmlNamespacesArg$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlNamespacesArg", index);
      }
      if (xmlNamespacesArg$RuleMemoStart == index) {
         if (xmlNamespacesArg$RuleMemoStart <= xmlNamespacesArg$RuleMemoEnd) {
            index = xmlNamespacesArg$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_NAMESPACES_ARG, xmlNamespacesArg$RuleMemoStart, xmlNamespacesArg$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlNamespacesArg$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlNamespacesArg$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (StringLiteral AsAlias)
      // StringLiteral
      match = stringLiteral$Rule();
      if (match) {
         // AsAlias
         match = asAlias$Rule();
      }
      if (match) {
         xmlNamespacesArg$RuleMemoStart = startIndex;
         xmlNamespacesArg$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlNamespacesArg$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_NAMESPACES_ARG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlNamespacesArg$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlNamespacesArg$RuleMemoStart = startIndex;
         xmlNamespacesArg$RuleMemoEnd = -1;
         xmlNamespacesArg$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlNamespacesArgs : (XmlNamespacesArg (',' OptionalSpacing XmlNamespacesArg)*)
   protected boolean xmlNamespacesArgs$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlNamespacesArgs", index);
      }
      startIndex = index;
      // (XmlNamespacesArg (',' OptionalSpacing XmlNamespacesArg)*)
      // XmlNamespacesArg
      match = xmlNamespacesArg$Rule();
      if (match) {
         // (',' OptionalSpacing XmlNamespacesArg)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing XmlNamespacesArg)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // XmlNamespacesArg
                  match = xmlNamespacesArg$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_NAMESPACES_ARGS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlNamespacesClause : ("xmlnamespaces" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlNamespacesArgs? ("default" TestNoAlpha OptionalSpacing StringLiteral)? ')' OptionalSpacing)
   protected boolean xmlNamespacesClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlNamespacesClause", index);
      }
      startIndex = index;
      // ("xmlnamespaces" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlNamespacesArgs? ("default" TestNoAlpha OptionalSpacing StringLiteral)? ')' OptionalSpacing)
      // "xmlnamespaces"
      match = ignoreCaseStringMatcher("xmlnamespaces", 13);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // XmlNamespacesArgs?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // XmlNamespacesArgs
                     match = xmlNamespacesArgs$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // ("default" TestNoAlpha OptionalSpacing StringLiteral)?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // ("default" TestNoAlpha OptionalSpacing StringLiteral)
                        // "default"
                        match = ignoreCaseStringMatcher("default", 7);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // StringLiteral
                                 match = stringLiteral$Rule();
                              }
                           }
                        }
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_NAMESPACES_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlTableColumn : (SqlIdentifier (("for" TestNoAlpha OptionalSpacing "ordinality" TestNoAlpha OptionalSpacing) | (SqlDataType ("path" TestNoAlpha OptionalSpacing StringLiteral)? ("default" TestNoAlpha OptionalSpacing SqlExpression)?)))
   protected boolean xmlTableColumn$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlTableColumn", index);
      }
      if (xmlTableColumn$RuleMemoStart == index) {
         if (xmlTableColumn$RuleMemoStart <= xmlTableColumn$RuleMemoEnd) {
            index = xmlTableColumn$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_TABLE_COLUMN, xmlTableColumn$RuleMemoStart, xmlTableColumn$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlTableColumn$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlTableColumn$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlIdentifier (("for" TestNoAlpha OptionalSpacing "ordinality" TestNoAlpha OptionalSpacing) | (SqlDataType ("path" TestNoAlpha OptionalSpacing StringLiteral)? ("default" TestNoAlpha OptionalSpacing SqlExpression)?)))
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         // (("for" TestNoAlpha OptionalSpacing "ordinality" TestNoAlpha OptionalSpacing) | (SqlDataType ("path" TestNoAlpha OptionalSpacing StringLiteral)? ("default" TestNoAlpha OptionalSpacing SqlExpression)?))
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("for" TestNoAlpha OptionalSpacing "ordinality" TestNoAlpha OptionalSpacing)
         // "for"
         match = ignoreCaseStringMatcher("for", 3);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "ordinality"
                  match = ignoreCaseStringMatcher("ordinality", 10);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // (SqlDataType ("path" TestNoAlpha OptionalSpacing StringLiteral)? ("default" TestNoAlpha OptionalSpacing SqlExpression)?)
            // SqlDataType
            match = sqlDataType$Rule();
            if (match) {
               // ("path" TestNoAlpha OptionalSpacing StringLiteral)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ("path" TestNoAlpha OptionalSpacing StringLiteral)
               // "path"
               match = ignoreCaseStringMatcher("path", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // StringLiteral
                        match = stringLiteral$Rule();
                     }
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ("default" TestNoAlpha OptionalSpacing SqlExpression)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ("default" TestNoAlpha OptionalSpacing SqlExpression)
                  // "default"
                  match = ignoreCaseStringMatcher("default", 7);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // SqlExpression
                           match = sqlExpression$Rule();
                        }
                     }
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         xmlTableColumn$RuleMemoStart = startIndex;
         xmlTableColumn$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlTableColumn$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_TABLE_COLUMN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlTableColumn$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlTableColumn$RuleMemoStart = startIndex;
         xmlTableColumn$RuleMemoEnd = -1;
         xmlTableColumn$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlTableOptions : (XmlPassingClause? ("columns" TestNoAlpha OptionalSpacing XmlTableColumn (',' OptionalSpacing XmlTableColumn)*)?)
   protected boolean xmlTableOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlTableOptions", index);
      }
      startIndex = index;
      // (XmlPassingClause? ("columns" TestNoAlpha OptionalSpacing XmlTableColumn (',' OptionalSpacing XmlTableColumn)*)?)
      // XmlPassingClause?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // XmlPassingClause
      match = xmlPassingClause$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ("columns" TestNoAlpha OptionalSpacing XmlTableColumn (',' OptionalSpacing XmlTableColumn)*)?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("columns" TestNoAlpha OptionalSpacing XmlTableColumn (',' OptionalSpacing XmlTableColumn)*)
         // "columns"
         match = ignoreCaseStringMatcher("columns", 7);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // XmlTableColumn
                  match = xmlTableColumn$Rule();
                  if (match) {
                     // (',' OptionalSpacing XmlTableColumn)*
                     Node lastNode_3;
                     int lastIndex_3;
                     do {
                        lastNode_3 = currentNode;
                        lastIndex_3 = index;
                        // (',' OptionalSpacing XmlTableColumn)
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // XmlTableColumn
                              match = xmlTableColumn$Rule();
                           }
                        }
                     } while(match);
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_TABLE_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //XmlTable : ("xmltable" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlNamespacesClause? SqlExpression XmlTableOptions ')' OptionalSpacing)
   protected boolean xmlTable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "XmlTable", index);
      }
      if (xmlTable$RuleMemoStart == index) {
         if (xmlTable$RuleMemoStart <= xmlTable$RuleMemoEnd) {
            index = xmlTable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.XML_TABLE, xmlTable$RuleMemoStart, xmlTable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (xmlTable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(xmlTable$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("xmltable" TestNoAlpha OptionalSpacing '(' OptionalSpacing XmlNamespacesClause? SqlExpression XmlTableOptions ')' OptionalSpacing)
      // "xmltable"
      match = ignoreCaseStringMatcher("xmltable", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // XmlNamespacesClause?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // XmlNamespacesClause
                     match = xmlNamespacesClause$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // SqlExpression
                        match = sqlExpression$Rule();
                        if (match) {
                           // XmlTableOptions
                           match = xmlTableOptions$Rule();
                           if (match) {
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         xmlTable$RuleMemoStart = startIndex;
         xmlTable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xmlTable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.XML_TABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xmlTable$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         xmlTable$RuleMemoStart = startIndex;
         xmlTable$RuleMemoEnd = -1;
         xmlTable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BuiltInFunctionCall : (AnalyticFunctionCall | Cast | Chr | ClusterId | ClusterProbability | ClusterSet | CumeDistAggregate | Decompose | DenseRankAggregate | Extract | FeatureId | FeatureSet | FeatureValue | FirstValue | LastValue | Lead | ListAgg | Max | Median | Min | NTile | PercentRankAggregate | PercentRankAnalytic | Prediction | PredictionBounds | PredictionCost | PredictionDetails | PredictionProbability | PredictionSet | RankAggregate | RankAnalytic | Translate | Treat | Trim | XmlAgg | XmlCast | XmlColAttVal | XmlElement | XmlExists | XmlForest | XmlParse | XmlPI | XmlQuery | XmlRoot | XmlTable)
   protected boolean builtInFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BuiltInFunctionCall", index);
      }
      if (builtInFunctionCall$RuleMemoStart == index) {
         if (builtInFunctionCall$RuleMemoStart <= builtInFunctionCall$RuleMemoEnd) {
            index = builtInFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BUILT_IN_FUNCTION_CALL, builtInFunctionCall$RuleMemoStart, builtInFunctionCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (builtInFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(builtInFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (AnalyticFunctionCall | Cast | Chr | ClusterId | ClusterProbability | ClusterSet | CumeDistAggregate | Decompose | DenseRankAggregate | Extract | FeatureId | FeatureSet | FeatureValue | FirstValue | LastValue | Lead | ListAgg | Max | Median | Min | NTile | PercentRankAggregate | PercentRankAnalytic | Prediction | PredictionBounds | PredictionCost | PredictionDetails | PredictionProbability | PredictionSet | RankAggregate | RankAnalytic | Translate | Treat | Trim | XmlAgg | XmlCast | XmlColAttVal | XmlElement | XmlExists | XmlForest | XmlParse | XmlPI | XmlQuery | XmlRoot | XmlTable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'l':
         case 'L': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // LastValue
               match = lastValue$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Lead
                  match = lead$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ListAgg
                     match = listAgg$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            // Max
            match = max$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Median
               match = median$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Min
                  match = min$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'n':
         case 'N': {
            // NTile
            match = nTile$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'p':
         case 'P': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PercentRankAggregate
               match = percentRankAggregate$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PercentRankAnalytic
                  match = percentRankAnalytic$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // Prediction
                     match = prediction$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PredictionBounds
                        match = predictionBounds$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // PredictionCost
                           match = predictionCost$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PredictionDetails
                              match = predictionDetails$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // PredictionProbability
                                 match = predictionProbability$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // PredictionSet
                                    match = predictionSet$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RankAggregate
               match = rankAggregate$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RankAnalytic
                  match = rankAnalytic$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'A':
         case 'a':
         case 's':
         case 'S':
         case 'v':
         case 'V': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'C':
         case 'c': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Cast
               match = cast$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Chr
                  match = chr$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ClusterId
                     match = clusterId$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ClusterProbability
                        match = clusterProbability$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ClusterSet
                           match = clusterSet$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // CumeDistAggregate
                              match = cumeDistAggregate$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 't':
         case 'T': {
            // Translate
            match = translate$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Treat
               match = treat$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Trim
                  match = trim$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'D':
         case 'd': {
            // AnalyticFunctionCall
            match = analyticFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Decompose
               match = decompose$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // DenseRankAggregate
                  match = denseRankAggregate$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'E':
         case 'e': {
            // Extract
            match = extract$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'F':
         case 'f': {
            // FeatureId
            match = featureId$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FeatureSet
               match = featureSet$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // FeatureValue
                  match = featureValue$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // FirstValue
                     match = firstValue$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'x':
         case 'X': {
            // XmlAgg
            match = xmlAgg$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // XmlCast
               match = xmlCast$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // XmlColAttVal
                  match = xmlColAttVal$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // XmlElement
                     match = xmlElement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // XmlExists
                        match = xmlExists$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // XmlForest
                           match = xmlForest$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // XmlParse
                              match = xmlParse$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // XmlPI
                                 match = xmlPI$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // XmlQuery
                                    match = xmlQuery$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // XmlRoot
                                       match = xmlRoot$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // XmlTable
                                          match = xmlTable$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         builtInFunctionCall$RuleMemoStart = startIndex;
         builtInFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            builtInFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BUILT_IN_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            builtInFunctionCall$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         builtInFunctionCall$RuleMemoStart = startIndex;
         builtInFunctionCall$RuleMemoEnd = -1;
         builtInFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AnalyticFunctionCall : (Avg | Corr | Count | CovarPop | CovarSamp | CumeDistAnalytic | DenseRankAnalytic | Lag | PercentileCont | PercentileDisc | RatioToReport | RegrLinearFunctions | RowNumber | StdDev | StdDevPop | StdDevSamp | Sum | VarPop | VarSamp | Variance)
   protected boolean analyticFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AnalyticFunctionCall", index);
      }
      if (analyticFunctionCall$RuleMemoStart == index) {
         if (analyticFunctionCall$RuleMemoStart <= analyticFunctionCall$RuleMemoEnd) {
            index = analyticFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ANALYTIC_FUNCTION_CALL, analyticFunctionCall$RuleMemoStart, analyticFunctionCall$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (analyticFunctionCall$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(analyticFunctionCall$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Avg | Corr | Count | CovarPop | CovarSamp | CumeDistAnalytic | DenseRankAnalytic | Lag | PercentileCont | PercentileDisc | RatioToReport | RegrLinearFunctions | RowNumber | StdDev | StdDevPop | StdDevSamp | Sum | VarPop | VarSamp | Variance)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'l':
         case 'L': {
            // Lag
            match = lag$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'p':
         case 'P': {
            // PercentileCont
            match = percentileCont$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PercentileDisc
               match = percentileDisc$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'a':
         case 'A': {
            // Avg
            match = avg$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'r':
         case 'R': {
            // RatioToReport
            match = ratioToReport$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RegrLinearFunctions
               match = regrLinearFunctions$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RowNumber
                  match = rowNumber$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 's':
         case 'S': {
            // StdDev
            match = stdDev$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // StdDevPop
               match = stdDevPop$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // StdDevSamp
                  match = stdDevSamp$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // Sum
                     match = sum$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            // Corr
            match = corr$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Count
               match = count$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // CovarPop
                  match = covarPop$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // CovarSamp
                     match = covarSamp$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // CumeDistAnalytic
                        match = cumeDistAnalytic$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            // DenseRankAnalytic
            match = denseRankAnalytic$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'v':
         case 'V': {
            // VarPop
            match = varPop$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // VarSamp
               match = varSamp$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Variance
                  match = variance$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         analyticFunctionCall$RuleMemoStart = startIndex;
         analyticFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            analyticFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ANALYTIC_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            analyticFunctionCall$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         analyticFunctionCall$RuleMemoStart = startIndex;
         analyticFunctionCall$RuleMemoEnd = -1;
         analyticFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlIdentifiedFunctionParameter : (SqlAnyIdentifier ('=' OptionalSpacing '>' OptionalSpacing) SqlExpression)
   protected boolean sqlIdentifiedFunctionParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlIdentifiedFunctionParameter", index);
      }
      if (sqlIdentifiedFunctionParameter$RuleMemoStart == index) {
         if (sqlIdentifiedFunctionParameter$RuleMemoStart <= sqlIdentifiedFunctionParameter$RuleMemoEnd) {
            index = sqlIdentifiedFunctionParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIED_FUNCTION_PARAMETER, sqlIdentifiedFunctionParameter$RuleMemoStart, sqlIdentifiedFunctionParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlIdentifiedFunctionParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlIdentifiedFunctionParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlAnyIdentifier ('=' OptionalSpacing '>' OptionalSpacing) SqlExpression)
      // SqlAnyIdentifier
      match = sqlAnyIdentifier$Rule();
      if (match) {
         // ('=' OptionalSpacing '>' OptionalSpacing)
         // '='
         match = charMatcher('=');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '>'
               match = charMatcher('>');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
         if (match) {
            // SqlExpression
            match = sqlExpression$Rule();
         }
      }
      if (match) {
         sqlIdentifiedFunctionParameter$RuleMemoStart = startIndex;
         sqlIdentifiedFunctionParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlIdentifiedFunctionParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIED_FUNCTION_PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlIdentifiedFunctionParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlIdentifiedFunctionParameter$RuleMemoStart = startIndex;
         sqlIdentifiedFunctionParameter$RuleMemoEnd = -1;
         sqlIdentifiedFunctionParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlFunctionParameter : (SqlIdentifiedFunctionParameter | SqlExpression)
   protected boolean sqlFunctionParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlFunctionParameter", index);
      }
      if (sqlFunctionParameter$RuleMemoStart == index) {
         if (sqlFunctionParameter$RuleMemoStart <= sqlFunctionParameter$RuleMemoEnd) {
            index = sqlFunctionParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_PARAMETER, sqlFunctionParameter$RuleMemoStart, sqlFunctionParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlFunctionParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlFunctionParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlIdentifiedFunctionParameter | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case '(':
         case ':':
         case '+':
         case '-':
         case '?': {
            // SqlExpression
            match = sqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlIdentifiedFunctionParameter
            match = sqlIdentifiedFunctionParameter$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlFunctionParameter$RuleMemoStart = startIndex;
         sqlFunctionParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlFunctionParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlFunctionParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlFunctionParameter$RuleMemoStart = startIndex;
         sqlFunctionParameter$RuleMemoEnd = -1;
         sqlFunctionParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnboundedPreceding : ("unbounded" TestNoAlpha OptionalSpacing "preceding" TestNoAlpha OptionalSpacing)
   protected boolean unboundedPreceding$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnboundedPreceding", index);
      }
      if (unboundedPreceding$RuleMemoStart == index) {
         if (unboundedPreceding$RuleMemoStart <= unboundedPreceding$RuleMemoEnd) {
            index = unboundedPreceding$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UNBOUNDED_PRECEDING, unboundedPreceding$RuleMemoStart, unboundedPreceding$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unboundedPreceding$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unboundedPreceding$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("unbounded" TestNoAlpha OptionalSpacing "preceding" TestNoAlpha OptionalSpacing)
      // "unbounded"
      match = ignoreCaseStringMatcher("unbounded", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "preceding"
               match = ignoreCaseStringMatcher("preceding", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         unboundedPreceding$RuleMemoStart = startIndex;
         unboundedPreceding$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unboundedPreceding$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UNBOUNDED_PRECEDING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unboundedPreceding$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         unboundedPreceding$RuleMemoStart = startIndex;
         unboundedPreceding$RuleMemoEnd = -1;
         unboundedPreceding$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnboundedFollowing : ("unbounded" TestNoAlpha OptionalSpacing "following" TestNoAlpha OptionalSpacing)
   protected boolean unboundedFollowing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnboundedFollowing", index);
      }
      if (unboundedFollowing$RuleMemoStart == index) {
         if (unboundedFollowing$RuleMemoStart <= unboundedFollowing$RuleMemoEnd) {
            index = unboundedFollowing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UNBOUNDED_FOLLOWING, unboundedFollowing$RuleMemoStart, unboundedFollowing$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unboundedFollowing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unboundedFollowing$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("unbounded" TestNoAlpha OptionalSpacing "following" TestNoAlpha OptionalSpacing)
      // "unbounded"
      match = ignoreCaseStringMatcher("unbounded", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "following"
               match = ignoreCaseStringMatcher("following", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         unboundedFollowing$RuleMemoStart = startIndex;
         unboundedFollowing$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unboundedFollowing$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UNBOUNDED_FOLLOWING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unboundedFollowing$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         unboundedFollowing$RuleMemoStart = startIndex;
         unboundedFollowing$RuleMemoEnd = -1;
         unboundedFollowing$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CurrentRow : ("current" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing)
   protected boolean currentRow$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CurrentRow", index);
      }
      if (currentRow$RuleMemoStart == index) {
         if (currentRow$RuleMemoStart <= currentRow$RuleMemoEnd) {
            index = currentRow$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURRENT_ROW, currentRow$RuleMemoStart, currentRow$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (currentRow$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(currentRow$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("current" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing)
      // "current"
      match = ignoreCaseStringMatcher("current", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "row"
               match = ignoreCaseStringMatcher("row", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         currentRow$RuleMemoStart = startIndex;
         currentRow$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            currentRow$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURRENT_ROW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            currentRow$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRow$RuleMemoStart = startIndex;
         currentRow$RuleMemoEnd = -1;
         currentRow$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Preceding : (SqlExpression "preceding" TestNoAlpha OptionalSpacing)
   protected boolean preceding$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Preceding", index);
      }
      if (preceding$RuleMemoStart == index) {
         if (preceding$RuleMemoStart <= preceding$RuleMemoEnd) {
            index = preceding$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRECEDING, preceding$RuleMemoStart, preceding$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (preceding$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(preceding$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression "preceding" TestNoAlpha OptionalSpacing)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // "preceding"
         match = ignoreCaseStringMatcher("preceding", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         preceding$RuleMemoStart = startIndex;
         preceding$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            preceding$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRECEDING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            preceding$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         preceding$RuleMemoStart = startIndex;
         preceding$RuleMemoEnd = -1;
         preceding$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Following : (SqlExpression "following" TestNoAlpha OptionalSpacing)
   protected boolean following$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Following", index);
      }
      if (following$RuleMemoStart == index) {
         if (following$RuleMemoStart <= following$RuleMemoEnd) {
            index = following$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FOLLOWING, following$RuleMemoStart, following$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (following$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(following$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression "following" TestNoAlpha OptionalSpacing)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // "following"
         match = ignoreCaseStringMatcher("following", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         following$RuleMemoStart = startIndex;
         following$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            following$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FOLLOWING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            following$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         following$RuleMemoStart = startIndex;
         following$RuleMemoEnd = -1;
         following$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BetweenWindowingClause : ("between" TestNoAlpha OptionalSpacing (UnboundedPreceding | CurrentRow | Preceding | Following) "and" TestNoAlpha OptionalSpacing (UnboundedFollowing | CurrentRow | Preceding | Following))
   protected boolean betweenWindowingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BetweenWindowingClause", index);
      }
      if (betweenWindowingClause$RuleMemoStart == index) {
         if (betweenWindowingClause$RuleMemoStart <= betweenWindowingClause$RuleMemoEnd) {
            index = betweenWindowingClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_WINDOWING_CLAUSE, betweenWindowingClause$RuleMemoStart, betweenWindowingClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (betweenWindowingClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(betweenWindowingClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("between" TestNoAlpha OptionalSpacing (UnboundedPreceding | CurrentRow | Preceding | Following) "and" TestNoAlpha OptionalSpacing (UnboundedFollowing | CurrentRow | Preceding | Following))
      // "between"
      match = ignoreCaseStringMatcher("between", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (UnboundedPreceding | CurrentRow | Preceding | Following)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '\'':
                  case '(':
                  case '+':
                  case '-':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case ':':
                  case '?':
                  case 'A':
                  case 'B':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // Preceding
                     match = preceding$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Following
                        match = following$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                     break;
                  }
                  case 'C':
                  case 'c': {
                     // CurrentRow
                     match = currentRow$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Preceding
                        match = preceding$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Following
                           match = following$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     break;
                  }
                  case 'U':
                  case 'u': {
                     // UnboundedPreceding
                     match = unboundedPreceding$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // Preceding
                        match = preceding$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // Following
                           match = following$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // "and"
                  match = ignoreCaseStringMatcher("and", 3);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // (UnboundedFollowing | CurrentRow | Preceding | Following)
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           switch(buffer.getChar(index)) {
                              case '\"':
                              case '#':
                              case '$':
                              case '\'':
                              case '(':
                              case '+':
                              case '-':
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case ':':
                              case '?':
                              case 'A':
                              case 'B':
                              case 'D':
                              case 'E':
                              case 'F':
                              case 'G':
                              case 'H':
                              case 'I':
                              case 'J':
                              case 'K':
                              case 'L':
                              case 'M':
                              case 'N':
                              case 'O':
                              case 'P':
                              case 'Q':
                              case 'R':
                              case 'S':
                              case 'T':
                              case 'V':
                              case 'W':
                              case 'X':
                              case 'Y':
                              case 'Z':
                              case '_':
                              case 'a':
                              case 'b':
                              case 'd':
                              case 'e':
                              case 'f':
                              case 'g':
                              case 'h':
                              case 'i':
                              case 'j':
                              case 'k':
                              case 'l':
                              case 'm':
                              case 'n':
                              case 'o':
                              case 'p':
                              case 'q':
                              case 'r':
                              case 's':
                              case 't':
                              case 'v':
                              case 'w':
                              case 'x':
                              case 'y':
                              case 'z':
                              case '\u00C1':
                              case '\u00C2':
                              case '\u00C3':
                              case '\u00C4':
                              case '\u00C7':
                              case '\u00C8':
                              case '\u00C9':
                              case '\u00CA':
                              case '\u00CB':
                              case '\u00CC':
                              case '\u00CD':
                              case '\u00CE':
                              case '\u00CF':
                              case '\u00D2':
                              case '\u00D3':
                              case '\u00D4':
                              case '\u00D5':
                              case '\u00D6':
                              case '\u00D9':
                              case '\u00DA':
                              case '\u00DB':
                              case '\u00DC':
                              case '\u00E0':
                              case '\u00E1':
                              case '\u00E2':
                              case '\u00E3':
                              case '\u00E4':
                              case '\u00E7':
                              case '\u00E8':
                              case '\u00E9':
                              case '\u00EA':
                              case '\u00EB':
                              case '\u00EC':
                              case '\u00ED':
                              case '\u00EE':
                              case '\u00EF':
                              case '\u00F2':
                              case '\u00F3':
                              case '\u00F4':
                              case '\u00F5':
                              case '\u00F6':
                              case '\u00F9':
                              case '\u00FA':
                              case '\u00FB':
                              case '\u00FC': {
                                 // Preceding
                                 match = preceding$Rule();
                                 if (! match) {
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                    // Following
                                    match = following$Rule();
                                    if (! match) {
                                       index = lastIndex_2;
                                       lastNode_2.setSibling(null);
                                       currentNode = lastNode_2;
                                    }
                                 }
                                 break;
                              }
                              case 'C':
                              case 'c': {
                                 // CurrentRow
                                 match = currentRow$Rule();
                                 if (! match) {
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                    // Preceding
                                    match = preceding$Rule();
                                    if (! match) {
                                       index = lastIndex_2;
                                       lastNode_2.setSibling(null);
                                       currentNode = lastNode_2;
                                       // Following
                                       match = following$Rule();
                                       if (! match) {
                                          index = lastIndex_2;
                                          lastNode_2.setSibling(null);
                                          currentNode = lastNode_2;
                                       }
                                    }
                                 }
                                 break;
                              }
                              case 'U':
                              case 'u': {
                                 // UnboundedFollowing
                                 match = unboundedFollowing$Rule();
                                 if (! match) {
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                    // Preceding
                                    match = preceding$Rule();
                                    if (! match) {
                                       index = lastIndex_2;
                                       lastNode_2.setSibling(null);
                                       currentNode = lastNode_2;
                                       // Following
                                       match = following$Rule();
                                       if (! match) {
                                          index = lastIndex_2;
                                          lastNode_2.setSibling(null);
                                          currentNode = lastNode_2;
                                       }
                                    }
                                 }
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         betweenWindowingClause$RuleMemoStart = startIndex;
         betweenWindowingClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            betweenWindowingClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_WINDOWING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            betweenWindowingClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         betweenWindowingClause$RuleMemoStart = startIndex;
         betweenWindowingClause$RuleMemoEnd = -1;
         betweenWindowingClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WindowingClause : ((("rows" | "range") TestNoAlpha OptionalSpacing) (BetweenWindowingClause | UnboundedPreceding | CurrentRow | Preceding))
   protected boolean windowingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WindowingClause", index);
      }
      startIndex = index;
      // ((("rows" | "range") TestNoAlpha OptionalSpacing) (BetweenWindowingClause | UnboundedPreceding | CurrentRow | Preceding))
      // (("rows" | "range") TestNoAlpha OptionalSpacing)
      // ("rows" | "range")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("ange" | "ows")
         switch(buffer.getChar(index)) {
            case 'o':
            case 'O': {
               ++index;
               // "ws"
               if (match = ignoreCaseStringTest("ws", 2)) {
                  index += 2;
               }
               break;
            }
            case 'a':
            case 'A': {
               ++index;
               // "nge"
               if (match = ignoreCaseStringTest("nge", 3)) {
                  index += 3;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // (BetweenWindowingClause | UnboundedPreceding | CurrentRow | Preceding)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '\"':
            case '#':
            case '$':
            case '\'':
            case '(':
            case '+':
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case '?':
            case 'A':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '\u00C1':
            case '\u00C2':
            case '\u00C3':
            case '\u00C4':
            case '\u00C7':
            case '\u00C8':
            case '\u00C9':
            case '\u00CA':
            case '\u00CB':
            case '\u00CC':
            case '\u00CD':
            case '\u00CE':
            case '\u00CF':
            case '\u00D2':
            case '\u00D3':
            case '\u00D4':
            case '\u00D5':
            case '\u00D6':
            case '\u00D9':
            case '\u00DA':
            case '\u00DB':
            case '\u00DC':
            case '\u00E0':
            case '\u00E1':
            case '\u00E2':
            case '\u00E3':
            case '\u00E4':
            case '\u00E7':
            case '\u00E8':
            case '\u00E9':
            case '\u00EA':
            case '\u00EB':
            case '\u00EC':
            case '\u00ED':
            case '\u00EE':
            case '\u00EF':
            case '\u00F2':
            case '\u00F3':
            case '\u00F4':
            case '\u00F5':
            case '\u00F6':
            case '\u00F9':
            case '\u00FA':
            case '\u00FB':
            case '\u00FC': {
               // Preceding
               match = preceding$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'B':
            case 'b': {
               // BetweenWindowingClause
               match = betweenWindowingClause$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Preceding
                  match = preceding$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case 'C':
            case 'c': {
               // CurrentRow
               match = currentRow$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Preceding
                  match = preceding$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            case 'U':
            case 'u': {
               // UnboundedPreceding
               match = unboundedPreceding$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // Preceding
                  match = preceding$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.WINDOWING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AnalyticOverClause : ("over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? (OrderByClause WindowingClause?)? ')' OptionalSpacing)
   protected boolean analyticOverClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AnalyticOverClause", index);
      }
      if (analyticOverClause$RuleMemoStart == index) {
         if (analyticOverClause$RuleMemoStart <= analyticOverClause$RuleMemoEnd) {
            index = analyticOverClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ANALYTIC_OVER_CLAUSE, analyticOverClause$RuleMemoStart, analyticOverClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (analyticOverClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(analyticOverClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("over" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryPartitionClause? (OrderByClause WindowingClause?)? ')' OptionalSpacing)
      // "over"
      match = ignoreCaseStringMatcher("over", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // QueryPartitionClause?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // QueryPartitionClause
                     match = queryPartitionClause$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // (OrderByClause WindowingClause?)?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // (OrderByClause WindowingClause?)
                        // OrderByClause
                        match = orderByClause$Rule();
                        if (match) {
                           // WindowingClause?
                           Node lastNode_3 = currentNode;
                           int lastIndex_3 = index;
                           // WindowingClause
                           match = windowingClause$Rule();
                           if (! match) {
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                              index = lastIndex_3;
                              match = true;
                           }
                        }
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         analyticOverClause$RuleMemoStart = startIndex;
         analyticOverClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            analyticOverClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ANALYTIC_OVER_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            analyticOverClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         analyticOverClause$RuleMemoStart = startIndex;
         analyticOverClause$RuleMemoEnd = -1;
         analyticOverClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelExpression : ((AnalyticFunctionCall ('[' OptionalSpacing (CellReferenceArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)?) | (SqlObjectIdentifier '[' OptionalSpacing ConditionOrExpressionList ']' OptionalSpacing))
   protected boolean modelExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelExpression", index);
      }
      if (modelExpression$RuleMemoStart == index) {
         if (modelExpression$RuleMemoStart <= modelExpression$RuleMemoEnd) {
            index = modelExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MODEL_EXPRESSION, modelExpression$RuleMemoStart, modelExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (modelExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(modelExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((AnalyticFunctionCall ('[' OptionalSpacing (CellReferenceArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)?) | (SqlObjectIdentifier '[' OptionalSpacing ConditionOrExpressionList ']' OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (AnalyticFunctionCall ('[' OptionalSpacing (CellReferenceArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)?)
      // AnalyticFunctionCall
      match = analyticFunctionCall$Rule();
      if (match) {
         // ('[' OptionalSpacing (CellReferenceArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ('[' OptionalSpacing (CellReferenceArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)
         // '['
         match = charMatcher('[');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (CellReferenceArgumentsList | MultiColumnForLoop)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '\'':
                  case '(':
                  case '+':
                  case '-':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case ':':
                  case '?':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // CellReferenceArgumentsList
                     match = cellReferenceArgumentsList$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                     break;
                  }
                  case 'F':
                  case 'f': {
                     // CellReferenceArgumentsList
                     match = cellReferenceArgumentsList$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        // MultiColumnForLoop
                        match = multiColumnForLoop$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // ']'
                  match = charMatcher(']');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (SqlObjectIdentifier '[' OptionalSpacing ConditionOrExpressionList ']' OptionalSpacing)
         // SqlObjectIdentifier
         match = sqlObjectIdentifier$Rule();
         if (match) {
            // '['
            match = charMatcher('[');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ConditionOrExpressionList
                  match = conditionOrExpressionList$Rule();
                  if (match) {
                     // ']'
                     match = charMatcher(']');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         modelExpression$RuleMemoStart = startIndex;
         modelExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            modelExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            modelExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         modelExpression$RuleMemoStart = startIndex;
         modelExpression$RuleMemoEnd = -1;
         modelExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorExpression : ("cursor" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
   protected boolean cursorExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorExpression", index);
      }
      if (cursorExpression$RuleMemoStart == index) {
         if (cursorExpression$RuleMemoStart <= cursorExpression$RuleMemoEnd) {
            index = cursorExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_EXPRESSION, cursorExpression$RuleMemoStart, cursorExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cursorExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cursorExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cursor" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
      // "cursor"
      match = ignoreCaseStringMatcher("cursor", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Subquery
                     match = subquery$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cursorExpression$RuleMemoStart = startIndex;
         cursorExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cursorExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cursorExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cursorExpression$RuleMemoStart = startIndex;
         cursorExpression$RuleMemoEnd = -1;
         cursorExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionOrExpression : (SqlCondition | SqlExpression)
   protected boolean conditionOrExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionOrExpression", index);
      }
      if (conditionOrExpression$RuleMemoStart == index) {
         if (conditionOrExpression$RuleMemoStart <= conditionOrExpression$RuleMemoEnd) {
            index = conditionOrExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONDITION_OR_EXPRESSION, conditionOrExpression$RuleMemoStart, conditionOrExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (conditionOrExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(conditionOrExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlCondition | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlCondition
            match = sqlCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         conditionOrExpression$RuleMemoStart = startIndex;
         conditionOrExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            conditionOrExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITION_OR_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            conditionOrExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         conditionOrExpression$RuleMemoStart = startIndex;
         conditionOrExpression$RuleMemoEnd = -1;
         conditionOrExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionOrExpressionList : (ConditionOrExpression (',' OptionalSpacing ConditionOrExpression)*)
   protected boolean conditionOrExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionOrExpressionList", index);
      }
      startIndex = index;
      // (ConditionOrExpression (',' OptionalSpacing ConditionOrExpression)*)
      // ConditionOrExpression
      match = conditionOrExpression$Rule();
      if (match) {
         // (',' OptionalSpacing ConditionOrExpression)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ConditionOrExpression)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ConditionOrExpression
                  match = conditionOrExpression$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITION_OR_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellReferenceArgumentsList : (CellReferenceArgument (',' OptionalSpacing CellReferenceArgument)*)
   protected boolean cellReferenceArgumentsList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellReferenceArgumentsList", index);
      }
      if (cellReferenceArgumentsList$RuleMemoStart == index) {
         if (cellReferenceArgumentsList$RuleMemoStart <= cellReferenceArgumentsList$RuleMemoEnd) {
            index = cellReferenceArgumentsList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_ARGUMENTS_LIST, cellReferenceArgumentsList$RuleMemoStart, cellReferenceArgumentsList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cellReferenceArgumentsList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cellReferenceArgumentsList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CellReferenceArgument (',' OptionalSpacing CellReferenceArgument)*)
      // CellReferenceArgument
      match = cellReferenceArgument$Rule();
      if (match) {
         // (',' OptionalSpacing CellReferenceArgument)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing CellReferenceArgument)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // CellReferenceArgument
                  match = cellReferenceArgument$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         cellReferenceArgumentsList$RuleMemoStart = startIndex;
         cellReferenceArgumentsList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cellReferenceArgumentsList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_ARGUMENTS_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cellReferenceArgumentsList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cellReferenceArgumentsList$RuleMemoStart = startIndex;
         cellReferenceArgumentsList$RuleMemoEnd = -1;
         cellReferenceArgumentsList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellReferenceArgument : (SqlCondition | SqlExpression | SingleColumnForLoop)
   protected boolean cellReferenceArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellReferenceArgument", index);
      }
      if (cellReferenceArgument$RuleMemoStart == index) {
         if (cellReferenceArgument$RuleMemoStart <= cellReferenceArgument$RuleMemoEnd) {
            index = cellReferenceArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_ARGUMENT, cellReferenceArgument$RuleMemoStart, cellReferenceArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cellReferenceArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cellReferenceArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlCondition | SqlExpression | SingleColumnForLoop)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlCondition
            match = sqlCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'F':
         case 'f': {
            // SqlCondition
            match = sqlCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SingleColumnForLoop
                  match = singleColumnForLoop$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         cellReferenceArgument$RuleMemoStart = startIndex;
         cellReferenceArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cellReferenceArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cellReferenceArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cellReferenceArgument$RuleMemoStart = startIndex;
         cellReferenceArgument$RuleMemoEnd = -1;
         cellReferenceArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlaceHolderExpression : (BindVariable (("indicator" TestNoAlpha OptionalSpacing)? BindVariable)?)
   protected boolean placeHolderExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlaceHolderExpression", index);
      }
      if (placeHolderExpression$RuleMemoStart == index) {
         if (placeHolderExpression$RuleMemoStart <= placeHolderExpression$RuleMemoEnd) {
            index = placeHolderExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PLACE_HOLDER_EXPRESSION, placeHolderExpression$RuleMemoStart, placeHolderExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (placeHolderExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(placeHolderExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BindVariable (("indicator" TestNoAlpha OptionalSpacing)? BindVariable)?)
      // BindVariable
      match = bindVariable$Rule();
      if (match) {
         // (("indicator" TestNoAlpha OptionalSpacing)? BindVariable)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // (("indicator" TestNoAlpha OptionalSpacing)? BindVariable)
         // ("indicator" TestNoAlpha OptionalSpacing)?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("indicator" TestNoAlpha OptionalSpacing)
         // "indicator"
         match = ignoreCaseStringMatcher("indicator", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
         if (match) {
            // BindVariable
            match = bindVariable$Rule();
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         placeHolderExpression$RuleMemoStart = startIndex;
         placeHolderExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            placeHolderExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PLACE_HOLDER_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            placeHolderExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         placeHolderExpression$RuleMemoStart = startIndex;
         placeHolderExpression$RuleMemoEnd = -1;
         placeHolderExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TypeConstructorExpression : ("new" TestNoAlpha OptionalSpacing SchemaObjectName '(' OptionalSpacing SqlExpressionList ')' OptionalSpacing)
   protected boolean typeConstructorExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TypeConstructorExpression", index);
      }
      if (typeConstructorExpression$RuleMemoStart == index) {
         if (typeConstructorExpression$RuleMemoStart <= typeConstructorExpression$RuleMemoEnd) {
            index = typeConstructorExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TYPE_CONSTRUCTOR_EXPRESSION, typeConstructorExpression$RuleMemoStart, typeConstructorExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (typeConstructorExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(typeConstructorExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("new" TestNoAlpha OptionalSpacing SchemaObjectName '(' OptionalSpacing SqlExpressionList ')' OptionalSpacing)
      // "new"
      match = ignoreCaseStringMatcher("new", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SchemaObjectName
               match = schemaObjectName$Rule();
               if (match) {
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlExpressionList
                        match = sqlExpressionList$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         typeConstructorExpression$RuleMemoStart = startIndex;
         typeConstructorExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            typeConstructorExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TYPE_CONSTRUCTOR_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            typeConstructorExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         typeConstructorExpression$RuleMemoStart = startIndex;
         typeConstructorExpression$RuleMemoEnd = -1;
         typeConstructorExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PivotForClause : ("for" TestNoAlpha OptionalSpacing (SqlAnyIdentifier | ('(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing)))
   protected boolean pivotForClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PivotForClause", index);
      }
      if (pivotForClause$RuleMemoStart == index) {
         if (pivotForClause$RuleMemoStart <= pivotForClause$RuleMemoEnd) {
            index = pivotForClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_FOR_CLAUSE, pivotForClause$RuleMemoStart, pivotForClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pivotForClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pivotForClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing (SqlAnyIdentifier | ('(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing)))
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (SqlAnyIdentifier | ('(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing))
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing)
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlIdentifierList
                        match = sqlIdentifierList$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
         }
      }
      if (match) {
         pivotForClause$RuleMemoStart = startIndex;
         pivotForClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pivotForClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_FOR_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pivotForClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pivotForClause$RuleMemoStart = startIndex;
         pivotForClause$RuleMemoEnd = -1;
         pivotForClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AnyList : ("any" TestNoAlpha OptionalSpacing (',' OptionalSpacing "any" TestNoAlpha OptionalSpacing)*)
   protected boolean anyList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AnyList", index);
      }
      if (anyList$RuleMemoStart == index) {
         if (anyList$RuleMemoStart <= anyList$RuleMemoEnd) {
            index = anyList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ANY_LIST, anyList$RuleMemoStart, anyList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (anyList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("any" TestNoAlpha OptionalSpacing (',' OptionalSpacing "any" TestNoAlpha OptionalSpacing)*)
      // "any"
      match = ignoreCaseStringMatcher("any", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (',' OptionalSpacing "any" TestNoAlpha OptionalSpacing)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing "any" TestNoAlpha OptionalSpacing)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "any"
                        match = ignoreCaseStringMatcher("any", 3);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
         }
      }
      if (match) {
         anyList$RuleMemoStart = startIndex;
         anyList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ANY_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         anyList$RuleMemoStart = startIndex;
         anyList$RuleMemoEnd = -1;
         anyList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlExpressionList : (SqlExpression (',' OptionalSpacing SqlExpression)*)
   protected boolean sqlExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlExpressionList", index);
      }
      if (sqlExpressionList$RuleMemoStart == index) {
         if (sqlExpressionList$RuleMemoStart <= sqlExpressionList$RuleMemoEnd) {
            index = sqlExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_EXPRESSION_LIST, sqlExpressionList$RuleMemoStart, sqlExpressionList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression (',' OptionalSpacing SqlExpression)*)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // (',' OptionalSpacing SqlExpression)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing SqlExpression)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlExpression
                  match = sqlExpression$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         sqlExpressionList$RuleMemoStart = startIndex;
         sqlExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlExpressionList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlExpressionList$RuleMemoStart = startIndex;
         sqlExpressionList$RuleMemoEnd = -1;
         sqlExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesSqlExpressionList : ('(' OptionalSpacing SqlExpressionList ')' OptionalSpacing)
   protected boolean parenthesesSqlExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesSqlExpressionList", index);
      }
      if (parenthesesSqlExpressionList$RuleMemoStart == index) {
         if (parenthesesSqlExpressionList$RuleMemoStart <= parenthesesSqlExpressionList$RuleMemoEnd) {
            index = parenthesesSqlExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_SQL_EXPRESSION_LIST, parenthesesSqlExpressionList$RuleMemoStart, parenthesesSqlExpressionList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesSqlExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesSqlExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlExpressionList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlExpressionList
            match = sqlExpressionList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesSqlExpressionList$RuleMemoStart = startIndex;
         parenthesesSqlExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesSqlExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_SQL_EXPRESSION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesSqlExpressionList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parenthesesSqlExpressionList$RuleMemoStart = startIndex;
         parenthesesSqlExpressionList$RuleMemoEnd = -1;
         parenthesesSqlExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PivoInExpressionList : (PivotInExpression (',' OptionalSpacing PivotInExpression)*)
   protected boolean pivoInExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PivoInExpressionList", index);
      }
      if (pivoInExpressionList$RuleMemoStart == index) {
         if (pivoInExpressionList$RuleMemoStart <= pivoInExpressionList$RuleMemoEnd) {
            index = pivoInExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PIVO_IN_EXPRESSION_LIST, pivoInExpressionList$RuleMemoStart, pivoInExpressionList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pivoInExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pivoInExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PivotInExpression (',' OptionalSpacing PivotInExpression)*)
      // PivotInExpression
      match = pivotInExpression$Rule();
      if (match) {
         // (',' OptionalSpacing PivotInExpression)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing PivotInExpression)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // PivotInExpression
                  match = pivotInExpression$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         pivoInExpressionList$RuleMemoStart = startIndex;
         pivoInExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pivoInExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PIVO_IN_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pivoInExpressionList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pivoInExpressionList$RuleMemoStart = startIndex;
         pivoInExpressionList$RuleMemoEnd = -1;
         pivoInExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AsOptionalAlias : (("as" TestNoAlpha OptionalSpacing)? SqlIdentifier)
   protected boolean asOptionalAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AsOptionalAlias", index);
      }
      if (asOptionalAlias$RuleMemoStart == index) {
         if (asOptionalAlias$RuleMemoStart <= asOptionalAlias$RuleMemoEnd) {
            index = asOptionalAlias$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AS_OPTIONAL_ALIAS, asOptionalAlias$RuleMemoStart, asOptionalAlias$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (asOptionalAlias$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(asOptionalAlias$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("as" TestNoAlpha OptionalSpacing)? SqlIdentifier)
      // ("as" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("as" TestNoAlpha OptionalSpacing)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // SqlIdentifier
         match = sqlIdentifier$Rule();
      }
      if (match) {
         asOptionalAlias$RuleMemoStart = startIndex;
         asOptionalAlias$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            asOptionalAlias$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AS_OPTIONAL_ALIAS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            asOptionalAlias$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         asOptionalAlias$RuleMemoStart = startIndex;
         asOptionalAlias$RuleMemoEnd = -1;
         asOptionalAlias$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PivotInExpression : (SqlExpressionList AsOptionalAlias?)
   protected boolean pivotInExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PivotInExpression", index);
      }
      if (pivotInExpression$RuleMemoStart == index) {
         if (pivotInExpression$RuleMemoStart <= pivotInExpression$RuleMemoEnd) {
            index = pivotInExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_IN_EXPRESSION, pivotInExpression$RuleMemoStart, pivotInExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pivotInExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pivotInExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpressionList AsOptionalAlias?)
      // SqlExpressionList
      match = sqlExpressionList$Rule();
      if (match) {
         // AsOptionalAlias?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // AsOptionalAlias
         match = asOptionalAlias$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         pivotInExpression$RuleMemoStart = startIndex;
         pivotInExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pivotInExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_IN_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pivotInExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pivotInExpression$RuleMemoStart = startIndex;
         pivotInExpression$RuleMemoEnd = -1;
         pivotInExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PivotInClause : ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (AnyList | Subquery | PivoInExpressionList) ')' OptionalSpacing)
   protected boolean pivotInClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PivotInClause", index);
      }
      startIndex = index;
      // ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (AnyList | Subquery | PivoInExpressionList) ')' OptionalSpacing)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (AnyList | Subquery | PivoInExpressionList)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '\'':
                        case '+':
                        case '-':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case ':':
                        case '?':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // PivoInExpressionList
                           match = pivoInExpressionList$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 'A':
                        case 'a': {
                           // AnyList
                           match = anyList$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PivoInExpressionList
                              match = pivoInExpressionList$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        case 'S':
                        case 's':
                        case '(': {
                           // Subquery
                           match = subquery$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PivoInExpressionList
                              match = pivoInExpressionList$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_IN_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PivotClause : ("pivot" TestNoAlpha OptionalSpacing ("xml" TestNoAlpha OptionalSpacing)? '(' OptionalSpacing SqlAnyIdentifier '(' OptionalSpacing SqlExpression ')' OptionalSpacing AsOptionalAlias? PivotForClause PivotInClause ')' OptionalSpacing)
   protected boolean pivotClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PivotClause", index);
      }
      startIndex = index;
      // ("pivot" TestNoAlpha OptionalSpacing ("xml" TestNoAlpha OptionalSpacing)? '(' OptionalSpacing SqlAnyIdentifier '(' OptionalSpacing SqlExpression ')' OptionalSpacing AsOptionalAlias? PivotForClause PivotInClause ')' OptionalSpacing)
      // "pivot"
      match = ignoreCaseStringMatcher("pivot", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("xml" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("xml" TestNoAlpha OptionalSpacing)
               // "xml"
               match = ignoreCaseStringMatcher("xml", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlAnyIdentifier
                        match = sqlAnyIdentifier$Rule();
                        if (match) {
                           // '('
                           match = charMatcher('(');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // AsOptionalAlias?
                                          Node lastNode_2 = currentNode;
                                          int lastIndex_2 = index;
                                          // AsOptionalAlias
                                          match = asOptionalAlias$Rule();
                                          if (! match) {
                                             lastNode_2.setSibling(null);
                                             currentNode = lastNode_2;
                                             index = lastIndex_2;
                                             match = true;
                                          }
                                          if (match) {
                                             // PivotForClause
                                             match = pivotForClause$Rule();
                                             if (match) {
                                                // PivotInClause
                                                match = pivotInClause$Rule();
                                                if (match) {
                                                   // ')'
                                                   match = charMatcher(')');
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PIVOT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IncludeNulls : ("include" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
   protected boolean includeNulls$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IncludeNulls", index);
      }
      if (includeNulls$RuleMemoStart == index) {
         if (includeNulls$RuleMemoStart <= includeNulls$RuleMemoEnd) {
            index = includeNulls$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INCLUDE_NULLS, includeNulls$RuleMemoStart, includeNulls$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (includeNulls$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(includeNulls$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("include" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
      // "include"
      match = ignoreCaseStringMatcher("include", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "nulls"
               match = ignoreCaseStringMatcher("nulls", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         includeNulls$RuleMemoStart = startIndex;
         includeNulls$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            includeNulls$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INCLUDE_NULLS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            includeNulls$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         includeNulls$RuleMemoStart = startIndex;
         includeNulls$RuleMemoEnd = -1;
         includeNulls$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExcludeNulls : ("exclude" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
   protected boolean excludeNulls$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExcludeNulls", index);
      }
      if (excludeNulls$RuleMemoStart == index) {
         if (excludeNulls$RuleMemoStart <= excludeNulls$RuleMemoEnd) {
            index = excludeNulls$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXCLUDE_NULLS, excludeNulls$RuleMemoStart, excludeNulls$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (excludeNulls$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(excludeNulls$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("exclude" TestNoAlpha OptionalSpacing "nulls" TestNoAlpha OptionalSpacing)
      // "exclude"
      match = ignoreCaseStringMatcher("exclude", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "nulls"
               match = ignoreCaseStringMatcher("nulls", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         excludeNulls$RuleMemoStart = startIndex;
         excludeNulls$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            excludeNulls$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXCLUDE_NULLS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            excludeNulls$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         excludeNulls$RuleMemoStart = startIndex;
         excludeNulls$RuleMemoEnd = -1;
         excludeNulls$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnpivotClause : ("unpivot" TestNoAlpha OptionalSpacing (IncludeNulls | ExcludeNulls)? '(' OptionalSpacing (SqlObjectIdentifier | ColumnsList) PivotForClause UnpivotInClause ')' OptionalSpacing)
   protected boolean unpivotClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnpivotClause", index);
      }
      startIndex = index;
      // ("unpivot" TestNoAlpha OptionalSpacing (IncludeNulls | ExcludeNulls)? '(' OptionalSpacing (SqlObjectIdentifier | ColumnsList) PivotForClause UnpivotInClause ')' OptionalSpacing)
      // "unpivot"
      match = ignoreCaseStringMatcher("unpivot", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (IncludeNulls | ExcludeNulls)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // (IncludeNulls | ExcludeNulls)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               switch(buffer.getChar(index)) {
                  case 'e':
                  case 'E': {
                     // ExcludeNulls
                     match = excludeNulls$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  case 'i':
                  case 'I': {
                     // IncludeNulls
                     match = includeNulls$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (SqlObjectIdentifier | ColumnsList)
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        switch(buffer.getChar(index)) {
                           case '\"':
                           case '#':
                           case '$':
                           case '0':
                           case '1':
                           case '2':
                           case '3':
                           case '4':
                           case '5':
                           case '6':
                           case '7':
                           case '8':
                           case '9':
                           case 'A':
                           case 'B':
                           case 'C':
                           case 'D':
                           case 'E':
                           case 'F':
                           case 'G':
                           case 'H':
                           case 'I':
                           case 'J':
                           case 'K':
                           case 'L':
                           case 'M':
                           case 'N':
                           case 'O':
                           case 'P':
                           case 'Q':
                           case 'R':
                           case 'S':
                           case 'T':
                           case 'U':
                           case 'V':
                           case 'W':
                           case 'X':
                           case 'Y':
                           case 'Z':
                           case '_':
                           case 'a':
                           case 'b':
                           case 'c':
                           case 'd':
                           case 'e':
                           case 'f':
                           case 'g':
                           case 'h':
                           case 'i':
                           case 'j':
                           case 'k':
                           case 'l':
                           case 'm':
                           case 'n':
                           case 'o':
                           case 'p':
                           case 'q':
                           case 'r':
                           case 's':
                           case 't':
                           case 'u':
                           case 'v':
                           case 'w':
                           case 'x':
                           case 'y':
                           case 'z':
                           case '\u00C1':
                           case '\u00C2':
                           case '\u00C3':
                           case '\u00C4':
                           case '\u00C7':
                           case '\u00C8':
                           case '\u00C9':
                           case '\u00CA':
                           case '\u00CB':
                           case '\u00CC':
                           case '\u00CD':
                           case '\u00CE':
                           case '\u00CF':
                           case '\u00D2':
                           case '\u00D3':
                           case '\u00D4':
                           case '\u00D5':
                           case '\u00D6':
                           case '\u00D9':
                           case '\u00DA':
                           case '\u00DB':
                           case '\u00DC':
                           case '\u00E0':
                           case '\u00E1':
                           case '\u00E2':
                           case '\u00E3':
                           case '\u00E4':
                           case '\u00E7':
                           case '\u00E8':
                           case '\u00E9':
                           case '\u00EA':
                           case '\u00EB':
                           case '\u00EC':
                           case '\u00ED':
                           case '\u00EE':
                           case '\u00EF':
                           case '\u00F2':
                           case '\u00F3':
                           case '\u00F4':
                           case '\u00F5':
                           case '\u00F6':
                           case '\u00F9':
                           case '\u00FA':
                           case '\u00FB':
                           case '\u00FC': {
                              // SqlObjectIdentifier
                              match = sqlObjectIdentifier$Rule();
                              if (! match) {
                                 index = lastIndex_3;
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                              }
                              break;
                           }
                           case '(': {
                              // ColumnsList
                              match = columnsList$Rule();
                              if (! match) {
                                 index = lastIndex_3;
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        if (match) {
                           // PivotForClause
                           match = pivotForClause$Rule();
                           if (match) {
                              // UnpivotInClause
                              match = unpivotInClause$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNPIVOT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnpivotInClause : ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing UnpivotInClauseList ')' OptionalSpacing)
   protected boolean unpivotInClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnpivotInClause", index);
      }
      startIndex = index;
      // ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing UnpivotInClauseList ')' OptionalSpacing)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // UnpivotInClauseList
                     match = unpivotInClauseList$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNPIVOT_IN_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnpivotInElement : ((SqlObjectIdentifier | ColumnsList) ("as" TestNoAlpha OptionalSpacing (SqlLiteral | ParenthesesLiteralList))?)
   protected boolean unpivotInElement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnpivotInElement", index);
      }
      if (unpivotInElement$RuleMemoStart == index) {
         if (unpivotInElement$RuleMemoStart <= unpivotInElement$RuleMemoEnd) {
            index = unpivotInElement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UNPIVOT_IN_ELEMENT, unpivotInElement$RuleMemoStart, unpivotInElement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unpivotInElement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unpivotInElement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((SqlObjectIdentifier | ColumnsList) ("as" TestNoAlpha OptionalSpacing (SqlLiteral | ParenthesesLiteralList))?)
      // (SqlObjectIdentifier | ColumnsList)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlObjectIdentifier
            match = sqlObjectIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // ColumnsList
            match = columnsList$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // ("as" TestNoAlpha OptionalSpacing (SqlLiteral | ParenthesesLiteralList))?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("as" TestNoAlpha OptionalSpacing (SqlLiteral | ParenthesesLiteralList))
         // "as"
         match = ignoreCaseStringMatcher("as", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // (SqlLiteral | ParenthesesLiteralList)
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  switch(buffer.getChar(index)) {
                     case 'd':
                     case 'D':
                     case '\'':
                     case 'i':
                     case 'I':
                     case '+':
                     case '-':
                     case 'n':
                     case 'N':
                     case '0':
                     case '1':
                     case '2':
                     case '3':
                     case '4':
                     case 't':
                     case 'T':
                     case '5':
                     case '6':
                     case '7':
                     case '8':
                     case '9': {
                        // SqlLiteral
                        match = sqlLiteral$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                        break;
                     }
                     case '(': {
                        // ParenthesesLiteralList
                        match = parenthesesLiteralList$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
         }
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (match) {
         unpivotInElement$RuleMemoStart = startIndex;
         unpivotInElement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unpivotInElement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UNPIVOT_IN_ELEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unpivotInElement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         unpivotInElement$RuleMemoStart = startIndex;
         unpivotInElement$RuleMemoEnd = -1;
         unpivotInElement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnpivotInClauseList : (UnpivotInElement (',' OptionalSpacing UnpivotInElement)*)
   protected boolean unpivotInClauseList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnpivotInClauseList", index);
      }
      startIndex = index;
      // (UnpivotInElement (',' OptionalSpacing UnpivotInElement)*)
      // UnpivotInElement
      match = unpivotInElement$Rule();
      if (match) {
         // (',' OptionalSpacing UnpivotInElement)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing UnpivotInElement)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // UnpivotInElement
                  match = unpivotInElement$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNPIVOT_IN_CLAUSE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlLiteralList : (SqlLiteral (',' OptionalSpacing SqlLiteral)*)
   protected boolean sqlLiteralList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlLiteralList", index);
      }
      if (sqlLiteralList$RuleMemoStart == index) {
         if (sqlLiteralList$RuleMemoStart <= sqlLiteralList$RuleMemoEnd) {
            index = sqlLiteralList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_LITERAL_LIST, sqlLiteralList$RuleMemoStart, sqlLiteralList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlLiteralList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlLiteralList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlLiteral (',' OptionalSpacing SqlLiteral)*)
      // SqlLiteral
      match = sqlLiteral$Rule();
      if (match) {
         // (',' OptionalSpacing SqlLiteral)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing SqlLiteral)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlLiteral
                  match = sqlLiteral$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         sqlLiteralList$RuleMemoStart = startIndex;
         sqlLiteralList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlLiteralList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_LITERAL_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlLiteralList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlLiteralList$RuleMemoStart = startIndex;
         sqlLiteralList$RuleMemoEnd = -1;
         sqlLiteralList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesLiteralList : ('(' OptionalSpacing SqlLiteralList ')' OptionalSpacing)
   protected boolean parenthesesLiteralList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesLiteralList", index);
      }
      if (parenthesesLiteralList$RuleMemoStart == index) {
         if (parenthesesLiteralList$RuleMemoStart <= parenthesesLiteralList$RuleMemoEnd) {
            index = parenthesesLiteralList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_LITERAL_LIST, parenthesesLiteralList$RuleMemoStart, parenthesesLiteralList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesLiteralList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesLiteralList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlLiteralList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlLiteralList
            match = sqlLiteralList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesLiteralList$RuleMemoStart = startIndex;
         parenthesesLiteralList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesLiteralList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_LITERAL_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesLiteralList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parenthesesLiteralList$RuleMemoStart = startIndex;
         parenthesesLiteralList$RuleMemoEnd = -1;
         parenthesesLiteralList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesLiteralListList : (ParenthesesLiteralList (',' OptionalSpacing ParenthesesLiteralList)*)
   protected boolean parenthesesLiteralListList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesLiteralListList", index);
      }
      if (parenthesesLiteralListList$RuleMemoStart == index) {
         if (parenthesesLiteralListList$RuleMemoStart <= parenthesesLiteralListList$RuleMemoEnd) {
            index = parenthesesLiteralListList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_LITERAL_LIST_LIST, parenthesesLiteralListList$RuleMemoStart, parenthesesLiteralListList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesLiteralListList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesLiteralListList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesLiteralList (',' OptionalSpacing ParenthesesLiteralList)*)
      // ParenthesesLiteralList
      match = parenthesesLiteralList$Rule();
      if (match) {
         // (',' OptionalSpacing ParenthesesLiteralList)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ParenthesesLiteralList)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ParenthesesLiteralList
                  match = parenthesesLiteralList$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         parenthesesLiteralListList$RuleMemoStart = startIndex;
         parenthesesLiteralListList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesLiteralListList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_LITERAL_LIST_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesLiteralListList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parenthesesLiteralListList$RuleMemoStart = startIndex;
         parenthesesLiteralListList$RuleMemoEnd = -1;
         parenthesesLiteralListList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Schema : SqlIdentifier
   protected boolean schema$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Schema", index);
      }
      if (schema$RuleMemoStart == index) {
         if (schema$RuleMemoStart <= schema$RuleMemoEnd) {
            index = schema$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SCHEMA, schema$RuleMemoStart, schema$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (schema$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(schema$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         schema$RuleMemoStart = startIndex;
         schema$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            schema$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SCHEMA, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            schema$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         schema$RuleMemoStart = startIndex;
         schema$RuleMemoEnd = -1;
         schema$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Table : SqlIdentifier
   protected boolean table$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Table", index);
      }
      if (table$RuleMemoStart == index) {
         if (table$RuleMemoStart <= table$RuleMemoEnd) {
            index = table$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE, table$RuleMemoStart, table$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (table$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(table$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         table$RuleMemoStart = startIndex;
         table$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            table$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            table$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         table$RuleMemoStart = startIndex;
         table$RuleMemoEnd = -1;
         table$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Object : SqlIdentifier
   protected boolean object$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Object", index);
      }
      if (object$RuleMemoStart == index) {
         if (object$RuleMemoStart <= object$RuleMemoEnd) {
            index = object$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OBJECT, object$RuleMemoStart, object$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (object$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(object$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         object$RuleMemoStart = startIndex;
         object$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            object$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OBJECT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            object$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         object$RuleMemoStart = startIndex;
         object$RuleMemoEnd = -1;
         object$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Column : SqlIdentifier
   protected boolean column$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Column", index);
      }
      if (column$RuleMemoStart == index) {
         if (column$RuleMemoStart <= column$RuleMemoEnd) {
            index = column$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMN, column$RuleMemoStart, column$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (column$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(column$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         column$RuleMemoStart = startIndex;
         column$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            column$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            column$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         column$RuleMemoStart = startIndex;
         column$RuleMemoEnd = -1;
         column$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SchemaObjectName : ((Schema '.' OptionalSpacing Object) | Object)
   protected boolean schemaObjectName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SchemaObjectName", index);
      }
      if (schemaObjectName$RuleMemoStart == index) {
         if (schemaObjectName$RuleMemoStart <= schemaObjectName$RuleMemoEnd) {
            index = schemaObjectName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SCHEMA_OBJECT_NAME, schemaObjectName$RuleMemoStart, schemaObjectName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (schemaObjectName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(schemaObjectName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((Schema '.' OptionalSpacing Object) | Object)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (Schema '.' OptionalSpacing Object)
      // Schema
      match = schema$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Object
               match = object$Rule();
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // Object
         match = object$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         schemaObjectName$RuleMemoStart = startIndex;
         schemaObjectName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            schemaObjectName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SCHEMA_OBJECT_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            schemaObjectName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         schemaObjectName$RuleMemoStart = startIndex;
         schemaObjectName$RuleMemoEnd = -1;
         schemaObjectName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnName : ((Schema '.' OptionalSpacing Table '.' OptionalSpacing Column) | (Table '.' OptionalSpacing Column) | Column)
   protected boolean columnName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnName", index);
      }
      if (columnName$RuleMemoStart == index) {
         if (columnName$RuleMemoStart <= columnName$RuleMemoEnd) {
            index = columnName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_NAME, columnName$RuleMemoStart, columnName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (columnName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(columnName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((Schema '.' OptionalSpacing Table '.' OptionalSpacing Column) | (Table '.' OptionalSpacing Column) | Column)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (Schema '.' OptionalSpacing Table '.' OptionalSpacing Column)
      // Schema
      match = schema$Rule();
      if (match) {
         // '.'
         match = charMatcher('.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Table
               match = table$Rule();
               if (match) {
                  // '.'
                  match = charMatcher('.');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Column
                        match = column$Rule();
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (Table '.' OptionalSpacing Column)
         // Table
         match = table$Rule();
         if (match) {
            // '.'
            match = charMatcher('.');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Column
                  match = column$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // Column
            match = column$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         columnName$RuleMemoStart = startIndex;
         columnName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            columnName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            columnName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         columnName$RuleMemoStart = startIndex;
         columnName$RuleMemoEnd = -1;
         columnName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnsList : ('(' OptionalSpacing ColumnName (',' OptionalSpacing ColumnName)* ')' OptionalSpacing)
   protected boolean columnsList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnsList", index);
      }
      if (columnsList$RuleMemoStart == index) {
         if (columnsList$RuleMemoStart <= columnsList$RuleMemoEnd) {
            index = columnsList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMNS_LIST, columnsList$RuleMemoStart, columnsList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (columnsList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(columnsList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ColumnName (',' OptionalSpacing ColumnName)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ColumnName
            match = columnName$Rule();
            if (match) {
               // (',' OptionalSpacing ColumnName)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing ColumnName)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ColumnName
                        match = columnName$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         columnsList$RuleMemoStart = startIndex;
         columnsList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            columnsList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMNS_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            columnsList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         columnsList$RuleMemoStart = startIndex;
         columnsList$RuleMemoEnd = -1;
         columnsList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OnlyQueryTableExpression : ("only" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryTableExpression ')' OptionalSpacing)
   protected boolean onlyQueryTableExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OnlyQueryTableExpression", index);
      }
      if (onlyQueryTableExpression$RuleMemoStart == index) {
         if (onlyQueryTableExpression$RuleMemoStart <= onlyQueryTableExpression$RuleMemoEnd) {
            index = onlyQueryTableExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ONLY_QUERY_TABLE_EXPRESSION, onlyQueryTableExpression$RuleMemoStart, onlyQueryTableExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (onlyQueryTableExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(onlyQueryTableExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("only" TestNoAlpha OptionalSpacing '(' OptionalSpacing QueryTableExpression ')' OptionalSpacing)
      // "only"
      match = ignoreCaseStringMatcher("only", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // QueryTableExpression
                     match = queryTableExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         onlyQueryTableExpression$RuleMemoStart = startIndex;
         onlyQueryTableExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            onlyQueryTableExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ONLY_QUERY_TABLE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            onlyQueryTableExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         onlyQueryTableExpression$RuleMemoStart = startIndex;
         onlyQueryTableExpression$RuleMemoEnd = -1;
         onlyQueryTableExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryTableExpressionPivotClause : (QueryTableExpression PivotClause)
   protected boolean queryTableExpressionPivotClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryTableExpressionPivotClause", index);
      }
      if (queryTableExpressionPivotClause$RuleMemoStart == index) {
         if (queryTableExpressionPivotClause$RuleMemoStart <= queryTableExpressionPivotClause$RuleMemoEnd) {
            index = queryTableExpressionPivotClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION_PIVOT_CLAUSE, queryTableExpressionPivotClause$RuleMemoStart, queryTableExpressionPivotClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (queryTableExpressionPivotClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(queryTableExpressionPivotClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (QueryTableExpression PivotClause)
      // QueryTableExpression
      match = queryTableExpression$Rule();
      if (match) {
         // PivotClause
         match = pivotClause$Rule();
      }
      if (match) {
         queryTableExpressionPivotClause$RuleMemoStart = startIndex;
         queryTableExpressionPivotClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            queryTableExpressionPivotClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION_PIVOT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            queryTableExpressionPivotClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         queryTableExpressionPivotClause$RuleMemoStart = startIndex;
         queryTableExpressionPivotClause$RuleMemoEnd = -1;
         queryTableExpressionPivotClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryTableExpressionUnpivotClause : (QueryTableExpression UnpivotClause)
   protected boolean queryTableExpressionUnpivotClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryTableExpressionUnpivotClause", index);
      }
      if (queryTableExpressionUnpivotClause$RuleMemoStart == index) {
         if (queryTableExpressionUnpivotClause$RuleMemoStart <= queryTableExpressionUnpivotClause$RuleMemoEnd) {
            index = queryTableExpressionUnpivotClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION_UNPIVOT_CLAUSE, queryTableExpressionUnpivotClause$RuleMemoStart, queryTableExpressionUnpivotClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (queryTableExpressionUnpivotClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(queryTableExpressionUnpivotClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (QueryTableExpression UnpivotClause)
      // QueryTableExpression
      match = queryTableExpression$Rule();
      if (match) {
         // UnpivotClause
         match = unpivotClause$Rule();
      }
      if (match) {
         queryTableExpressionUnpivotClause$RuleMemoStart = startIndex;
         queryTableExpressionUnpivotClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            queryTableExpressionUnpivotClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION_UNPIVOT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            queryTableExpressionUnpivotClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         queryTableExpressionUnpivotClause$RuleMemoStart = startIndex;
         queryTableExpressionUnpivotClause$RuleMemoEnd = -1;
         queryTableExpressionUnpivotClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryTableExpressionType : (OnlyQueryTableExpression | QueryTableExpressionPivotClause | QueryTableExpressionUnpivotClause | QueryTableExpression)
   protected boolean queryTableExpressionType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryTableExpressionType", index);
      }
      startIndex = index;
      // (OnlyQueryTableExpression | QueryTableExpressionPivotClause | QueryTableExpressionUnpivotClause | QueryTableExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'O':
         case 'o': {
            // OnlyQueryTableExpression
            match = onlyQueryTableExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // QueryTableExpressionPivotClause
               match = queryTableExpressionPivotClause$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QueryTableExpressionUnpivotClause
                  match = queryTableExpressionUnpivotClause$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // QueryTableExpression
                     match = queryTableExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '(':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // QueryTableExpressionPivotClause
            match = queryTableExpressionPivotClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // QueryTableExpressionUnpivotClause
               match = queryTableExpressionUnpivotClause$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // QueryTableExpression
                  match = queryTableExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_TABLE_EXPRESSION_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TableReference : (QueryTableExpressionType FlashbackQueryClause? SqlIdentifier?)
   protected boolean tableReference$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TableReference", index);
      }
      if (tableReference$RuleMemoStart == index) {
         if (tableReference$RuleMemoStart <= tableReference$RuleMemoEnd) {
            index = tableReference$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_REFERENCE, tableReference$RuleMemoStart, tableReference$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tableReference$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tableReference$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (QueryTableExpressionType FlashbackQueryClause? SqlIdentifier?)
      // QueryTableExpressionType
      match = queryTableExpressionType$Rule();
      if (match) {
         // FlashbackQueryClause?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // FlashbackQueryClause
         match = flashbackQueryClause$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // SqlIdentifier?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // SqlIdentifier
            match = sqlIdentifier$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         tableReference$RuleMemoStart = startIndex;
         tableReference$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tableReference$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_REFERENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tableReference$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tableReference$RuleMemoStart = startIndex;
         tableReference$RuleMemoEnd = -1;
         tableReference$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VersionsBetween : ("versions" TestNoAlpha OptionalSpacing "between" TestNoAlpha OptionalSpacing (("scn" | "timestamp") TestNoAlpha OptionalSpacing) (("minvalue" TestNoAlpha OptionalSpacing) | SqlExpression) "and" TestNoAlpha OptionalSpacing (("maxvalue" TestNoAlpha OptionalSpacing) | SqlExpression))
   protected boolean versionsBetween$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VersionsBetween", index);
      }
      startIndex = index;
      // ("versions" TestNoAlpha OptionalSpacing "between" TestNoAlpha OptionalSpacing (("scn" | "timestamp") TestNoAlpha OptionalSpacing) (("minvalue" TestNoAlpha OptionalSpacing) | SqlExpression) "and" TestNoAlpha OptionalSpacing (("maxvalue" TestNoAlpha OptionalSpacing) | SqlExpression))
      // "versions"
      match = ignoreCaseStringMatcher("versions", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "between"
               match = ignoreCaseStringMatcher("between", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (("scn" | "timestamp") TestNoAlpha OptionalSpacing)
                        // ("scn" | "timestamp")
                        int startIndex_1 = index;
                        switch(buffer.getChar(index)) {
                           case 's':
                           case 'S': {
                              ++index;
                              // "cn"
                              if (match = ignoreCaseStringTest("cn", 2)) {
                                 index += 2;
                              }
                              break;
                           }
                           case 't':
                           case 'T': {
                              ++index;
                              // "imestamp"
                              if (match = ignoreCaseStringTest("imestamp", 8)) {
                                 index += 8;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        if (! match) {
                           index = startIndex_1;
                        } else if(! currentRuleIsAtomic) {
                           currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                           currentNode = currentNode.getSibling();
                        }
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (match) {
                           // (("minvalue" TestNoAlpha OptionalSpacing) | SqlExpression)
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // ("minvalue" TestNoAlpha OptionalSpacing)
                           // "minvalue"
                           match = ignoreCaseStringMatcher("minvalue", 8);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                              }
                           }
                           if (match) {
                              // "and"
                              match = ignoreCaseStringMatcher("and", 3);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // (("maxvalue" TestNoAlpha OptionalSpacing) | SqlExpression)
                                       Node lastNode_3 = currentNode;
                                       int lastIndex_3 = index;
                                       // ("maxvalue" TestNoAlpha OptionalSpacing)
                                       // "maxvalue"
                                       match = ignoreCaseStringMatcher("maxvalue", 8);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_3;
                                          lastNode_3.setSibling(null);
                                          currentNode = lastNode_3;
                                          // SqlExpression
                                          match = sqlExpression$Rule();
                                          if (! match) {
                                             index = lastIndex_3;
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.VERSIONS_BETWEEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FlashbackQueryClause : (VersionsBetween? "as" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing (("scn" | "timestamp") TestNoAlpha OptionalSpacing) SqlExpression)
   protected boolean flashbackQueryClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FlashbackQueryClause", index);
      }
      startIndex = index;
      // (VersionsBetween? "as" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing (("scn" | "timestamp") TestNoAlpha OptionalSpacing) SqlExpression)
      // VersionsBetween?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // VersionsBetween
      match = versionsBetween$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "as"
         match = ignoreCaseStringMatcher("as", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "of"
                  match = ignoreCaseStringMatcher("of", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // (("scn" | "timestamp") TestNoAlpha OptionalSpacing)
                           // ("scn" | "timestamp")
                           int startIndex_2 = index;
                           switch(buffer.getChar(index)) {
                              case 's':
                              case 'S': {
                                 ++index;
                                 // "cn"
                                 if (match = ignoreCaseStringTest("cn", 2)) {
                                    index += 2;
                                 }
                                 break;
                              }
                              case 't':
                              case 'T': {
                                 ++index;
                                 // "imestamp"
                                 if (match = ignoreCaseStringTest("imestamp", 8)) {
                                    index += 8;
                                 }
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                           if (! match) {
                              index = startIndex_2;
                           } else if(! currentRuleIsAtomic) {
                              currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                              currentNode = currentNode.getSibling();
                           }
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FLASHBACK_QUERY_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //EqualityOperator : (('=' OptionalSpacing '>'!) | ('<' OptionalSpacing '>' OptionalSpacing) | ('!' OptionalSpacing '=' OptionalSpacing) | ('^' OptionalSpacing '=' OptionalSpacing) | ('~' OptionalSpacing '=' OptionalSpacing))
   protected boolean equalityOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "EqualityOperator", index);
      }
      startIndex = index;
      // (('=' OptionalSpacing '>'!) | ('<' OptionalSpacing '>' OptionalSpacing) | ('!' OptionalSpacing '=' OptionalSpacing) | ('^' OptionalSpacing '=' OptionalSpacing) | ('~' OptionalSpacing '=' OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('=' OptionalSpacing '>'!)
      // '='
      match = charMatcher('=');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '>'!
            // '>'
            match = buffer.matchChar(index, '>');
            match = ! match;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('<' OptionalSpacing '>' OptionalSpacing)
         // '<'
         match = charMatcher('<');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '>'
               match = charMatcher('>');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('!' OptionalSpacing '=' OptionalSpacing)
            // '!'
            match = charMatcher('!');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '='
                  match = charMatcher('=');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('^' OptionalSpacing '=' OptionalSpacing)
               // '^'
               match = charMatcher('^');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // '='
                     match = charMatcher('=');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('~' OptionalSpacing '=' OptionalSpacing)
                  // '~'
                  match = charMatcher('~');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '='
                        match = charMatcher('=');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EQUALITY_OPERATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RelationalOperator : (('=' OptionalSpacing '>'!) | ('<' OptionalSpacing '>' OptionalSpacing) | ('!' OptionalSpacing '=' OptionalSpacing) | ('^' OptionalSpacing '=' OptionalSpacing) | ('~' OptionalSpacing '=' OptionalSpacing) | ('>' OptionalSpacing '=' OptionalSpacing) | ('<' OptionalSpacing '=' OptionalSpacing) | ('>' OptionalSpacing '='!) | ('<' OptionalSpacing (('=' | '>') OptionalSpacing)!))
   protected boolean relationalOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RelationalOperator", index);
      }
      if (relationalOperator$RuleMemoStart == index) {
         if (relationalOperator$RuleMemoStart <= relationalOperator$RuleMemoEnd) {
            index = relationalOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_OPERATOR, relationalOperator$RuleMemoStart, relationalOperator$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (relationalOperator$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(relationalOperator$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (('=' OptionalSpacing '>'!) | ('<' OptionalSpacing '>' OptionalSpacing) | ('!' OptionalSpacing '=' OptionalSpacing) | ('^' OptionalSpacing '=' OptionalSpacing) | ('~' OptionalSpacing '=' OptionalSpacing) | ('>' OptionalSpacing '=' OptionalSpacing) | ('<' OptionalSpacing '=' OptionalSpacing) | ('>' OptionalSpacing '='!) | ('<' OptionalSpacing (('=' | '>') OptionalSpacing)!))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('=' OptionalSpacing '>'!)
      // '='
      match = charMatcher('=');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '>'!
            // '>'
            match = buffer.matchChar(index, '>');
            match = ! match;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('<' OptionalSpacing '>' OptionalSpacing)
         // '<'
         match = charMatcher('<');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '>'
               match = charMatcher('>');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ('!' OptionalSpacing '=' OptionalSpacing)
            // '!'
            match = charMatcher('!');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '='
                  match = charMatcher('=');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ('^' OptionalSpacing '=' OptionalSpacing)
               // '^'
               match = charMatcher('^');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // '='
                     match = charMatcher('=');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('~' OptionalSpacing '=' OptionalSpacing)
                  // '~'
                  match = charMatcher('~');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '='
                        match = charMatcher('=');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ('>' OptionalSpacing '=' OptionalSpacing)
                     // '>'
                     match = charMatcher('>');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '='
                           match = charMatcher('=');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ('<' OptionalSpacing '=' OptionalSpacing)
                        // '<'
                        match = charMatcher('<');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '='
                              match = charMatcher('=');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ('>' OptionalSpacing '='!)
                           // '>'
                           match = charMatcher('>');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // '='!
                                 // '='
                                 match = buffer.matchChar(index, '=');
                                 match = ! match;
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ('<' OptionalSpacing (('=' | '>') OptionalSpacing)!)
                              // '<'
                              match = charMatcher('<');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // (('=' | '>') OptionalSpacing)!
                                    Node lastNode_2 = currentNode;
                                    int lastIndex_2 = index;
                                    boolean lastAtomic_2 = currentRuleIsAtomic;
                                    // (('=' | '>') OptionalSpacing)
                                    // ('=' | '>')
                                    int startIndex_3 = index;
                                    switch(buffer.getChar(index)) {
                                       case '=': {
                                          ++index;
                                          // <EMPTY>
                                          match = true;
                                          break;
                                       }
                                       case '>': {
                                          ++index;
                                          // <EMPTY>
                                          match = true;
                                          break;
                                       }
                                       default: {
                                          match = false;
                                       }
                                    }
                                    if (! match) {
                                       index = startIndex_3;
                                    } else if(! currentRuleIsAtomic) {
                                       currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                                       currentNode = currentNode.getSibling();
                                    }
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                    currentRuleIsAtomic = lastAtomic_2;
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                    match = ! match;
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         relationalOperator$RuleMemoStart = startIndex;
         relationalOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            relationalOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_OPERATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            relationalOperator$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         relationalOperator$RuleMemoStart = startIndex;
         relationalOperator$RuleMemoEnd = -1;
         relationalOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlCondition : (NotCondition | AndCondition | OrCondition | ConditionExpression)
   protected boolean sqlCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlCondition", index);
      }
      if (sqlCondition$RuleMemoStart == index) {
         if (sqlCondition$RuleMemoStart <= sqlCondition$RuleMemoEnd) {
            index = sqlCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_CONDITION, sqlCondition$RuleMemoStart, sqlCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NotCondition | AndCondition | OrCondition | ConditionExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // AndCondition
            match = andCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OrCondition
               match = orCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ConditionExpression
                  match = conditionExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'N':
         case 'n': {
            // NotCondition
            match = notCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AndCondition
               match = andCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // OrCondition
                  match = orCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ConditionExpression
                     match = conditionExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlCondition$RuleMemoStart = startIndex;
         sqlCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlCondition$RuleMemoStart = startIndex;
         sqlCondition$RuleMemoEnd = -1;
         sqlCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrCondition : (ConditionExpression "or" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean orCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrCondition", index);
      }
      if (orCondition$RuleMemoStart == index) {
         if (orCondition$RuleMemoStart <= orCondition$RuleMemoEnd) {
            index = orCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OR_CONDITION, orCondition$RuleMemoStart, orCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ConditionExpression "or" TestNoAlpha OptionalSpacing SqlCondition)
      // ConditionExpression
      match = conditionExpression$Rule();
      if (match) {
         // "or"
         match = ignoreCaseStringMatcher("or", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlCondition
                  match = sqlCondition$Rule();
               }
            }
         }
      }
      if (match) {
         orCondition$RuleMemoStart = startIndex;
         orCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OR_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         orCondition$RuleMemoStart = startIndex;
         orCondition$RuleMemoEnd = -1;
         orCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AndCondition : (ConditionExpression "and" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean andCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AndCondition", index);
      }
      if (andCondition$RuleMemoStart == index) {
         if (andCondition$RuleMemoStart <= andCondition$RuleMemoEnd) {
            index = andCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AND_CONDITION, andCondition$RuleMemoStart, andCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (andCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(andCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ConditionExpression "and" TestNoAlpha OptionalSpacing SqlCondition)
      // ConditionExpression
      match = conditionExpression$Rule();
      if (match) {
         // "and"
         match = ignoreCaseStringMatcher("and", 3);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlCondition
                  match = sqlCondition$Rule();
               }
            }
         }
      }
      if (match) {
         andCondition$RuleMemoStart = startIndex;
         andCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            andCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AND_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            andCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         andCondition$RuleMemoStart = startIndex;
         andCondition$RuleMemoEnd = -1;
         andCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NotCondition : ("not" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean notCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NotCondition", index);
      }
      if (notCondition$RuleMemoStart == index) {
         if (notCondition$RuleMemoStart <= notCondition$RuleMemoEnd) {
            index = notCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NOT_CONDITION, notCondition$RuleMemoStart, notCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (notCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(notCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("not" TestNoAlpha OptionalSpacing SqlCondition)
      // "not"
      match = ignoreCaseStringMatcher("not", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlCondition
               match = sqlCondition$Rule();
            }
         }
      }
      if (match) {
         notCondition$RuleMemoStart = startIndex;
         notCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            notCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NOT_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            notCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         notCondition$RuleMemoStart = startIndex;
         notCondition$RuleMemoEnd = -1;
         notCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesCondition : ('(' OptionalSpacing SqlCondition ')' OptionalSpacing)
   protected boolean parenthesesCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesCondition", index);
      }
      if (parenthesesCondition$RuleMemoStart == index) {
         if (parenthesesCondition$RuleMemoStart <= parenthesesCondition$RuleMemoEnd) {
            index = parenthesesCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_CONDITION, parenthesesCondition$RuleMemoStart, parenthesesCondition$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (parenthesesCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parenthesesCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlCondition ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlCondition
            match = sqlCondition$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesCondition$RuleMemoStart = startIndex;
         parenthesesCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_CONDITION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parenthesesCondition$RuleMemoStart = startIndex;
         parenthesesCondition$RuleMemoEnd = -1;
         parenthesesCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionExpression : (ExistsCondition | IsCondition | RelationalCondition | RelationalGroupCondition | InCondition | IsASetCondition | IsAnyCondition | IsEmptyCondition | IsOfTypeCondition | IsPresentCondition | LikeCondition | RegexCondition | MemberCondition | BetweenCondition | SubMultiSetCondition | EqualsPathCondition | UnderPathCondition | ParenthesesCondition)
   protected boolean conditionExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionExpression", index);
      }
      if (conditionExpression$RuleMemoStart == index) {
         if (conditionExpression$RuleMemoStart <= conditionExpression$RuleMemoEnd) {
            index = conditionExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONDITION_EXPRESSION, conditionExpression$RuleMemoStart, conditionExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (conditionExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(conditionExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ExistsCondition | IsCondition | RelationalCondition | RelationalGroupCondition | InCondition | IsASetCondition | IsAnyCondition | IsEmptyCondition | IsOfTypeCondition | IsPresentCondition | LikeCondition | RegexCondition | MemberCondition | BetweenCondition | SubMultiSetCondition | EqualsPathCondition | UnderPathCondition | ParenthesesCondition)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case ':':
         case '+':
         case '-':
         case '?': {
            // IsCondition
            match = isCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalCondition
               match = relationalCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalGroupCondition
                  match = relationalGroupCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // InCondition
                     match = inCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsOfTypeCondition
                        match = isOfTypeCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // LikeCondition
                           match = likeCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MemberCondition
                              match = memberCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // BetweenCondition
                                 match = betweenCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'S':
         case 'T':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 's':
         case 't':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // IsCondition
            match = isCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalCondition
               match = relationalCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalGroupCondition
                  match = relationalGroupCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // InCondition
                     match = inCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsASetCondition
                        match = isASetCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IsAnyCondition
                           match = isAnyCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // IsEmptyCondition
                              match = isEmptyCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // IsOfTypeCondition
                                 match = isOfTypeCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IsPresentCondition
                                    match = isPresentCondition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // LikeCondition
                                       match = likeCondition$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // MemberCondition
                                          match = memberCondition$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // BetweenCondition
                                             match = betweenCondition$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // SubMultiSetCondition
                                                match = subMultiSetCondition$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'R':
         case 'r': {
            // IsCondition
            match = isCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalCondition
               match = relationalCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalGroupCondition
                  match = relationalGroupCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // InCondition
                     match = inCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsASetCondition
                        match = isASetCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IsAnyCondition
                           match = isAnyCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // IsEmptyCondition
                              match = isEmptyCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // IsOfTypeCondition
                                 match = isOfTypeCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IsPresentCondition
                                    match = isPresentCondition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // LikeCondition
                                       match = likeCondition$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // RegexCondition
                                          match = regexCondition$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // MemberCondition
                                             match = memberCondition$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // BetweenCondition
                                                match = betweenCondition$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // SubMultiSetCondition
                                                   match = subMultiSetCondition$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'E':
         case 'e': {
            // ExistsCondition
            match = existsCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // IsCondition
               match = isCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalCondition
                  match = relationalCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // RelationalGroupCondition
                     match = relationalGroupCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // InCondition
                        match = inCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IsASetCondition
                           match = isASetCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // IsAnyCondition
                              match = isAnyCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // IsEmptyCondition
                                 match = isEmptyCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IsOfTypeCondition
                                    match = isOfTypeCondition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // IsPresentCondition
                                       match = isPresentCondition$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // LikeCondition
                                          match = likeCondition$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // MemberCondition
                                             match = memberCondition$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // BetweenCondition
                                                match = betweenCondition$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // SubMultiSetCondition
                                                   match = subMultiSetCondition$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // EqualsPathCondition
                                                      match = equalsPathCondition$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'U':
         case 'u': {
            // IsCondition
            match = isCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalCondition
               match = relationalCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalGroupCondition
                  match = relationalGroupCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // InCondition
                     match = inCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsASetCondition
                        match = isASetCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IsAnyCondition
                           match = isAnyCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // IsEmptyCondition
                              match = isEmptyCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // IsOfTypeCondition
                                 match = isOfTypeCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // IsPresentCondition
                                    match = isPresentCondition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // LikeCondition
                                       match = likeCondition$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // MemberCondition
                                          match = memberCondition$Rule();
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             // BetweenCondition
                                             match = betweenCondition$Rule();
                                             if (! match) {
                                                index = lastIndex_1;
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                // SubMultiSetCondition
                                                match = subMultiSetCondition$Rule();
                                                if (! match) {
                                                   index = lastIndex_1;
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   // UnderPathCondition
                                                   match = underPathCondition$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // IsCondition
            match = isCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalCondition
               match = relationalCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RelationalGroupCondition
                  match = relationalGroupCondition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // InCondition
                     match = inCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsOfTypeCondition
                        match = isOfTypeCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // LikeCondition
                           match = likeCondition$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // MemberCondition
                              match = memberCondition$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // BetweenCondition
                                 match = betweenCondition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // ParenthesesCondition
                                    match = parenthesesCondition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         conditionExpression$RuleMemoStart = startIndex;
         conditionExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            conditionExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITION_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            conditionExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         conditionExpression$RuleMemoStart = startIndex;
         conditionExpression$RuleMemoEnd = -1;
         conditionExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExistsCondition : ("exists" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
   protected boolean existsCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExistsCondition", index);
      }
      if (existsCondition$RuleMemoStart == index) {
         if (existsCondition$RuleMemoStart <= existsCondition$RuleMemoEnd) {
            index = existsCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXISTS_CONDITION, existsCondition$RuleMemoStart, existsCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (existsCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(existsCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("exists" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
      // "exists"
      match = ignoreCaseStringMatcher("exists", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Subquery
                     match = subquery$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         existsCondition$RuleMemoStart = startIndex;
         existsCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            existsCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXISTS_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            existsCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         existsCondition$RuleMemoStart = startIndex;
         existsCondition$RuleMemoEnd = -1;
         existsCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Not : ("not" TestNoAlpha OptionalSpacing)
   protected boolean not$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Not", index);
      }
      if (not$RuleMemoStart == index) {
         if (not$RuleMemoStart <= not$RuleMemoEnd) {
            index = not$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NOT, not$RuleMemoStart, not$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (not$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(not$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("not" TestNoAlpha OptionalSpacing)
      // "not"
      match = ignoreCaseStringMatcher("not", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         not$RuleMemoStart = startIndex;
         not$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            not$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NOT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            not$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         not$RuleMemoStart = startIndex;
         not$RuleMemoEnd = -1;
         not$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsConditionOption : (("null" | "nan" | "infinite") TestNoAlpha OptionalSpacing)
   protected boolean isConditionOption$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsConditionOption", index);
      }
      startIndex = index;
      // (("null" | "nan" | "infinite") TestNoAlpha OptionalSpacing)
      // ("null" | "nan" | "infinite")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'n':
         case 'N': {
            ++index;
            // ("ull" | "an")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A': {
                  ++index;
                  // "n"
                  if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                     ++index;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "ll"
                  if (match = ignoreCaseStringTest("ll", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'i':
         case 'I': {
            ++index;
            // "nfinite"
            if (match = ignoreCaseStringTest("nfinite", 7)) {
               index += 7;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_CONDITION_OPTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsCondition : (SqlExpression "is" TestNoAlpha OptionalSpacing Not? IsConditionOption)
   protected boolean isCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsCondition", index);
      }
      if (isCondition$RuleMemoStart == index) {
         if (isCondition$RuleMemoStart <= isCondition$RuleMemoEnd) {
            index = isCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_CONDITION, isCondition$RuleMemoStart, isCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression "is" TestNoAlpha OptionalSpacing Not? IsConditionOption)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Not?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // Not
                  match = not$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // IsConditionOption
                     match = isConditionOption$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         isCondition$RuleMemoStart = startIndex;
         isCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isCondition$RuleMemoStart = startIndex;
         isCondition$RuleMemoEnd = -1;
         isCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Prior : ("prior" TestNoAlpha OptionalSpacing)
   protected boolean prior$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Prior", index);
      }
      if (prior$RuleMemoStart == index) {
         if (prior$RuleMemoStart <= prior$RuleMemoEnd) {
            index = prior$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRIOR, prior$RuleMemoStart, prior$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (prior$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(prior$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("prior" TestNoAlpha OptionalSpacing)
      // "prior"
      match = ignoreCaseStringMatcher("prior", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         prior$RuleMemoStart = startIndex;
         prior$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            prior$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRIOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            prior$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         prior$RuleMemoStart = startIndex;
         prior$RuleMemoEnd = -1;
         prior$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RelationalCondition : (Prior? SqlExpression RelationalOperator Prior? SqlExpression)
   protected boolean relationalCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RelationalCondition", index);
      }
      if (relationalCondition$RuleMemoStart == index) {
         if (relationalCondition$RuleMemoStart <= relationalCondition$RuleMemoEnd) {
            index = relationalCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_CONDITION, relationalCondition$RuleMemoStart, relationalCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (relationalCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(relationalCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Prior? SqlExpression RelationalOperator Prior? SqlExpression)
      // Prior?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Prior
      match = prior$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // SqlExpression
         match = sqlExpression$Rule();
         if (match) {
            // RelationalOperator
            match = relationalOperator$Rule();
            if (match) {
               // Prior?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // Prior
               match = prior$Rule();
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // SqlExpression
                  match = sqlExpression$Rule();
               }
            }
         }
      }
      if (match) {
         relationalCondition$RuleMemoStart = startIndex;
         relationalCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            relationalCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            relationalCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         relationalCondition$RuleMemoStart = startIndex;
         relationalCondition$RuleMemoEnd = -1;
         relationalCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupConditionCoverageType : (("any" | "some" | "all") TestNoAlpha OptionalSpacing)
   protected boolean groupConditionCoverageType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupConditionCoverageType", index);
      }
      if (groupConditionCoverageType$RuleMemoStart == index) {
         if (groupConditionCoverageType$RuleMemoStart <= groupConditionCoverageType$RuleMemoEnd) {
            index = groupConditionCoverageType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GROUP_CONDITION_COVERAGE_TYPE, groupConditionCoverageType$RuleMemoStart, groupConditionCoverageType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (groupConditionCoverageType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(groupConditionCoverageType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("any" | "some" | "all") TestNoAlpha OptionalSpacing)
      // ("any" | "some" | "all")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'a':
         case 'A': {
            ++index;
            // ("ny" | "ll")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // "y"
                  if (match = buffer.matchIgnoreCaseChar(index, 'y')) {
                     ++index;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "l"
                  if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                     ++index;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // "ome"
            if (match = ignoreCaseStringTest("ome", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         groupConditionCoverageType$RuleMemoStart = startIndex;
         groupConditionCoverageType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            groupConditionCoverageType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUP_CONDITION_COVERAGE_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            groupConditionCoverageType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         groupConditionCoverageType$RuleMemoStart = startIndex;
         groupConditionCoverageType$RuleMemoEnd = -1;
         groupConditionCoverageType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //EqualityGroupCondition : (ParenthesesSqlExpressionList EqualityOperator GroupConditionCoverageType? ParenthesesSqlExpressionList)
   protected boolean equalityGroupCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "EqualityGroupCondition", index);
      }
      if (equalityGroupCondition$RuleMemoStart == index) {
         if (equalityGroupCondition$RuleMemoStart <= equalityGroupCondition$RuleMemoEnd) {
            index = equalityGroupCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EQUALITY_GROUP_CONDITION, equalityGroupCondition$RuleMemoStart, equalityGroupCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (equalityGroupCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(equalityGroupCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesSqlExpressionList EqualityOperator GroupConditionCoverageType? ParenthesesSqlExpressionList)
      // ParenthesesSqlExpressionList
      match = parenthesesSqlExpressionList$Rule();
      if (match) {
         // EqualityOperator
         match = equalityOperator$Rule();
         if (match) {
            // GroupConditionCoverageType?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // GroupConditionCoverageType
            match = groupConditionCoverageType$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // ParenthesesSqlExpressionList
               match = parenthesesSqlExpressionList$Rule();
            }
         }
      }
      if (match) {
         equalityGroupCondition$RuleMemoStart = startIndex;
         equalityGroupCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            equalityGroupCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EQUALITY_GROUP_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            equalityGroupCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         equalityGroupCondition$RuleMemoStart = startIndex;
         equalityGroupCondition$RuleMemoEnd = -1;
         equalityGroupCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AnyRelationalGroupCondition : (SqlExpression RelationalOperator GroupConditionCoverageType ParenthesesSqlExpressionList)
   protected boolean anyRelationalGroupCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AnyRelationalGroupCondition", index);
      }
      if (anyRelationalGroupCondition$RuleMemoStart == index) {
         if (anyRelationalGroupCondition$RuleMemoStart <= anyRelationalGroupCondition$RuleMemoEnd) {
            index = anyRelationalGroupCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ANY_RELATIONAL_GROUP_CONDITION, anyRelationalGroupCondition$RuleMemoStart, anyRelationalGroupCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (anyRelationalGroupCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anyRelationalGroupCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression RelationalOperator GroupConditionCoverageType ParenthesesSqlExpressionList)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // RelationalOperator
         match = relationalOperator$Rule();
         if (match) {
            // GroupConditionCoverageType
            match = groupConditionCoverageType$Rule();
            if (match) {
               // ParenthesesSqlExpressionList
               match = parenthesesSqlExpressionList$Rule();
            }
         }
      }
      if (match) {
         anyRelationalGroupCondition$RuleMemoStart = startIndex;
         anyRelationalGroupCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyRelationalGroupCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ANY_RELATIONAL_GROUP_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyRelationalGroupCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         anyRelationalGroupCondition$RuleMemoStart = startIndex;
         anyRelationalGroupCondition$RuleMemoEnd = -1;
         anyRelationalGroupCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RelationalGroupCondition : (EqualityGroupCondition | AnyRelationalGroupCondition)
   protected boolean relationalGroupCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RelationalGroupCondition", index);
      }
      if (relationalGroupCondition$RuleMemoStart == index) {
         if (relationalGroupCondition$RuleMemoStart <= relationalGroupCondition$RuleMemoEnd) {
            index = relationalGroupCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_GROUP_CONDITION, relationalGroupCondition$RuleMemoStart, relationalGroupCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (relationalGroupCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(relationalGroupCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (EqualityGroupCondition | AnyRelationalGroupCondition)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // AnyRelationalGroupCondition
            match = anyRelationalGroupCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // EqualityGroupCondition
            match = equalityGroupCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AnyRelationalGroupCondition
               match = anyRelationalGroupCondition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         relationalGroupCondition$RuleMemoStart = startIndex;
         relationalGroupCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            relationalGroupCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_GROUP_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            relationalGroupCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         relationalGroupCondition$RuleMemoStart = startIndex;
         relationalGroupCondition$RuleMemoEnd = -1;
         relationalGroupCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //inExpressionList : (ParenthesesSqlExpressionList | SqlExpression)
   protected boolean inExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "inExpressionList", index);
      }
      startIndex = index;
      // (ParenthesesSqlExpressionList | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlExpression
            match = sqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // ParenthesesSqlExpressionList
            match = parenthesesSqlExpressionList$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IN_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InCondition : (inExpressionList Not? "in" TestNoAlpha OptionalSpacing (ParenthesesSqlExpressionList | SqlObjectIdentifier))
   protected boolean inCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InCondition", index);
      }
      if (inCondition$RuleMemoStart == index) {
         if (inCondition$RuleMemoStart <= inCondition$RuleMemoEnd) {
            index = inCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IN_CONDITION, inCondition$RuleMemoStart, inCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (inCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(inCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (inExpressionList Not? "in" TestNoAlpha OptionalSpacing (ParenthesesSqlExpressionList | SqlObjectIdentifier))
      // inExpressionList
      match = inExpressionList$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "in"
            match = ignoreCaseStringMatcher("in", 2);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (ParenthesesSqlExpressionList | SqlObjectIdentifier)
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     switch(buffer.getChar(index)) {
                        case '\"':
                        case '#':
                        case '$':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'O':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'o':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // SqlObjectIdentifier
                           match = sqlObjectIdentifier$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                           break;
                        }
                        case '(': {
                           // ParenthesesSqlExpressionList
                           match = parenthesesSqlExpressionList$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         inCondition$RuleMemoStart = startIndex;
         inCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IN_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         inCondition$RuleMemoStart = startIndex;
         inCondition$RuleMemoEnd = -1;
         inCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsASetCondition : (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing Not? "a" TestNoAlpha OptionalSpacing "set" TestNoAlpha OptionalSpacing)
   protected boolean isASetCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsASetCondition", index);
      }
      if (isASetCondition$RuleMemoStart == index) {
         if (isASetCondition$RuleMemoStart <= isASetCondition$RuleMemoEnd) {
            index = isASetCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_ASET_CONDITION, isASetCondition$RuleMemoStart, isASetCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isASetCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isASetCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing Not? "a" TestNoAlpha OptionalSpacing "set" TestNoAlpha OptionalSpacing)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Not?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // Not
                  match = not$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // "a"
                     match = ignoreCaseCharMatcher('a');
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "set"
                              match = ignoreCaseStringMatcher("set", 3);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         isASetCondition$RuleMemoStart = startIndex;
         isASetCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isASetCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_ASET_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isASetCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isASetCondition$RuleMemoStart = startIndex;
         isASetCondition$RuleMemoEnd = -1;
         isASetCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ObjectIs : (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing)
   protected boolean objectIs$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ObjectIs", index);
      }
      if (objectIs$RuleMemoStart == index) {
         if (objectIs$RuleMemoStart <= objectIs$RuleMemoEnd) {
            index = objectIs$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OBJECT_IS, objectIs$RuleMemoStart, objectIs$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (objectIs$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(objectIs$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         objectIs$RuleMemoStart = startIndex;
         objectIs$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            objectIs$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OBJECT_IS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            objectIs$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         objectIs$RuleMemoStart = startIndex;
         objectIs$RuleMemoEnd = -1;
         objectIs$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsAnyCondition : (ObjectIs? "any" TestNoAlpha OptionalSpacing)
   protected boolean isAnyCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsAnyCondition", index);
      }
      if (isAnyCondition$RuleMemoStart == index) {
         if (isAnyCondition$RuleMemoStart <= isAnyCondition$RuleMemoEnd) {
            index = isAnyCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_ANY_CONDITION, isAnyCondition$RuleMemoStart, isAnyCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isAnyCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isAnyCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ObjectIs? "any" TestNoAlpha OptionalSpacing)
      // ObjectIs?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ObjectIs
      match = objectIs$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "any"
         match = ignoreCaseStringMatcher("any", 3);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         isAnyCondition$RuleMemoStart = startIndex;
         isAnyCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isAnyCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_ANY_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isAnyCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isAnyCondition$RuleMemoStart = startIndex;
         isAnyCondition$RuleMemoEnd = -1;
         isAnyCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsEmptyCondition : (ObjectIs Not? "empty" TestNoAlpha OptionalSpacing)
   protected boolean isEmptyCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsEmptyCondition", index);
      }
      if (isEmptyCondition$RuleMemoStart == index) {
         if (isEmptyCondition$RuleMemoStart <= isEmptyCondition$RuleMemoEnd) {
            index = isEmptyCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_EMPTY_CONDITION, isEmptyCondition$RuleMemoStart, isEmptyCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isEmptyCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isEmptyCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ObjectIs Not? "empty" TestNoAlpha OptionalSpacing)
      // ObjectIs
      match = objectIs$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "empty"
            match = ignoreCaseStringMatcher("empty", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         isEmptyCondition$RuleMemoStart = startIndex;
         isEmptyCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isEmptyCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_EMPTY_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isEmptyCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isEmptyCondition$RuleMemoStart = startIndex;
         isEmptyCondition$RuleMemoEnd = -1;
         isEmptyCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsOfTypeCondition : (SqlExpression "is" TestNoAlpha OptionalSpacing Not? "of" TestNoAlpha OptionalSpacing ("type" TestNoAlpha OptionalSpacing)? '(' OptionalSpacing IsOfTypeList ')' OptionalSpacing)
   protected boolean isOfTypeCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsOfTypeCondition", index);
      }
      if (isOfTypeCondition$RuleMemoStart == index) {
         if (isOfTypeCondition$RuleMemoStart <= isOfTypeCondition$RuleMemoEnd) {
            index = isOfTypeCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_OF_TYPE_CONDITION, isOfTypeCondition$RuleMemoStart, isOfTypeCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isOfTypeCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isOfTypeCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression "is" TestNoAlpha OptionalSpacing Not? "of" TestNoAlpha OptionalSpacing ("type" TestNoAlpha OptionalSpacing)? '(' OptionalSpacing IsOfTypeList ')' OptionalSpacing)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Not?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // Not
                  match = not$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // "of"
                     match = ignoreCaseStringMatcher("of", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // ("type" TestNoAlpha OptionalSpacing)?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // ("type" TestNoAlpha OptionalSpacing)
                              // "type"
                              match = ignoreCaseStringMatcher("type", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                              if (match) {
                                 // '('
                                 match = charMatcher('(');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // IsOfTypeList
                                       match = isOfTypeList$Rule();
                                       if (match) {
                                          // ')'
                                          match = charMatcher(')');
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         isOfTypeCondition$RuleMemoStart = startIndex;
         isOfTypeCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isOfTypeCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_OF_TYPE_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isOfTypeCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isOfTypeCondition$RuleMemoStart = startIndex;
         isOfTypeCondition$RuleMemoEnd = -1;
         isOfTypeCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Only : ("only" TestNoAlpha OptionalSpacing)
   protected boolean only$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Only", index);
      }
      startIndex = index;
      // ("only" TestNoAlpha OptionalSpacing)
      // "only"
      match = ignoreCaseStringMatcher("only", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ONLY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsTypeOfObject : (Only? SqlObjectIdentifier)
   protected boolean isTypeOfObject$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsTypeOfObject", index);
      }
      if (isTypeOfObject$RuleMemoStart == index) {
         if (isTypeOfObject$RuleMemoStart <= isTypeOfObject$RuleMemoEnd) {
            index = isTypeOfObject$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_TYPE_OF_OBJECT, isTypeOfObject$RuleMemoStart, isTypeOfObject$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isTypeOfObject$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isTypeOfObject$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Only? SqlObjectIdentifier)
      // Only?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Only
      match = only$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // SqlObjectIdentifier
         match = sqlObjectIdentifier$Rule();
      }
      if (match) {
         isTypeOfObject$RuleMemoStart = startIndex;
         isTypeOfObject$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isTypeOfObject$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_TYPE_OF_OBJECT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isTypeOfObject$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isTypeOfObject$RuleMemoStart = startIndex;
         isTypeOfObject$RuleMemoEnd = -1;
         isTypeOfObject$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsOfTypeList : (IsTypeOfObject (',' OptionalSpacing IsTypeOfObject)*)
   protected boolean isOfTypeList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsOfTypeList", index);
      }
      startIndex = index;
      // (IsTypeOfObject (',' OptionalSpacing IsTypeOfObject)*)
      // IsTypeOfObject
      match = isTypeOfObject$Rule();
      if (match) {
         // (',' OptionalSpacing IsTypeOfObject)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing IsTypeOfObject)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // IsTypeOfObject
                  match = isTypeOfObject$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_OF_TYPE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsPresentCondition : (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing "present" TestNoAlpha OptionalSpacing)
   protected boolean isPresentCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsPresentCondition", index);
      }
      if (isPresentCondition$RuleMemoStart == index) {
         if (isPresentCondition$RuleMemoStart <= isPresentCondition$RuleMemoEnd) {
            index = isPresentCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_PRESENT_CONDITION, isPresentCondition$RuleMemoStart, isPresentCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isPresentCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isPresentCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier "is" TestNoAlpha OptionalSpacing "present" TestNoAlpha OptionalSpacing)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "present"
                  match = ignoreCaseStringMatcher("present", 7);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         isPresentCondition$RuleMemoStart = startIndex;
         isPresentCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isPresentCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_PRESENT_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isPresentCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isPresentCondition$RuleMemoStart = startIndex;
         isPresentCondition$RuleMemoEnd = -1;
         isPresentCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LikeOperator : (("like" TestNoAlpha OptionalSpacing) | ("likec" TestNoAlpha OptionalSpacing) | ("like2" OptionalSpacing) | ("like4" OptionalSpacing))
   protected boolean likeOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LikeOperator", index);
      }
      startIndex = index;
      // (("like" TestNoAlpha OptionalSpacing) | ("likec" TestNoAlpha OptionalSpacing) | ("like2" OptionalSpacing) | ("like4" OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("like" TestNoAlpha OptionalSpacing)
      // "like"
      match = ignoreCaseStringMatcher("like", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("likec" TestNoAlpha OptionalSpacing)
         // "likec"
         match = ignoreCaseStringMatcher("likec", 5);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("like2" OptionalSpacing)
            // "like2"
            match = ignoreCaseStringMatcher("like2", 5);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("like4" OptionalSpacing)
               // "like4"
               match = ignoreCaseStringMatcher("like4", 5);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.LIKE_OPERATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Escape : ("escape" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean escape$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Escape", index);
      }
      startIndex = index;
      // ("escape" TestNoAlpha OptionalSpacing SqlExpression)
      // "escape"
      match = ignoreCaseStringMatcher("escape", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ESCAPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LikeCondition : (SqlExpression Not? LikeOperator SqlExpression Escape?)
   protected boolean likeCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LikeCondition", index);
      }
      if (likeCondition$RuleMemoStart == index) {
         if (likeCondition$RuleMemoStart <= likeCondition$RuleMemoEnd) {
            index = likeCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LIKE_CONDITION, likeCondition$RuleMemoStart, likeCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (likeCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(likeCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression Not? LikeOperator SqlExpression Escape?)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // LikeOperator
            match = likeOperator$Rule();
            if (match) {
               // SqlExpression
               match = sqlExpression$Rule();
               if (match) {
                  // Escape?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Escape
                  match = escape$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         likeCondition$RuleMemoStart = startIndex;
         likeCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            likeCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LIKE_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            likeCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         likeCondition$RuleMemoStart = startIndex;
         likeCondition$RuleMemoEnd = -1;
         likeCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MatchParam : (',' OptionalSpacing StringLiteral)
   protected boolean matchParam$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MatchParam", index);
      }
      startIndex = index;
      // (',' OptionalSpacing StringLiteral)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // StringLiteral
            match = stringLiteral$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MATCH_PARAM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RegexCondition : ("regexp_like" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing SqlExpression MatchParam? ')' OptionalSpacing)
   protected boolean regexCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RegexCondition", index);
      }
      if (regexCondition$RuleMemoStart == index) {
         if (regexCondition$RuleMemoStart <= regexCondition$RuleMemoEnd) {
            index = regexCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.REGEX_CONDITION, regexCondition$RuleMemoStart, regexCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (regexCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(regexCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("regexp_like" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ',' OptionalSpacing SqlExpression MatchParam? ')' OptionalSpacing)
      // "regexp_like"
      match = ignoreCaseStringMatcher("regexp_like", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlExpression
                              match = sqlExpression$Rule();
                              if (match) {
                                 // MatchParam?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // MatchParam
                                 match = matchParam$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         regexCondition$RuleMemoStart = startIndex;
         regexCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            regexCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.REGEX_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            regexCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         regexCondition$RuleMemoStart = startIndex;
         regexCondition$RuleMemoEnd = -1;
         regexCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MemberCondition : (SqlExpression Not? "member" TestNoAlpha OptionalSpacing ("of" TestNoAlpha OptionalSpacing)? SqlObjectIdentifier)
   protected boolean memberCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MemberCondition", index);
      }
      if (memberCondition$RuleMemoStart == index) {
         if (memberCondition$RuleMemoStart <= memberCondition$RuleMemoEnd) {
            index = memberCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MEMBER_CONDITION, memberCondition$RuleMemoStart, memberCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (memberCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(memberCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression Not? "member" TestNoAlpha OptionalSpacing ("of" TestNoAlpha OptionalSpacing)? SqlObjectIdentifier)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "member"
            match = ignoreCaseStringMatcher("member", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ("of" TestNoAlpha OptionalSpacing)?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ("of" TestNoAlpha OptionalSpacing)
                     // "of"
                     match = ignoreCaseStringMatcher("of", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                     if (match) {
                        // SqlObjectIdentifier
                        match = sqlObjectIdentifier$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         memberCondition$RuleMemoStart = startIndex;
         memberCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            memberCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MEMBER_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            memberCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         memberCondition$RuleMemoStart = startIndex;
         memberCondition$RuleMemoEnd = -1;
         memberCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BetweenCondition : (SqlExpression Not? "between" TestNoAlpha OptionalSpacing SqlExpression "and" TestNoAlpha OptionalSpacing SqlExpression)
   protected boolean betweenCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BetweenCondition", index);
      }
      if (betweenCondition$RuleMemoStart == index) {
         if (betweenCondition$RuleMemoStart <= betweenCondition$RuleMemoEnd) {
            index = betweenCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_CONDITION, betweenCondition$RuleMemoStart, betweenCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (betweenCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(betweenCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression Not? "between" TestNoAlpha OptionalSpacing SqlExpression "and" TestNoAlpha OptionalSpacing SqlExpression)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "between"
            match = ignoreCaseStringMatcher("between", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // "and"
                        match = ignoreCaseStringMatcher("and", 3);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlExpression
                                 match = sqlExpression$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         betweenCondition$RuleMemoStart = startIndex;
         betweenCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            betweenCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            betweenCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         betweenCondition$RuleMemoStart = startIndex;
         betweenCondition$RuleMemoEnd = -1;
         betweenCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubMultiSetCondition : (SqlObjectIdentifier Not? "ubmultiset" TestNoAlpha OptionalSpacing ("of" TestNoAlpha OptionalSpacing)? SqlObjectIdentifier)
   protected boolean subMultiSetCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubMultiSetCondition", index);
      }
      if (subMultiSetCondition$RuleMemoStart == index) {
         if (subMultiSetCondition$RuleMemoStart <= subMultiSetCondition$RuleMemoEnd) {
            index = subMultiSetCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUB_MULTI_SET_CONDITION, subMultiSetCondition$RuleMemoStart, subMultiSetCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subMultiSetCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subMultiSetCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier Not? "ubmultiset" TestNoAlpha OptionalSpacing ("of" TestNoAlpha OptionalSpacing)? SqlObjectIdentifier)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "ubmultiset"
            match = ignoreCaseStringMatcher("ubmultiset", 10);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ("of" TestNoAlpha OptionalSpacing)?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ("of" TestNoAlpha OptionalSpacing)
                     // "of"
                     match = ignoreCaseStringMatcher("of", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                     if (match) {
                        // SqlObjectIdentifier
                        match = sqlObjectIdentifier$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         subMultiSetCondition$RuleMemoStart = startIndex;
         subMultiSetCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subMultiSetCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUB_MULTI_SET_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subMultiSetCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subMultiSetCondition$RuleMemoStart = startIndex;
         subMultiSetCondition$RuleMemoEnd = -1;
         subMultiSetCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CorrelationInteger : (',' OptionalSpacing IntegerLiteral)
   protected boolean correlationInteger$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CorrelationInteger", index);
      }
      if (correlationInteger$RuleMemoStart == index) {
         if (correlationInteger$RuleMemoStart <= correlationInteger$RuleMemoEnd) {
            index = correlationInteger$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CORRELATION_INTEGER, correlationInteger$RuleMemoStart, correlationInteger$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (correlationInteger$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(correlationInteger$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (',' OptionalSpacing IntegerLiteral)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IntegerLiteral
            match = integerLiteral$Rule();
         }
      }
      if (match) {
         correlationInteger$RuleMemoStart = startIndex;
         correlationInteger$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            correlationInteger$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CORRELATION_INTEGER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            correlationInteger$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         correlationInteger$RuleMemoStart = startIndex;
         correlationInteger$RuleMemoEnd = -1;
         correlationInteger$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //EqualsPathCondition : ("equals_path" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier ',' OptionalSpacing IdentifierOrStringLiteral CorrelationInteger? ')' OptionalSpacing)
   protected boolean equalsPathCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "EqualsPathCondition", index);
      }
      if (equalsPathCondition$RuleMemoStart == index) {
         if (equalsPathCondition$RuleMemoStart <= equalsPathCondition$RuleMemoEnd) {
            index = equalsPathCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EQUALS_PATH_CONDITION, equalsPathCondition$RuleMemoStart, equalsPathCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (equalsPathCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(equalsPathCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("equals_path" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier ',' OptionalSpacing IdentifierOrStringLiteral CorrelationInteger? ')' OptionalSpacing)
      // "equals_path"
      match = ignoreCaseStringMatcher("equals_path", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (match) {
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // IdentifierOrStringLiteral
                              match = identifierOrStringLiteral$Rule();
                              if (match) {
                                 // CorrelationInteger?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // CorrelationInteger
                                 match = correlationInteger$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         equalsPathCondition$RuleMemoStart = startIndex;
         equalsPathCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            equalsPathCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EQUALS_PATH_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            equalsPathCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         equalsPathCondition$RuleMemoStart = startIndex;
         equalsPathCondition$RuleMemoEnd = -1;
         equalsPathCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnderPathLevels : (',' OptionalSpacing IntegerLiteral)
   protected boolean underPathLevels$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnderPathLevels", index);
      }
      startIndex = index;
      // (',' OptionalSpacing IntegerLiteral)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IntegerLiteral
            match = integerLiteral$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNDER_PATH_LEVELS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnderPathCondition : ("under_path" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier UnderPathLevels? ',' OptionalSpacing IdentifierOrStringLiteral CorrelationInteger ')' OptionalSpacing)
   protected boolean underPathCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnderPathCondition", index);
      }
      if (underPathCondition$RuleMemoStart == index) {
         if (underPathCondition$RuleMemoStart <= underPathCondition$RuleMemoEnd) {
            index = underPathCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UNDER_PATH_CONDITION, underPathCondition$RuleMemoStart, underPathCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (underPathCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(underPathCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("under_path" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier UnderPathLevels? ',' OptionalSpacing IdentifierOrStringLiteral CorrelationInteger ')' OptionalSpacing)
      // "under_path"
      match = ignoreCaseStringMatcher("under_path", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (match) {
                        // UnderPathLevels?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // UnderPathLevels
                        match = underPathLevels$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ','
                           match = charMatcher(',');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // IdentifierOrStringLiteral
                                 match = identifierOrStringLiteral$Rule();
                                 if (match) {
                                    // CorrelationInteger
                                    match = correlationInteger$Rule();
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         underPathCondition$RuleMemoStart = startIndex;
         underPathCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            underPathCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UNDER_PATH_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            underPathCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         underPathCondition$RuleMemoStart = startIndex;
         underPathCondition$RuleMemoEnd = -1;
         underPathCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IdentifierOrStringLiteral : (StringLiteral | SqlIdentifier)
   protected boolean identifierOrStringLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IdentifierOrStringLiteral", index);
      }
      if (identifierOrStringLiteral$RuleMemoStart == index) {
         if (identifierOrStringLiteral$RuleMemoStart <= identifierOrStringLiteral$RuleMemoEnd) {
            index = identifierOrStringLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_OR_STRING_LITERAL, identifierOrStringLiteral$RuleMemoStart, identifierOrStringLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (identifierOrStringLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(identifierOrStringLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (StringLiteral | SqlIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'N':
         case 'n': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlIdentifier
               match = sqlIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlIdentifier
            match = sqlIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\'': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         identifierOrStringLiteral$RuleMemoStart = startIndex;
         identifierOrStringLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierOrStringLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_OR_STRING_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifierOrStringLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         identifierOrStringLiteral$RuleMemoStart = startIndex;
         identifierOrStringLiteral$RuleMemoEnd = -1;
         identifierOrStringLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OnCondition : ("on" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean onCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OnCondition", index);
      }
      if (onCondition$RuleMemoStart == index) {
         if (onCondition$RuleMemoStart <= onCondition$RuleMemoEnd) {
            index = onCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ON_CONDITION, onCondition$RuleMemoStart, onCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (onCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(onCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("on" TestNoAlpha OptionalSpacing SqlCondition)
      // "on"
      match = ignoreCaseStringMatcher("on", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlCondition
               match = sqlCondition$Rule();
            }
         }
      }
      if (match) {
         onCondition$RuleMemoStart = startIndex;
         onCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            onCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ON_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            onCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         onCondition$RuleMemoStart = startIndex;
         onCondition$RuleMemoEnd = -1;
         onCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Using : ("using" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing)
   protected boolean using$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Using", index);
      }
      if (using$RuleMemoStart == index) {
         if (using$RuleMemoStart <= using$RuleMemoEnd) {
            index = using$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.USING, using$RuleMemoStart, using$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (using$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(using$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("using" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing)
      // "using"
      match = ignoreCaseStringMatcher("using", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlIdentifierList
                     match = sqlIdentifierList$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         using$RuleMemoStart = startIndex;
         using$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            using$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.USING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            using$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         using$RuleMemoStart = startIndex;
         using$RuleMemoEnd = -1;
         using$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InnerCrossJoinClause : ((("inner" TestNoAlpha OptionalSpacing)? "join" TestNoAlpha OptionalSpacing TableReference (OnCondition | Using)) | ((("cross" TestNoAlpha OptionalSpacing) | ("natural" TestNoAlpha OptionalSpacing ("inner" TestNoAlpha OptionalSpacing)?)) "join" TestNoAlpha OptionalSpacing TableReference))
   protected boolean innerCrossJoinClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InnerCrossJoinClause", index);
      }
      if (innerCrossJoinClause$RuleMemoStart == index) {
         if (innerCrossJoinClause$RuleMemoStart <= innerCrossJoinClause$RuleMemoEnd) {
            index = innerCrossJoinClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INNER_CROSS_JOIN_CLAUSE, innerCrossJoinClause$RuleMemoStart, innerCrossJoinClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (innerCrossJoinClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(innerCrossJoinClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("inner" TestNoAlpha OptionalSpacing)? "join" TestNoAlpha OptionalSpacing TableReference (OnCondition | Using)) | ((("cross" TestNoAlpha OptionalSpacing) | ("natural" TestNoAlpha OptionalSpacing ("inner" TestNoAlpha OptionalSpacing)?)) "join" TestNoAlpha OptionalSpacing TableReference))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (("inner" TestNoAlpha OptionalSpacing)? "join" TestNoAlpha OptionalSpacing TableReference (OnCondition | Using))
      // ("inner" TestNoAlpha OptionalSpacing)?
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ("inner" TestNoAlpha OptionalSpacing)
      // "inner"
      match = ignoreCaseStringMatcher("inner", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      }
      if (match) {
         // "join"
         match = ignoreCaseStringMatcher("join", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // TableReference
                  match = tableReference$Rule();
                  if (match) {
                     // (OnCondition | Using)
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     switch(buffer.getChar(index)) {
                        case 'o':
                        case 'O': {
                           // OnCondition
                           match = onCondition$Rule();
                           if (! match) {
                              index = lastIndex_3;
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                           }
                           break;
                        }
                        case 'u':
                        case 'U': {
                           // Using
                           match = using$Rule();
                           if (! match) {
                              index = lastIndex_3;
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ((("cross" TestNoAlpha OptionalSpacing) | ("natural" TestNoAlpha OptionalSpacing ("inner" TestNoAlpha OptionalSpacing)?)) "join" TestNoAlpha OptionalSpacing TableReference)
         // (("cross" TestNoAlpha OptionalSpacing) | ("natural" TestNoAlpha OptionalSpacing ("inner" TestNoAlpha OptionalSpacing)?))
         Node lastNode_4 = currentNode;
         int lastIndex_4 = index;
         // ("cross" TestNoAlpha OptionalSpacing)
         // "cross"
         match = ignoreCaseStringMatcher("cross", 5);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_4;
            lastNode_4.setSibling(null);
            currentNode = lastNode_4;
            // ("natural" TestNoAlpha OptionalSpacing ("inner" TestNoAlpha OptionalSpacing)?)
            // "natural"
            match = ignoreCaseStringMatcher("natural", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ("inner" TestNoAlpha OptionalSpacing)?
                     Node lastNode_5 = currentNode;
                     int lastIndex_5 = index;
                     // ("inner" TestNoAlpha OptionalSpacing)
                     // "inner"
                     match = ignoreCaseStringMatcher("inner", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                        index = lastIndex_5;
                        match = true;
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_4;
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
            }
         }
         if (match) {
            // "join"
            match = ignoreCaseStringMatcher("join", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // TableReference
                     match = tableReference$Rule();
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         innerCrossJoinClause$RuleMemoStart = startIndex;
         innerCrossJoinClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            innerCrossJoinClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INNER_CROSS_JOIN_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            innerCrossJoinClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         innerCrossJoinClause$RuleMemoStart = startIndex;
         innerCrossJoinClause$RuleMemoEnd = -1;
         innerCrossJoinClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NaturalOuterJoin : ("natural" TestNoAlpha OptionalSpacing OuterJoinType? "join" TestNoAlpha OptionalSpacing)
   protected boolean naturalOuterJoin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NaturalOuterJoin", index);
      }
      if (naturalOuterJoin$RuleMemoStart == index) {
         if (naturalOuterJoin$RuleMemoStart <= naturalOuterJoin$RuleMemoEnd) {
            index = naturalOuterJoin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NATURAL_OUTER_JOIN, naturalOuterJoin$RuleMemoStart, naturalOuterJoin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (naturalOuterJoin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(naturalOuterJoin$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("natural" TestNoAlpha OptionalSpacing OuterJoinType? "join" TestNoAlpha OptionalSpacing)
      // "natural"
      match = ignoreCaseStringMatcher("natural", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // OuterJoinType?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // OuterJoinType
               match = outerJoinType$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // "join"
                  match = ignoreCaseStringMatcher("join", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         naturalOuterJoin$RuleMemoStart = startIndex;
         naturalOuterJoin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            naturalOuterJoin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NATURAL_OUTER_JOIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            naturalOuterJoin$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         naturalOuterJoin$RuleMemoStart = startIndex;
         naturalOuterJoin$RuleMemoEnd = -1;
         naturalOuterJoin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NormalOuterJoin : (OuterJoinType "join" TestNoAlpha OptionalSpacing)
   protected boolean normalOuterJoin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NormalOuterJoin", index);
      }
      if (normalOuterJoin$RuleMemoStart == index) {
         if (normalOuterJoin$RuleMemoStart <= normalOuterJoin$RuleMemoEnd) {
            index = normalOuterJoin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NORMAL_OUTER_JOIN, normalOuterJoin$RuleMemoStart, normalOuterJoin$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (normalOuterJoin$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(normalOuterJoin$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (OuterJoinType "join" TestNoAlpha OptionalSpacing)
      // OuterJoinType
      match = outerJoinType$Rule();
      if (match) {
         // "join"
         match = ignoreCaseStringMatcher("join", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         normalOuterJoin$RuleMemoStart = startIndex;
         normalOuterJoin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            normalOuterJoin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NORMAL_OUTER_JOIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            normalOuterJoin$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         normalOuterJoin$RuleMemoStart = startIndex;
         normalOuterJoin$RuleMemoEnd = -1;
         normalOuterJoin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OuterJoinClause : (QueryPartitionClause? (NaturalOuterJoin | NormalOuterJoin) TableReference QueryPartitionClause? (OnCondition | Using))
   protected boolean outerJoinClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OuterJoinClause", index);
      }
      if (outerJoinClause$RuleMemoStart == index) {
         if (outerJoinClause$RuleMemoStart <= outerJoinClause$RuleMemoEnd) {
            index = outerJoinClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_CLAUSE, outerJoinClause$RuleMemoStart, outerJoinClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (outerJoinClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(outerJoinClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (QueryPartitionClause? (NaturalOuterJoin | NormalOuterJoin) TableReference QueryPartitionClause? (OnCondition | Using))
      // QueryPartitionClause?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // QueryPartitionClause
      match = queryPartitionClause$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // (NaturalOuterJoin | NormalOuterJoin)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case 'r':
            case 'R':
            case 'f':
            case 'F':
            case 'l':
            case 'L': {
               // NormalOuterJoin
               match = normalOuterJoin$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'n':
            case 'N': {
               // NaturalOuterJoin
               match = naturalOuterJoin$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            default: {
               match = false;
            }
         }
         if (match) {
            // TableReference
            match = tableReference$Rule();
            if (match) {
               // QueryPartitionClause?
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // QueryPartitionClause
               match = queryPartitionClause$Rule();
               if (! match) {
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  match = true;
               }
               if (match) {
                  // (OnCondition | Using)
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  switch(buffer.getChar(index)) {
                     case 'o':
                     case 'O': {
                        // OnCondition
                        match = onCondition$Rule();
                        if (! match) {
                           index = lastIndex_4;
                           lastNode_4.setSibling(null);
                           currentNode = lastNode_4;
                        }
                        break;
                     }
                     case 'u':
                     case 'U': {
                        // Using
                        match = using$Rule();
                        if (! match) {
                           index = lastIndex_4;
                           lastNode_4.setSibling(null);
                           currentNode = lastNode_4;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         outerJoinClause$RuleMemoStart = startIndex;
         outerJoinClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            outerJoinClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            outerJoinClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         outerJoinClause$RuleMemoStart = startIndex;
         outerJoinClause$RuleMemoEnd = -1;
         outerJoinClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //JoinClauseType : (InnerCrossJoinClause | OuterJoinClause)
   protected boolean joinClauseType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "JoinClauseType", index);
      }
      startIndex = index;
      // (InnerCrossJoinClause | OuterJoinClause)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'p':
         case 'P':
         case 'r':
         case 'R':
         case 'f':
         case 'F':
         case 'l':
         case 'L': {
            // OuterJoinClause
            match = outerJoinClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'n':
         case 'N': {
            // InnerCrossJoinClause
            match = innerCrossJoinClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // OuterJoinClause
               match = outerJoinClause$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'c':
         case 'C':
         case 'i':
         case 'I':
         case 'j':
         case 'J': {
            // InnerCrossJoinClause
            match = innerCrossJoinClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.JOIN_CLAUSE_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //JoinClause : JoinClauseType*
   protected boolean joinClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "JoinClause", index);
      }
      startIndex = index;
      // JoinClauseType*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // JoinClauseType
         match = joinClauseType$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(OracleScriptRuleType.JOIN_CLAUSE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //OuterJoinType : ((("full" | "left" | "right") TestNoAlpha OptionalSpacing) ("outer" TestNoAlpha OptionalSpacing)?)
   protected boolean outerJoinType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OuterJoinType", index);
      }
      if (outerJoinType$RuleMemoStart == index) {
         if (outerJoinType$RuleMemoStart <= outerJoinType$RuleMemoEnd) {
            index = outerJoinType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_TYPE, outerJoinType$RuleMemoStart, outerJoinType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (outerJoinType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(outerJoinType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("full" | "left" | "right") TestNoAlpha OptionalSpacing) ("outer" TestNoAlpha OptionalSpacing)?)
      // (("full" | "left" | "right") TestNoAlpha OptionalSpacing)
      // ("full" | "left" | "right")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // "ull"
            if (match = ignoreCaseStringTest("ull", 3)) {
               index += 3;
            }
            break;
         }
         case 'r':
         case 'R': {
            ++index;
            // "ight"
            if (match = ignoreCaseStringTest("ight", 4)) {
               index += 4;
            }
            break;
         }
         case 'l':
         case 'L': {
            ++index;
            // "eft"
            if (match = ignoreCaseStringTest("eft", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // ("outer" TestNoAlpha OptionalSpacing)?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("outer" TestNoAlpha OptionalSpacing)
         // "outer"
         match = ignoreCaseStringMatcher("outer", 5);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (match) {
         outerJoinType$RuleMemoStart = startIndex;
         outerJoinType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            outerJoinType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OUTER_JOIN_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            outerJoinType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         outerJoinType$RuleMemoStart = startIndex;
         outerJoinType$RuleMemoEnd = -1;
         outerJoinType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryPartitionClause : ("partition" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpressionList)
   protected boolean queryPartitionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryPartitionClause", index);
      }
      if (queryPartitionClause$RuleMemoStart == index) {
         if (queryPartitionClause$RuleMemoStart <= queryPartitionClause$RuleMemoEnd) {
            index = queryPartitionClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUERY_PARTITION_CLAUSE, queryPartitionClause$RuleMemoStart, queryPartitionClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (queryPartitionClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(queryPartitionClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("partition" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing SqlExpressionList)
      // "partition"
      match = ignoreCaseStringMatcher("partition", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlExpressionList
                        match = sqlExpressionList$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         queryPartitionClause$RuleMemoStart = startIndex;
         queryPartitionClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            queryPartitionClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_PARTITION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            queryPartitionClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         queryPartitionClause$RuleMemoStart = startIndex;
         queryPartitionClause$RuleMemoEnd = -1;
         queryPartitionClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FromArgument : (TableReference JoinClause)
   protected boolean fromArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FromArgument", index);
      }
      if (fromArgument$RuleMemoStart == index) {
         if (fromArgument$RuleMemoStart <= fromArgument$RuleMemoEnd) {
            index = fromArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FROM_ARGUMENT, fromArgument$RuleMemoStart, fromArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (fromArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(fromArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableReference JoinClause)
      // TableReference
      match = tableReference$Rule();
      if (match) {
         // JoinClause
         match = joinClause$Rule();
      }
      if (match) {
         fromArgument$RuleMemoStart = startIndex;
         fromArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fromArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FROM_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fromArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         fromArgument$RuleMemoStart = startIndex;
         fromArgument$RuleMemoEnd = -1;
         fromArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FromClause : ("from" TestNoAlpha OptionalSpacing FromArgument (',' OptionalSpacing FromArgument)*)
   protected boolean fromClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FromClause", index);
      }
      startIndex = index;
      // ("from" TestNoAlpha OptionalSpacing FromArgument (',' OptionalSpacing FromArgument)*)
      // "from"
      match = ignoreCaseStringMatcher("from", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // FromArgument
               match = fromArgument$Rule();
               if (match) {
                  // (',' OptionalSpacing FromArgument)*
                  Node lastNode_1;
                  int lastIndex_1;
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // (',' OptionalSpacing FromArgument)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // FromArgument
                           match = fromArgument$Rule();
                        }
                     }
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FROM_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CurrentOf : ("current" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing SqlObjectIdentifier)
   protected boolean currentOf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CurrentOf", index);
      }
      if (currentOf$RuleMemoStart == index) {
         if (currentOf$RuleMemoStart <= currentOf$RuleMemoEnd) {
            index = currentOf$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURRENT_OF, currentOf$RuleMemoStart, currentOf$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (currentOf$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(currentOf$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("current" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing SqlObjectIdentifier)
      // "current"
      match = ignoreCaseStringMatcher("current", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "of"
               match = ignoreCaseStringMatcher("of", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlObjectIdentifier
                        match = sqlObjectIdentifier$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentOf$RuleMemoStart = startIndex;
         currentOf$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            currentOf$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURRENT_OF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            currentOf$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentOf$RuleMemoStart = startIndex;
         currentOf$RuleMemoEnd = -1;
         currentOf$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WhereClause : ("where" TestNoAlpha OptionalSpacing (CurrentOf | SqlCondition))
   protected boolean whereClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WhereClause", index);
      }
      if (whereClause$RuleMemoStart == index) {
         if (whereClause$RuleMemoStart <= whereClause$RuleMemoEnd) {
            index = whereClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.WHERE_CLAUSE, whereClause$RuleMemoStart, whereClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (whereClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(whereClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("where" TestNoAlpha OptionalSpacing (CurrentOf | SqlCondition))
      // "where"
      match = ignoreCaseStringMatcher("where", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (CurrentOf | SqlCondition)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '\'':
                  case '(':
                  case '+':
                  case '-':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case ':':
                  case '?':
                  case 'A':
                  case 'B':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // SqlCondition
                     match = sqlCondition$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'C':
                  case 'c': {
                     // CurrentOf
                     match = currentOf$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlCondition
                        match = sqlCondition$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         whereClause$RuleMemoStart = startIndex;
         whereClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            whereClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.WHERE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            whereClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         whereClause$RuleMemoStart = startIndex;
         whereClause$RuleMemoEnd = -1;
         whereClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BulkCollect : ("bulk" TestNoAlpha OptionalSpacing "collect" TestNoAlpha OptionalSpacing)
   protected boolean bulkCollect$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BulkCollect", index);
      }
      if (bulkCollect$RuleMemoStart == index) {
         if (bulkCollect$RuleMemoStart <= bulkCollect$RuleMemoEnd) {
            index = bulkCollect$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BULK_COLLECT, bulkCollect$RuleMemoStart, bulkCollect$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bulkCollect$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bulkCollect$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("bulk" TestNoAlpha OptionalSpacing "collect" TestNoAlpha OptionalSpacing)
      // "bulk"
      match = ignoreCaseStringMatcher("bulk", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "collect"
               match = ignoreCaseStringMatcher("collect", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         bulkCollect$RuleMemoStart = startIndex;
         bulkCollect$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bulkCollect$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BULK_COLLECT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bulkCollect$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         bulkCollect$RuleMemoStart = startIndex;
         bulkCollect$RuleMemoEnd = -1;
         bulkCollect$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectIntoClause : (BulkCollect? "into" TestNoAlpha OptionalSpacing (('(' OptionalSpacing SqlObjectIdentifierList ')' OptionalSpacing) | SqlObjectIdentifierList))
   protected boolean selectIntoClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectIntoClause", index);
      }
      startIndex = index;
      // (BulkCollect? "into" TestNoAlpha OptionalSpacing (('(' OptionalSpacing SqlObjectIdentifierList ')' OptionalSpacing) | SqlObjectIdentifierList))
      // BulkCollect?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // BulkCollect
      match = bulkCollect$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "into"
         match = ignoreCaseStringMatcher("into", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // (('(' OptionalSpacing SqlObjectIdentifierList ')' OptionalSpacing) | SqlObjectIdentifierList)
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ('(' OptionalSpacing SqlObjectIdentifierList ')' OptionalSpacing)
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlObjectIdentifierList
                        match = sqlObjectIdentifierList$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // SqlObjectIdentifierList
                     match = sqlObjectIdentifierList$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_INTO_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Distinct : (("distinct" | "unique" | "all") TestNoAlpha OptionalSpacing)
   protected boolean distinct$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Distinct", index);
      }
      startIndex = index;
      // (("distinct" | "unique" | "all") TestNoAlpha OptionalSpacing)
      // ("distinct" | "unique" | "all")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'a':
         case 'A': {
            ++index;
            // "ll"
            if (match = ignoreCaseStringTest("ll", 2)) {
               index += 2;
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // "istinct"
            if (match = ignoreCaseStringTest("istinct", 7)) {
               index += 7;
            }
            break;
         }
         case 'u':
         case 'U': {
            ++index;
            // "nique"
            if (match = ignoreCaseStringTest("nique", 5)) {
               index += 5;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.DISTINCT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnionType : (("union" TestNoAlpha OptionalSpacing "all" TestNoAlpha OptionalSpacing) | ("union" TestNoAlpha OptionalSpacing) | ("intersect" TestNoAlpha OptionalSpacing) | ("minus" TestNoAlpha OptionalSpacing))
   protected boolean unionType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnionType", index);
      }
      startIndex = index;
      // (("union" TestNoAlpha OptionalSpacing "all" TestNoAlpha OptionalSpacing) | ("union" TestNoAlpha OptionalSpacing) | ("intersect" TestNoAlpha OptionalSpacing) | ("minus" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("union" TestNoAlpha OptionalSpacing "all" TestNoAlpha OptionalSpacing)
      // "union"
      match = ignoreCaseStringMatcher("union", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "all"
               match = ignoreCaseStringMatcher("all", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("union" TestNoAlpha OptionalSpacing)
         // "union"
         match = ignoreCaseStringMatcher("union", 5);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("intersect" TestNoAlpha OptionalSpacing)
            // "intersect"
            match = ignoreCaseStringMatcher("intersect", 9);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("minus" TestNoAlpha OptionalSpacing)
               // "minus"
               match = ignoreCaseStringMatcher("minus", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNION_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnionClause : (UnionType Subquery)
   protected boolean unionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnionClause", index);
      }
      startIndex = index;
      // (UnionType Subquery)
      // UnionType
      match = unionType$Rule();
      if (match) {
         // Subquery
         match = subquery$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //QueryBlock : ("select" TestNoAlpha OptionalSpacing Hint? Distinct? SelectList SelectIntoClause? FromClause WhereClause? HierarchicalQueryClause? GroupByClause? HavingClause? ModelClause?)
   protected boolean queryBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "QueryBlock", index);
      }
      if (queryBlock$RuleMemoStart == index) {
         if (queryBlock$RuleMemoStart <= queryBlock$RuleMemoEnd) {
            index = queryBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUERY_BLOCK, queryBlock$RuleMemoStart, queryBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (queryBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(queryBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("select" TestNoAlpha OptionalSpacing Hint? Distinct? SelectList SelectIntoClause? FromClause WhereClause? HierarchicalQueryClause? GroupByClause? HavingClause? ModelClause?)
      // "select"
      match = ignoreCaseStringMatcher("select", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // Distinct?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Distinct
                  match = distinct$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // SelectList
                     match = selectList$Rule();
                     if (match) {
                        // SelectIntoClause?
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // SelectIntoClause
                        match = selectIntoClause$Rule();
                        if (! match) {
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                        if (match) {
                           // FromClause
                           match = fromClause$Rule();
                           if (match) {
                              // WhereClause?
                              Node lastNode_4 = currentNode;
                              int lastIndex_4 = index;
                              // WhereClause
                              match = whereClause$Rule();
                              if (! match) {
                                 lastNode_4.setSibling(null);
                                 currentNode = lastNode_4;
                                 index = lastIndex_4;
                                 match = true;
                              }
                              if (match) {
                                 // HierarchicalQueryClause?
                                 Node lastNode_5 = currentNode;
                                 int lastIndex_5 = index;
                                 // HierarchicalQueryClause
                                 match = hierarchicalQueryClause$Rule();
                                 if (! match) {
                                    lastNode_5.setSibling(null);
                                    currentNode = lastNode_5;
                                    index = lastIndex_5;
                                    match = true;
                                 }
                                 if (match) {
                                    // GroupByClause?
                                    Node lastNode_6 = currentNode;
                                    int lastIndex_6 = index;
                                    // GroupByClause
                                    match = groupByClause$Rule();
                                    if (! match) {
                                       lastNode_6.setSibling(null);
                                       currentNode = lastNode_6;
                                       index = lastIndex_6;
                                       match = true;
                                    }
                                    if (match) {
                                       // HavingClause?
                                       Node lastNode_7 = currentNode;
                                       int lastIndex_7 = index;
                                       // HavingClause
                                       match = havingClause$Rule();
                                       if (! match) {
                                          lastNode_7.setSibling(null);
                                          currentNode = lastNode_7;
                                          index = lastIndex_7;
                                          match = true;
                                       }
                                       if (match) {
                                          // ModelClause?
                                          Node lastNode_8 = currentNode;
                                          int lastIndex_8 = index;
                                          // ModelClause
                                          match = modelClause$Rule();
                                          if (! match) {
                                             lastNode_8.setSibling(null);
                                             currentNode = lastNode_8;
                                             index = lastIndex_8;
                                             match = true;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         queryBlock$RuleMemoStart = startIndex;
         queryBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            queryBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUERY_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            queryBlock$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         queryBlock$RuleMemoStart = startIndex;
         queryBlock$RuleMemoEnd = -1;
         queryBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //EnclosedSubquery : ('(' OptionalSpacing Subquery ')' OptionalSpacing)
   protected boolean enclosedSubquery$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "EnclosedSubquery", index);
      }
      if (enclosedSubquery$RuleMemoStart == index) {
         if (enclosedSubquery$RuleMemoStart <= enclosedSubquery$RuleMemoEnd) {
            index = enclosedSubquery$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ENCLOSED_SUBQUERY, enclosedSubquery$RuleMemoStart, enclosedSubquery$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (enclosedSubquery$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(enclosedSubquery$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing Subquery ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Subquery
            match = subquery$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         enclosedSubquery$RuleMemoStart = startIndex;
         enclosedSubquery$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            enclosedSubquery$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ENCLOSED_SUBQUERY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            enclosedSubquery$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         enclosedSubquery$RuleMemoStart = startIndex;
         enclosedSubquery$RuleMemoEnd = -1;
         enclosedSubquery$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Subquery : ((EnclosedSubquery | QueryBlock) UnionClause? OrderByClause?)
   protected boolean subquery$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Subquery", index);
      }
      if (subquery$RuleMemoStart == index) {
         if (subquery$RuleMemoStart <= subquery$RuleMemoEnd) {
            index = subquery$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY, subquery$RuleMemoStart, subquery$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subquery$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subquery$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((EnclosedSubquery | QueryBlock) UnionClause? OrderByClause?)
      // (EnclosedSubquery | QueryBlock)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 's':
         case 'S': {
            // QueryBlock
            match = queryBlock$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // EnclosedSubquery
            match = enclosedSubquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         // UnionClause?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // UnionClause
         match = unionClause$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
         if (match) {
            // OrderByClause?
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // OrderByClause
            match = orderByClause$Rule();
            if (! match) {
               lastNode_3.setSibling(null);
               currentNode = lastNode_3;
               index = lastIndex_3;
               match = true;
            }
         }
      }
      if (match) {
         subquery$RuleMemoStart = startIndex;
         subquery$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subquery$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subquery$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subquery$RuleMemoStart = startIndex;
         subquery$RuleMemoEnd = -1;
         subquery$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NoCycleOption : ("nocycle" TestNoAlpha OptionalSpacing)?
   protected boolean noCycleOption$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NoCycleOption", index);
      }
      startIndex = index;
      // ("nocycle" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("nocycle" TestNoAlpha OptionalSpacing)
      // "nocycle"
      match = ignoreCaseStringMatcher("nocycle", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.NO_CYCLE_OPTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StartWithCondition : ("start" TestNoAlpha OptionalSpacing "with" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean startWithCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StartWithCondition", index);
      }
      if (startWithCondition$RuleMemoStart == index) {
         if (startWithCondition$RuleMemoStart <= startWithCondition$RuleMemoEnd) {
            index = startWithCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.START_WITH_CONDITION, startWithCondition$RuleMemoStart, startWithCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (startWithCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(startWithCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("start" TestNoAlpha OptionalSpacing "with" TestNoAlpha OptionalSpacing SqlCondition)
      // "start"
      match = ignoreCaseStringMatcher("start", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "with"
               match = ignoreCaseStringMatcher("with", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlCondition
                        match = sqlCondition$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         startWithCondition$RuleMemoStart = startIndex;
         startWithCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            startWithCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.START_WITH_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            startWithCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         startWithCondition$RuleMemoStart = startIndex;
         startWithCondition$RuleMemoEnd = -1;
         startWithCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConnectByCondition : ("connect" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing NoCycleOption SqlCondition)
   protected boolean connectByCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConnectByCondition", index);
      }
      if (connectByCondition$RuleMemoStart == index) {
         if (connectByCondition$RuleMemoStart <= connectByCondition$RuleMemoEnd) {
            index = connectByCondition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONNECT_BY_CONDITION, connectByCondition$RuleMemoStart, connectByCondition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (connectByCondition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(connectByCondition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("connect" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing NoCycleOption SqlCondition)
      // "connect"
      match = ignoreCaseStringMatcher("connect", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // NoCycleOption
                        match = noCycleOption$Rule();
                        if (match) {
                           // SqlCondition
                           match = sqlCondition$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         connectByCondition$RuleMemoStart = startIndex;
         connectByCondition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            connectByCondition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONNECT_BY_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            connectByCondition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         connectByCondition$RuleMemoStart = startIndex;
         connectByCondition$RuleMemoEnd = -1;
         connectByCondition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConnectBy : (ConnectByCondition StartWithCondition?)
   protected boolean connectBy$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConnectBy", index);
      }
      if (connectBy$RuleMemoStart == index) {
         if (connectBy$RuleMemoStart <= connectBy$RuleMemoEnd) {
            index = connectBy$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONNECT_BY, connectBy$RuleMemoStart, connectBy$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (connectBy$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(connectBy$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ConnectByCondition StartWithCondition?)
      // ConnectByCondition
      match = connectByCondition$Rule();
      if (match) {
         // StartWithCondition?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // StartWithCondition
         match = startWithCondition$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         connectBy$RuleMemoStart = startIndex;
         connectBy$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            connectBy$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONNECT_BY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            connectBy$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         connectBy$RuleMemoStart = startIndex;
         connectBy$RuleMemoEnd = -1;
         connectBy$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StartWith : (StartWithCondition ConnectByCondition)
   protected boolean startWith$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StartWith", index);
      }
      if (startWith$RuleMemoStart == index) {
         if (startWith$RuleMemoStart <= startWith$RuleMemoEnd) {
            index = startWith$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.START_WITH, startWith$RuleMemoStart, startWith$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (startWith$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(startWith$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (StartWithCondition ConnectByCondition)
      // StartWithCondition
      match = startWithCondition$Rule();
      if (match) {
         // ConnectByCondition
         match = connectByCondition$Rule();
      }
      if (match) {
         startWith$RuleMemoStart = startIndex;
         startWith$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            startWith$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.START_WITH, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            startWith$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         startWith$RuleMemoStart = startIndex;
         startWith$RuleMemoEnd = -1;
         startWith$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //HierarchicalQueryClause : (ConnectBy | StartWith)
   protected boolean hierarchicalQueryClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "HierarchicalQueryClause", index);
      }
      startIndex = index;
      // (ConnectBy | StartWith)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'c':
         case 'C': {
            // ConnectBy
            match = connectBy$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 's':
         case 'S': {
            // StartWith
            match = startWith$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.HIERARCHICAL_QUERY_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupByArgument : (RollupCubeClause | GroupingSetsClause | SqlExpression)
   protected boolean groupByArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupByArgument", index);
      }
      if (groupByArgument$RuleMemoStart == index) {
         if (groupByArgument$RuleMemoStart <= groupByArgument$RuleMemoEnd) {
            index = groupByArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GROUP_BY_ARGUMENT, groupByArgument$RuleMemoStart, groupByArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (groupByArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(groupByArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (RollupCubeClause | GroupingSetsClause | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'D':
         case 'E':
         case 'F':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'd':
         case 'e':
         case 'f':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlExpression
            match = sqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'R':
         case 'r':
         case 'C':
         case 'c': {
            // RollupCubeClause
            match = rollupCubeClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'G':
         case 'g': {
            // GroupingSetsClause
            match = groupingSetsClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         groupByArgument$RuleMemoStart = startIndex;
         groupByArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            groupByArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUP_BY_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            groupByArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         groupByArgument$RuleMemoStart = startIndex;
         groupByArgument$RuleMemoEnd = -1;
         groupByArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupByArguments : (GroupByArgument (',' OptionalSpacing GroupByArgument)*)
   protected boolean groupByArguments$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupByArguments", index);
      }
      startIndex = index;
      // (GroupByArgument (',' OptionalSpacing GroupByArgument)*)
      // GroupByArgument
      match = groupByArgument$Rule();
      if (match) {
         // (',' OptionalSpacing GroupByArgument)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing GroupByArgument)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // GroupByArgument
                  match = groupByArgument$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUP_BY_ARGUMENTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RollupCubeClause : ((("rollup" | "cube") TestNoAlpha OptionalSpacing) '(' OptionalSpacing GroupingExpressionList ')' OptionalSpacing)
   protected boolean rollupCubeClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RollupCubeClause", index);
      }
      if (rollupCubeClause$RuleMemoStart == index) {
         if (rollupCubeClause$RuleMemoStart <= rollupCubeClause$RuleMemoEnd) {
            index = rollupCubeClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROLLUP_CUBE_CLAUSE, rollupCubeClause$RuleMemoStart, rollupCubeClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rollupCubeClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rollupCubeClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("rollup" | "cube") TestNoAlpha OptionalSpacing) '(' OptionalSpacing GroupingExpressionList ')' OptionalSpacing)
      // (("rollup" | "cube") TestNoAlpha OptionalSpacing)
      // ("rollup" | "cube")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'r':
         case 'R': {
            ++index;
            // "ollup"
            if (match = ignoreCaseStringTest("ollup", 5)) {
               index += 5;
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // "ube"
            if (match = ignoreCaseStringTest("ube", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // GroupingExpressionList
               match = groupingExpressionList$Rule();
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         rollupCubeClause$RuleMemoStart = startIndex;
         rollupCubeClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rollupCubeClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROLLUP_CUBE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rollupCubeClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rollupCubeClause$RuleMemoStart = startIndex;
         rollupCubeClause$RuleMemoEnd = -1;
         rollupCubeClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupingExpressionList : (SqlExpressionList (',' OptionalSpacing SqlExpressionList)*)
   protected boolean groupingExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupingExpressionList", index);
      }
      if (groupingExpressionList$RuleMemoStart == index) {
         if (groupingExpressionList$RuleMemoStart <= groupingExpressionList$RuleMemoEnd) {
            index = groupingExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_EXPRESSION_LIST, groupingExpressionList$RuleMemoStart, groupingExpressionList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (groupingExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(groupingExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpressionList (',' OptionalSpacing SqlExpressionList)*)
      // SqlExpressionList
      match = sqlExpressionList$Rule();
      if (match) {
         // (',' OptionalSpacing SqlExpressionList)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing SqlExpressionList)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlExpressionList
                  match = sqlExpressionList$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         groupingExpressionList$RuleMemoStart = startIndex;
         groupingExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            groupingExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            groupingExpressionList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         groupingExpressionList$RuleMemoStart = startIndex;
         groupingExpressionList$RuleMemoEnd = -1;
         groupingExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupingSetsClause : ("grouping" TestNoAlpha OptionalSpacing "sets" TestNoAlpha OptionalSpacing '(' OptionalSpacing GroupingSetsClauseArguments ')' OptionalSpacing)
   protected boolean groupingSetsClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupingSetsClause", index);
      }
      if (groupingSetsClause$RuleMemoStart == index) {
         if (groupingSetsClause$RuleMemoStart <= groupingSetsClause$RuleMemoEnd) {
            index = groupingSetsClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_SETS_CLAUSE, groupingSetsClause$RuleMemoStart, groupingSetsClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (groupingSetsClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(groupingSetsClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("grouping" TestNoAlpha OptionalSpacing "sets" TestNoAlpha OptionalSpacing '(' OptionalSpacing GroupingSetsClauseArguments ')' OptionalSpacing)
      // "grouping"
      match = ignoreCaseStringMatcher("grouping", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "sets"
               match = ignoreCaseStringMatcher("sets", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '('
                        match = charMatcher('(');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // GroupingSetsClauseArguments
                              match = groupingSetsClauseArguments$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         groupingSetsClause$RuleMemoStart = startIndex;
         groupingSetsClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            groupingSetsClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_SETS_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            groupingSetsClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         groupingSetsClause$RuleMemoStart = startIndex;
         groupingSetsClause$RuleMemoEnd = -1;
         groupingSetsClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupingSetsClauseArgument : (RollupCubeClause | GroupingExpressionList)
   protected boolean groupingSetsClauseArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupingSetsClauseArgument", index);
      }
      if (groupingSetsClauseArgument$RuleMemoStart == index) {
         if (groupingSetsClauseArgument$RuleMemoStart <= groupingSetsClauseArgument$RuleMemoEnd) {
            index = groupingSetsClauseArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_SETS_CLAUSE_ARGUMENT, groupingSetsClauseArgument$RuleMemoStart, groupingSetsClauseArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (groupingSetsClauseArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(groupingSetsClauseArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (RollupCubeClause | GroupingExpressionList)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // GroupingExpressionList
            match = groupingExpressionList$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'R':
         case 'r':
         case 'C':
         case 'c': {
            // RollupCubeClause
            match = rollupCubeClause$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // GroupingExpressionList
               match = groupingExpressionList$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         groupingSetsClauseArgument$RuleMemoStart = startIndex;
         groupingSetsClauseArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            groupingSetsClauseArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_SETS_CLAUSE_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            groupingSetsClauseArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         groupingSetsClauseArgument$RuleMemoStart = startIndex;
         groupingSetsClauseArgument$RuleMemoEnd = -1;
         groupingSetsClauseArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupingSetsClauseArguments : (GroupingSetsClauseArgument (',' OptionalSpacing GroupingSetsClauseArgument)*)
   protected boolean groupingSetsClauseArguments$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupingSetsClauseArguments", index);
      }
      startIndex = index;
      // (GroupingSetsClauseArgument (',' OptionalSpacing GroupingSetsClauseArgument)*)
      // GroupingSetsClauseArgument
      match = groupingSetsClauseArgument$Rule();
      if (match) {
         // (',' OptionalSpacing GroupingSetsClauseArgument)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing GroupingSetsClauseArgument)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // GroupingSetsClauseArgument
                  match = groupingSetsClauseArgument$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUPING_SETS_CLAUSE_ARGUMENTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GroupByClause : ("group" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing GroupByArguments HavingClause?)
   protected boolean groupByClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GroupByClause", index);
      }
      startIndex = index;
      // ("group" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing GroupByArguments HavingClause?)
      // "group"
      match = ignoreCaseStringMatcher("group", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // GroupByArguments
                        match = groupByArguments$Rule();
                        if (match) {
                           // HavingClause?
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           // HavingClause
                           match = havingClause$Rule();
                           if (! match) {
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              index = lastIndex_1;
                              match = true;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.GROUP_BY_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //HavingClause : ("having" TestNoAlpha OptionalSpacing SqlCondition)
   protected boolean havingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "HavingClause", index);
      }
      if (havingClause$RuleMemoStart == index) {
         if (havingClause$RuleMemoStart <= havingClause$RuleMemoEnd) {
            index = havingClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.HAVING_CLAUSE, havingClause$RuleMemoStart, havingClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (havingClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(havingClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("having" TestNoAlpha OptionalSpacing SqlCondition)
      // "having"
      match = ignoreCaseStringMatcher("having", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlCondition
               match = sqlCondition$Rule();
            }
         }
      }
      if (match) {
         havingClause$RuleMemoStart = startIndex;
         havingClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            havingClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.HAVING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            havingClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         havingClause$RuleMemoStart = startIndex;
         havingClause$RuleMemoEnd = -1;
         havingClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelClause : ("model" TestNoAlpha OptionalSpacing CellReferenceOptions ReturnRowsClause ReferenceModel MainModel)
   protected boolean modelClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelClause", index);
      }
      startIndex = index;
      // ("model" TestNoAlpha OptionalSpacing CellReferenceOptions ReturnRowsClause ReferenceModel MainModel)
      // "model"
      match = ignoreCaseStringMatcher("model", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CellReferenceOptions
               match = cellReferenceOptions$Rule();
               if (match) {
                  // ReturnRowsClause
                  match = returnRowsClause$Rule();
                  if (match) {
                     // ReferenceModel
                     match = referenceModel$Rule();
                     if (match) {
                        // MainModel
                        match = mainModel$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellReferenceOptions : (((("ignore" | "keep") TestNoAlpha OptionalSpacing) "nav" TestNoAlpha OptionalSpacing)? ("unique" TestNoAlpha OptionalSpacing (("dimension" TestNoAlpha OptionalSpacing) | ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing)))?)
   protected boolean cellReferenceOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellReferenceOptions", index);
      }
      if (cellReferenceOptions$RuleMemoStart == index) {
         if (cellReferenceOptions$RuleMemoStart <= cellReferenceOptions$RuleMemoEnd) {
            index = cellReferenceOptions$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_OPTIONS, cellReferenceOptions$RuleMemoStart, cellReferenceOptions$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cellReferenceOptions$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cellReferenceOptions$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (((("ignore" | "keep") TestNoAlpha OptionalSpacing) "nav" TestNoAlpha OptionalSpacing)? ("unique" TestNoAlpha OptionalSpacing (("dimension" TestNoAlpha OptionalSpacing) | ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing)))?)
      // ((("ignore" | "keep") TestNoAlpha OptionalSpacing) "nav" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ((("ignore" | "keep") TestNoAlpha OptionalSpacing) "nav" TestNoAlpha OptionalSpacing)
      // (("ignore" | "keep") TestNoAlpha OptionalSpacing)
      // ("ignore" | "keep")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'i':
         case 'I': {
            ++index;
            // "gnore"
            if (match = ignoreCaseStringTest("gnore", 5)) {
               index += 5;
            }
            break;
         }
         case 'k':
         case 'K': {
            ++index;
            // "eep"
            if (match = ignoreCaseStringTest("eep", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // "nav"
         match = ignoreCaseStringMatcher("nav", 3);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ("unique" TestNoAlpha OptionalSpacing (("dimension" TestNoAlpha OptionalSpacing) | ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing)))?
         Node lastNode_3 = currentNode;
         int lastIndex_3 = index;
         // ("unique" TestNoAlpha OptionalSpacing (("dimension" TestNoAlpha OptionalSpacing) | ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing)))
         // "unique"
         match = ignoreCaseStringMatcher("unique", 6);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // (("dimension" TestNoAlpha OptionalSpacing) | ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing))
                  Node lastNode_4 = currentNode;
                  int lastIndex_4 = index;
                  // ("dimension" TestNoAlpha OptionalSpacing)
                  // "dimension"
                  match = ignoreCaseStringMatcher("dimension", 9);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                     // ("single" TestNoAlpha OptionalSpacing "reference" TestNoAlpha OptionalSpacing)
                     // "single"
                     match = ignoreCaseStringMatcher("single", 6);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "reference"
                              match = ignoreCaseStringMatcher("reference", 9);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_4;
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                     }
                  }
               }
            }
         }
         if (! match) {
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
            index = lastIndex_3;
            match = true;
         }
      }
      if (match) {
         cellReferenceOptions$RuleMemoStart = startIndex;
         cellReferenceOptions$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cellReferenceOptions$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_REFERENCE_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cellReferenceOptions$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cellReferenceOptions$RuleMemoStart = startIndex;
         cellReferenceOptions$RuleMemoEnd = -1;
         cellReferenceOptions$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturnRowsClause : ("return" TestNoAlpha OptionalSpacing (("updated" | "all") TestNoAlpha OptionalSpacing) "rows" TestNoAlpha OptionalSpacing)?
   protected boolean returnRowsClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturnRowsClause", index);
      }
      startIndex = index;
      // ("return" TestNoAlpha OptionalSpacing (("updated" | "all") TestNoAlpha OptionalSpacing) "rows" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("return" TestNoAlpha OptionalSpacing (("updated" | "all") TestNoAlpha OptionalSpacing) "rows" TestNoAlpha OptionalSpacing)
      // "return"
      match = ignoreCaseStringMatcher("return", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("updated" | "all") TestNoAlpha OptionalSpacing)
               // ("updated" | "all")
               int startIndex_2 = index;
               switch(buffer.getChar(index)) {
                  case 'a':
                  case 'A': {
                     ++index;
                     // "ll"
                     if (match = ignoreCaseStringTest("ll", 2)) {
                        index += 2;
                     }
                     break;
                  }
                  case 'u':
                  case 'U': {
                     ++index;
                     // "pdated"
                     if (match = ignoreCaseStringTest("pdated", 6)) {
                        index += 6;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  index = startIndex_2;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (match) {
                  // "rows"
                  match = ignoreCaseStringMatcher("rows", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURN_ROWS_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReferenceModel : ("reference" TestNoAlpha OptionalSpacing SqlAnyIdentifier "on" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing ModelColumnClause CellReferenceOptions)*
   protected boolean referenceModel$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReferenceModel", index);
      }
      startIndex = index;
      // ("reference" TestNoAlpha OptionalSpacing SqlAnyIdentifier "on" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing ModelColumnClause CellReferenceOptions)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // ("reference" TestNoAlpha OptionalSpacing SqlAnyIdentifier "on" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing ModelColumnClause CellReferenceOptions)
         // "reference"
         match = ignoreCaseStringMatcher("reference", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlAnyIdentifier
                  match = sqlAnyIdentifier$Rule();
                  if (match) {
                     // "on"
                     match = ignoreCaseStringMatcher("on", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '('
                              match = charMatcher('(');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // Subquery
                                    match = subquery$Rule();
                                    if (match) {
                                       // ')'
                                       match = charMatcher(')');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // ModelColumnClause
                                             match = modelColumnClause$Rule();
                                             if (match) {
                                                // CellReferenceOptions
                                                match = cellReferenceOptions$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(OracleScriptRuleType.REFERENCE_MODEL, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //ModelColumnPartition : (QueryPartitionClause SqlIdentifier?)
   protected boolean modelColumnPartition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelColumnPartition", index);
      }
      startIndex = index;
      // (QueryPartitionClause SqlIdentifier?)
      // QueryPartitionClause
      match = queryPartitionClause$Rule();
      if (match) {
         // SqlIdentifier?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // SqlIdentifier
         match = sqlIdentifier$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN_PARTITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelColumnClause : (ModelColumnPartition? "dimension" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing '(' OptionalSpacing ModelColumnList ')' OptionalSpacing "measures" TestNoAlpha OptionalSpacing '(' OptionalSpacing ModelColumnList ')' OptionalSpacing)
   protected boolean modelColumnClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelColumnClause", index);
      }
      if (modelColumnClause$RuleMemoStart == index) {
         if (modelColumnClause$RuleMemoStart <= modelColumnClause$RuleMemoEnd) {
            index = modelColumnClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN_CLAUSE, modelColumnClause$RuleMemoStart, modelColumnClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (modelColumnClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(modelColumnClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ModelColumnPartition? "dimension" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing '(' OptionalSpacing ModelColumnList ')' OptionalSpacing "measures" TestNoAlpha OptionalSpacing '(' OptionalSpacing ModelColumnList ')' OptionalSpacing)
      // ModelColumnPartition?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ModelColumnPartition
      match = modelColumnPartition$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "dimension"
         match = ignoreCaseStringMatcher("dimension", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "by"
                  match = ignoreCaseStringMatcher("by", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '('
                           match = charMatcher('(');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // ModelColumnList
                                 match = modelColumnList$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // "measures"
                                          match = ignoreCaseStringMatcher("measures", 8);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // '('
                                                   match = charMatcher('(');
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // ModelColumnList
                                                         match = modelColumnList$Rule();
                                                         if (match) {
                                                            // ')'
                                                            match = charMatcher(')');
                                                            if (match) {
                                                               // OptionalSpacing
                                                               match = optionalSpacing$Rule();
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         modelColumnClause$RuleMemoStart = startIndex;
         modelColumnClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            modelColumnClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            modelColumnClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         modelColumnClause$RuleMemoStart = startIndex;
         modelColumnClause$RuleMemoEnd = -1;
         modelColumnClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelColumnList : (ModelColumn (',' OptionalSpacing ModelColumn)*)
   protected boolean modelColumnList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelColumnList", index);
      }
      if (modelColumnList$RuleMemoStart == index) {
         if (modelColumnList$RuleMemoStart <= modelColumnList$RuleMemoEnd) {
            index = modelColumnList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN_LIST, modelColumnList$RuleMemoStart, modelColumnList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (modelColumnList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(modelColumnList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ModelColumn (',' OptionalSpacing ModelColumn)*)
      // ModelColumn
      match = modelColumn$Rule();
      if (match) {
         // (',' OptionalSpacing ModelColumn)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ModelColumn)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ModelColumn
                  match = modelColumn$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         modelColumnList$RuleMemoStart = startIndex;
         modelColumnList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            modelColumnList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            modelColumnList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         modelColumnList$RuleMemoStart = startIndex;
         modelColumnList$RuleMemoEnd = -1;
         modelColumnList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelColumn : (SqlExpression AsOptionalAlias?)
   protected boolean modelColumn$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelColumn", index);
      }
      if (modelColumn$RuleMemoStart == index) {
         if (modelColumn$RuleMemoStart <= modelColumn$RuleMemoEnd) {
            index = modelColumn$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN, modelColumn$RuleMemoStart, modelColumn$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (modelColumn$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(modelColumn$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlExpression AsOptionalAlias?)
      // SqlExpression
      match = sqlExpression$Rule();
      if (match) {
         // AsOptionalAlias?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // AsOptionalAlias
         match = asOptionalAlias$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         modelColumn$RuleMemoStart = startIndex;
         modelColumn$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            modelColumn$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_COLUMN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            modelColumn$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         modelColumn$RuleMemoStart = startIndex;
         modelColumn$RuleMemoEnd = -1;
         modelColumn$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MainModel : (("main" TestNoAlpha OptionalSpacing SqlAnyIdentifier)? ModelColumnClause CellReferenceOptions ModelRulesClause)
   protected boolean mainModel$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MainModel", index);
      }
      startIndex = index;
      // (("main" TestNoAlpha OptionalSpacing SqlAnyIdentifier)? ModelColumnClause CellReferenceOptions ModelRulesClause)
      // ("main" TestNoAlpha OptionalSpacing SqlAnyIdentifier)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("main" TestNoAlpha OptionalSpacing SqlAnyIdentifier)
      // "main"
      match = ignoreCaseStringMatcher("main", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ModelColumnClause
         match = modelColumnClause$Rule();
         if (match) {
            // CellReferenceOptions
            match = cellReferenceOptions$Rule();
            if (match) {
               // ModelRulesClause
               match = modelRulesClause$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MAIN_MODEL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelRulesUpdate : ("rules" TestNoAlpha OptionalSpacing (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))? ((("automatic" | "sequential") TestNoAlpha OptionalSpacing) "order" TestNoAlpha OptionalSpacing)?)?
   protected boolean modelRulesUpdate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelRulesUpdate", index);
      }
      startIndex = index;
      // ("rules" TestNoAlpha OptionalSpacing (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))? ((("automatic" | "sequential") TestNoAlpha OptionalSpacing) "order" TestNoAlpha OptionalSpacing)?)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("rules" TestNoAlpha OptionalSpacing (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))? ((("automatic" | "sequential") TestNoAlpha OptionalSpacing) "order" TestNoAlpha OptionalSpacing)?)
      // "rules"
      match = ignoreCaseStringMatcher("rules", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // ("update" TestNoAlpha OptionalSpacing)
               // "update"
               match = ignoreCaseStringMatcher("update", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  // ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?)
                  // "upsert"
                  match = ignoreCaseStringMatcher("upsert", 6);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ("all" TestNoAlpha OptionalSpacing)?
                           Node lastNode_4 = currentNode;
                           int lastIndex_4 = index;
                           // ("all" TestNoAlpha OptionalSpacing)
                           // "all"
                           match = ignoreCaseStringMatcher("all", 3);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_4.setSibling(null);
                              currentNode = lastNode_4;
                              index = lastIndex_4;
                              match = true;
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ((("automatic" | "sequential") TestNoAlpha OptionalSpacing) "order" TestNoAlpha OptionalSpacing)?
                  Node lastNode_5 = currentNode;
                  int lastIndex_5 = index;
                  // ((("automatic" | "sequential") TestNoAlpha OptionalSpacing) "order" TestNoAlpha OptionalSpacing)
                  // (("automatic" | "sequential") TestNoAlpha OptionalSpacing)
                  // ("automatic" | "sequential")
                  int startIndex_6 = index;
                  switch(buffer.getChar(index)) {
                     case 'a':
                     case 'A': {
                        ++index;
                        // "utomatic"
                        if (match = ignoreCaseStringTest("utomatic", 8)) {
                           index += 8;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "equential"
                        if (match = ignoreCaseStringTest("equential", 9)) {
                           index += 9;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  if (! match) {
                     index = startIndex_6;
                  } else if(! currentRuleIsAtomic) {
                     currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_6, index, false, false));
                     currentNode = currentNode.getSibling();
                  }
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (match) {
                     // "order"
                     match = ignoreCaseStringMatcher("order", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
                  if (! match) {
                     lastNode_5.setSibling(null);
                     currentNode = lastNode_5;
                     index = lastIndex_5;
                     match = true;
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_UPDATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UntilCondition : ("until" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlCondition ')' OptionalSpacing)
   protected boolean untilCondition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UntilCondition", index);
      }
      startIndex = index;
      // ("until" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlCondition ')' OptionalSpacing)
      // "until"
      match = ignoreCaseStringMatcher("until", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlCondition
                     match = sqlCondition$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.UNTIL_CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelRulesIterate : ("iterate" TestNoAlpha OptionalSpacing '(' OptionalSpacing NumberLiteral ')' OptionalSpacing UntilCondition?)
   protected boolean modelRulesIterate$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelRulesIterate", index);
      }
      startIndex = index;
      // ("iterate" TestNoAlpha OptionalSpacing '(' OptionalSpacing NumberLiteral ')' OptionalSpacing UntilCondition?)
      // "iterate"
      match = ignoreCaseStringMatcher("iterate", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // NumberLiteral
                     match = numberLiteral$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // UntilCondition?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // UntilCondition
                              match = untilCondition$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_ITERATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelRulesClause : (ModelRulesUpdate ModelRulesIterate? '(' OptionalSpacing ModelRulesClauseCellAssignmentList ')' OptionalSpacing)
   protected boolean modelRulesClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelRulesClause", index);
      }
      startIndex = index;
      // (ModelRulesUpdate ModelRulesIterate? '(' OptionalSpacing ModelRulesClauseCellAssignmentList ')' OptionalSpacing)
      // ModelRulesUpdate
      match = modelRulesUpdate$Rule();
      if (match) {
         // ModelRulesIterate?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ModelRulesIterate
         match = modelRulesIterate$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // '('
            match = charMatcher('(');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ModelRulesClauseCellAssignmentList
                  match = modelRulesClauseCellAssignmentList$Rule();
                  if (match) {
                     // ')'
                     match = charMatcher(')');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelRulesClauseCellAssignmentList : (ModelRulesClauseCellAssignment (',' OptionalSpacing ModelRulesClauseCellAssignment)*)
   protected boolean modelRulesClauseCellAssignmentList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelRulesClauseCellAssignmentList", index);
      }
      startIndex = index;
      // (ModelRulesClauseCellAssignment (',' OptionalSpacing ModelRulesClauseCellAssignment)*)
      // ModelRulesClauseCellAssignment
      match = modelRulesClauseCellAssignment$Rule();
      if (match) {
         // (',' OptionalSpacing ModelRulesClauseCellAssignment)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ModelRulesClauseCellAssignment)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ModelRulesClauseCellAssignment
                  match = modelRulesClauseCellAssignment$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_CLAUSE_CELL_ASSIGNMENT_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ModelRulesClauseCellAssignment : ((("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))? CellAssignment OrderByClause? '=' OptionalSpacing SqlExpression)
   protected boolean modelRulesClauseCellAssignment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ModelRulesClauseCellAssignment", index);
      }
      if (modelRulesClauseCellAssignment$RuleMemoStart == index) {
         if (modelRulesClauseCellAssignment$RuleMemoStart <= modelRulesClauseCellAssignment$RuleMemoEnd) {
            index = modelRulesClauseCellAssignment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_CLAUSE_CELL_ASSIGNMENT, modelRulesClauseCellAssignment$RuleMemoStart, modelRulesClauseCellAssignment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (modelRulesClauseCellAssignment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(modelRulesClauseCellAssignment$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))? CellAssignment OrderByClause? '=' OptionalSpacing SqlExpression)
      // (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (("update" TestNoAlpha OptionalSpacing) | ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?))
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ("update" TestNoAlpha OptionalSpacing)
      // "update"
      match = ignoreCaseStringMatcher("update", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_2;
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         // ("upsert" TestNoAlpha OptionalSpacing ("all" TestNoAlpha OptionalSpacing)?)
         // "upsert"
         match = ignoreCaseStringMatcher("upsert", 6);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ("all" TestNoAlpha OptionalSpacing)?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ("all" TestNoAlpha OptionalSpacing)
                  // "all"
                  match = ignoreCaseStringMatcher("all", 3);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // CellAssignment
         match = cellAssignment$Rule();
         if (match) {
            // OrderByClause?
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // OrderByClause
            match = orderByClause$Rule();
            if (! match) {
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
               index = lastIndex_4;
               match = true;
            }
            if (match) {
               // '='
               match = charMatcher('=');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         modelRulesClauseCellAssignment$RuleMemoStart = startIndex;
         modelRulesClauseCellAssignment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            modelRulesClauseCellAssignment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MODEL_RULES_CLAUSE_CELL_ASSIGNMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            modelRulesClauseCellAssignment$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         modelRulesClauseCellAssignment$RuleMemoStart = startIndex;
         modelRulesClauseCellAssignment$RuleMemoEnd = -1;
         modelRulesClauseCellAssignment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellAssignment : (SqlAnyIdentifier '[' OptionalSpacing (CellAssignmentArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)
   protected boolean cellAssignment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellAssignment", index);
      }
      startIndex = index;
      // (SqlAnyIdentifier '[' OptionalSpacing (CellAssignmentArgumentsList | MultiColumnForLoop) ']' OptionalSpacing)
      // SqlAnyIdentifier
      match = sqlAnyIdentifier$Rule();
      if (match) {
         // '['
         match = charMatcher('[');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (CellAssignmentArgumentsList | MultiColumnForLoop)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '\'':
                  case '(':
                  case '+':
                  case '-':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case ':':
                  case '?':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // CellAssignmentArgumentsList
                     match = cellAssignmentArgumentsList$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'F':
                  case 'f': {
                     // CellAssignmentArgumentsList
                     match = cellAssignmentArgumentsList$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // MultiColumnForLoop
                        match = multiColumnForLoop$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (match) {
                  // ']'
                  match = charMatcher(']');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_ASSIGNMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellAssignmentArgumentsList : (CellAssignmentArgument (',' OptionalSpacing CellAssignmentArgument)*)
   protected boolean cellAssignmentArgumentsList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellAssignmentArgumentsList", index);
      }
      if (cellAssignmentArgumentsList$RuleMemoStart == index) {
         if (cellAssignmentArgumentsList$RuleMemoStart <= cellAssignmentArgumentsList$RuleMemoEnd) {
            index = cellAssignmentArgumentsList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CELL_ASSIGNMENT_ARGUMENTS_LIST, cellAssignmentArgumentsList$RuleMemoStart, cellAssignmentArgumentsList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cellAssignmentArgumentsList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cellAssignmentArgumentsList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CellAssignmentArgument (',' OptionalSpacing CellAssignmentArgument)*)
      // CellAssignmentArgument
      match = cellAssignmentArgument$Rule();
      if (match) {
         // (',' OptionalSpacing CellAssignmentArgument)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing CellAssignmentArgument)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // CellAssignmentArgument
                  match = cellAssignmentArgument$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         cellAssignmentArgumentsList$RuleMemoStart = startIndex;
         cellAssignmentArgumentsList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cellAssignmentArgumentsList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_ASSIGNMENT_ARGUMENTS_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cellAssignmentArgumentsList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cellAssignmentArgumentsList$RuleMemoStart = startIndex;
         cellAssignmentArgumentsList$RuleMemoEnd = -1;
         cellAssignmentArgumentsList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CellAssignmentArgument : (SqlCondition | SqlExpression | SingleColumnForLoop)
   protected boolean cellAssignmentArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CellAssignmentArgument", index);
      }
      if (cellAssignmentArgument$RuleMemoStart == index) {
         if (cellAssignmentArgument$RuleMemoStart <= cellAssignmentArgument$RuleMemoEnd) {
            index = cellAssignmentArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CELL_ASSIGNMENT_ARGUMENT, cellAssignmentArgument$RuleMemoStart, cellAssignmentArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cellAssignmentArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cellAssignmentArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlCondition | SqlExpression | SingleColumnForLoop)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlCondition
            match = sqlCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'F':
         case 'f': {
            // SqlCondition
            match = sqlCondition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SingleColumnForLoop
                  match = singleColumnForLoop$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         cellAssignmentArgument$RuleMemoStart = startIndex;
         cellAssignmentArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cellAssignmentArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CELL_ASSIGNMENT_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cellAssignmentArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cellAssignmentArgument$RuleMemoStart = startIndex;
         cellAssignmentArgument$RuleMemoEnd = -1;
         cellAssignmentArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForIn : ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (SqlLiteralList | Subquery) ')' OptionalSpacing)
   protected boolean forIn$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForIn", index);
      }
      if (forIn$RuleMemoStart == index) {
         if (forIn$RuleMemoStart <= forIn$RuleMemoEnd) {
            index = forIn$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FOR_IN, forIn$RuleMemoStart, forIn$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forIn$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forIn$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (SqlLiteralList | Subquery) ')' OptionalSpacing)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // (SqlLiteralList | Subquery)
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     switch(buffer.getChar(index)) {
                        case 'd':
                        case 'D':
                        case '\'':
                        case 'i':
                        case 'I':
                        case '+':
                        case '-':
                        case 'n':
                        case 'N':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case 't':
                        case 'T':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9': {
                           // SqlLiteralList
                           match = sqlLiteralList$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        case 's':
                        case 'S':
                        case '(': {
                           // Subquery
                           match = subquery$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forIn$RuleMemoStart = startIndex;
         forIn$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forIn$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_IN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forIn$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forIn$RuleMemoStart = startIndex;
         forIn$RuleMemoEnd = -1;
         forIn$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LikeString : ("like" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean likeString$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LikeString", index);
      }
      startIndex = index;
      // ("like" TestNoAlpha OptionalSpacing StringLiteral)
      // "like"
      match = ignoreCaseStringMatcher("like", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.LIKE_STRING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForLike : (LikeString? "from" TestNoAlpha OptionalSpacing SqlLiteral "to" TestNoAlpha OptionalSpacing SqlLiteral (("increment" | "decrement") TestNoAlpha OptionalSpacing) SqlLiteral)
   protected boolean forLike$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForLike", index);
      }
      if (forLike$RuleMemoStart == index) {
         if (forLike$RuleMemoStart <= forLike$RuleMemoEnd) {
            index = forLike$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FOR_LIKE, forLike$RuleMemoStart, forLike$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forLike$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forLike$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (LikeString? "from" TestNoAlpha OptionalSpacing SqlLiteral "to" TestNoAlpha OptionalSpacing SqlLiteral (("increment" | "decrement") TestNoAlpha OptionalSpacing) SqlLiteral)
      // LikeString?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // LikeString
      match = likeString$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // "from"
         match = ignoreCaseStringMatcher("from", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlLiteral
                  match = sqlLiteral$Rule();
                  if (match) {
                     // "to"
                     match = ignoreCaseStringMatcher("to", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlLiteral
                              match = sqlLiteral$Rule();
                              if (match) {
                                 // (("increment" | "decrement") TestNoAlpha OptionalSpacing)
                                 // ("increment" | "decrement")
                                 int startIndex_2 = index;
                                 switch(buffer.getChar(index)) {
                                    case 'i':
                                    case 'I': {
                                       ++index;
                                       // "ncrement"
                                       if (match = ignoreCaseStringTest("ncrement", 8)) {
                                          index += 8;
                                       }
                                       break;
                                    }
                                    case 'd':
                                    case 'D': {
                                       ++index;
                                       // "ecrement"
                                       if (match = ignoreCaseStringTest("ecrement", 8)) {
                                          index += 8;
                                       }
                                       break;
                                    }
                                    default: {
                                       match = false;
                                    }
                                 }
                                 if (! match) {
                                    index = startIndex_2;
                                 } else if(! currentRuleIsAtomic) {
                                    currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                                    currentNode = currentNode.getSibling();
                                 }
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                                 if (match) {
                                    // SqlLiteral
                                    match = sqlLiteral$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forLike$RuleMemoStart = startIndex;
         forLike$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forLike$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_LIKE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forLike$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forLike$RuleMemoStart = startIndex;
         forLike$RuleMemoEnd = -1;
         forLike$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SingleColumnForLoop : ("for" TestNoAlpha OptionalSpacing SqlIdentifier (ForIn | ForLike))
   protected boolean singleColumnForLoop$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SingleColumnForLoop", index);
      }
      if (singleColumnForLoop$RuleMemoStart == index) {
         if (singleColumnForLoop$RuleMemoStart <= singleColumnForLoop$RuleMemoEnd) {
            index = singleColumnForLoop$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_COLUMN_FOR_LOOP, singleColumnForLoop$RuleMemoStart, singleColumnForLoop$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (singleColumnForLoop$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(singleColumnForLoop$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing SqlIdentifier (ForIn | ForLike))
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlIdentifier
               match = sqlIdentifier$Rule();
               if (match) {
                  // (ForIn | ForLike)
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F':
                     case 'l':
                     case 'L': {
                        // ForLike
                        match = forLike$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     case 'i':
                     case 'I': {
                        // ForIn
                        match = forIn$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         singleColumnForLoop$RuleMemoStart = startIndex;
         singleColumnForLoop$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            singleColumnForLoop$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_COLUMN_FOR_LOOP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            singleColumnForLoop$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         singleColumnForLoop$RuleMemoStart = startIndex;
         singleColumnForLoop$RuleMemoEnd = -1;
         singleColumnForLoop$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MultiColumnForLoop : ("for" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (ParenthesesLiteralListList | Subquery) ')' OptionalSpacing)
   protected boolean multiColumnForLoop$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MultiColumnForLoop", index);
      }
      if (multiColumnForLoop$RuleMemoStart == index) {
         if (multiColumnForLoop$RuleMemoStart <= multiColumnForLoop$RuleMemoEnd) {
            index = multiColumnForLoop$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MULTI_COLUMN_FOR_LOOP, multiColumnForLoop$RuleMemoStart, multiColumnForLoop$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multiColumnForLoop$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multiColumnForLoop$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlIdentifierList ')' OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing (ParenthesesLiteralListList | Subquery) ')' OptionalSpacing)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlIdentifierList
                     match = sqlIdentifierList$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // "in"
                              match = ignoreCaseStringMatcher("in", 2);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // '('
                                       match = charMatcher('(');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // (ParenthesesLiteralListList | Subquery)
                                             Node lastNode_1 = currentNode;
                                             int lastIndex_1 = index;
                                             switch(buffer.getChar(index)) {
                                                case 's':
                                                case 'S': {
                                                   // Subquery
                                                   match = subquery$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                   }
                                                   break;
                                                }
                                                case '(': {
                                                   // ParenthesesLiteralListList
                                                   match = parenthesesLiteralListList$Rule();
                                                   if (! match) {
                                                      index = lastIndex_1;
                                                      lastNode_1.setSibling(null);
                                                      currentNode = lastNode_1;
                                                      // Subquery
                                                      match = subquery$Rule();
                                                      if (! match) {
                                                         index = lastIndex_1;
                                                         lastNode_1.setSibling(null);
                                                         currentNode = lastNode_1;
                                                      }
                                                   }
                                                   break;
                                                }
                                                default: {
                                                   match = false;
                                                }
                                             }
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         multiColumnForLoop$RuleMemoStart = startIndex;
         multiColumnForLoop$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multiColumnForLoop$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MULTI_COLUMN_FOR_LOOP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multiColumnForLoop$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         multiColumnForLoop$RuleMemoStart = startIndex;
         multiColumnForLoop$RuleMemoEnd = -1;
         multiColumnForLoop$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlLiteral : (NumberLiteral | StringLiteral | DateLiteral | TimestampLiteral | IntervalDayToSecondLiteral | IntervalYearToMonthLiteral | NullLiteral)
   protected boolean sqlLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlLiteral", index);
      }
      if (sqlLiteral$RuleMemoStart == index) {
         if (sqlLiteral$RuleMemoStart <= sqlLiteral$RuleMemoEnd) {
            index = sqlLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_LITERAL, sqlLiteral$RuleMemoStart, sqlLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumberLiteral | StringLiteral | DateLiteral | TimestampLiteral | IntervalDayToSecondLiteral | IntervalYearToMonthLiteral | NullLiteral)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '+':
         case '-': {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'n':
         case 'N': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NullLiteral
               match = nullLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 't':
         case 'T': {
            // TimestampLiteral
            match = timestampLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'd':
         case 'D': {
            // DateLiteral
            match = dateLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\'': {
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'i':
         case 'I': {
            // IntervalDayToSecondLiteral
            match = intervalDayToSecondLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // IntervalYearToMonthLiteral
               match = intervalYearToMonthLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlLiteral$RuleMemoStart = startIndex;
         sqlLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlLiteral$RuleMemoStart = startIndex;
         sqlLiteral$RuleMemoEnd = -1;
         sqlLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NullLiteral : (NullPattern TestNoAlpha OptionalSpacing)
   protected boolean nullLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NullLiteral", index);
      }
      if (nullLiteral$RuleMemoStart == index) {
         if (nullLiteral$RuleMemoStart <= nullLiteral$RuleMemoEnd) {
            index = nullLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NULL_LITERAL, nullLiteral$RuleMemoStart, nullLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (nullLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nullLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NullPattern TestNoAlpha OptionalSpacing)
      // NullPattern
      match = nullPattern$Rule();
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         nullLiteral$RuleMemoStart = startIndex;
         nullLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nullLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NULL_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nullLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nullLiteral$RuleMemoStart = startIndex;
         nullLiteral$RuleMemoEnd = -1;
         nullLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NullPattern : "null"
   protected boolean nullPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NullPattern", index);
      }
      startIndex = index;
      // "null"
      match = ignoreCaseStringMatcher("null", 4);
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.NULL_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DateLiteral : (DatePattern "DateLiteral" TestNoAlpha OptionalSpacing OptionalSpacing)
   protected boolean dateLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DateLiteral", index);
      }
      if (dateLiteral$RuleMemoStart == index) {
         if (dateLiteral$RuleMemoStart <= dateLiteral$RuleMemoEnd) {
            index = dateLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DATE_LITERAL, dateLiteral$RuleMemoStart, dateLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (dateLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dateLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (DatePattern "DateLiteral" TestNoAlpha OptionalSpacing OptionalSpacing)
      // DatePattern
      match = datePattern$Rule();
      if (match) {
         // "DateLiteral"
         match = ignoreCaseStringMatcher("DateLiteral", 11);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         dateLiteral$RuleMemoStart = startIndex;
         dateLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dateLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DATE_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dateLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dateLiteral$RuleMemoStart = startIndex;
         dateLiteral$RuleMemoEnd = -1;
         dateLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Year : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing '0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean year$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Year", index);
      }
      if (year$RuleMemoStart == index) {
         if (year$RuleMemoStart <= year$RuleMemoEnd) {
            index = year$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.YEAR, year$RuleMemoStart, year$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (year$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(year$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing '0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '0'-'9'
                        match = charRangeMatcher('0', '9');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         year$RuleMemoStart = startIndex;
         year$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            year$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.YEAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            year$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         year$RuleMemoStart = startIndex;
         year$RuleMemoEnd = -1;
         year$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Month : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean month$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Month", index);
      }
      if (month$RuleMemoStart == index) {
         if (month$RuleMemoStart <= month$RuleMemoEnd) {
            index = month$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MONTH, month$RuleMemoStart, month$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (month$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(month$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         month$RuleMemoStart = startIndex;
         month$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            month$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MONTH, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            month$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         month$RuleMemoStart = startIndex;
         month$RuleMemoEnd = -1;
         month$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Day : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean day$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Day", index);
      }
      if (day$RuleMemoStart == index) {
         if (day$RuleMemoStart <= day$RuleMemoEnd) {
            index = day$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DAY, day$RuleMemoStart, day$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (day$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(day$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         day$RuleMemoStart = startIndex;
         day$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            day$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DAY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            day$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         day$RuleMemoStart = startIndex;
         day$RuleMemoEnd = -1;
         day$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Hour : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean hour$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Hour", index);
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.HOUR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Minute : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean minute$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Minute", index);
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MINUTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Second : ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
   protected boolean second$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Second", index);
      }
      startIndex = index;
      // ('0'-'9' OptionalSpacing '0'-'9' OptionalSpacing)
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SECOND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DatePattern : ("date" '\'' Spaces? Year Spaces? '-' Spaces? Month Spaces? '-' Spaces? Day Spaces? '\'')
   protected boolean datePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "DatePattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("date" '\'' Spaces? Year Spaces? '-' Spaces? Month Spaces? '-' Spaces? Day Spaces? '\'')
      // "date"
      match = ignoreCaseStringMatcher("date", 4);
      if (match) {
         // '\''
         match = charMatcher('\'');
         if (match) {
            // Spaces?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // Spaces
            match = spaces$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // Year
               match = year$Rule();
               if (match) {
                  // Spaces?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Spaces
                  match = spaces$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // '-'
                     match = charMatcher('-');
                     if (match) {
                        // Spaces?
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // Spaces
                        match = spaces$Rule();
                        if (! match) {
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                        if (match) {
                           // Month
                           match = month$Rule();
                           if (match) {
                              // Spaces?
                              Node lastNode_4 = currentNode;
                              int lastIndex_4 = index;
                              // Spaces
                              match = spaces$Rule();
                              if (! match) {
                                 lastNode_4.setSibling(null);
                                 currentNode = lastNode_4;
                                 index = lastIndex_4;
                                 match = true;
                              }
                              if (match) {
                                 // '-'
                                 match = charMatcher('-');
                                 if (match) {
                                    // Spaces?
                                    Node lastNode_5 = currentNode;
                                    int lastIndex_5 = index;
                                    // Spaces
                                    match = spaces$Rule();
                                    if (! match) {
                                       lastNode_5.setSibling(null);
                                       currentNode = lastNode_5;
                                       index = lastIndex_5;
                                       match = true;
                                    }
                                    if (match) {
                                       // Day
                                       match = day$Rule();
                                       if (match) {
                                          // Spaces?
                                          Node lastNode_6 = currentNode;
                                          int lastIndex_6 = index;
                                          // Spaces
                                          match = spaces$Rule();
                                          if (! match) {
                                             lastNode_6.setSibling(null);
                                             currentNode = lastNode_6;
                                             index = lastIndex_6;
                                             match = true;
                                          }
                                          if (match) {
                                             // '\''
                                             match = charMatcher('\'');
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.DATE_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TimestampLiteral : (TimestampPattern OptionalSpacing)
   protected boolean timestampLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TimestampLiteral", index);
      }
      if (timestampLiteral$RuleMemoStart == index) {
         if (timestampLiteral$RuleMemoStart <= timestampLiteral$RuleMemoEnd) {
            index = timestampLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TIMESTAMP_LITERAL, timestampLiteral$RuleMemoStart, timestampLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (timestampLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timestampLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TimestampPattern OptionalSpacing)
      // TimestampPattern
      match = timestampPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         timestampLiteral$RuleMemoStart = startIndex;
         timestampLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timestampLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TIMESTAMP_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            timestampLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         timestampLiteral$RuleMemoStart = startIndex;
         timestampLiteral$RuleMemoEnd = -1;
         timestampLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TimestampPattern : ("timestamp" '\'' Spaces? Year Spaces? '-' Spaces? Month Spaces? '-' Spaces? Day Spaces? Hour Spaces? ':' Spaces? Minute Spaces? ':' Spaces? Second Spaces? '\'')
   protected boolean timestampPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "TimestampPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ("timestamp" '\'' Spaces? Year Spaces? '-' Spaces? Month Spaces? '-' Spaces? Day Spaces? Hour Spaces? ':' Spaces? Minute Spaces? ':' Spaces? Second Spaces? '\'')
      // "timestamp"
      match = ignoreCaseStringMatcher("timestamp", 9);
      if (match) {
         // '\''
         match = charMatcher('\'');
         if (match) {
            // Spaces?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // Spaces
            match = spaces$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // Year
               match = year$Rule();
               if (match) {
                  // Spaces?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Spaces
                  match = spaces$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // '-'
                     match = charMatcher('-');
                     if (match) {
                        // Spaces?
                        Node lastNode_3 = currentNode;
                        int lastIndex_3 = index;
                        // Spaces
                        match = spaces$Rule();
                        if (! match) {
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                           index = lastIndex_3;
                           match = true;
                        }
                        if (match) {
                           // Month
                           match = month$Rule();
                           if (match) {
                              // Spaces?
                              Node lastNode_4 = currentNode;
                              int lastIndex_4 = index;
                              // Spaces
                              match = spaces$Rule();
                              if (! match) {
                                 lastNode_4.setSibling(null);
                                 currentNode = lastNode_4;
                                 index = lastIndex_4;
                                 match = true;
                              }
                              if (match) {
                                 // '-'
                                 match = charMatcher('-');
                                 if (match) {
                                    // Spaces?
                                    Node lastNode_5 = currentNode;
                                    int lastIndex_5 = index;
                                    // Spaces
                                    match = spaces$Rule();
                                    if (! match) {
                                       lastNode_5.setSibling(null);
                                       currentNode = lastNode_5;
                                       index = lastIndex_5;
                                       match = true;
                                    }
                                    if (match) {
                                       // Day
                                       match = day$Rule();
                                       if (match) {
                                          // Spaces?
                                          Node lastNode_6 = currentNode;
                                          int lastIndex_6 = index;
                                          // Spaces
                                          match = spaces$Rule();
                                          if (! match) {
                                             lastNode_6.setSibling(null);
                                             currentNode = lastNode_6;
                                             index = lastIndex_6;
                                             match = true;
                                          }
                                          if (match) {
                                             // Hour
                                             match = hour$Rule();
                                             if (match) {
                                                // Spaces?
                                                Node lastNode_7 = currentNode;
                                                int lastIndex_7 = index;
                                                // Spaces
                                                match = spaces$Rule();
                                                if (! match) {
                                                   lastNode_7.setSibling(null);
                                                   currentNode = lastNode_7;
                                                   index = lastIndex_7;
                                                   match = true;
                                                }
                                                if (match) {
                                                   // ':'
                                                   match = charMatcher(':');
                                                   if (match) {
                                                      // Spaces?
                                                      Node lastNode_8 = currentNode;
                                                      int lastIndex_8 = index;
                                                      // Spaces
                                                      match = spaces$Rule();
                                                      if (! match) {
                                                         lastNode_8.setSibling(null);
                                                         currentNode = lastNode_8;
                                                         index = lastIndex_8;
                                                         match = true;
                                                      }
                                                      if (match) {
                                                         // Minute
                                                         match = minute$Rule();
                                                         if (match) {
                                                            // Spaces?
                                                            Node lastNode_9 = currentNode;
                                                            int lastIndex_9 = index;
                                                            // Spaces
                                                            match = spaces$Rule();
                                                            if (! match) {
                                                               lastNode_9.setSibling(null);
                                                               currentNode = lastNode_9;
                                                               index = lastIndex_9;
                                                               match = true;
                                                            }
                                                            if (match) {
                                                               // ':'
                                                               match = charMatcher(':');
                                                               if (match) {
                                                                  // Spaces?
                                                                  Node lastNode_10 = currentNode;
                                                                  int lastIndex_10 = index;
                                                                  // Spaces
                                                                  match = spaces$Rule();
                                                                  if (! match) {
                                                                     lastNode_10.setSibling(null);
                                                                     currentNode = lastNode_10;
                                                                     index = lastIndex_10;
                                                                     match = true;
                                                                  }
                                                                  if (match) {
                                                                     // Second
                                                                     match = second$Rule();
                                                                     if (match) {
                                                                        // Spaces?
                                                                        Node lastNode_11 = currentNode;
                                                                        int lastIndex_11 = index;
                                                                        // Spaces
                                                                        match = spaces$Rule();
                                                                        if (! match) {
                                                                           lastNode_11.setSibling(null);
                                                                           currentNode = lastNode_11;
                                                                           index = lastIndex_11;
                                                                           match = true;
                                                                        }
                                                                        if (match) {
                                                                           // '\''
                                                                           match = charMatcher('\'');
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.TIMESTAMP_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StringLiteral : (StringPattern OptionalSpacing)
   protected boolean stringLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "StringLiteral", index);
      }
      if (stringLiteral$RuleMemoStart == index) {
         if (stringLiteral$RuleMemoStart <= stringLiteral$RuleMemoEnd) {
            index = stringLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.STRING_LITERAL, stringLiteral$RuleMemoStart, stringLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (stringLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(stringLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (StringPattern OptionalSpacing)
      // StringPattern
      match = stringPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stringLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.STRING_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stringLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = -1;
         stringLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //StringPattern : (('n' | 'N')? ('\'' ("''" | ('\''! .))* '\''))
   protected boolean stringPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "StringPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('n' | 'N')? ('\'' ("''" | ('\''! .))* '\''))
      // ('n' | 'N')?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('n' | 'N')
      switch(buffer.getChar(index)) {
         case 'n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case 'N': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ('\'' ("''" | ('\''! .))* '\'')
         // '\''
         match = charMatcher('\'');
         if (match) {
            // ("''" | ('\''! .))*
            Node lastNode_2;
            int lastIndex_2;
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // ("''" | ('\''! .))
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // "''"
               match = ignoreCaseStringMatcher("''", 2);
               if (! match) {
                  // ('\''! .)
                  // '\''!
                  // '\''
                  match = buffer.matchChar(index, '\'');
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            // '\''
            match = charMatcher('\'');
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.STRING, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Order : (("asc" | "desc") TestNoAlpha OptionalSpacing)
   protected boolean order$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Order", index);
      }
      startIndex = index;
      // (("asc" | "desc") TestNoAlpha OptionalSpacing)
      // ("asc" | "desc")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'a':
         case 'A': {
            ++index;
            // "sc"
            if (match = ignoreCaseStringTest("sc", 2)) {
               index += 2;
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // "esc"
            if (match = ignoreCaseStringTest("esc", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NullsOrder : ("nulls" TestNoAlpha OptionalSpacing (("first" | "last") TestNoAlpha OptionalSpacing))
   protected boolean nullsOrder$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NullsOrder", index);
      }
      startIndex = index;
      // ("nulls" TestNoAlpha OptionalSpacing (("first" | "last") TestNoAlpha OptionalSpacing))
      // "nulls"
      match = ignoreCaseStringMatcher("nulls", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("first" | "last") TestNoAlpha OptionalSpacing)
               // ("first" | "last")
               int startIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case 'f':
                  case 'F': {
                     ++index;
                     // "irst"
                     if (match = ignoreCaseStringTest("irst", 4)) {
                        index += 4;
                     }
                     break;
                  }
                  case 'l':
                  case 'L': {
                     ++index;
                     // "ast"
                     if (match = ignoreCaseStringTest("ast", 3)) {
                        index += 3;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  index = startIndex_1;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.NULLS_ORDER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrderByArg : (IntegerLiteral | SqlExpression)
   protected boolean orderByArg$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrderByArg", index);
      }
      startIndex = index;
      // (IntegerLiteral | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case ':':
         case '?':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlExpression
            match = sqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // IntegerLiteral
            match = integerLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlExpression
               match = sqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_ARG, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrderByArgument : (OrderByArg Order? NullsOrder?)
   protected boolean orderByArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrderByArgument", index);
      }
      if (orderByArgument$RuleMemoStart == index) {
         if (orderByArgument$RuleMemoStart <= orderByArgument$RuleMemoEnd) {
            index = orderByArgument$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_ARGUMENT, orderByArgument$RuleMemoStart, orderByArgument$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orderByArgument$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orderByArgument$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (OrderByArg Order? NullsOrder?)
      // OrderByArg
      match = orderByArg$Rule();
      if (match) {
         // Order?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Order
         match = order$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // NullsOrder?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // NullsOrder
            match = nullsOrder$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         orderByArgument$RuleMemoStart = startIndex;
         orderByArgument$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orderByArgument$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_ARGUMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orderByArgument$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         orderByArgument$RuleMemoStart = startIndex;
         orderByArgument$RuleMemoEnd = -1;
         orderByArgument$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrderByArguments : (OrderByArgument (',' OptionalSpacing OrderByArgument)*)
   protected boolean orderByArguments$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrderByArguments", index);
      }
      if (orderByArguments$RuleMemoStart == index) {
         if (orderByArguments$RuleMemoStart <= orderByArguments$RuleMemoEnd) {
            index = orderByArguments$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_ARGUMENTS, orderByArguments$RuleMemoStart, orderByArguments$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orderByArguments$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orderByArguments$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (OrderByArgument (',' OptionalSpacing OrderByArgument)*)
      // OrderByArgument
      match = orderByArgument$Rule();
      if (match) {
         // (',' OptionalSpacing OrderByArgument)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing OrderByArgument)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // OrderByArgument
                  match = orderByArgument$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         orderByArguments$RuleMemoStart = startIndex;
         orderByArguments$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orderByArguments$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_ARGUMENTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orderByArguments$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         orderByArguments$RuleMemoStart = startIndex;
         orderByArguments$RuleMemoEnd = -1;
         orderByArguments$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrderByClause : ("order" TestNoAlpha OptionalSpacing ("siblings" TestNoAlpha OptionalSpacing)? "by" TestNoAlpha OptionalSpacing OrderByArguments)
   protected boolean orderByClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrderByClause", index);
      }
      if (orderByClause$RuleMemoStart == index) {
         if (orderByClause$RuleMemoStart <= orderByClause$RuleMemoEnd) {
            index = orderByClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_CLAUSE, orderByClause$RuleMemoStart, orderByClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (orderByClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(orderByClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("order" TestNoAlpha OptionalSpacing ("siblings" TestNoAlpha OptionalSpacing)? "by" TestNoAlpha OptionalSpacing OrderByArguments)
      // "order"
      match = ignoreCaseStringMatcher("order", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("siblings" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("siblings" TestNoAlpha OptionalSpacing)
               // "siblings"
               match = ignoreCaseStringMatcher("siblings", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // "by"
                  match = ignoreCaseStringMatcher("by", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // OrderByArguments
                           match = orderByArguments$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         orderByClause$RuleMemoStart = startIndex;
         orderByClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            orderByClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ORDER_BY_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            orderByClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         orderByClause$RuleMemoStart = startIndex;
         orderByClause$RuleMemoEnd = -1;
         orderByClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryFactoringSource : (SqlIdentifier "as" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
   protected boolean subqueryFactoringSource$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryFactoringSource", index);
      }
      if (subqueryFactoringSource$RuleMemoStart == index) {
         if (subqueryFactoringSource$RuleMemoStart <= subqueryFactoringSource$RuleMemoEnd) {
            index = subqueryFactoringSource$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_FACTORING_SOURCE, subqueryFactoringSource$RuleMemoStart, subqueryFactoringSource$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subqueryFactoringSource$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subqueryFactoringSource$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlIdentifier "as" TestNoAlpha OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         // "as"
         match = ignoreCaseStringMatcher("as", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Subquery
                        match = subquery$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         subqueryFactoringSource$RuleMemoStart = startIndex;
         subqueryFactoringSource$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subqueryFactoringSource$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_FACTORING_SOURCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subqueryFactoringSource$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subqueryFactoringSource$RuleMemoStart = startIndex;
         subqueryFactoringSource$RuleMemoEnd = -1;
         subqueryFactoringSource$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryFactoringClause : ("with" TestNoAlpha OptionalSpacing SubqueryFactoringSource (',' OptionalSpacing SubqueryFactoringSource)*)
   protected boolean subqueryFactoringClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryFactoringClause", index);
      }
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing SubqueryFactoringSource (',' OptionalSpacing SubqueryFactoringSource)*)
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SubqueryFactoringSource
               match = subqueryFactoringSource$Rule();
               if (match) {
                  // (',' OptionalSpacing SubqueryFactoringSource)*
                  Node lastNode_1;
                  int lastIndex_1;
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // (',' OptionalSpacing SubqueryFactoringSource)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // SubqueryFactoringSource
                           match = subqueryFactoringSource$Rule();
                        }
                     }
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_FACTORING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WaitClause : (("nowait" TestNoAlpha OptionalSpacing) | ("wait" TestNoAlpha OptionalSpacing IntegerLiteral) | ("skip" TestNoAlpha OptionalSpacing "locked" TestNoAlpha OptionalSpacing))
   protected boolean waitClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WaitClause", index);
      }
      startIndex = index;
      // (("nowait" TestNoAlpha OptionalSpacing) | ("wait" TestNoAlpha OptionalSpacing IntegerLiteral) | ("skip" TestNoAlpha OptionalSpacing "locked" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("nowait" TestNoAlpha OptionalSpacing)
      // "nowait"
      match = ignoreCaseStringMatcher("nowait", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("wait" TestNoAlpha OptionalSpacing IntegerLiteral)
         // "wait"
         match = ignoreCaseStringMatcher("wait", 4);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // IntegerLiteral
                  match = integerLiteral$Rule();
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ("skip" TestNoAlpha OptionalSpacing "locked" TestNoAlpha OptionalSpacing)
            // "skip"
            match = ignoreCaseStringMatcher("skip", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "locked"
                     match = ignoreCaseStringMatcher("locked", 6);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.WAIT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForUpdateClause : ("for" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing (("of" TestNoAlpha OptionalSpacing TableName) "OfTable" TestNoAlpha OptionalSpacing)? WaitClause?)
   protected boolean forUpdateClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForUpdateClause", index);
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing "update" TestNoAlpha OptionalSpacing (("of" TestNoAlpha OptionalSpacing TableName) "OfTable" TestNoAlpha OptionalSpacing)? WaitClause?)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "update"
               match = ignoreCaseStringMatcher("update", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (("of" TestNoAlpha OptionalSpacing TableName) "OfTable" TestNoAlpha OptionalSpacing)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // (("of" TestNoAlpha OptionalSpacing TableName) "OfTable" TestNoAlpha OptionalSpacing)
                        // ("of" TestNoAlpha OptionalSpacing TableName)
                        // "of"
                        match = ignoreCaseStringMatcher("of", 2);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // TableName
                                 match = tableName$Rule();
                              }
                           }
                        }
                        if (match) {
                           // "OfTable"
                           match = ignoreCaseStringMatcher("OfTable", 7);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // WaitClause?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // WaitClause
                           match = waitClause$Rule();
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_UPDATE_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OnlyDmlTableExpresionClause : ("only" TestNoAlpha OptionalSpacing '(' OptionalSpacing DmlTableExpressionClause ')' OptionalSpacing)
   protected boolean onlyDmlTableExpresionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OnlyDmlTableExpresionClause", index);
      }
      if (onlyDmlTableExpresionClause$RuleMemoStart == index) {
         if (onlyDmlTableExpresionClause$RuleMemoStart <= onlyDmlTableExpresionClause$RuleMemoEnd) {
            index = onlyDmlTableExpresionClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ONLY_DML_TABLE_EXPRESION_CLAUSE, onlyDmlTableExpresionClause$RuleMemoStart, onlyDmlTableExpresionClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (onlyDmlTableExpresionClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(onlyDmlTableExpresionClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("only" TestNoAlpha OptionalSpacing '(' OptionalSpacing DmlTableExpressionClause ')' OptionalSpacing)
      // "only"
      match = ignoreCaseStringMatcher("only", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // DmlTableExpressionClause
                     match = dmlTableExpressionClause$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         onlyDmlTableExpresionClause$RuleMemoStart = startIndex;
         onlyDmlTableExpresionClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            onlyDmlTableExpresionClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ONLY_DML_TABLE_EXPRESION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            onlyDmlTableExpresionClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         onlyDmlTableExpresionClause$RuleMemoStart = startIndex;
         onlyDmlTableExpresionClause$RuleMemoEnd = -1;
         onlyDmlTableExpresionClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UpdateStatement : ("update" TestNoAlpha OptionalSpacing Hint? (OnlyDmlTableExpresionClause | DmlTableExpressionClause) SqlIdentifier? UpdateSetClause WhereClause? ReturningClause?)
   protected boolean updateStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UpdateStatement", index);
      }
      if (updateStatement$RuleMemoStart == index) {
         if (updateStatement$RuleMemoStart <= updateStatement$RuleMemoEnd) {
            index = updateStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UPDATE_STATEMENT, updateStatement$RuleMemoStart, updateStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (updateStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(updateStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("update" TestNoAlpha OptionalSpacing Hint? (OnlyDmlTableExpresionClause | DmlTableExpressionClause) SqlIdentifier? UpdateSetClause WhereClause? ReturningClause?)
      // "update"
      match = ignoreCaseStringMatcher("update", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // (OnlyDmlTableExpresionClause | DmlTableExpressionClause)
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  switch(buffer.getChar(index)) {
                     case 'O':
                     case 'o': {
                        // OnlyDmlTableExpresionClause
                        match = onlyDmlTableExpresionClause$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           // DmlTableExpressionClause
                           match = dmlTableExpressionClause$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                        }
                        break;
                     }
                     case '\"':
                     case '#':
                     case '$':
                     case '(':
                     case '0':
                     case '1':
                     case '2':
                     case '3':
                     case '4':
                     case '5':
                     case '6':
                     case '7':
                     case '8':
                     case '9':
                     case 'A':
                     case 'B':
                     case 'C':
                     case 'D':
                     case 'E':
                     case 'F':
                     case 'G':
                     case 'H':
                     case 'I':
                     case 'J':
                     case 'K':
                     case 'L':
                     case 'M':
                     case 'N':
                     case 'P':
                     case 'Q':
                     case 'R':
                     case 'S':
                     case 'T':
                     case 'U':
                     case 'V':
                     case 'W':
                     case 'X':
                     case 'Y':
                     case 'Z':
                     case '_':
                     case 'a':
                     case 'b':
                     case 'c':
                     case 'd':
                     case 'e':
                     case 'f':
                     case 'g':
                     case 'h':
                     case 'i':
                     case 'j':
                     case 'k':
                     case 'l':
                     case 'm':
                     case 'n':
                     case 'p':
                     case 'q':
                     case 'r':
                     case 's':
                     case 't':
                     case 'u':
                     case 'v':
                     case 'w':
                     case 'x':
                     case 'y':
                     case 'z':
                     case '\u00C1':
                     case '\u00C2':
                     case '\u00C3':
                     case '\u00C4':
                     case '\u00C7':
                     case '\u00C8':
                     case '\u00C9':
                     case '\u00CA':
                     case '\u00CB':
                     case '\u00CC':
                     case '\u00CD':
                     case '\u00CE':
                     case '\u00CF':
                     case '\u00D2':
                     case '\u00D3':
                     case '\u00D4':
                     case '\u00D5':
                     case '\u00D6':
                     case '\u00D9':
                     case '\u00DA':
                     case '\u00DB':
                     case '\u00DC':
                     case '\u00E0':
                     case '\u00E1':
                     case '\u00E2':
                     case '\u00E3':
                     case '\u00E4':
                     case '\u00E7':
                     case '\u00E8':
                     case '\u00E9':
                     case '\u00EA':
                     case '\u00EB':
                     case '\u00EC':
                     case '\u00ED':
                     case '\u00EE':
                     case '\u00EF':
                     case '\u00F2':
                     case '\u00F3':
                     case '\u00F4':
                     case '\u00F5':
                     case '\u00F6':
                     case '\u00F9':
                     case '\u00FA':
                     case '\u00FB':
                     case '\u00FC': {
                        // DmlTableExpressionClause
                        match = dmlTableExpressionClause$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  if (match) {
                     // SqlIdentifier?
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // SqlIdentifier
                     match = sqlIdentifier$Rule();
                     if (! match) {
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        index = lastIndex_3;
                        match = true;
                     }
                     if (match) {
                        // UpdateSetClause
                        match = updateSetClause$Rule();
                        if (match) {
                           // WhereClause?
                           Node lastNode_4 = currentNode;
                           int lastIndex_4 = index;
                           // WhereClause
                           match = whereClause$Rule();
                           if (! match) {
                              lastNode_4.setSibling(null);
                              currentNode = lastNode_4;
                              index = lastIndex_4;
                              match = true;
                           }
                           if (match) {
                              // ReturningClause?
                              Node lastNode_5 = currentNode;
                              int lastIndex_5 = index;
                              // ReturningClause
                              match = returningClause$Rule();
                              if (! match) {
                                 lastNode_5.setSibling(null);
                                 currentNode = lastNode_5;
                                 index = lastIndex_5;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         updateStatement$RuleMemoStart = startIndex;
         updateStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            updateStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UPDATE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            updateStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         updateStatement$RuleMemoStart = startIndex;
         updateStatement$RuleMemoEnd = -1;
         updateStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PartitionName : ('(' OptionalSpacing SqlAnyIdentifier ')' OptionalSpacing)
   protected boolean partitionName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PartitionName", index);
      }
      if (partitionName$RuleMemoStart == index) {
         if (partitionName$RuleMemoStart <= partitionName$RuleMemoEnd) {
            index = partitionName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARTITION_NAME, partitionName$RuleMemoStart, partitionName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (partitionName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(partitionName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SqlAnyIdentifier ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlAnyIdentifier
            match = sqlAnyIdentifier$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         partitionName$RuleMemoStart = startIndex;
         partitionName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            partitionName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARTITION_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            partitionName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         partitionName$RuleMemoStart = startIndex;
         partitionName$RuleMemoEnd = -1;
         partitionName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PartitionKey : ("for" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing)
   protected boolean partitionKey$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PartitionKey", index);
      }
      if (partitionKey$RuleMemoStart == index) {
         if (partitionKey$RuleMemoStart <= partitionKey$RuleMemoEnd) {
            index = partitionKey$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARTITION_KEY, partitionKey$RuleMemoStart, partitionKey$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (partitionKey$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(partitionKey$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlExpression ')' OptionalSpacing)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         partitionKey$RuleMemoStart = startIndex;
         partitionKey$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            partitionKey$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARTITION_KEY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            partitionKey$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         partitionKey$RuleMemoStart = startIndex;
         partitionKey$RuleMemoEnd = -1;
         partitionKey$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TablePartitionName : (TableName "partition" TestNoAlpha OptionalSpacing (PartitionName | PartitionKey))
   protected boolean tablePartitionName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TablePartitionName", index);
      }
      if (tablePartitionName$RuleMemoStart == index) {
         if (tablePartitionName$RuleMemoStart <= tablePartitionName$RuleMemoEnd) {
            index = tablePartitionName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_PARTITION_NAME, tablePartitionName$RuleMemoStart, tablePartitionName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tablePartitionName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tablePartitionName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableName "partition" TestNoAlpha OptionalSpacing (PartitionName | PartitionKey))
      // TableName
      match = tableName$Rule();
      if (match) {
         // "partition"
         match = ignoreCaseStringMatcher("partition", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // (PartitionName | PartitionKey)
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F': {
                        // PartitionKey
                        match = partitionKey$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     case '(': {
                        // PartitionName
                        match = partitionName$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         tablePartitionName$RuleMemoStart = startIndex;
         tablePartitionName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tablePartitionName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_PARTITION_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tablePartitionName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tablePartitionName$RuleMemoStart = startIndex;
         tablePartitionName$RuleMemoEnd = -1;
         tablePartitionName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TableSubPartitionName : (TableName "subpartition" TestNoAlpha OptionalSpacing (PartitionName | PartitionKey))
   protected boolean tableSubPartitionName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TableSubPartitionName", index);
      }
      if (tableSubPartitionName$RuleMemoStart == index) {
         if (tableSubPartitionName$RuleMemoStart <= tableSubPartitionName$RuleMemoEnd) {
            index = tableSubPartitionName$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TABLE_SUB_PARTITION_NAME, tableSubPartitionName$RuleMemoStart, tableSubPartitionName$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (tableSubPartitionName$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(tableSubPartitionName$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TableName "subpartition" TestNoAlpha OptionalSpacing (PartitionName | PartitionKey))
      // TableName
      match = tableName$Rule();
      if (match) {
         // "subpartition"
         match = ignoreCaseStringMatcher("subpartition", 12);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // (PartitionName | PartitionKey)
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F': {
                        // PartitionKey
                        match = partitionKey$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     case '(': {
                        // PartitionName
                        match = partitionName$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         tableSubPartitionName$RuleMemoStart = startIndex;
         tableSubPartitionName$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tableSubPartitionName$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TABLE_SUB_PARTITION_NAME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tableSubPartitionName$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         tableSubPartitionName$RuleMemoStart = startIndex;
         tableSubPartitionName$RuleMemoEnd = -1;
         tableSubPartitionName$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubqueryDmlExpression : ('(' OptionalSpacing Subquery SubqueryRestriction ')' OptionalSpacing)
   protected boolean subqueryDmlExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubqueryDmlExpression", index);
      }
      if (subqueryDmlExpression$RuleMemoStart == index) {
         if (subqueryDmlExpression$RuleMemoStart <= subqueryDmlExpression$RuleMemoEnd) {
            index = subqueryDmlExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_DML_EXPRESSION, subqueryDmlExpression$RuleMemoStart, subqueryDmlExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subqueryDmlExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subqueryDmlExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing Subquery SubqueryRestriction ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Subquery
            match = subquery$Rule();
            if (match) {
               // SubqueryRestriction
               match = subqueryRestriction$Rule();
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         subqueryDmlExpression$RuleMemoStart = startIndex;
         subqueryDmlExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subqueryDmlExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBQUERY_DML_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subqueryDmlExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subqueryDmlExpression$RuleMemoStart = startIndex;
         subqueryDmlExpression$RuleMemoEnd = -1;
         subqueryDmlExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DmlTableExpressionClause : (TablePartitionName | TableSubPartitionName | TableName | SubqueryDmlExpression | TableCollectionExpression)
   protected boolean dmlTableExpressionClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DmlTableExpressionClause", index);
      }
      if (dmlTableExpressionClause$RuleMemoStart == index) {
         if (dmlTableExpressionClause$RuleMemoStart <= dmlTableExpressionClause$RuleMemoEnd) {
            index = dmlTableExpressionClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DML_TABLE_EXPRESSION_CLAUSE, dmlTableExpressionClause$RuleMemoStart, dmlTableExpressionClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dmlTableExpressionClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dmlTableExpressionClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (TablePartitionName | TableSubPartitionName | TableName | SubqueryDmlExpression | TableCollectionExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // TablePartitionName
            match = tablePartitionName$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // TableSubPartitionName
               match = tableSubPartitionName$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // TableName
                  match = tableName$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'T':
         case 't': {
            // TablePartitionName
            match = tablePartitionName$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // TableSubPartitionName
               match = tableSubPartitionName$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // TableName
                  match = tableName$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // TableCollectionExpression
                     match = tableCollectionExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // SubqueryDmlExpression
            match = subqueryDmlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         dmlTableExpressionClause$RuleMemoStart = startIndex;
         dmlTableExpressionClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dmlTableExpressionClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DML_TABLE_EXPRESSION_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dmlTableExpressionClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dmlTableExpressionClause$RuleMemoStart = startIndex;
         dmlTableExpressionClause$RuleMemoEnd = -1;
         dmlTableExpressionClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UpdateSetClause : ("set" TestNoAlpha OptionalSpacing (ObjectSetValue | ColumnSetValueList))
   protected boolean updateSetClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UpdateSetClause", index);
      }
      if (updateSetClause$RuleMemoStart == index) {
         if (updateSetClause$RuleMemoStart <= updateSetClause$RuleMemoEnd) {
            index = updateSetClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UPDATE_SET_CLAUSE, updateSetClause$RuleMemoStart, updateSetClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (updateSetClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(updateSetClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("set" TestNoAlpha OptionalSpacing (ObjectSetValue | ColumnSetValueList))
      // "set"
      match = ignoreCaseStringMatcher("set", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (ObjectSetValue | ColumnSetValueList)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '(':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // ColumnSetValueList
                     match = columnSetValueList$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case 'V':
                  case 'v': {
                     // ObjectSetValue
                     match = objectSetValue$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ColumnSetValueList
                        match = columnSetValueList$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         updateSetClause$RuleMemoStart = startIndex;
         updateSetClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            updateSetClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UPDATE_SET_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            updateSetClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         updateSetClause$RuleMemoStart = startIndex;
         updateSetClause$RuleMemoEnd = -1;
         updateSetClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Alias : SqlIdentifier
   protected boolean alias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Alias", index);
      }
      if (alias$RuleMemoStart == index) {
         if (alias$RuleMemoStart <= alias$RuleMemoEnd) {
            index = alias$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ALIAS, alias$RuleMemoStart, alias$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (alias$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(alias$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         alias$RuleMemoStart = startIndex;
         alias$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            alias$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ALIAS, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            alias$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         alias$RuleMemoStart = startIndex;
         alias$RuleMemoEnd = -1;
         alias$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ObjectSetValue : ("value" TestNoAlpha OptionalSpacing '(' OptionalSpacing Alias ')' OptionalSpacing '=' OptionalSpacing (('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression))
   protected boolean objectSetValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ObjectSetValue", index);
      }
      if (objectSetValue$RuleMemoStart == index) {
         if (objectSetValue$RuleMemoStart <= objectSetValue$RuleMemoEnd) {
            index = objectSetValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OBJECT_SET_VALUE, objectSetValue$RuleMemoStart, objectSetValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (objectSetValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(objectSetValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("value" TestNoAlpha OptionalSpacing '(' OptionalSpacing Alias ')' OptionalSpacing '=' OptionalSpacing (('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression))
      // "value"
      match = ignoreCaseStringMatcher("value", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Alias
                     match = alias$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '='
                              match = charMatcher('=');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // (('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression)
                                    Node lastNode_1 = currentNode;
                                    int lastIndex_1 = index;
                                    // ('(' OptionalSpacing Subquery ')' OptionalSpacing)
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // Subquery
                                          match = subquery$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // SqlExpression
                                       match = sqlExpression$Rule();
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         objectSetValue$RuleMemoStart = startIndex;
         objectSetValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            objectSetValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OBJECT_SET_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            objectSetValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         objectSetValue$RuleMemoStart = startIndex;
         objectSetValue$RuleMemoEnd = -1;
         objectSetValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnsGroupSetValue : (ColumnsList '=' OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
   protected boolean columnsGroupSetValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnsGroupSetValue", index);
      }
      if (columnsGroupSetValue$RuleMemoStart == index) {
         if (columnsGroupSetValue$RuleMemoStart <= columnsGroupSetValue$RuleMemoEnd) {
            index = columnsGroupSetValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMNS_GROUP_SET_VALUE, columnsGroupSetValue$RuleMemoStart, columnsGroupSetValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (columnsGroupSetValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(columnsGroupSetValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ColumnsList '=' OptionalSpacing '(' OptionalSpacing Subquery ')' OptionalSpacing)
      // ColumnsList
      match = columnsList$Rule();
      if (match) {
         // '='
         match = charMatcher('=');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Subquery
                     match = subquery$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         columnsGroupSetValue$RuleMemoStart = startIndex;
         columnsGroupSetValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            columnsGroupSetValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMNS_GROUP_SET_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            columnsGroupSetValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         columnsGroupSetValue$RuleMemoStart = startIndex;
         columnsGroupSetValue$RuleMemoEnd = -1;
         columnsGroupSetValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SingleColumnSetValue : (ColumnName '=' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | ('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression))
   protected boolean singleColumnSetValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SingleColumnSetValue", index);
      }
      if (singleColumnSetValue$RuleMemoStart == index) {
         if (singleColumnSetValue$RuleMemoStart <= singleColumnSetValue$RuleMemoEnd) {
            index = singleColumnSetValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_COLUMN_SET_VALUE, singleColumnSetValue$RuleMemoStart, singleColumnSetValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (singleColumnSetValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(singleColumnSetValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ColumnName '=' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | ('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression))
      // ColumnName
      match = columnName$Rule();
      if (match) {
         // '='
         match = charMatcher('=');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("default" TestNoAlpha OptionalSpacing) | ('(' OptionalSpacing Subquery ')' OptionalSpacing) | SqlExpression)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("default" TestNoAlpha OptionalSpacing)
               // "default"
               match = ignoreCaseStringMatcher("default", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ('(' OptionalSpacing Subquery ')' OptionalSpacing)
                  // '('
                  match = charMatcher('(');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Subquery
                        match = subquery$Rule();
                        if (match) {
                           // ')'
                           match = charMatcher(')');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlExpression
                     match = sqlExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         singleColumnSetValue$RuleMemoStart = startIndex;
         singleColumnSetValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            singleColumnSetValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_COLUMN_SET_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            singleColumnSetValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         singleColumnSetValue$RuleMemoStart = startIndex;
         singleColumnSetValue$RuleMemoEnd = -1;
         singleColumnSetValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnSetValue : (ColumnsGroupSetValue | SingleColumnSetValue)
   protected boolean columnSetValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnSetValue", index);
      }
      if (columnSetValue$RuleMemoStart == index) {
         if (columnSetValue$RuleMemoStart <= columnSetValue$RuleMemoEnd) {
            index = columnSetValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_SET_VALUE, columnSetValue$RuleMemoStart, columnSetValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (columnSetValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(columnSetValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ColumnsGroupSetValue | SingleColumnSetValue)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SingleColumnSetValue
            match = singleColumnSetValue$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '(': {
            // ColumnsGroupSetValue
            match = columnsGroupSetValue$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         columnSetValue$RuleMemoStart = startIndex;
         columnSetValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            columnSetValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_SET_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            columnSetValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         columnSetValue$RuleMemoStart = startIndex;
         columnSetValue$RuleMemoEnd = -1;
         columnSetValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ColumnSetValueList : (ColumnSetValue (',' OptionalSpacing ColumnSetValue)*)
   protected boolean columnSetValueList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ColumnSetValueList", index);
      }
      if (columnSetValueList$RuleMemoStart == index) {
         if (columnSetValueList$RuleMemoStart <= columnSetValueList$RuleMemoEnd) {
            index = columnSetValueList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_SET_VALUE_LIST, columnSetValueList$RuleMemoStart, columnSetValueList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (columnSetValueList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(columnSetValueList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ColumnSetValue (',' OptionalSpacing ColumnSetValue)*)
      // ColumnSetValue
      match = columnSetValue$Rule();
      if (match) {
         // (',' OptionalSpacing ColumnSetValue)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ColumnSetValue)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ColumnSetValue
                  match = columnSetValue$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         columnSetValueList$RuleMemoStart = startIndex;
         columnSetValueList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            columnSetValueList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLUMN_SET_VALUE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            columnSetValueList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         columnSetValueList$RuleMemoStart = startIndex;
         columnSetValueList$RuleMemoEnd = -1;
         columnSetValueList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturningClause : ((("returning" | "return") TestNoAlpha OptionalSpacing) SqlExpressionList BulkCollect? "into" TestNoAlpha OptionalSpacing ReturnIntoVariablesList)
   protected boolean returningClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturningClause", index);
      }
      if (returningClause$RuleMemoStart == index) {
         if (returningClause$RuleMemoStart <= returningClause$RuleMemoEnd) {
            index = returningClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RETURNING_CLAUSE, returningClause$RuleMemoStart, returningClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (returningClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(returningClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("returning" | "return") TestNoAlpha OptionalSpacing) SqlExpressionList BulkCollect? "into" TestNoAlpha OptionalSpacing ReturnIntoVariablesList)
      // (("returning" | "return") TestNoAlpha OptionalSpacing)
      // ("returning" | "return")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eturning" | "eturn")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("turning" | "turn")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("urning" | "urn")
               match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
               if (match) {
                  ++index;
                  // ("rning" | "rn")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("ning" | "n")
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("ing" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // "ng"
                           if (match = ignoreCaseStringTest("ng", 2)) {
                              index += 2;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // SqlExpressionList
         match = sqlExpressionList$Rule();
         if (match) {
            // BulkCollect?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // BulkCollect
            match = bulkCollect$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
            if (match) {
               // "into"
               match = ignoreCaseStringMatcher("into", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ReturnIntoVariablesList
                        match = returnIntoVariablesList$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         returningClause$RuleMemoStart = startIndex;
         returningClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            returningClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURNING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            returningClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         returningClause$RuleMemoStart = startIndex;
         returningClause$RuleMemoEnd = -1;
         returningClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BindVariable : (('?' OptionalSpacing) | (':' OptionalSpacing (SqlAnyIdentifier | IntegerLiteral)))
   protected boolean bindVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BindVariable", index);
      }
      if (bindVariable$RuleMemoStart == index) {
         if (bindVariable$RuleMemoStart <= bindVariable$RuleMemoEnd) {
            index = bindVariable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BIND_VARIABLE, bindVariable$RuleMemoStart, bindVariable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bindVariable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bindVariable$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (('?' OptionalSpacing) | (':' OptionalSpacing (SqlAnyIdentifier | IntegerLiteral)))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('?' OptionalSpacing)
      // '?'
      match = charMatcher('?');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (':' OptionalSpacing (SqlAnyIdentifier | IntegerLiteral))
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (SqlAnyIdentifier | IntegerLiteral)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               switch(buffer.getChar(index)) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9': {
                     // SqlAnyIdentifier
                     match = sqlAnyIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        // IntegerLiteral
                        match = integerLiteral$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                        }
                     }
                     break;
                  }
                  case '\"':
                  case '#':
                  case '$':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // SqlAnyIdentifier
                     match = sqlAnyIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         bindVariable$RuleMemoStart = startIndex;
         bindVariable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bindVariable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BIND_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bindVariable$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         bindVariable$RuleMemoStart = startIndex;
         bindVariable$RuleMemoEnd = -1;
         bindVariable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturnIntoVariable : (BindVariable | SqlObjectIdentifier)
   protected boolean returnIntoVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturnIntoVariable", index);
      }
      if (returnIntoVariable$RuleMemoStart == index) {
         if (returnIntoVariable$RuleMemoStart <= returnIntoVariable$RuleMemoEnd) {
            index = returnIntoVariable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RETURN_INTO_VARIABLE, returnIntoVariable$RuleMemoStart, returnIntoVariable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (returnIntoVariable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(returnIntoVariable$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BindVariable | SqlObjectIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlObjectIdentifier
            match = sqlObjectIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case ':':
         case '?': {
            // BindVariable
            match = bindVariable$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         returnIntoVariable$RuleMemoStart = startIndex;
         returnIntoVariable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            returnIntoVariable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURN_INTO_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            returnIntoVariable$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         returnIntoVariable$RuleMemoStart = startIndex;
         returnIntoVariable$RuleMemoEnd = -1;
         returnIntoVariable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturnIntoVariablesList : (ReturnIntoVariable (',' OptionalSpacing ReturnIntoVariable)*)
   protected boolean returnIntoVariablesList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturnIntoVariablesList", index);
      }
      startIndex = index;
      // (ReturnIntoVariable (',' OptionalSpacing ReturnIntoVariable)*)
      // ReturnIntoVariable
      match = returnIntoVariable$Rule();
      if (match) {
         // (',' OptionalSpacing ReturnIntoVariable)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing ReturnIntoVariable)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ReturnIntoVariable
                  match = returnIntoVariable$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURN_INTO_VARIABLES_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InsertStatement : (SingleTableInsert | MultiTableInsert)
   protected boolean insertStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InsertStatement", index);
      }
      if (insertStatement$RuleMemoStart == index) {
         if (insertStatement$RuleMemoStart <= insertStatement$RuleMemoEnd) {
            index = insertStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INSERT_STATEMENT, insertStatement$RuleMemoStart, insertStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (insertStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(insertStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SingleTableInsert | MultiTableInsert)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'i':
         case 'I': {
            // SingleTableInsert
            match = singleTableInsert$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // MultiTableInsert
               match = multiTableInsert$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         insertStatement$RuleMemoStart = startIndex;
         insertStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            insertStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INSERT_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            insertStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         insertStatement$RuleMemoStart = startIndex;
         insertStatement$RuleMemoEnd = -1;
         insertStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Values : (ValuesClause ReturningClause?)
   protected boolean values$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Values", index);
      }
      if (values$RuleMemoStart == index) {
         if (values$RuleMemoStart <= values$RuleMemoEnd) {
            index = values$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VALUES, values$RuleMemoStart, values$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (values$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(values$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ValuesClause ReturningClause?)
      // ValuesClause
      match = valuesClause$Rule();
      if (match) {
         // ReturningClause?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ReturningClause
         match = returningClause$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         values$RuleMemoStart = startIndex;
         values$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            values$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VALUES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            values$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         values$RuleMemoStart = startIndex;
         values$RuleMemoEnd = -1;
         values$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SingleInsertSource : (Values | Subquery)
   protected boolean singleInsertSource$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SingleInsertSource", index);
      }
      startIndex = index;
      // (Values | Subquery)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 's':
         case 'S':
         case '(': {
            // Subquery
            match = subquery$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'v':
         case 'V': {
            // Values
            match = values$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_INSERT_SOURCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SingleTableInsert : ("insert" TestNoAlpha OptionalSpacing Hint? InsertIntoClause SingleInsertSource ErrorLogingClause?)
   protected boolean singleTableInsert$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SingleTableInsert", index);
      }
      if (singleTableInsert$RuleMemoStart == index) {
         if (singleTableInsert$RuleMemoStart <= singleTableInsert$RuleMemoEnd) {
            index = singleTableInsert$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_TABLE_INSERT, singleTableInsert$RuleMemoStart, singleTableInsert$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (singleTableInsert$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(singleTableInsert$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("insert" TestNoAlpha OptionalSpacing Hint? InsertIntoClause SingleInsertSource ErrorLogingClause?)
      // "insert"
      match = ignoreCaseStringMatcher("insert", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // InsertIntoClause
                  match = insertIntoClause$Rule();
                  if (match) {
                     // SingleInsertSource
                     match = singleInsertSource$Rule();
                     if (match) {
                        // ErrorLogingClause?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // ErrorLogingClause
                        match = errorLogingClause$Rule();
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         singleTableInsert$RuleMemoStart = startIndex;
         singleTableInsert$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            singleTableInsert$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SINGLE_TABLE_INSERT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            singleTableInsert$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         singleTableInsert$RuleMemoStart = startIndex;
         singleTableInsert$RuleMemoEnd = -1;
         singleTableInsert$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InsertInto : (InsertIntoClause ValuesClause? ErrorLogingClause?)
   protected boolean insertInto$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InsertInto", index);
      }
      startIndex = index;
      // (InsertIntoClause ValuesClause? ErrorLogingClause?)
      // InsertIntoClause
      match = insertIntoClause$Rule();
      if (match) {
         // ValuesClause?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ValuesClause
         match = valuesClause$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // ErrorLogingClause?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // ErrorLogingClause
            match = errorLogingClause$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MultiIntoClause : ("all" TestNoAlpha OptionalSpacing InsertInto+)
   protected boolean multiIntoClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MultiIntoClause", index);
      }
      if (multiIntoClause$RuleMemoStart == index) {
         if (multiIntoClause$RuleMemoStart <= multiIntoClause$RuleMemoEnd) {
            index = multiIntoClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MULTI_INTO_CLAUSE, multiIntoClause$RuleMemoStart, multiIntoClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multiIntoClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multiIntoClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("all" TestNoAlpha OptionalSpacing InsertInto+)
      // "all"
      match = ignoreCaseStringMatcher("all", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // InsertInto+
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // InsertInto
               match = insertInto$Rule();
               if (match) {
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // InsertInto
                     match = insertInto$Rule();
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               } else {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
               }
            }
         }
      }
      if (match) {
         multiIntoClause$RuleMemoStart = startIndex;
         multiIntoClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multiIntoClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MULTI_INTO_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multiIntoClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         multiIntoClause$RuleMemoStart = startIndex;
         multiIntoClause$RuleMemoEnd = -1;
         multiIntoClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MultiTableInsert : ("insert" TestNoAlpha OptionalSpacing Hint? (MultiIntoClause | ConditionalInsertClause) Subquery)
   protected boolean multiTableInsert$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MultiTableInsert", index);
      }
      if (multiTableInsert$RuleMemoStart == index) {
         if (multiTableInsert$RuleMemoStart <= multiTableInsert$RuleMemoEnd) {
            index = multiTableInsert$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MULTI_TABLE_INSERT, multiTableInsert$RuleMemoStart, multiTableInsert$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multiTableInsert$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multiTableInsert$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("insert" TestNoAlpha OptionalSpacing Hint? (MultiIntoClause | ConditionalInsertClause) Subquery)
      // "insert"
      match = ignoreCaseStringMatcher("insert", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // (MultiIntoClause | ConditionalInsertClause)
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  switch(buffer.getChar(index)) {
                     case 'a':
                     case 'A': {
                        // MultiIntoClause
                        match = multiIntoClause$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           // ConditionalInsertClause
                           match = conditionalInsertClause$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                        }
                        break;
                     }
                     case 'f':
                     case 'F':
                     case 'w':
                     case 'W': {
                        // ConditionalInsertClause
                        match = conditionalInsertClause$Rule();
                        if (! match) {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  if (match) {
                     // Subquery
                     match = subquery$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         multiTableInsert$RuleMemoStart = startIndex;
         multiTableInsert$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multiTableInsert$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MULTI_TABLE_INSERT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multiTableInsert$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         multiTableInsert$RuleMemoStart = startIndex;
         multiTableInsert$RuleMemoEnd = -1;
         multiTableInsert$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InsertIntoValuesClause : (InsertIntoClause ValuesClause?)
   protected boolean insertIntoValuesClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InsertIntoValuesClause", index);
      }
      startIndex = index;
      // (InsertIntoClause ValuesClause?)
      // InsertIntoClause
      match = insertIntoClause$Rule();
      if (match) {
         // ValuesClause?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ValuesClause
         match = valuesClause$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO_VALUES_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InsertIntoValuesClauseList : InsertIntoValuesClause+
   protected boolean insertIntoValuesClauseList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InsertIntoValuesClauseList", index);
      }
      if (insertIntoValuesClauseList$RuleMemoStart == index) {
         if (insertIntoValuesClauseList$RuleMemoStart <= insertIntoValuesClauseList$RuleMemoEnd) {
            index = insertIntoValuesClauseList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO_VALUES_CLAUSE_LIST, insertIntoValuesClauseList$RuleMemoStart, insertIntoValuesClauseList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (insertIntoValuesClauseList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(insertIntoValuesClauseList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // InsertIntoValuesClause+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // InsertIntoValuesClause
      match = insertIntoValuesClause$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // InsertIntoValuesClause
            match = insertIntoValuesClause$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         insertIntoValuesClauseList$RuleMemoStart = startIndex;
         insertIntoValuesClauseList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            insertIntoValuesClauseList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO_VALUES_CLAUSE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            insertIntoValuesClauseList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         insertIntoValuesClauseList$RuleMemoStart = startIndex;
         insertIntoValuesClauseList$RuleMemoEnd = -1;
         insertIntoValuesClauseList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionalInsertWhen : ("when" TestNoAlpha OptionalSpacing SqlCondition "then" TestNoAlpha OptionalSpacing InsertIntoValuesClauseList)
   protected boolean conditionalInsertWhen$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionalInsertWhen", index);
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing SqlCondition "then" TestNoAlpha OptionalSpacing InsertIntoValuesClauseList)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlCondition
               match = sqlCondition$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // InsertIntoValuesClauseList
                           match = insertIntoValuesClauseList$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITIONAL_INSERT_WHEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionalInsertElse : ("else" TestNoAlpha OptionalSpacing InsertIntoValuesClauseList)
   protected boolean conditionalInsertElse$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionalInsertElse", index);
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing InsertIntoValuesClauseList)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // InsertIntoValuesClauseList
               match = insertIntoValuesClauseList$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITIONAL_INSERT_ELSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionalInsertWhenList : ConditionalInsertWhen+
   protected boolean conditionalInsertWhenList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionalInsertWhenList", index);
      }
      startIndex = index;
      // ConditionalInsertWhen+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ConditionalInsertWhen
      match = conditionalInsertWhen$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ConditionalInsertWhen
            match = conditionalInsertWhen$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITIONAL_INSERT_WHEN_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConditionalInsertClause : ((("all" | "first") TestNoAlpha OptionalSpacing)? ConditionalInsertWhenList ConditionalInsertElse?)
   protected boolean conditionalInsertClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConditionalInsertClause", index);
      }
      if (conditionalInsertClause$RuleMemoStart == index) {
         if (conditionalInsertClause$RuleMemoStart <= conditionalInsertClause$RuleMemoEnd) {
            index = conditionalInsertClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONDITIONAL_INSERT_CLAUSE, conditionalInsertClause$RuleMemoStart, conditionalInsertClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (conditionalInsertClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(conditionalInsertClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("all" | "first") TestNoAlpha OptionalSpacing)? ConditionalInsertWhenList ConditionalInsertElse?)
      // (("all" | "first") TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (("all" | "first") TestNoAlpha OptionalSpacing)
      // ("all" | "first")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // "irst"
            if (match = ignoreCaseStringTest("irst", 4)) {
               index += 4;
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // "ll"
            if (match = ignoreCaseStringTest("ll", 2)) {
               index += 2;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // ConditionalInsertWhenList
         match = conditionalInsertWhenList$Rule();
         if (match) {
            // ConditionalInsertElse?
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // ConditionalInsertElse
            match = conditionalInsertElse$Rule();
            if (! match) {
               lastNode_3.setSibling(null);
               currentNode = lastNode_3;
               index = lastIndex_3;
               match = true;
            }
         }
      }
      if (match) {
         conditionalInsertClause$RuleMemoStart = startIndex;
         conditionalInsertClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            conditionalInsertClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONDITIONAL_INSERT_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            conditionalInsertClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         conditionalInsertClause$RuleMemoStart = startIndex;
         conditionalInsertClause$RuleMemoEnd = -1;
         conditionalInsertClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InsertIntoClause : ("into" TestNoAlpha OptionalSpacing DmlTableExpressionClause SqlIdentifier? ColumnsList?)
   protected boolean insertIntoClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InsertIntoClause", index);
      }
      if (insertIntoClause$RuleMemoStart == index) {
         if (insertIntoClause$RuleMemoStart <= insertIntoClause$RuleMemoEnd) {
            index = insertIntoClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO_CLAUSE, insertIntoClause$RuleMemoStart, insertIntoClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (insertIntoClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(insertIntoClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("into" TestNoAlpha OptionalSpacing DmlTableExpressionClause SqlIdentifier? ColumnsList?)
      // "into"
      match = ignoreCaseStringMatcher("into", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DmlTableExpressionClause
               match = dmlTableExpressionClause$Rule();
               if (match) {
                  // SqlIdentifier?
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // SqlIdentifier
                  match = sqlIdentifier$Rule();
                  if (! match) {
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     index = lastIndex_1;
                     match = true;
                  }
                  if (match) {
                     // ColumnsList?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ColumnsList
                     match = columnsList$Rule();
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         insertIntoClause$RuleMemoStart = startIndex;
         insertIntoClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            insertIntoClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INSERT_INTO_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            insertIntoClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         insertIntoClause$RuleMemoStart = startIndex;
         insertIntoClause$RuleMemoEnd = -1;
         insertIntoClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ValueClauseData : (("default" TestNoAlpha OptionalSpacing) | SqlExpression)
   protected boolean valueClauseData$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ValueClauseData", index);
      }
      if (valueClauseData$RuleMemoStart == index) {
         if (valueClauseData$RuleMemoStart <= valueClauseData$RuleMemoEnd) {
            index = valueClauseData$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VALUE_CLAUSE_DATA, valueClauseData$RuleMemoStart, valueClauseData$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (valueClauseData$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valueClauseData$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("default" TestNoAlpha OptionalSpacing) | SqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("default" TestNoAlpha OptionalSpacing)
      // "default"
      match = ignoreCaseStringMatcher("default", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // SqlExpression
         match = sqlExpression$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         valueClauseData$RuleMemoStart = startIndex;
         valueClauseData$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valueClauseData$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VALUE_CLAUSE_DATA, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valueClauseData$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         valueClauseData$RuleMemoStart = startIndex;
         valueClauseData$RuleMemoEnd = -1;
         valueClauseData$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ValuesClauseList : ('(' OptionalSpacing ValueClauseData (',' OptionalSpacing ValueClauseData)* ')' OptionalSpacing)
   protected boolean valuesClauseList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ValuesClauseList", index);
      }
      if (valuesClauseList$RuleMemoStart == index) {
         if (valuesClauseList$RuleMemoStart <= valuesClauseList$RuleMemoEnd) {
            index = valuesClauseList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VALUES_CLAUSE_LIST, valuesClauseList$RuleMemoStart, valuesClauseList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (valuesClauseList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valuesClauseList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ValueClauseData (',' OptionalSpacing ValueClauseData)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ValueClauseData
            match = valueClauseData$Rule();
            if (match) {
               // (',' OptionalSpacing ValueClauseData)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing ValueClauseData)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ValueClauseData
                        match = valueClauseData$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         valuesClauseList$RuleMemoStart = startIndex;
         valuesClauseList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valuesClauseList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VALUES_CLAUSE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valuesClauseList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         valuesClauseList$RuleMemoStart = startIndex;
         valuesClauseList$RuleMemoEnd = -1;
         valuesClauseList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ValuesClause : ("values" TestNoAlpha OptionalSpacing (ValuesClauseList | SqlObjectIdentifier))
   protected boolean valuesClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ValuesClause", index);
      }
      if (valuesClause$RuleMemoStart == index) {
         if (valuesClause$RuleMemoStart <= valuesClause$RuleMemoEnd) {
            index = valuesClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VALUES_CLAUSE, valuesClause$RuleMemoStart, valuesClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (valuesClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valuesClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("values" TestNoAlpha OptionalSpacing (ValuesClauseList | SqlObjectIdentifier))
      // "values"
      match = ignoreCaseStringMatcher("values", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (ValuesClauseList | SqlObjectIdentifier)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               switch(buffer.getChar(index)) {
                  case '\"':
                  case '#':
                  case '$':
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                  case '\u00C1':
                  case '\u00C2':
                  case '\u00C3':
                  case '\u00C4':
                  case '\u00C7':
                  case '\u00C8':
                  case '\u00C9':
                  case '\u00CA':
                  case '\u00CB':
                  case '\u00CC':
                  case '\u00CD':
                  case '\u00CE':
                  case '\u00CF':
                  case '\u00D2':
                  case '\u00D3':
                  case '\u00D4':
                  case '\u00D5':
                  case '\u00D6':
                  case '\u00D9':
                  case '\u00DA':
                  case '\u00DB':
                  case '\u00DC':
                  case '\u00E0':
                  case '\u00E1':
                  case '\u00E2':
                  case '\u00E3':
                  case '\u00E4':
                  case '\u00E7':
                  case '\u00E8':
                  case '\u00E9':
                  case '\u00EA':
                  case '\u00EB':
                  case '\u00EC':
                  case '\u00ED':
                  case '\u00EE':
                  case '\u00EF':
                  case '\u00F2':
                  case '\u00F3':
                  case '\u00F4':
                  case '\u00F5':
                  case '\u00F6':
                  case '\u00F9':
                  case '\u00FA':
                  case '\u00FB':
                  case '\u00FC': {
                     // SqlObjectIdentifier
                     match = sqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  case '(': {
                     // ValuesClauseList
                     match = valuesClauseList$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
         }
      }
      if (match) {
         valuesClause$RuleMemoStart = startIndex;
         valuesClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valuesClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VALUES_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valuesClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         valuesClause$RuleMemoStart = startIndex;
         valuesClause$RuleMemoEnd = -1;
         valuesClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntoTable : ("into" TestNoAlpha OptionalSpacing TableName)
   protected boolean intoTable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntoTable", index);
      }
      startIndex = index;
      // ("into" TestNoAlpha OptionalSpacing TableName)
      // "into"
      match = ignoreCaseStringMatcher("into", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // TableName
               match = tableName$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INTO_TABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RejectLimit : ("reject" TestNoAlpha OptionalSpacing "limit" TestNoAlpha OptionalSpacing (("unlimited" TestNoAlpha OptionalSpacing) | IntegerLiteral))
   protected boolean rejectLimit$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RejectLimit", index);
      }
      startIndex = index;
      // ("reject" TestNoAlpha OptionalSpacing "limit" TestNoAlpha OptionalSpacing (("unlimited" TestNoAlpha OptionalSpacing) | IntegerLiteral))
      // "reject"
      match = ignoreCaseStringMatcher("reject", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "limit"
               match = ignoreCaseStringMatcher("limit", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (("unlimited" TestNoAlpha OptionalSpacing) | IntegerLiteral)
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ("unlimited" TestNoAlpha OptionalSpacing)
                        // "unlimited"
                        match = ignoreCaseStringMatcher("unlimited", 9);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // IntegerLiteral
                           match = integerLiteral$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.REJECT_LIMIT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ErrorLogingClause : ("log" TestNoAlpha OptionalSpacing "errors" TestNoAlpha OptionalSpacing IntoTable? ('(' OptionalSpacing SqlSimpleExpression ')' OptionalSpacing)? RejectLimit?)
   protected boolean errorLogingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ErrorLogingClause", index);
      }
      if (errorLogingClause$RuleMemoStart == index) {
         if (errorLogingClause$RuleMemoStart <= errorLogingClause$RuleMemoEnd) {
            index = errorLogingClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ERROR_LOGING_CLAUSE, errorLogingClause$RuleMemoStart, errorLogingClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (errorLogingClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(errorLogingClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("log" TestNoAlpha OptionalSpacing "errors" TestNoAlpha OptionalSpacing IntoTable? ('(' OptionalSpacing SqlSimpleExpression ')' OptionalSpacing)? RejectLimit?)
      // "log"
      match = ignoreCaseStringMatcher("log", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "errors"
               match = ignoreCaseStringMatcher("errors", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // IntoTable?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // IntoTable
                        match = intoTable$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // ('(' OptionalSpacing SqlSimpleExpression ')' OptionalSpacing)?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // ('(' OptionalSpacing SqlSimpleExpression ')' OptionalSpacing)
                           // '('
                           match = charMatcher('(');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // SqlSimpleExpression
                                 match = sqlSimpleExpression$Rule();
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // RejectLimit?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // RejectLimit
                              match = rejectLimit$Rule();
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         errorLogingClause$RuleMemoStart = startIndex;
         errorLogingClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            errorLogingClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ERROR_LOGING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            errorLogingClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         errorLogingClause$RuleMemoStart = startIndex;
         errorLogingClause$RuleMemoEnd = -1;
         errorLogingClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DeleteStatement : ("delete" TestNoAlpha OptionalSpacing Hint? ("from" TestNoAlpha OptionalSpacing)? (OnlyDmlTableExpresionClause | DmlTableExpressionClause) SqlIdentifier? WhereClause? ReturningClause? ErrorLogingClause?)
   protected boolean deleteStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DeleteStatement", index);
      }
      if (deleteStatement$RuleMemoStart == index) {
         if (deleteStatement$RuleMemoStart <= deleteStatement$RuleMemoEnd) {
            index = deleteStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DELETE_STATEMENT, deleteStatement$RuleMemoStart, deleteStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (deleteStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(deleteStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("delete" TestNoAlpha OptionalSpacing Hint? ("from" TestNoAlpha OptionalSpacing)? (OnlyDmlTableExpresionClause | DmlTableExpressionClause) SqlIdentifier? WhereClause? ReturningClause? ErrorLogingClause?)
      // "delete"
      match = ignoreCaseStringMatcher("delete", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Hint?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Hint
               match = hint$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ("from" TestNoAlpha OptionalSpacing)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ("from" TestNoAlpha OptionalSpacing)
                  // "from"
                  match = ignoreCaseStringMatcher("from", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // (OnlyDmlTableExpresionClause | DmlTableExpressionClause)
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     switch(buffer.getChar(index)) {
                        case 'O':
                        case 'o': {
                           // OnlyDmlTableExpresionClause
                           match = onlyDmlTableExpresionClause$Rule();
                           if (! match) {
                              index = lastIndex_3;
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                              // DmlTableExpressionClause
                              match = dmlTableExpressionClause$Rule();
                              if (! match) {
                                 index = lastIndex_3;
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                              }
                           }
                           break;
                        }
                        case '\"':
                        case '#':
                        case '$':
                        case '(':
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'G':
                        case 'H':
                        case 'I':
                        case 'J':
                        case 'K':
                        case 'L':
                        case 'M':
                        case 'N':
                        case 'P':
                        case 'Q':
                        case 'R':
                        case 'S':
                        case 'T':
                        case 'U':
                        case 'V':
                        case 'W':
                        case 'X':
                        case 'Y':
                        case 'Z':
                        case '_':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                        case 'g':
                        case 'h':
                        case 'i':
                        case 'j':
                        case 'k':
                        case 'l':
                        case 'm':
                        case 'n':
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                        case 't':
                        case 'u':
                        case 'v':
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                        case '\u00C1':
                        case '\u00C2':
                        case '\u00C3':
                        case '\u00C4':
                        case '\u00C7':
                        case '\u00C8':
                        case '\u00C9':
                        case '\u00CA':
                        case '\u00CB':
                        case '\u00CC':
                        case '\u00CD':
                        case '\u00CE':
                        case '\u00CF':
                        case '\u00D2':
                        case '\u00D3':
                        case '\u00D4':
                        case '\u00D5':
                        case '\u00D6':
                        case '\u00D9':
                        case '\u00DA':
                        case '\u00DB':
                        case '\u00DC':
                        case '\u00E0':
                        case '\u00E1':
                        case '\u00E2':
                        case '\u00E3':
                        case '\u00E4':
                        case '\u00E7':
                        case '\u00E8':
                        case '\u00E9':
                        case '\u00EA':
                        case '\u00EB':
                        case '\u00EC':
                        case '\u00ED':
                        case '\u00EE':
                        case '\u00EF':
                        case '\u00F2':
                        case '\u00F3':
                        case '\u00F4':
                        case '\u00F5':
                        case '\u00F6':
                        case '\u00F9':
                        case '\u00FA':
                        case '\u00FB':
                        case '\u00FC': {
                           // DmlTableExpressionClause
                           match = dmlTableExpressionClause$Rule();
                           if (! match) {
                              index = lastIndex_3;
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                     if (match) {
                        // SqlIdentifier?
                        Node lastNode_4 = currentNode;
                        int lastIndex_4 = index;
                        // SqlIdentifier
                        match = sqlIdentifier$Rule();
                        if (! match) {
                           lastNode_4.setSibling(null);
                           currentNode = lastNode_4;
                           index = lastIndex_4;
                           match = true;
                        }
                        if (match) {
                           // WhereClause?
                           Node lastNode_5 = currentNode;
                           int lastIndex_5 = index;
                           // WhereClause
                           match = whereClause$Rule();
                           if (! match) {
                              lastNode_5.setSibling(null);
                              currentNode = lastNode_5;
                              index = lastIndex_5;
                              match = true;
                           }
                           if (match) {
                              // ReturningClause?
                              Node lastNode_6 = currentNode;
                              int lastIndex_6 = index;
                              // ReturningClause
                              match = returningClause$Rule();
                              if (! match) {
                                 lastNode_6.setSibling(null);
                                 currentNode = lastNode_6;
                                 index = lastIndex_6;
                                 match = true;
                              }
                              if (match) {
                                 // ErrorLogingClause?
                                 Node lastNode_7 = currentNode;
                                 int lastIndex_7 = index;
                                 // ErrorLogingClause
                                 match = errorLogingClause$Rule();
                                 if (! match) {
                                    lastNode_7.setSibling(null);
                                    currentNode = lastNode_7;
                                    index = lastIndex_7;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         deleteStatement$RuleMemoStart = startIndex;
         deleteStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            deleteStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DELETE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            deleteStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         deleteStatement$RuleMemoStart = startIndex;
         deleteStatement$RuleMemoEnd = -1;
         deleteStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UnsignedNumber : (IntegerPattern ('.' OptionalSpacing IntegerPattern)?)
   protected boolean unsignedNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UnsignedNumber", index);
      }
      if (unsignedNumber$RuleMemoStart == index) {
         if (unsignedNumber$RuleMemoStart <= unsignedNumber$RuleMemoEnd) {
            index = unsignedNumber$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UNSIGNED_NUMBER, unsignedNumber$RuleMemoStart, unsignedNumber$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (unsignedNumber$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(unsignedNumber$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (IntegerPattern ('.' OptionalSpacing IntegerPattern)?)
      // IntegerPattern
      match = integerPattern$Rule();
      if (match) {
         // ('.' OptionalSpacing IntegerPattern)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ('.' OptionalSpacing IntegerPattern)
         // '.'
         match = charMatcher('.');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IntegerPattern
               match = integerPattern$Rule();
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         unsignedNumber$RuleMemoStart = startIndex;
         unsignedNumber$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unsignedNumber$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UNSIGNED_NUMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unsignedNumber$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         unsignedNumber$RuleMemoStart = startIndex;
         unsignedNumber$RuleMemoEnd = -1;
         unsignedNumber$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Sign : (('+' | '-') OptionalSpacing)
   protected boolean sign$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Sign", index);
      }
      if (sign$RuleMemoStart == index) {
         if (sign$RuleMemoStart <= sign$RuleMemoEnd) {
            index = sign$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SIGN, sign$RuleMemoStart, sign$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sign$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sign$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (('+' | '-') OptionalSpacing)
      // ('+' | '-')
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '-': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         sign$RuleMemoStart = startIndex;
         sign$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sign$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SIGN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sign$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sign$RuleMemoStart = startIndex;
         sign$RuleMemoEnd = -1;
         sign$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NumberLiteral : (NumberPattern OptionalSpacing)
   protected boolean numberLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NumberLiteral", index);
      }
      if (numberLiteral$RuleMemoStart == index) {
         if (numberLiteral$RuleMemoStart <= numberLiteral$RuleMemoEnd) {
            index = numberLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NUMBER_LITERAL, numberLiteral$RuleMemoStart, numberLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (numberLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numberLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumberPattern OptionalSpacing)
      // NumberPattern
      match = numberPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numberLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMBER_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numberLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = -1;
         numberLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Exponent : ("e" TestNoAlpha OptionalSpacing Sign? IntegerPattern ("d" TestNoAlpha OptionalSpacing)?)
   protected boolean exponent$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Exponent", index);
      }
      startIndex = index;
      // ("e" TestNoAlpha OptionalSpacing Sign? IntegerPattern ("d" TestNoAlpha OptionalSpacing)?)
      // "e"
      match = ignoreCaseCharMatcher('e');
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Sign?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Sign
               match = sign$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // IntegerPattern
                  match = integerPattern$Rule();
                  if (match) {
                     // ("d" TestNoAlpha OptionalSpacing)?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ("d" TestNoAlpha OptionalSpacing)
                     // "d"
                     match = ignoreCaseCharMatcher('d');
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EXPONENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NumberPattern : (Sign? UnsignedNumber Exponent?)
   protected boolean numberPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "NumberPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (Sign? UnsignedNumber Exponent?)
      // Sign?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // Sign
      match = sign$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // UnsignedNumber
         match = unsignedNumber$Rule();
         if (match) {
            // Exponent?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // Exponent
            match = exponent$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMBER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntegerLiteral : (IntegerPattern OptionalSpacing)
   protected boolean integerLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntegerLiteral", index);
      }
      if (integerLiteral$RuleMemoStart == index) {
         if (integerLiteral$RuleMemoStart <= integerLiteral$RuleMemoEnd) {
            index = integerLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTEGER_LITERAL, integerLiteral$RuleMemoStart, integerLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (integerLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(integerLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (IntegerPattern OptionalSpacing)
      // IntegerPattern
      match = integerPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         integerLiteral$RuleMemoStart = startIndex;
         integerLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integerLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTEGER_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            integerLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         integerLiteral$RuleMemoStart = startIndex;
         integerLiteral$RuleMemoEnd = -1;
         integerLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntegerPattern : '0'-'9'+
   protected boolean integerPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "IntegerPattern", index);
      }
      if (integerPattern$RuleMemoStart == index) {
         if (integerPattern$RuleMemoStart <= integerPattern$RuleMemoEnd) {
            index = integerPattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTEGER_LITERAL, integerPattern$RuleMemoStart, integerPattern$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (integerPattern$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(integerPattern$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // '0'-'9'+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // '0'-'9'
            match = charRangeMatcher('0', '9');
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerPattern$RuleMemoStart = startIndex;
         integerPattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integerPattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTEGER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            integerPattern$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerPattern$RuleMemoStart = startIndex;
         integerPattern$RuleMemoEnd = -1;
         integerPattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Size : ('(' OptionalSpacing NumberLiteral ')' OptionalSpacing)
   protected boolean size$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Size", index);
      }
      if (size$RuleMemoStart == index) {
         if (size$RuleMemoStart <= size$RuleMemoEnd) {
            index = size$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SIZE, size$RuleMemoStart, size$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (size$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(size$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing NumberLiteral ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         size$RuleMemoStart = startIndex;
         size$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            size$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SIZE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            size$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         size$RuleMemoStart = startIndex;
         size$RuleMemoEnd = -1;
         size$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CharSetDefinition : ("character" TestNoAlpha OptionalSpacing "set" TestNoAlpha OptionalSpacing SqlObjectIdentifier CharSetAttr)?
   protected boolean charSetDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CharSetDefinition", index);
      }
      if (charSetDefinition$RuleMemoStart == index) {
         if (charSetDefinition$RuleMemoStart <= charSetDefinition$RuleMemoEnd) {
            index = charSetDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CHAR_SET_DEFINITION, charSetDefinition$RuleMemoStart, charSetDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (charSetDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(charSetDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("character" TestNoAlpha OptionalSpacing "set" TestNoAlpha OptionalSpacing SqlObjectIdentifier CharSetAttr)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("character" TestNoAlpha OptionalSpacing "set" TestNoAlpha OptionalSpacing SqlObjectIdentifier CharSetAttr)
      // "character"
      match = ignoreCaseStringMatcher("character", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "set"
               match = ignoreCaseStringMatcher("set", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlObjectIdentifier
                        match = sqlObjectIdentifier$Rule();
                        if (match) {
                           // CharSetAttr
                           match = charSetAttr$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         charSetDefinition$RuleMemoStart = startIndex;
         charSetDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            charSetDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CHAR_SET_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            charSetDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         charSetDefinition$RuleMemoStart = startIndex;
         charSetDefinition$RuleMemoEnd = -1;
         charSetDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CharSetAttr : ('%' OptionalSpacing "charset" TestNoAlpha OptionalSpacing)?
   protected boolean charSetAttr$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CharSetAttr", index);
      }
      startIndex = index;
      // ('%' OptionalSpacing "charset" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('%' OptionalSpacing "charset" TestNoAlpha OptionalSpacing)
      // '%'
      match = charMatcher('%');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "charset"
            match = ignoreCaseStringMatcher("charset", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CHAR_SET_ATTR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CharSize : ('(' OptionalSpacing NumberLiteral (("byte" | "char") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)?
   protected boolean charSize$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CharSize", index);
      }
      if (charSize$RuleMemoStart == index) {
         if (charSize$RuleMemoStart <= charSize$RuleMemoEnd) {
            index = charSize$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CHAR_SIZE, charSize$RuleMemoStart, charSize$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (charSize$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(charSize$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing NumberLiteral (("byte" | "char") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('(' OptionalSpacing NumberLiteral (("byte" | "char") TestNoAlpha OptionalSpacing)? ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // NumberLiteral
            match = numberLiteral$Rule();
            if (match) {
               // (("byte" | "char") TestNoAlpha OptionalSpacing)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (("byte" | "char") TestNoAlpha OptionalSpacing)
               // ("byte" | "char")
               int startIndex_3 = index;
               switch(buffer.getChar(index)) {
                  case 'b':
                  case 'B': {
                     ++index;
                     // "yte"
                     if (match = ignoreCaseStringTest("yte", 3)) {
                        index += 3;
                     }
                     break;
                  }
                  case 'c':
                  case 'C': {
                     ++index;
                     // "har"
                     if (match = ignoreCaseStringTest("har", 3)) {
                        index += 3;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
               if (! match) {
                  index = startIndex_3;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         charSize$RuleMemoStart = startIndex;
         charSize$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            charSize$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CHAR_SIZE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            charSize$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         charSize$RuleMemoStart = startIndex;
         charSize$RuleMemoEnd = -1;
         charSize$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VarChar2 : ("varchar2" OptionalSpacing CharSize CharSetDefinition)
   protected boolean varChar2$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VarChar2", index);
      }
      if (varChar2$RuleMemoStart == index) {
         if (varChar2$RuleMemoStart <= varChar2$RuleMemoEnd) {
            index = varChar2$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VAR_CHAR2, varChar2$RuleMemoStart, varChar2$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (varChar2$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(varChar2$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("varchar2" OptionalSpacing CharSize CharSetDefinition)
      // "varchar2"
      match = ignoreCaseStringMatcher("varchar2", 8);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // CharSize
            match = charSize$Rule();
            if (match) {
               // CharSetDefinition
               match = charSetDefinition$Rule();
            }
         }
      }
      if (match) {
         varChar2$RuleMemoStart = startIndex;
         varChar2$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            varChar2$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VAR_CHAR2, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            varChar2$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         varChar2$RuleMemoStart = startIndex;
         varChar2$RuleMemoEnd = -1;
         varChar2$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VarChar : ("varchar" TestNoAlpha OptionalSpacing CharSize CharSetDefinition)
   protected boolean varChar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VarChar", index);
      }
      if (varChar$RuleMemoStart == index) {
         if (varChar$RuleMemoStart <= varChar$RuleMemoEnd) {
            index = varChar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VAR_CHAR, varChar$RuleMemoStart, varChar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (varChar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(varChar$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("varchar" TestNoAlpha OptionalSpacing CharSize CharSetDefinition)
      // "varchar"
      match = ignoreCaseStringMatcher("varchar", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CharSize
               match = charSize$Rule();
               if (match) {
                  // CharSetDefinition
                  match = charSetDefinition$Rule();
               }
            }
         }
      }
      if (match) {
         varChar$RuleMemoStart = startIndex;
         varChar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            varChar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VAR_CHAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            varChar$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         varChar$RuleMemoStart = startIndex;
         varChar$RuleMemoEnd = -1;
         varChar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Char : ("char" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? CharSize CharSetDefinition)
   protected boolean char$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Char", index);
      }
      if (char$RuleMemoStart == index) {
         if (char$RuleMemoStart <= char$RuleMemoEnd) {
            index = char$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CHAR, char$RuleMemoStart, char$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (char$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(char$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("char" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? CharSize CharSetDefinition)
      // "char"
      match = ignoreCaseStringMatcher("char", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("varying" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("varying" TestNoAlpha OptionalSpacing)
               // "varying"
               match = ignoreCaseStringMatcher("varying", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // CharSize
                  match = charSize$Rule();
                  if (match) {
                     // CharSetDefinition
                     match = charSetDefinition$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         char$RuleMemoStart = startIndex;
         char$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            char$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CHAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            char$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         char$RuleMemoStart = startIndex;
         char$RuleMemoEnd = -1;
         char$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Precision : NumberLiteral
   protected boolean precision$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Precision", index);
      }
      startIndex = index;
      // NumberLiteral
      match = numberLiteral$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PRECISION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NumberSize : ('(' OptionalSpacing Precision (',' OptionalSpacing NumberLiteral)? ')' OptionalSpacing)?
   protected boolean numberSize$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NumberSize", index);
      }
      if (numberSize$RuleMemoStart == index) {
         if (numberSize$RuleMemoStart <= numberSize$RuleMemoEnd) {
            index = numberSize$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NUMBER_SIZE, numberSize$RuleMemoStart, numberSize$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (numberSize$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numberSize$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing Precision (',' OptionalSpacing NumberLiteral)? ')' OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('(' OptionalSpacing Precision (',' OptionalSpacing NumberLiteral)? ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Precision
            match = precision$Rule();
            if (match) {
               // (',' OptionalSpacing NumberLiteral)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // (',' OptionalSpacing NumberLiteral)
               // ','
               match = charMatcher(',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // NumberLiteral
                     match = numberLiteral$Rule();
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         numberSize$RuleMemoStart = startIndex;
         numberSize$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numberSize$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMBER_SIZE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numberSize$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         numberSize$RuleMemoStart = startIndex;
         numberSize$RuleMemoEnd = -1;
         numberSize$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Number : ("number" TestNoAlpha OptionalSpacing NumberSize)
   protected boolean number$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Number", index);
      }
      if (number$RuleMemoStart == index) {
         if (number$RuleMemoStart <= number$RuleMemoEnd) {
            index = number$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NUMBER, number$RuleMemoStart, number$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (number$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(number$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("number" TestNoAlpha OptionalSpacing NumberSize)
      // "number"
      match = ignoreCaseStringMatcher("number", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // NumberSize
               match = numberSize$Rule();
            }
         }
      }
      if (match) {
         number$RuleMemoStart = startIndex;
         number$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            number$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            number$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         number$RuleMemoStart = startIndex;
         number$RuleMemoEnd = -1;
         number$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Float : ("float" TestNoAlpha OptionalSpacing Size?)
   protected boolean float$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Float", index);
      }
      if (float$RuleMemoStart == index) {
         if (float$RuleMemoStart <= float$RuleMemoEnd) {
            index = float$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FLOAT, float$RuleMemoStart, float$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (float$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(float$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("float" TestNoAlpha OptionalSpacing Size?)
      // "float"
      match = ignoreCaseStringMatcher("float", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         float$RuleMemoStart = startIndex;
         float$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            float$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FLOAT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            float$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         float$RuleMemoStart = startIndex;
         float$RuleMemoEnd = -1;
         float$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Timestamp : ("timestamp" TestNoAlpha OptionalSpacing Size? ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)? "TimeZone" TestNoAlpha OptionalSpacing)
   protected boolean timestamp$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Timestamp", index);
      }
      if (timestamp$RuleMemoStart == index) {
         if (timestamp$RuleMemoStart <= timestamp$RuleMemoEnd) {
            index = timestamp$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TIMESTAMP, timestamp$RuleMemoStart, timestamp$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (timestamp$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(timestamp$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("timestamp" TestNoAlpha OptionalSpacing Size? ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)? "TimeZone" TestNoAlpha OptionalSpacing)
      // "timestamp"
      match = ignoreCaseStringMatcher("timestamp", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)
                  // "with"
                  match = ignoreCaseStringMatcher("with", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ("local" TestNoAlpha OptionalSpacing)?
                           Node lastNode_3 = currentNode;
                           int lastIndex_3 = index;
                           // ("local" TestNoAlpha OptionalSpacing)
                           // "local"
                           match = ignoreCaseStringMatcher("local", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                              index = lastIndex_3;
                              match = true;
                           }
                           if (match) {
                              // "time"
                              match = ignoreCaseStringMatcher("time", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "zone"
                                       match = ignoreCaseStringMatcher("zone", 4);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // "TimeZone"
                     match = ignoreCaseStringMatcher("TimeZone", 8);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         timestamp$RuleMemoStart = startIndex;
         timestamp$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timestamp$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TIMESTAMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            timestamp$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         timestamp$RuleMemoStart = startIndex;
         timestamp$RuleMemoEnd = -1;
         timestamp$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalDayToSecondSpec : ('\'' OptionalSpacing ((IntegerPattern TimeExpression) | TimeExpression | IntegerPattern) '\'' OptionalSpacing)
   protected boolean intervalDayToSecondSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalDayToSecondSpec", index);
      }
      startIndex = index;
      // ('\'' OptionalSpacing ((IntegerPattern TimeExpression) | TimeExpression | IntegerPattern) '\'' OptionalSpacing)
      // '\''
      match = charMatcher('\'');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ((IntegerPattern TimeExpression) | TimeExpression | IntegerPattern)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // (IntegerPattern TimeExpression)
            // IntegerPattern
            match = integerPattern$Rule();
            if (match) {
               // TimeExpression
               match = timeExpression$Rule();
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // TimeExpression
               match = timeExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IntegerPattern
                  match = integerPattern$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            if (match) {
               // '\''
               match = charMatcher('\'');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND_SPEC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalDayToSecondLeadingPrecision : ('(' OptionalSpacing IntegerPattern ("," OptionalSpacing IntegerPattern)? ')' OptionalSpacing)
   protected boolean intervalDayToSecondLeadingPrecision$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalDayToSecondLeadingPrecision", index);
      }
      startIndex = index;
      // ('(' OptionalSpacing IntegerPattern ("," OptionalSpacing IntegerPattern)? ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IntegerPattern
            match = integerPattern$Rule();
            if (match) {
               // ("," OptionalSpacing IntegerPattern)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("," OptionalSpacing IntegerPattern)
               // ","
               match = ignoreCaseCharMatcher(',');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // IntegerPattern
                     match = integerPattern$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND_LEADING_PRECISION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalDayToSecondLiteral : ("interval" TestNoAlpha OptionalSpacing IntervalDayToSecondSpec (("day" | "hour" | "minute" | "seconds") TestNoAlpha OptionalSpacing) IntervalDayToSecondLeadingPrecision ("to" TestNoAlpha OptionalSpacing (("day" TestNoAlpha OptionalSpacing) | ("hour" TestNoAlpha OptionalSpacing) | ("minute" TestNoAlpha OptionalSpacing) | ("second" TestNoAlpha OptionalSpacing IntegerPattern?)))?)
   protected boolean intervalDayToSecondLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalDayToSecondLiteral", index);
      }
      if (intervalDayToSecondLiteral$RuleMemoStart == index) {
         if (intervalDayToSecondLiteral$RuleMemoStart <= intervalDayToSecondLiteral$RuleMemoEnd) {
            index = intervalDayToSecondLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND_LITERAL, intervalDayToSecondLiteral$RuleMemoStart, intervalDayToSecondLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intervalDayToSecondLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intervalDayToSecondLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("interval" TestNoAlpha OptionalSpacing IntervalDayToSecondSpec (("day" | "hour" | "minute" | "seconds") TestNoAlpha OptionalSpacing) IntervalDayToSecondLeadingPrecision ("to" TestNoAlpha OptionalSpacing (("day" TestNoAlpha OptionalSpacing) | ("hour" TestNoAlpha OptionalSpacing) | ("minute" TestNoAlpha OptionalSpacing) | ("second" TestNoAlpha OptionalSpacing IntegerPattern?)))?)
      // "interval"
      match = ignoreCaseStringMatcher("interval", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IntervalDayToSecondSpec
               match = intervalDayToSecondSpec$Rule();
               if (match) {
                  // (("day" | "hour" | "minute" | "seconds") TestNoAlpha OptionalSpacing)
                  // ("day" | "hour" | "minute" | "seconds")
                  int startIndex_1 = index;
                  switch(buffer.getChar(index)) {
                     case 'h':
                     case 'H': {
                        ++index;
                        // "our"
                        if (match = ignoreCaseStringTest("our", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "econds"
                        if (match = ignoreCaseStringTest("econds", 6)) {
                           index += 6;
                        }
                        break;
                     }
                     case 'd':
                     case 'D': {
                        ++index;
                        // "ay"
                        if (match = ignoreCaseStringTest("ay", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'm':
                     case 'M': {
                        ++index;
                        // "inute"
                        if (match = ignoreCaseStringTest("inute", 5)) {
                           index += 5;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  if (! match) {
                     index = startIndex_1;
                  } else if(! currentRuleIsAtomic) {
                     currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                     currentNode = currentNode.getSibling();
                  }
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (match) {
                     // IntervalDayToSecondLeadingPrecision
                     match = intervalDayToSecondLeadingPrecision$Rule();
                     if (match) {
                        // ("to" TestNoAlpha OptionalSpacing (("day" TestNoAlpha OptionalSpacing) | ("hour" TestNoAlpha OptionalSpacing) | ("minute" TestNoAlpha OptionalSpacing) | ("second" TestNoAlpha OptionalSpacing IntegerPattern?)))?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // ("to" TestNoAlpha OptionalSpacing (("day" TestNoAlpha OptionalSpacing) | ("hour" TestNoAlpha OptionalSpacing) | ("minute" TestNoAlpha OptionalSpacing) | ("second" TestNoAlpha OptionalSpacing IntegerPattern?)))
                        // "to"
                        match = ignoreCaseStringMatcher("to", 2);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // (("day" TestNoAlpha OptionalSpacing) | ("hour" TestNoAlpha OptionalSpacing) | ("minute" TestNoAlpha OptionalSpacing) | ("second" TestNoAlpha OptionalSpacing IntegerPattern?))
                                 Node lastNode_3 = currentNode;
                                 int lastIndex_3 = index;
                                 // ("day" TestNoAlpha OptionalSpacing)
                                 // "day"
                                 match = ignoreCaseStringMatcher("day", 3);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                                 if (! match) {
                                    index = lastIndex_3;
                                    lastNode_3.setSibling(null);
                                    currentNode = lastNode_3;
                                    // ("hour" TestNoAlpha OptionalSpacing)
                                    // "hour"
                                    match = ignoreCaseStringMatcher("hour", 4);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                    if (! match) {
                                       index = lastIndex_3;
                                       lastNode_3.setSibling(null);
                                       currentNode = lastNode_3;
                                       // ("minute" TestNoAlpha OptionalSpacing)
                                       // "minute"
                                       match = ignoreCaseStringMatcher("minute", 6);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_3;
                                          lastNode_3.setSibling(null);
                                          currentNode = lastNode_3;
                                          // ("second" TestNoAlpha OptionalSpacing IntegerPattern?)
                                          // "second"
                                          match = ignoreCaseStringMatcher("second", 6);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // IntegerPattern?
                                                   Node lastNode_4 = currentNode;
                                                   int lastIndex_4 = index;
                                                   // IntegerPattern
                                                   match = integerPattern$Rule();
                                                   if (! match) {
                                                      lastNode_4.setSibling(null);
                                                      currentNode = lastNode_4;
                                                      index = lastIndex_4;
                                                      match = true;
                                                   }
                                                }
                                             }
                                          }
                                          if (! match) {
                                             index = lastIndex_3;
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         intervalDayToSecondLiteral$RuleMemoStart = startIndex;
         intervalDayToSecondLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intervalDayToSecondLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intervalDayToSecondLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intervalDayToSecondLiteral$RuleMemoStart = startIndex;
         intervalDayToSecondLiteral$RuleMemoEnd = -1;
         intervalDayToSecondLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalDayToSecond : ("interval" TestNoAlpha OptionalSpacing "day" TestNoAlpha OptionalSpacing Size? "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing Size?)
   protected boolean intervalDayToSecond$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalDayToSecond", index);
      }
      if (intervalDayToSecond$RuleMemoStart == index) {
         if (intervalDayToSecond$RuleMemoStart <= intervalDayToSecond$RuleMemoEnd) {
            index = intervalDayToSecond$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND, intervalDayToSecond$RuleMemoStart, intervalDayToSecond$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intervalDayToSecond$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intervalDayToSecond$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("interval" TestNoAlpha OptionalSpacing "day" TestNoAlpha OptionalSpacing Size? "to" TestNoAlpha OptionalSpacing "second" TestNoAlpha OptionalSpacing Size?)
      // "interval"
      match = ignoreCaseStringMatcher("interval", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "day"
               match = ignoreCaseStringMatcher("day", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Size?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // Size
                        match = size$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // "to"
                           match = ignoreCaseStringMatcher("to", 2);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "second"
                                    match = ignoreCaseStringMatcher("second", 6);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // Size?
                                             Node lastNode_2 = currentNode;
                                             int lastIndex_2 = index;
                                             // Size
                                             match = size$Rule();
                                             if (! match) {
                                                lastNode_2.setSibling(null);
                                                currentNode = lastNode_2;
                                                index = lastIndex_2;
                                                match = true;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         intervalDayToSecond$RuleMemoStart = startIndex;
         intervalDayToSecond$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intervalDayToSecond$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_DAY_TO_SECOND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intervalDayToSecond$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intervalDayToSecond$RuleMemoStart = startIndex;
         intervalDayToSecond$RuleMemoEnd = -1;
         intervalDayToSecond$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalYearToMonthLeadingTrailing : ('\'' OptionalSpacing IntegerPattern ("-" OptionalSpacing IntegerPattern)? '\'' OptionalSpacing)
   protected boolean intervalYearToMonthLeadingTrailing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalYearToMonthLeadingTrailing", index);
      }
      if (intervalYearToMonthLeadingTrailing$RuleMemoStart == index) {
         if (intervalYearToMonthLeadingTrailing$RuleMemoStart <= intervalYearToMonthLeadingTrailing$RuleMemoEnd) {
            index = intervalYearToMonthLeadingTrailing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH_LEADING_TRAILING, intervalYearToMonthLeadingTrailing$RuleMemoStart, intervalYearToMonthLeadingTrailing$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intervalYearToMonthLeadingTrailing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intervalYearToMonthLeadingTrailing$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('\'' OptionalSpacing IntegerPattern ("-" OptionalSpacing IntegerPattern)? '\'' OptionalSpacing)
      // '\''
      match = charMatcher('\'');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IntegerPattern
            match = integerPattern$Rule();
            if (match) {
               // ("-" OptionalSpacing IntegerPattern)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("-" OptionalSpacing IntegerPattern)
               // "-"
               match = ignoreCaseCharMatcher('-');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // IntegerPattern
                     match = integerPattern$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // '\''
                  match = charMatcher('\'');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         intervalYearToMonthLeadingTrailing$RuleMemoStart = startIndex;
         intervalYearToMonthLeadingTrailing$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intervalYearToMonthLeadingTrailing$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH_LEADING_TRAILING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intervalYearToMonthLeadingTrailing$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intervalYearToMonthLeadingTrailing$RuleMemoStart = startIndex;
         intervalYearToMonthLeadingTrailing$RuleMemoEnd = -1;
         intervalYearToMonthLeadingTrailing$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalYearToMonthLiteral : (("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "year" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)?) | ("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "month" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing)?))
   protected boolean intervalYearToMonthLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalYearToMonthLiteral", index);
      }
      if (intervalYearToMonthLiteral$RuleMemoStart == index) {
         if (intervalYearToMonthLiteral$RuleMemoStart <= intervalYearToMonthLiteral$RuleMemoEnd) {
            index = intervalYearToMonthLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH_LITERAL, intervalYearToMonthLiteral$RuleMemoStart, intervalYearToMonthLiteral$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intervalYearToMonthLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intervalYearToMonthLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "year" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)?) | ("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "month" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing)?))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "year" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)?)
      // "interval"
      match = ignoreCaseStringMatcher("interval", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IntervalYearToMonthLeadingTrailing
               match = intervalYearToMonthLeadingTrailing$Rule();
               if (match) {
                  // "year"
                  match = ignoreCaseStringMatcher("year", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Size?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // Size
                           match = size$Rule();
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // ("to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // ("to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)
                              // "to"
                              match = ignoreCaseStringMatcher("to", 2);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "month"
                                       match = ignoreCaseStringMatcher("month", 5);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("interval" TestNoAlpha OptionalSpacing IntervalYearToMonthLeadingTrailing "month" TestNoAlpha OptionalSpacing Size? ("to" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing)?)
         // "interval"
         match = ignoreCaseStringMatcher("interval", 8);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // IntervalYearToMonthLeadingTrailing
                  match = intervalYearToMonthLeadingTrailing$Rule();
                  if (match) {
                     // "month"
                     match = ignoreCaseStringMatcher("month", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // Size?
                              Node lastNode_4 = currentNode;
                              int lastIndex_4 = index;
                              // Size
                              match = size$Rule();
                              if (! match) {
                                 lastNode_4.setSibling(null);
                                 currentNode = lastNode_4;
                                 index = lastIndex_4;
                                 match = true;
                              }
                              if (match) {
                                 // ("to" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing)?
                                 Node lastNode_5 = currentNode;
                                 int lastIndex_5 = index;
                                 // ("to" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing)
                                 // "to"
                                 match = ignoreCaseStringMatcher("to", 2);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // "year"
                                          match = ignoreCaseStringMatcher("year", 4);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                                 if (! match) {
                                    lastNode_5.setSibling(null);
                                    currentNode = lastNode_5;
                                    index = lastIndex_5;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         intervalYearToMonthLiteral$RuleMemoStart = startIndex;
         intervalYearToMonthLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intervalYearToMonthLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intervalYearToMonthLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intervalYearToMonthLiteral$RuleMemoStart = startIndex;
         intervalYearToMonthLiteral$RuleMemoEnd = -1;
         intervalYearToMonthLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntervalYearToMonth : ("interval" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing Size? "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)
   protected boolean intervalYearToMonth$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntervalYearToMonth", index);
      }
      if (intervalYearToMonth$RuleMemoStart == index) {
         if (intervalYearToMonth$RuleMemoStart <= intervalYearToMonth$RuleMemoEnd) {
            index = intervalYearToMonth$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH, intervalYearToMonth$RuleMemoStart, intervalYearToMonth$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intervalYearToMonth$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intervalYearToMonth$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("interval" TestNoAlpha OptionalSpacing "year" TestNoAlpha OptionalSpacing Size? "to" TestNoAlpha OptionalSpacing "month" TestNoAlpha OptionalSpacing)
      // "interval"
      match = ignoreCaseStringMatcher("interval", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "year"
               match = ignoreCaseStringMatcher("year", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Size?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // Size
                        match = size$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // "to"
                           match = ignoreCaseStringMatcher("to", 2);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "month"
                                    match = ignoreCaseStringMatcher("month", 5);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         intervalYearToMonth$RuleMemoStart = startIndex;
         intervalYearToMonth$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intervalYearToMonth$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTERVAL_YEAR_TO_MONTH, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intervalYearToMonth$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intervalYearToMonth$RuleMemoStart = startIndex;
         intervalYearToMonth$RuleMemoEnd = -1;
         intervalYearToMonth$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Time : ("time" TestNoAlpha OptionalSpacing Size? ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)? "TimeZone" TestNoAlpha OptionalSpacing)
   protected boolean time$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Time", index);
      }
      if (time$RuleMemoStart == index) {
         if (time$RuleMemoStart <= time$RuleMemoEnd) {
            index = time$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TIME, time$RuleMemoStart, time$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (time$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(time$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("time" TestNoAlpha OptionalSpacing Size? ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)? "TimeZone" TestNoAlpha OptionalSpacing)
      // "time"
      match = ignoreCaseStringMatcher("time", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ("with" TestNoAlpha OptionalSpacing ("local" TestNoAlpha OptionalSpacing)? "time" TestNoAlpha OptionalSpacing "zone" TestNoAlpha OptionalSpacing)
                  // "with"
                  match = ignoreCaseStringMatcher("with", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ("local" TestNoAlpha OptionalSpacing)?
                           Node lastNode_3 = currentNode;
                           int lastIndex_3 = index;
                           // ("local" TestNoAlpha OptionalSpacing)
                           // "local"
                           match = ignoreCaseStringMatcher("local", 5);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              lastNode_3.setSibling(null);
                              currentNode = lastNode_3;
                              index = lastIndex_3;
                              match = true;
                           }
                           if (match) {
                              // "time"
                              match = ignoreCaseStringMatcher("time", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "zone"
                                       match = ignoreCaseStringMatcher("zone", 4);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // "TimeZone"
                     match = ignoreCaseStringMatcher("TimeZone", 8);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         time$RuleMemoStart = startIndex;
         time$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            time$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TIME, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            time$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         time$RuleMemoStart = startIndex;
         time$RuleMemoEnd = -1;
         time$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RefXml : ("ref" TestNoAlpha OptionalSpacing "xmltype" TestNoAlpha OptionalSpacing)
   protected boolean refXml$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RefXml", index);
      }
      if (refXml$RuleMemoStart == index) {
         if (refXml$RuleMemoStart <= refXml$RuleMemoEnd) {
            index = refXml$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.REF_XML, refXml$RuleMemoStart, refXml$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (refXml$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(refXml$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("ref" TestNoAlpha OptionalSpacing "xmltype" TestNoAlpha OptionalSpacing)
      // "ref"
      match = ignoreCaseStringMatcher("ref", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "xmltype"
               match = ignoreCaseStringMatcher("xmltype", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         refXml$RuleMemoStart = startIndex;
         refXml$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            refXml$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.REF_XML, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            refXml$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         refXml$RuleMemoStart = startIndex;
         refXml$RuleMemoEnd = -1;
         refXml$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NChar : ("nchar" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? Size?)
   protected boolean nChar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NChar", index);
      }
      if (nChar$RuleMemoStart == index) {
         if (nChar$RuleMemoStart <= nChar$RuleMemoEnd) {
            index = nChar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NCHAR, nChar$RuleMemoStart, nChar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nChar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nChar$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("nchar" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? Size?)
      // "nchar"
      match = ignoreCaseStringMatcher("nchar", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("varying" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("varying" TestNoAlpha OptionalSpacing)
               // "varying"
               match = ignoreCaseStringMatcher("varying", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // Size?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Size
                  match = size$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         nChar$RuleMemoStart = startIndex;
         nChar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nChar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NCHAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nChar$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nChar$RuleMemoStart = startIndex;
         nChar$RuleMemoEnd = -1;
         nChar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NVarChar2 : ("nvarchar2" OptionalSpacing Size?)
   protected boolean nVarChar2$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NVarChar2", index);
      }
      if (nVarChar2$RuleMemoStart == index) {
         if (nVarChar2$RuleMemoStart <= nVarChar2$RuleMemoEnd) {
            index = nVarChar2$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NVAR_CHAR2, nVarChar2$RuleMemoStart, nVarChar2$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nVarChar2$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nVarChar2$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("nvarchar2" OptionalSpacing Size?)
      // "nvarchar2"
      match = ignoreCaseStringMatcher("nvarchar2", 9);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Size?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // Size
            match = size$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
         }
      }
      if (match) {
         nVarChar2$RuleMemoStart = startIndex;
         nVarChar2$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nVarChar2$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NVAR_CHAR2, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nVarChar2$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nVarChar2$RuleMemoStart = startIndex;
         nVarChar2$RuleMemoEnd = -1;
         nVarChar2$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LongRaw : ("long" TestNoAlpha OptionalSpacing ("raw" TestNoAlpha OptionalSpacing)? Size?)
   protected boolean longRaw$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LongRaw", index);
      }
      if (longRaw$RuleMemoStart == index) {
         if (longRaw$RuleMemoStart <= longRaw$RuleMemoEnd) {
            index = longRaw$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LONG_RAW, longRaw$RuleMemoStart, longRaw$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (longRaw$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(longRaw$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("long" TestNoAlpha OptionalSpacing ("raw" TestNoAlpha OptionalSpacing)? Size?)
      // "long"
      match = ignoreCaseStringMatcher("long", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("raw" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("raw" TestNoAlpha OptionalSpacing)
               // "raw"
               match = ignoreCaseStringMatcher("raw", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // Size?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Size
                  match = size$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         longRaw$RuleMemoStart = startIndex;
         longRaw$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            longRaw$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LONG_RAW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            longRaw$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         longRaw$RuleMemoStart = startIndex;
         longRaw$RuleMemoEnd = -1;
         longRaw$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Raw : ("raw" TestNoAlpha OptionalSpacing Size?)
   protected boolean raw$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Raw", index);
      }
      if (raw$RuleMemoStart == index) {
         if (raw$RuleMemoStart <= raw$RuleMemoEnd) {
            index = raw$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RAW, raw$RuleMemoStart, raw$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (raw$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(raw$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("raw" TestNoAlpha OptionalSpacing Size?)
      // "raw"
      match = ignoreCaseStringMatcher("raw", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         raw$RuleMemoStart = startIndex;
         raw$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            raw$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RAW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            raw$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         raw$RuleMemoStart = startIndex;
         raw$RuleMemoEnd = -1;
         raw$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CLob : ("clob" TestNoAlpha OptionalSpacing CharSetDefinition)
   protected boolean cLob$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CLob", index);
      }
      if (cLob$RuleMemoStart == index) {
         if (cLob$RuleMemoStart <= cLob$RuleMemoEnd) {
            index = cLob$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CLOB, cLob$RuleMemoStart, cLob$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cLob$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cLob$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("clob" TestNoAlpha OptionalSpacing CharSetDefinition)
      // "clob"
      match = ignoreCaseStringMatcher("clob", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CharSetDefinition
               match = charSetDefinition$Rule();
            }
         }
      }
      if (match) {
         cLob$RuleMemoStart = startIndex;
         cLob$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cLob$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CLOB, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cLob$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cLob$RuleMemoStart = startIndex;
         cLob$RuleMemoEnd = -1;
         cLob$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //URowId : ("urowid" TestNoAlpha OptionalSpacing Size?)
   protected boolean uRowId$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "URowId", index);
      }
      if (uRowId$RuleMemoStart == index) {
         if (uRowId$RuleMemoStart <= uRowId$RuleMemoEnd) {
            index = uRowId$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.UROW_ID, uRowId$RuleMemoStart, uRowId$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (uRowId$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(uRowId$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("urowid" TestNoAlpha OptionalSpacing Size?)
      // "urowid"
      match = ignoreCaseStringMatcher("urowid", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         uRowId$RuleMemoStart = startIndex;
         uRowId$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            uRowId$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.UROW_ID, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            uRowId$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         uRowId$RuleMemoStart = startIndex;
         uRowId$RuleMemoEnd = -1;
         uRowId$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BinaryFloat : ("binary_float" TestNoAlpha OptionalSpacing)
   protected boolean binaryFloat$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BinaryFloat", index);
      }
      if (binaryFloat$RuleMemoStart == index) {
         if (binaryFloat$RuleMemoStart <= binaryFloat$RuleMemoEnd) {
            index = binaryFloat$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BINARY_FLOAT, binaryFloat$RuleMemoStart, binaryFloat$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (binaryFloat$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(binaryFloat$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("binary_float" TestNoAlpha OptionalSpacing)
      // "binary_float"
      match = ignoreCaseStringMatcher("binary_float", 12);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         binaryFloat$RuleMemoStart = startIndex;
         binaryFloat$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            binaryFloat$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BINARY_FLOAT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            binaryFloat$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         binaryFloat$RuleMemoStart = startIndex;
         binaryFloat$RuleMemoEnd = -1;
         binaryFloat$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BinaryDouble : ("binary_double" TestNoAlpha OptionalSpacing)
   protected boolean binaryDouble$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BinaryDouble", index);
      }
      if (binaryDouble$RuleMemoStart == index) {
         if (binaryDouble$RuleMemoStart <= binaryDouble$RuleMemoEnd) {
            index = binaryDouble$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BINARY_DOUBLE, binaryDouble$RuleMemoStart, binaryDouble$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (binaryDouble$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(binaryDouble$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("binary_double" TestNoAlpha OptionalSpacing)
      // "binary_double"
      match = ignoreCaseStringMatcher("binary_double", 13);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         binaryDouble$RuleMemoStart = startIndex;
         binaryDouble$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            binaryDouble$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BINARY_DOUBLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            binaryDouble$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         binaryDouble$RuleMemoStart = startIndex;
         binaryDouble$RuleMemoEnd = -1;
         binaryDouble$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Date : ("date" TestNoAlpha OptionalSpacing)
   protected boolean date$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Date", index);
      }
      if (date$RuleMemoStart == index) {
         if (date$RuleMemoStart <= date$RuleMemoEnd) {
            index = date$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DATE, date$RuleMemoStart, date$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (date$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(date$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("date" TestNoAlpha OptionalSpacing)
      // "date"
      match = ignoreCaseStringMatcher("date", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         date$RuleMemoStart = startIndex;
         date$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            date$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DATE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            date$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         date$RuleMemoStart = startIndex;
         date$RuleMemoEnd = -1;
         date$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BLob : ("blob" TestNoAlpha OptionalSpacing)
   protected boolean bLob$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BLob", index);
      }
      if (bLob$RuleMemoStart == index) {
         if (bLob$RuleMemoStart <= bLob$RuleMemoEnd) {
            index = bLob$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BLOB, bLob$RuleMemoStart, bLob$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bLob$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bLob$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("blob" TestNoAlpha OptionalSpacing)
      // "blob"
      match = ignoreCaseStringMatcher("blob", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         bLob$RuleMemoStart = startIndex;
         bLob$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bLob$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BLOB, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bLob$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         bLob$RuleMemoStart = startIndex;
         bLob$RuleMemoEnd = -1;
         bLob$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NCLob : ("nclob" TestNoAlpha OptionalSpacing)
   protected boolean nCLob$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NCLob", index);
      }
      if (nCLob$RuleMemoStart == index) {
         if (nCLob$RuleMemoStart <= nCLob$RuleMemoEnd) {
            index = nCLob$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NCLOB, nCLob$RuleMemoStart, nCLob$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nCLob$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nCLob$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("nclob" TestNoAlpha OptionalSpacing)
      // "nclob"
      match = ignoreCaseStringMatcher("nclob", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         nCLob$RuleMemoStart = startIndex;
         nCLob$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nCLob$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NCLOB, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nCLob$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nCLob$RuleMemoStart = startIndex;
         nCLob$RuleMemoEnd = -1;
         nCLob$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BFile : ("bfile" TestNoAlpha OptionalSpacing)
   protected boolean bFile$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BFile", index);
      }
      if (bFile$RuleMemoStart == index) {
         if (bFile$RuleMemoStart <= bFile$RuleMemoEnd) {
            index = bFile$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BFILE, bFile$RuleMemoStart, bFile$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bFile$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bFile$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("bfile" TestNoAlpha OptionalSpacing)
      // "bfile"
      match = ignoreCaseStringMatcher("bfile", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         bFile$RuleMemoStart = startIndex;
         bFile$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bFile$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BFILE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bFile$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         bFile$RuleMemoStart = startIndex;
         bFile$RuleMemoEnd = -1;
         bFile$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RowId : ("rowid" TestNoAlpha OptionalSpacing)
   protected boolean rowId$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RowId", index);
      }
      if (rowId$RuleMemoStart == index) {
         if (rowId$RuleMemoStart <= rowId$RuleMemoEnd) {
            index = rowId$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROW_ID, rowId$RuleMemoStart, rowId$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rowId$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rowId$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("rowid" TestNoAlpha OptionalSpacing)
      // "rowid"
      match = ignoreCaseStringMatcher("rowid", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         rowId$RuleMemoStart = startIndex;
         rowId$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rowId$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROW_ID, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rowId$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rowId$RuleMemoStart = startIndex;
         rowId$RuleMemoEnd = -1;
         rowId$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlDataType : (BinaryFloat | BinaryDouble | Date | Number | IntervalDayToSecond | IntervalYearToMonth | Time | Timestamp | RefXml | Float | Char | NChar | NVarChar2 | VarChar2 | VarChar | LongRaw | Raw | BLob | CLob | NCLob | BFile | RowId | URowId)
   protected boolean sqlDataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlDataType", index);
      }
      if (sqlDataType$RuleMemoStart == index) {
         if (sqlDataType$RuleMemoStart <= sqlDataType$RuleMemoEnd) {
            index = sqlDataType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_DATA_TYPE, sqlDataType$RuleMemoStart, sqlDataType$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlDataType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlDataType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BinaryFloat | BinaryDouble | Date | Number | IntervalDayToSecond | IntervalYearToMonth | Time | Timestamp | RefXml | Float | Char | NChar | NVarChar2 | VarChar2 | VarChar | LongRaw | Raw | BLob | CLob | NCLob | BFile | RowId | URowId)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'l':
         case 'L': {
            // LongRaw
            match = longRaw$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'n':
         case 'N': {
            // Number
            match = number$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NChar
               match = nChar$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // NVarChar2
                  match = nVarChar2$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // NCLob
                     match = nCLob$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            // RefXml
            match = refXml$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Raw
               match = raw$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RowId
                  match = rowId$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'b':
         case 'B': {
            // BinaryFloat
            match = binaryFloat$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BinaryDouble
               match = binaryDouble$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // BLob
                  match = bLob$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // BFile
                     match = bFile$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            // Char
            match = char$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CLob
               match = cLob$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 't':
         case 'T': {
            // Time
            match = time$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Timestamp
               match = timestamp$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            // Date
            match = date$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'u':
         case 'U': {
            // URowId
            match = uRowId$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'v':
         case 'V': {
            // VarChar2
            match = varChar2$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // VarChar
               match = varChar$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'f':
         case 'F': {
            // Float
            match = float$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'i':
         case 'I': {
            // IntervalDayToSecond
            match = intervalDayToSecond$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // IntervalYearToMonth
               match = intervalYearToMonth$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlDataType$RuleMemoStart = startIndex;
         sqlDataType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlDataType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_DATA_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlDataType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlDataType$RuleMemoStart = startIndex;
         sqlDataType$RuleMemoEnd = -1;
         sqlDataType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlParameters : ('(' OptionalSpacing (SqlFunctionParameter (',' OptionalSpacing SqlFunctionParameter)*)? ')' OptionalSpacing)
   protected boolean sqlParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlParameters", index);
      }
      if (sqlParameters$RuleMemoStart == index) {
         if (sqlParameters$RuleMemoStart <= sqlParameters$RuleMemoEnd) {
            index = sqlParameters$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS, sqlParameters$RuleMemoStart, sqlParameters$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlParameters$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlParameters$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing (SqlFunctionParameter (',' OptionalSpacing SqlFunctionParameter)*)? ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (SqlFunctionParameter (',' OptionalSpacing SqlFunctionParameter)*)?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // (SqlFunctionParameter (',' OptionalSpacing SqlFunctionParameter)*)
            // SqlFunctionParameter
            match = sqlFunctionParameter$Rule();
            if (match) {
               // (',' OptionalSpacing SqlFunctionParameter)*
               Node lastNode_2;
               int lastIndex_2;
               do {
                  lastNode_2 = currentNode;
                  lastIndex_2 = index;
                  // (',' OptionalSpacing SqlFunctionParameter)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // SqlFunctionParameter
                        match = sqlFunctionParameter$Rule();
                     }
                  }
               } while(match);
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         sqlParameters$RuleMemoStart = startIndex;
         sqlParameters$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlParameters$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlParameters$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlParameters$RuleMemoStart = startIndex;
         sqlParameters$RuleMemoEnd = -1;
         sqlParameters$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlQualifiedIdentifierRemote : (SqlQualifiedIdentifier DBLink SqlParameters* SqlAttributes?)
   protected boolean sqlQualifiedIdentifierRemote$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlQualifiedIdentifierRemote", index);
      }
      if (sqlQualifiedIdentifierRemote$RuleMemoStart == index) {
         if (sqlQualifiedIdentifierRemote$RuleMemoStart <= sqlQualifiedIdentifierRemote$RuleMemoEnd) {
            index = sqlQualifiedIdentifierRemote$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER_REMOTE, sqlQualifiedIdentifierRemote$RuleMemoStart, sqlQualifiedIdentifierRemote$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlQualifiedIdentifierRemote$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlQualifiedIdentifierRemote$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlQualifiedIdentifier DBLink SqlParameters* SqlAttributes?)
      // SqlQualifiedIdentifier
      match = sqlQualifiedIdentifier$Rule();
      if (match) {
         // DBLink
         match = dBLink$Rule();
         if (match) {
            // SqlParameters*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // SqlParameters
               match = sqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
            // SqlAttributes?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // SqlAttributes
            match = sqlAttributes$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         sqlQualifiedIdentifierRemote$RuleMemoStart = startIndex;
         sqlQualifiedIdentifierRemote$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlQualifiedIdentifierRemote$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER_REMOTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlQualifiedIdentifierRemote$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlQualifiedIdentifierRemote$RuleMemoStart = startIndex;
         sqlQualifiedIdentifierRemote$RuleMemoEnd = -1;
         sqlQualifiedIdentifierRemote$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlSimpleIdentifierRemote : (SqlSimpleIdentifier DBLink SqlParameters* SqlAttributes?)
   protected boolean sqlSimpleIdentifierRemote$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSimpleIdentifierRemote", index);
      }
      if (sqlSimpleIdentifierRemote$RuleMemoStart == index) {
         if (sqlSimpleIdentifierRemote$RuleMemoStart <= sqlSimpleIdentifierRemote$RuleMemoEnd) {
            index = sqlSimpleIdentifierRemote$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_REMOTE, sqlSimpleIdentifierRemote$RuleMemoStart, sqlSimpleIdentifierRemote$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlSimpleIdentifierRemote$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlSimpleIdentifierRemote$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlSimpleIdentifier DBLink SqlParameters* SqlAttributes?)
      // SqlSimpleIdentifier
      match = sqlSimpleIdentifier$Rule();
      if (match) {
         // DBLink
         match = dBLink$Rule();
         if (match) {
            // SqlParameters*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // SqlParameters
               match = sqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
            // SqlAttributes?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // SqlAttributes
            match = sqlAttributes$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         sqlSimpleIdentifierRemote$RuleMemoStart = startIndex;
         sqlSimpleIdentifierRemote$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlSimpleIdentifierRemote$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_REMOTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlSimpleIdentifierRemote$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlSimpleIdentifierRemote$RuleMemoStart = startIndex;
         sqlSimpleIdentifierRemote$RuleMemoEnd = -1;
         sqlSimpleIdentifierRemote$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAttributes : ('.' OptionalSpacing SqlAnySimpleIdentifier)+
   protected boolean sqlAttributes$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAttributes", index);
      }
      if (sqlAttributes$RuleMemoStart == index) {
         if (sqlAttributes$RuleMemoStart <= sqlAttributes$RuleMemoEnd) {
            index = sqlAttributes$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_ATTRIBUTES, sqlAttributes$RuleMemoStart, sqlAttributes$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlAttributes$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlAttributes$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('.' OptionalSpacing SqlAnySimpleIdentifier)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('.' OptionalSpacing SqlAnySimpleIdentifier)
      // '.'
      match = charMatcher('.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SqlAnySimpleIdentifier
            match = sqlAnySimpleIdentifier$Rule();
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('.' OptionalSpacing SqlAnySimpleIdentifier)
            // '.'
            match = charMatcher('.');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlAnySimpleIdentifier
                  match = sqlAnySimpleIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         sqlAttributes$RuleMemoStart = startIndex;
         sqlAttributes$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlAttributes$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_ATTRIBUTES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlAttributes$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlAttributes$RuleMemoStart = startIndex;
         sqlAttributes$RuleMemoEnd = -1;
         sqlAttributes$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlQualifiedIdentifier : (SqlSimpleIdentifier SqlAttributes)
   protected boolean sqlQualifiedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlQualifiedIdentifier", index);
      }
      if (sqlQualifiedIdentifier$RuleMemoStart == index) {
         if (sqlQualifiedIdentifier$RuleMemoStart <= sqlQualifiedIdentifier$RuleMemoEnd) {
            index = sqlQualifiedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER, sqlQualifiedIdentifier$RuleMemoStart, sqlQualifiedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlQualifiedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlQualifiedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlSimpleIdentifier SqlAttributes)
      // SqlSimpleIdentifier
      match = sqlSimpleIdentifier$Rule();
      if (match) {
         // SqlAttributes
         match = sqlAttributes$Rule();
      }
      if (match) {
         sqlQualifiedIdentifier$RuleMemoStart = startIndex;
         sqlQualifiedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlQualifiedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlQualifiedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlQualifiedIdentifier$RuleMemoStart = startIndex;
         sqlQualifiedIdentifier$RuleMemoEnd = -1;
         sqlQualifiedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAnySimpleIdentifier : (SqlAnyParameterizedIdentifier | SqlAnyIdentifier)
   protected boolean sqlAnySimpleIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAnySimpleIdentifier", index);
      }
      startIndex = index;
      // (SqlAnyParameterizedIdentifier | SqlAnyIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlAnyParameterizedIdentifier
            match = sqlAnyParameterizedIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlAnyIdentifier
               match = sqlAnyIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_ANY_SIMPLE_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAnyParameterizedIdentifier : (SqlAnyIdentifier SqlParameters+)
   protected boolean sqlAnyParameterizedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAnyParameterizedIdentifier", index);
      }
      if (sqlAnyParameterizedIdentifier$RuleMemoStart == index) {
         if (sqlAnyParameterizedIdentifier$RuleMemoStart <= sqlAnyParameterizedIdentifier$RuleMemoEnd) {
            index = sqlAnyParameterizedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, sqlAnyParameterizedIdentifier$RuleMemoStart, sqlAnyParameterizedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlAnyParameterizedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlAnyParameterizedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlAnyIdentifier SqlParameters+)
      // SqlAnyIdentifier
      match = sqlAnyIdentifier$Rule();
      if (match) {
         // SqlParameters+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // SqlParameters
         match = sqlParameters$Rule();
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // SqlParameters
               match = sqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         sqlAnyParameterizedIdentifier$RuleMemoStart = startIndex;
         sqlAnyParameterizedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlAnyParameterizedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlAnyParameterizedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlAnyParameterizedIdentifier$RuleMemoStart = startIndex;
         sqlAnyParameterizedIdentifier$RuleMemoEnd = -1;
         sqlAnyParameterizedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlSimpleIdentifier : (SqlParameterizedIdentifier | SqlIdentifier)
   protected boolean sqlSimpleIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlSimpleIdentifier", index);
      }
      if (sqlSimpleIdentifier$RuleMemoStart == index) {
         if (sqlSimpleIdentifier$RuleMemoStart <= sqlSimpleIdentifier$RuleMemoEnd) {
            index = sqlSimpleIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_IDENTIFIER, sqlSimpleIdentifier$RuleMemoStart, sqlSimpleIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlSimpleIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlSimpleIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlParameterizedIdentifier | SqlIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlParameterizedIdentifier
            match = sqlParameterizedIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlIdentifier
               match = sqlIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlSimpleIdentifier$RuleMemoStart = startIndex;
         sqlSimpleIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlSimpleIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_SIMPLE_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlSimpleIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlSimpleIdentifier$RuleMemoStart = startIndex;
         sqlSimpleIdentifier$RuleMemoEnd = -1;
         sqlSimpleIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlParameterizedIdentifier : (SqlIdentifier SqlParameters+)
   protected boolean sqlParameterizedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlParameterizedIdentifier", index);
      }
      if (sqlParameterizedIdentifier$RuleMemoStart == index) {
         if (sqlParameterizedIdentifier$RuleMemoStart <= sqlParameterizedIdentifier$RuleMemoEnd) {
            index = sqlParameterizedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, sqlParameterizedIdentifier$RuleMemoStart, sqlParameterizedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlParameterizedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlParameterizedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlIdentifier SqlParameters+)
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         // SqlParameters+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // SqlParameters
         match = sqlParameters$Rule();
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // SqlParameters
               match = sqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         sqlParameterizedIdentifier$RuleMemoStart = startIndex;
         sqlParameterizedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlParameterizedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlParameterizedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlParameterizedIdentifier$RuleMemoStart = startIndex;
         sqlParameterizedIdentifier$RuleMemoEnd = -1;
         sqlParameterizedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlObjectIdentifier : (BuiltInFunctionCall | SqlQualifiedIdentifierRemote | SqlSimpleIdentifierRemote | SqlQualifiedIdentifier | SqlSimpleIdentifier)
   protected boolean sqlObjectIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlObjectIdentifier", index);
      }
      if (sqlObjectIdentifier$RuleMemoStart == index) {
         if (sqlObjectIdentifier$RuleMemoStart <= sqlObjectIdentifier$RuleMemoEnd) {
            index = sqlObjectIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_OBJECT_IDENTIFIER, sqlObjectIdentifier$RuleMemoStart, sqlObjectIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlObjectIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlObjectIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BuiltInFunctionCall | SqlQualifiedIdentifierRemote | SqlSimpleIdentifierRemote | SqlQualifiedIdentifier | SqlSimpleIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '\u00C1':
         case 'B':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case 'I':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'Q':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case 'U':
         case '\u00D5':
         case '\u00D6':
         case 'W':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case '\u00E1':
         case 'b':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case 'i':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'q':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case 'u':
         case '\u00F5':
         case '\u00F6':
         case 'w':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // SqlQualifiedIdentifierRemote
            match = sqlQualifiedIdentifierRemote$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlSimpleIdentifierRemote
               match = sqlSimpleIdentifierRemote$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlQualifiedIdentifier
                  match = sqlQualifiedIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlSimpleIdentifier
                     match = sqlSimpleIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'L':
         case 'M':
         case 'N':
         case 'P':
         case 'R':
         case 'S':
         case 'T':
         case 'V':
         case 'X':
         case 'a':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'l':
         case 'm':
         case 'n':
         case 'p':
         case 'r':
         case 's':
         case 't':
         case 'v':
         case 'x': {
            // BuiltInFunctionCall
            match = builtInFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SqlQualifiedIdentifierRemote
               match = sqlQualifiedIdentifierRemote$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlSimpleIdentifierRemote
                  match = sqlSimpleIdentifierRemote$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlQualifiedIdentifier
                     match = sqlQualifiedIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlSimpleIdentifier
                        match = sqlSimpleIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         sqlObjectIdentifier$RuleMemoStart = startIndex;
         sqlObjectIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlObjectIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_OBJECT_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlObjectIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlObjectIdentifier$RuleMemoStart = startIndex;
         sqlObjectIdentifier$RuleMemoEnd = -1;
         sqlObjectIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlIdentifier : (SqlKeyword! SqlIdentifierPattern OptionalSpacing)
   protected boolean sqlIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlIdentifier", index);
      }
      if (sqlIdentifier$RuleMemoStart == index) {
         if (sqlIdentifier$RuleMemoStart <= sqlIdentifier$RuleMemoEnd) {
            index = sqlIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIER, sqlIdentifier$RuleMemoStart, sqlIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlKeyword! SqlIdentifierPattern OptionalSpacing)
      // SqlKeyword!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // (("access" | "add" | "all" | "alter" | "and" | "any" | "as" | "asc" | "audit" | "between" | "bulk" | "by" | "case" | "char" | "check" | "cluster" | "collect" | "column" | "comment" | "compress" | "connect" | "create" | "current" | "date" | "decimal" | "default" | "delete" | "desc" | "distinct" | "drop" | "else" | "exclusive" | "exists" | "file" | "float" | "for" | "from" | "grant" | "group" | "having" | "identified" | "immediate" | "in" | "increment" | "index" | "initialvinsert" | "integer" | "intersect" | "into" | "is" | "level" | "like" | "lock" | "long" | "maxextents" | "minus" | "mlslabel" | "mode" | "modify" | "noaudit" | "nocompress" | "not" | "nowait" | "null" | "number" | "of" | "offline" | "on" | "online" | "option" | "or" | "order" | "pctfree" | "prior" | "privileges" | "public" | "raw" | "rename" | "resource" | "revoke" | "row" | "rowid" | "rownum" | "rows" | "select" | "session" | "set" | "share" | "size" | "smallint" | "start" | "successful" | "synonym" | "sysdate" | "table" | "then" | "to" | "trigger" | "uid" | "union" | "unique" | "update" | "user" | "using" | "validate" | "values" | "varchar" | "varchar2" | "view" | "whenever" | "when" | "where" | "with") TestNoAlpha)
      // ("access" | "add" | "all" | "alter" | "and" | "any" | "as" | "asc" | "audit" | "between" | "bulk" | "by" | "case" | "char" | "check" | "cluster" | "collect" | "column" | "comment" | "compress" | "connect" | "create" | "current" | "date" | "decimal" | "default" | "delete" | "desc" | "distinct" | "drop" | "else" | "exclusive" | "exists" | "file" | "float" | "for" | "from" | "grant" | "group" | "having" | "identified" | "immediate" | "in" | "increment" | "index" | "initialvinsert" | "integer" | "intersect" | "into" | "is" | "level" | "like" | "lock" | "long" | "maxextents" | "minus" | "mlslabel" | "mode" | "modify" | "noaudit" | "nocompress" | "not" | "nowait" | "null" | "number" | "of" | "offline" | "on" | "online" | "option" | "or" | "order" | "pctfree" | "prior" | "privileges" | "public" | "raw" | "rename" | "resource" | "revoke" | "row" | "rowid" | "rownum" | "rows" | "select" | "session" | "set" | "share" | "size" | "smallint" | "start" | "successful" | "synonym" | "sysdate" | "table" | "then" | "to" | "trigger" | "uid" | "union" | "unique" | "update" | "user" | "using" | "validate" | "values" | "varchar" | "varchar2" | "view" | "whenever" | "when" | "where" | "with")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // ("loat" | "ile" | "rom" | "or")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "r"
                  if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                     ++index;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "le"
                  if (match = ignoreCaseStringTest("le", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "om"
                  if (match = ignoreCaseStringTest("om", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "oat"
                  if (match = ignoreCaseStringTest("oat", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'v':
         case 'V': {
            ++index;
            // ("alidate" | "archar2" | "archar" | "alues" | "iew")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A': {
                  ++index;
                  // ("lidate" | "rchar2" | "rchar" | "lues")
                  switch(buffer.getChar(index)) {
                     case 'r':
                     case 'R': {
                        ++index;
                        // ("char2" | "char")
                        match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                        if (match) {
                           ++index;
                           // ("har2" | "har")
                           match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
                           if (match) {
                              ++index;
                              // ("ar2" | "ar")
                              match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                              if (match) {
                                 ++index;
                                 // ("r2" | "r")
                                 match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                                 if (match) {
                                    ++index;
                                    // ("2" | <EMPTY>)
                                    match = buffer.matchChar(index, '2');
                                    if (match) {
                                       ++index;
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 }
                              }
                           }
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // ("idate" | "ues")
                        switch(buffer.getChar(index)) {
                           case 'i':
                           case 'I': {
                              ++index;
                              // "date"
                              if (match = ignoreCaseStringTest("date", 4)) {
                                 index += 4;
                              }
                              break;
                           }
                           case 'u':
                           case 'U': {
                              ++index;
                              // "es"
                              if (match = ignoreCaseStringTest("es", 2)) {
                                 index += 2;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "ew"
                  if (match = ignoreCaseStringTest("ew", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'g':
         case 'G': {
            ++index;
            // ("rant" | "roup")
            match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
            if (match) {
               ++index;
               // ("ant" | "oup")
               switch(buffer.getChar(index)) {
                  case 'o':
                  case 'O': {
                     ++index;
                     // "up"
                     if (match = ignoreCaseStringTest("up", 2)) {
                        index += 2;
                     }
                     break;
                  }
                  case 'a':
                  case 'A': {
                     ++index;
                     // "nt"
                     if (match = ignoreCaseStringTest("nt", 2)) {
                        index += 2;
                     }
                     break;
                  }
                  default: {
                     match = false;
                  }
               }
            }
            break;
         }
         case 'w':
         case 'W': {
            ++index;
            // ("henever" | "here" | "hen" | "ith")
            switch(buffer.getChar(index)) {
               case 'h':
               case 'H': {
                  ++index;
                  // ("enever" | "ere" | "en")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("never" | "re" | "n")
                     switch(buffer.getChar(index)) {
                        case 'n':
                        case 'N': {
                           ++index;
                           // ("ever" | <EMPTY>)
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // "ver"
                              if (match = ignoreCaseStringTest("ver", 3)) {
                                 index += 3;
                              }
                           } else {
                              match = true;
                           }
                           break;
                        }
                        case 'r':
                        case 'R': {
                           ++index;
                           // "e"
                           if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                              ++index;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "th"
                  if (match = ignoreCaseStringTest("th", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'h':
         case 'H': {
            ++index;
            // "aving"
            if (match = ignoreCaseStringTest("aving", 5)) {
               index += 5;
            }
            break;
         }
         case 'i':
         case 'I': {
            ++index;
            // ("nitialvinsert" | "dentified" | "mmediate" | "ncrement" | "ntersect" | "nteger" | "ndex" | "nto" | "n" | "s")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("itialvinsert" | "crement" | "tersect" | "teger" | "dex" | "to" | <EMPTY>)
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "tialvinsert"
                        if (match = ignoreCaseStringTest("tialvinsert", 11)) {
                           index += 11;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "rement"
                        if (match = ignoreCaseStringTest("rement", 6)) {
                           index += 6;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // ("ersect" | "eger" | "o")
                        switch(buffer.getChar(index)) {
                           case 'o':
                           case 'O': {
                              ++index;
                              // <EMPTY>
                              match = true;
                              break;
                           }
                           case 'e':
                           case 'E': {
                              ++index;
                              // ("rsect" | "ger")
                              switch(buffer.getChar(index)) {
                                 case 'g':
                                 case 'G': {
                                    ++index;
                                    // "er"
                                    if (match = ignoreCaseStringTest("er", 2)) {
                                       index += 2;
                                    }
                                    break;
                                 }
                                 case 'r':
                                 case 'R': {
                                    ++index;
                                    // "sect"
                                    if (match = ignoreCaseStringTest("sect", 4)) {
                                       index += 4;
                                    }
                                    break;
                                 }
                                 default: {
                                    match = false;
                                 }
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 'd':
                     case 'D': {
                        ++index;
                        // "ex"
                        if (match = ignoreCaseStringTest("ex", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     default: {
                        match = true;
                     }
                  }
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'd':
               case 'D': {
                  ++index;
                  // "entified"
                  if (match = ignoreCaseStringTest("entified", 8)) {
                     index += 8;
                  }
                  break;
               }
               case 'm':
               case 'M': {
                  ++index;
                  // "mediate"
                  if (match = ignoreCaseStringTest("mediate", 7)) {
                     index += 7;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'l':
         case 'L': {
            ++index;
            // ("evel" | "ike" | "ock" | "ong")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("ck" | "ng")
                  switch(buffer.getChar(index)) {
                     case 'n':
                     case 'N': {
                        ++index;
                        // "g"
                        if (match = buffer.matchIgnoreCaseChar(index, 'g')) {
                           ++index;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "k"
                        if (match = buffer.matchIgnoreCaseChar(index, 'k')) {
                           ++index;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "ke"
                  if (match = ignoreCaseStringTest("ke", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "vel"
                  if (match = ignoreCaseStringTest("vel", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // ("axextents" | "lslabel" | "odify" | "inus" | "ode")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("dify" | "de")
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // ("ify" | "e")
                     switch(buffer.getChar(index)) {
                        case 'i':
                        case 'I': {
                           ++index;
                           // "fy"
                           if (match = ignoreCaseStringTest("fy", 2)) {
                              index += 2;
                           }
                           break;
                        }
                        case 'e':
                        case 'E': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "xextents"
                  if (match = ignoreCaseStringTest("xextents", 8)) {
                     index += 8;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "nus"
                  if (match = ignoreCaseStringTest("nus", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "slabel"
                  if (match = ignoreCaseStringTest("slabel", 6)) {
                     index += 6;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'n':
         case 'N': {
            ++index;
            // ("ocompress" | "oaudit" | "owait" | "umber" | "ull" | "ot")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("compress" | "audit" | "wait" | "t")
                  switch(buffer.getChar(index)) {
                     case 'w':
                     case 'W': {
                        ++index;
                        // "ait"
                        if (match = ignoreCaseStringTest("ait", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 'a':
                     case 'A': {
                        ++index;
                        // "udit"
                        if (match = ignoreCaseStringTest("udit", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "ompress"
                        if (match = ignoreCaseStringTest("ompress", 7)) {
                           index += 7;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // ("mber" | "ll")
                  switch(buffer.getChar(index)) {
                     case 'l':
                     case 'L': {
                        ++index;
                        // "l"
                        if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                           ++index;
                        }
                        break;
                     }
                     case 'm':
                     case 'M': {
                        ++index;
                        // "ber"
                        if (match = ignoreCaseStringTest("ber", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'o':
         case 'O': {
            ++index;
            // ("ffline" | "nline" | "ption" | "rder" | "f" | "n" | "r")
            switch(buffer.getChar(index)) {
               case 'f':
               case 'F': {
                  ++index;
                  // ("fline" | <EMPTY>)
                  match = buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F');
                  if (match) {
                     ++index;
                     // "line"
                     if (match = ignoreCaseStringTest("line", 4)) {
                        index += 4;
                     }
                  } else {
                     match = true;
                  }
                  break;
               }
               case 'n':
               case 'N': {
                  ++index;
                  // ("line" | <EMPTY>)
                  match = buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L');
                  if (match) {
                     ++index;
                     // "ine"
                     if (match = ignoreCaseStringTest("ine", 3)) {
                        index += 3;
                     }
                  } else {
                     match = true;
                  }
                  break;
               }
               case 'p':
               case 'P': {
                  ++index;
                  // "tion"
                  if (match = ignoreCaseStringTest("tion", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("der" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // "er"
                     if (match = ignoreCaseStringTest("er", 2)) {
                        index += 2;
                     }
                  } else {
                     match = true;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // ("rivileges" | "ctfree" | "ublic" | "rior")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("ivileges" | "ior")
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("vileges" | "or")
                     switch(buffer.getChar(index)) {
                        case 'v':
                        case 'V': {
                           ++index;
                           // "ileges"
                           if (match = ignoreCaseStringTest("ileges", 6)) {
                              index += 6;
                           }
                           break;
                        }
                        case 'o':
                        case 'O': {
                           ++index;
                           // "r"
                           if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                              ++index;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'c':
               case 'C': {
                  ++index;
                  // "tfree"
                  if (match = ignoreCaseStringTest("tfree", 5)) {
                     index += 5;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "blic"
                  if (match = ignoreCaseStringTest("blic", 4)) {
                     index += 4;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // ("ccess" | "lter" | "udit" | "dd" | "ll" | "nd" | "ny" | "sc" | "s")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("d" | "y")
                  switch(buffer.getChar(index)) {
                     case 'y':
                     case 'Y': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case 'd':
                     case 'D': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'c':
               case 'C': {
                  ++index;
                  // "cess"
                  if (match = ignoreCaseStringTest("cess", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // ("c" | <EMPTY>)
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // ("ter" | "l")
                  switch(buffer.getChar(index)) {
                     case 't':
                     case 'T': {
                        ++index;
                        // "er"
                        if (match = ignoreCaseStringTest("er", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'd':
               case 'D': {
                  ++index;
                  // "d"
                  if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                     ++index;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "dit"
                  if (match = ignoreCaseStringTest("dit", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'b':
         case 'B': {
            ++index;
            // ("etween" | "ulk" | "y")
            switch(buffer.getChar(index)) {
               case 'y':
               case 'Y': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "tween"
                  if (match = ignoreCaseStringTest("tween", 5)) {
                     index += 5;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "lk"
                  if (match = ignoreCaseStringTest("lk", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            ++index;
            // ("esource" | "ename" | "evoke" | "ownum" | "owid" | "ows" | "aw" | "ow")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("wnum" | "wid" | "ws" | "w")
                  match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
                  if (match) {
                     ++index;
                     // ("num" | "id" | "s" | <EMPTY>)
                     switch(buffer.getChar(index)) {
                        case 'n':
                        case 'N': {
                           ++index;
                           // "um"
                           if (match = ignoreCaseStringTest("um", 2)) {
                              index += 2;
                           }
                           break;
                        }
                        case 'i':
                        case 'I': {
                           ++index;
                           // "d"
                           if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                              ++index;
                           }
                           break;
                        }
                        case 's':
                        case 'S': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        default: {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "w"
                  if (match = buffer.matchIgnoreCaseChar(index, 'w')) {
                     ++index;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("source" | "name" | "voke")
                  switch(buffer.getChar(index)) {
                     case 'n':
                     case 'N': {
                        ++index;
                        // "ame"
                        if (match = ignoreCaseStringTest("ame", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 'v':
                     case 'V': {
                        ++index;
                        // "oke"
                        if (match = ignoreCaseStringTest("oke", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "ource"
                        if (match = ignoreCaseStringTest("ource", 5)) {
                           index += 5;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // ("ompress" | "luster" | "ollect" | "omment" | "onnect" | "urrent" | "olumn" | "reate" | "heck" | "ase" | "har")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("mpress" | "llect" | "mment" | "nnect" | "lumn")
                  switch(buffer.getChar(index)) {
                     case 'n':
                     case 'N': {
                        ++index;
                        // "nect"
                        if (match = ignoreCaseStringTest("nect", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // ("lect" | "umn")
                        switch(buffer.getChar(index)) {
                           case 'l':
                           case 'L': {
                              ++index;
                              // "ect"
                              if (match = ignoreCaseStringTest("ect", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           case 'u':
                           case 'U': {
                              ++index;
                              // "mn"
                              if (match = ignoreCaseStringTest("mn", 2)) {
                                 index += 2;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 'm':
                     case 'M': {
                        ++index;
                        // ("press" | "ment")
                        switch(buffer.getChar(index)) {
                           case 'p':
                           case 'P': {
                              ++index;
                              // "ress"
                              if (match = ignoreCaseStringTest("ress", 4)) {
                                 index += 4;
                              }
                              break;
                           }
                           case 'm':
                           case 'M': {
                              ++index;
                              // "ent"
                              if (match = ignoreCaseStringTest("ent", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'h':
               case 'H': {
                  ++index;
                  // ("eck" | "ar")
                  switch(buffer.getChar(index)) {
                     case 'a':
                     case 'A': {
                        ++index;
                        // "r"
                        if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                           ++index;
                        }
                        break;
                     }
                     case 'e':
                     case 'E': {
                        ++index;
                        // "ck"
                        if (match = ignoreCaseStringTest("ck", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "eate"
                  if (match = ignoreCaseStringTest("eate", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "uster"
                  if (match = ignoreCaseStringTest("uster", 5)) {
                     index += 5;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "rrent"
                  if (match = ignoreCaseStringTest("rrent", 5)) {
                     index += 5;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // ("uccessful" | "mallint" | "ession" | "ynonym" | "ysdate" | "elect" | "hare" | "tart" | "ize" | "et")
            switch(buffer.getChar(index)) {
               case 'h':
               case 'H': {
                  ++index;
                  // "are"
                  if (match = ignoreCaseStringTest("are", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'y':
               case 'Y': {
                  ++index;
                  // ("nonym" | "sdate")
                  switch(buffer.getChar(index)) {
                     case 'n':
                     case 'N': {
                        ++index;
                        // "onym"
                        if (match = ignoreCaseStringTest("onym", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "date"
                        if (match = ignoreCaseStringTest("date", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "ze"
                  if (match = ignoreCaseStringTest("ze", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 't':
               case 'T': {
                  ++index;
                  // "art"
                  if (match = ignoreCaseStringTest("art", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "ccessful"
                  if (match = ignoreCaseStringTest("ccessful", 8)) {
                     index += 8;
                  }
                  break;
               }
               case 'm':
               case 'M': {
                  ++index;
                  // "allint"
                  if (match = ignoreCaseStringTest("allint", 6)) {
                     index += 6;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("ssion" | "lect" | "t")
                  switch(buffer.getChar(index)) {
                     case 's':
                     case 'S': {
                        ++index;
                        // "sion"
                        if (match = ignoreCaseStringTest("sion", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // "ect"
                        if (match = ignoreCaseStringTest("ect", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // ("istinct" | "ecimal" | "efault" | "elete" | "ate" | "esc" | "rop")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I': {
                  ++index;
                  // "stinct"
                  if (match = ignoreCaseStringTest("stinct", 6)) {
                     index += 6;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "te"
                  if (match = ignoreCaseStringTest("te", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "op"
                  if (match = ignoreCaseStringTest("op", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("cimal" | "fault" | "lete" | "sc")
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F': {
                        ++index;
                        // "ault"
                        if (match = ignoreCaseStringTest("ault", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "imal"
                        if (match = ignoreCaseStringTest("imal", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "c"
                        if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                           ++index;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // "ete"
                        if (match = ignoreCaseStringTest("ete", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // ("rigger" | "able" | "hen" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'h':
               case 'H': {
                  ++index;
                  // "en"
                  if (match = ignoreCaseStringTest("en", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "ble"
                  if (match = ignoreCaseStringTest("ble", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "igger"
                  if (match = ignoreCaseStringTest("igger", 5)) {
                     index += 5;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // ("xclusive" | "xists" | "lse")
            switch(buffer.getChar(index)) {
               case 'x':
               case 'X': {
                  ++index;
                  // ("clusive" | "ists")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "sts"
                        if (match = ignoreCaseStringTest("sts", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "lusive"
                        if (match = ignoreCaseStringTest("lusive", 6)) {
                           index += 6;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'u':
         case 'U': {
            ++index;
            // ("nique" | "pdate" | "nion" | "sing" | "ser" | "id")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("ique" | "ion")
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("que" | "on")
                     switch(buffer.getChar(index)) {
                        case 'o':
                        case 'O': {
                           ++index;
                           // "n"
                           if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                              ++index;
                           }
                           break;
                        }
                        case 'q':
                        case 'Q': {
                           ++index;
                           // "ue"
                           if (match = ignoreCaseStringTest("ue", 2)) {
                              index += 2;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'p':
               case 'P': {
                  ++index;
                  // "date"
                  if (match = ignoreCaseStringTest("date", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "d"
                  if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                     ++index;
                  }
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // ("ing" | "er")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "ng"
                        if (match = ignoreCaseStringTest("ng", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'e':
                     case 'E': {
                        ++index;
                        // "r"
                        if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                           ++index;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
      }
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // SqlIdentifierPattern
         match = sqlIdentifierPattern$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         sqlIdentifier$RuleMemoStart = startIndex;
         sqlIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlIdentifier$RuleMemoStart = startIndex;
         sqlIdentifier$RuleMemoEnd = -1;
         sqlIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlIdentifierPattern : (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
   protected boolean sqlIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "SqlIdentifierPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
         if (! match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               // '_'
               match = charMatcher('_');
               if (! match) {
                  // '$'
                  match = charMatcher('$');
                  if (! match) {
                     // '#'
                     match = charMatcher('#');
                     if (! match) {
                        // ''
                        match = charMatcher('\u00C1');
                        if (! match) {
                           // ''
                           match = charMatcher('\u00C1');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C2');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C3');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C4');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C7');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C8');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C9');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00CA');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00CB');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CC');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CD');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CE');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CF');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00D2');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00D3');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D4');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D5');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D6');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D9');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00DA');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00DB');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DC');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00E0');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00E1');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E2');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E3');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E4');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E7');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E8');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E9');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00EA');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00EB');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EC');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00ED');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EE');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00EF');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00F2');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00F3');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F4');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F5');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F6');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F9');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00FA');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00FB');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FC');
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                     if (! match) {
                        // '$'
                        match = charMatcher('$');
                        if (! match) {
                           // '#'
                           match = charMatcher('#');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C1');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C1');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C2');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C3');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C4');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C7');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00C8');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00C9');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CA');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CB');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CC');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CD');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00CE');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00CF');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D2');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D3');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D4');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D5');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00D6');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00D9');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DA');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00DB');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00DC');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E0');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E1');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E2');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E3');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E4');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E7');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00E8');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00E9');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EA');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00EB');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EC');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00ED');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00EE');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00EF');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F2');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F3');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F4');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F5');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00F6');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00F9');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FA');
                                                                                                                                                               if (! match) {
                                                                                                                                                                  // ''
                                                                                                                                                                  match = charMatcher('\u00FB');
                                                                                                                                                                  if (! match) {
                                                                                                                                                                     // ''
                                                                                                                                                                     match = charMatcher('\u00FC');
                                                                                                                                                                  }
                                                                                                                                                               }
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      } else {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('"' (('\r' | '\n' | '"')! .)+ '"')
         // '"'
         match = charMatcher('\"');
         if (match) {
            // (('\r' | '\n' | '"')! .)+
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // (('\r' | '\n' | '"')! .)
            // ('\r' | '\n' | '"')!
            // ('\r' | '\n' | '"')
            int startIndex_6 = index;
            switch(buffer.getChar(index)) {
               case '\r': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_6;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
            if (match) {
               do {
                  lastNode_5 = currentNode;
                  lastIndex_5 = index;
                  // (('\r' | '\n' | '"')! .)
                  // ('\r' | '\n' | '"')!
                  // ('\r' | '\n' | '"')
                  int startIndex_7 = index;
                  switch(buffer.getChar(index)) {
                     case '\r': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\"': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\n': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  index = startIndex_7;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
               } while(match);
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
               match = true;
            } else {
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
            }
            if (match) {
               // '"'
               match = charMatcher('\"');
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAnyIdentifier : (SqlAnyIdentifierPattern OptionalSpacing)
   protected boolean sqlAnyIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAnyIdentifier", index);
      }
      if (sqlAnyIdentifier$RuleMemoStart == index) {
         if (sqlAnyIdentifier$RuleMemoStart <= sqlAnyIdentifier$RuleMemoEnd) {
            index = sqlAnyIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_ANY_IDENTIFIER, sqlAnyIdentifier$RuleMemoStart, sqlAnyIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlAnyIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlAnyIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlAnyIdentifierPattern OptionalSpacing)
      // SqlAnyIdentifierPattern
      match = sqlAnyIdentifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         sqlAnyIdentifier$RuleMemoStart = startIndex;
         sqlAnyIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlAnyIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_ANY_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlAnyIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlAnyIdentifier$RuleMemoStart = startIndex;
         sqlAnyIdentifier$RuleMemoEnd = -1;
         sqlAnyIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlAnyIdentifierPattern : (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
   protected boolean sqlAnyIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "SqlAnyIdentifierPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
         if (! match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               // '_'
               match = charMatcher('_');
               if (! match) {
                  // '$'
                  match = charMatcher('$');
                  if (! match) {
                     // '#'
                     match = charMatcher('#');
                     if (! match) {
                        // ''
                        match = charMatcher('\u00C1');
                        if (! match) {
                           // ''
                           match = charMatcher('\u00C1');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C2');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C3');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C4');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C7');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C8');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C9');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00CA');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00CB');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CC');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CD');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CE');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CF');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00D2');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00D3');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D4');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D5');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D6');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D9');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00DA');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00DB');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DC');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00E0');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00E1');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E2');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E3');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E4');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E7');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E8');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E9');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00EA');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00EB');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EC');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00ED');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EE');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00EF');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00F2');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00F3');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F4');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F5');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F6');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F9');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00FA');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00FB');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FC');
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                     if (! match) {
                        // '$'
                        match = charMatcher('$');
                        if (! match) {
                           // '#'
                           match = charMatcher('#');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C1');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C1');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C2');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C3');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C4');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C7');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00C8');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00C9');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CA');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CB');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CC');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CD');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00CE');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00CF');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D2');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D3');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D4');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D5');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00D6');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00D9');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DA');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00DB');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00DC');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E0');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E1');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E2');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E3');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E4');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E7');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00E8');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00E9');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EA');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00EB');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EC');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00ED');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00EE');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00EF');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F2');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F3');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F4');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F5');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00F6');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00F9');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FA');
                                                                                                                                                               if (! match) {
                                                                                                                                                                  // ''
                                                                                                                                                                  match = charMatcher('\u00FB');
                                                                                                                                                                  if (! match) {
                                                                                                                                                                     // ''
                                                                                                                                                                     match = charMatcher('\u00FC');
                                                                                                                                                                  }
                                                                                                                                                               }
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      } else {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('"' (('\r' | '\n' | '"')! .)+ '"')
         // '"'
         match = charMatcher('\"');
         if (match) {
            // (('\r' | '\n' | '"')! .)+
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // (('\r' | '\n' | '"')! .)
            // ('\r' | '\n' | '"')!
            // ('\r' | '\n' | '"')
            int startIndex_6 = index;
            switch(buffer.getChar(index)) {
               case '\r': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_6;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
            if (match) {
               do {
                  lastNode_5 = currentNode;
                  lastIndex_5 = index;
                  // (('\r' | '\n' | '"')! .)
                  // ('\r' | '\n' | '"')!
                  // ('\r' | '\n' | '"')
                  int startIndex_7 = index;
                  switch(buffer.getChar(index)) {
                     case '\r': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\"': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\n': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  index = startIndex_7;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
               } while(match);
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
               match = true;
            } else {
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
            }
            if (match) {
               // '"'
               match = charMatcher('\"');
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TestNoAlpha : ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#')!
   protected boolean testNoAlpha$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TestNoAlpha", index);
      }
      if (testNoAlpha$RuleMemoStart == index) {
         if (testNoAlpha$RuleMemoStart <= testNoAlpha$RuleMemoEnd) {
            index = testNoAlpha$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TEST_NO_ALPHA, testNoAlpha$RuleMemoStart, testNoAlpha$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (testNoAlpha$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(testNoAlpha$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#')!
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#')
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // 'a'-'z'
      match = buffer.matchCharRange(index, 'a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = buffer.matchCharRange(index, 'A', 'Z');
         if (! match) {
            // '0'-'9'
            match = buffer.matchCharRange(index, '0', '9');
            if (! match) {
               // '_'
               match = buffer.matchChar(index, '_');
               if (! match) {
                  // '$'
                  match = buffer.matchChar(index, '$');
                  if (! match) {
                     // '#'
                     match = buffer.matchChar(index, '#');
                  }
               }
            }
         }
      }
      match = ! match;
      if (match) {
         testNoAlpha$RuleMemoStart = startIndex;
         testNoAlpha$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            testNoAlpha$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TEST_NO_ALPHA, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            testNoAlpha$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         testNoAlpha$RuleMemoStart = startIndex;
         testNoAlpha$RuleMemoEnd = -1;
         testNoAlpha$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OptionalSpacing : (Spaces | BlockComment | LineComment)*
   protected boolean optionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OptionalSpacing", index);
      }
      if (optionalSpacing$RuleMemoStart == index) {
         if (optionalSpacing$RuleMemoStart <= optionalSpacing$RuleMemoEnd) {
            index = optionalSpacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OPTIONAL_SPACING, optionalSpacing$RuleMemoStart, optionalSpacing$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (optionalSpacing$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalSpacing$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Spaces | BlockComment | LineComment)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (Spaces | BlockComment | LineComment)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case ' ':
            case '\t':
            case '\n':
            case '\f':
            case '\r': {
               // Spaces
               match = spaces$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '-': {
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case '/': {
               // BlockComment
               match = blockComment$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      optionalSpacing$RuleMemoStart = startIndex;
      optionalSpacing$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         optionalSpacing$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(OracleScriptRuleType.OPTIONAL_SPACING, startIndex, index, false, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         optionalSpacing$RuleMemoFirstNode = currentNode;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //SqlObjectIdentifierList : (SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)*)
   protected boolean sqlObjectIdentifierList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlObjectIdentifierList", index);
      }
      if (sqlObjectIdentifierList$RuleMemoStart == index) {
         if (sqlObjectIdentifierList$RuleMemoStart <= sqlObjectIdentifierList$RuleMemoEnd) {
            index = sqlObjectIdentifierList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_OBJECT_IDENTIFIER_LIST, sqlObjectIdentifierList$RuleMemoStart, sqlObjectIdentifierList$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (sqlObjectIdentifierList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlObjectIdentifierList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)*)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // (',' OptionalSpacing SqlObjectIdentifier)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing SqlObjectIdentifier)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlObjectIdentifier
                  match = sqlObjectIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         sqlObjectIdentifierList$RuleMemoStart = startIndex;
         sqlObjectIdentifierList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlObjectIdentifierList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_OBJECT_IDENTIFIER_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlObjectIdentifierList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlObjectIdentifierList$RuleMemoStart = startIndex;
         sqlObjectIdentifierList$RuleMemoEnd = -1;
         sqlObjectIdentifierList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlIdentifierList : (SqlIdentifier (',' OptionalSpacing SqlIdentifier)*)
   protected boolean sqlIdentifierList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlIdentifierList", index);
      }
      if (sqlIdentifierList$RuleMemoStart == index) {
         if (sqlIdentifierList$RuleMemoStart <= sqlIdentifierList$RuleMemoEnd) {
            index = sqlIdentifierList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIER_LIST, sqlIdentifierList$RuleMemoStart, sqlIdentifierList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlIdentifierList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlIdentifierList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlIdentifier (',' OptionalSpacing SqlIdentifier)*)
      // SqlIdentifier
      match = sqlIdentifier$Rule();
      if (match) {
         // (',' OptionalSpacing SqlIdentifier)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing SqlIdentifier)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SqlIdentifier
                  match = sqlIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         sqlIdentifierList$RuleMemoStart = startIndex;
         sqlIdentifierList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlIdentifierList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_IDENTIFIER_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlIdentifierList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlIdentifierList$RuleMemoStart = startIndex;
         sqlIdentifierList$RuleMemoEnd = -1;
         sqlIdentifierList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Spaces : (' ' | '\r' | '\n' | '\t' | '\f')+
   protected boolean spaces$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "Spaces", index);
      }
      if (spaces$RuleMemoStart == index) {
         if (spaces$RuleMemoStart <= spaces$RuleMemoEnd) {
            index = spaces$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SPACES, spaces$RuleMemoStart, spaces$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (spaces$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(spaces$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (' ' | '\r' | '\n' | '\t' | '\f')+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (' ' | '\r' | '\n' | '\t' | '\f')
      switch(buffer.getChar(index)) {
         case '\f': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\r': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case ' ': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\t': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '\n': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (' ' | '\r' | '\n' | '\t' | '\f')
            switch(buffer.getChar(index)) {
               case '\f': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\r': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case ' ': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\t': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         spaces$RuleMemoStart = startIndex;
         spaces$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            spaces$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SPACES, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            spaces$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         spaces$RuleMemoStart = startIndex;
         spaces$RuleMemoEnd = -1;
         spaces$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BlockComment : ('/*' ('*/'! .)* '*/')
   protected boolean blockComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "BlockComment", index);
      }
      if (blockComment$RuleMemoStart == index) {
         if (blockComment$RuleMemoStart <= blockComment$RuleMemoEnd) {
            index = blockComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BLOCK_COMMENT, blockComment$RuleMemoStart, blockComment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (blockComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(blockComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('/*' ('*/'! .)* '*/')
      // '/*'
      match = stringMatcher("/*", 2);
      if (match) {
         // ('*/'! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('*/'! .)
            // '*/'!
            // '*/'
            match = stringTest("*/", 2);
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         // '*/'
         match = stringMatcher("*/", 2);
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BLOCK_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            blockComment$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = -1;
         blockComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LineComment : ('--' ('\n'! .)* ('\n' | '\r\n' | <EOI>))
   protected boolean lineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "LineComment", index);
      }
      if (lineComment$RuleMemoStart == index) {
         if (lineComment$RuleMemoStart <= lineComment$RuleMemoEnd) {
            index = lineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LINE_COMMENT, lineComment$RuleMemoStart, lineComment$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (lineComment$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(lineComment$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('--' ('\n'! .)* ('\n' | '\r\n' | <EOI>))
      // '--'
      match = stringMatcher("--", 2);
      if (match) {
         // ('\n'! .)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('\n'! .)
            // '\n'!
            // '\n'
            match = buffer.matchChar(index, '\n');
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
         // ('\n' | '\r\n' | <EOI>)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // '\n'
         match = charMatcher('\n');
         if (! match) {
            // '\r\n'
            match = stringMatcher("\r\n", 4);
            if (! match) {
               // <EOI>
               match = eoi();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            lineComment$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = -1;
         lineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlProgram : (OptionalSpacing PlSqlSource OptionalSpacing)
   protected boolean plSqlProgram$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlProgram", index);
      }
      startIndex = index;
      // (OptionalSpacing PlSqlSource OptionalSpacing)
      // OptionalSpacing
      match = optionalSpacing$Rule();
      if (match) {
         // PlSqlSource
         match = plSqlSource$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_PROGRAM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlSource : (CreatePackageBody | CreatePackage | CreateFunction | CreateProcedure | AnonymousPlSqlBlock)
   protected boolean plSqlSource$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlSource", index);
      }
      if (plSqlSource$RuleMemoStart == index) {
         if (plSqlSource$RuleMemoStart <= plSqlSource$RuleMemoEnd) {
            index = plSqlSource$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_SOURCE, plSqlSource$RuleMemoStart, plSqlSource$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlSource$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlSource$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CreatePackageBody | CreatePackage | CreateFunction | CreateProcedure | AnonymousPlSqlBlock)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'b':
         case 'B':
         case 'd':
         case 'D': {
            // AnonymousPlSqlBlock
            match = anonymousPlSqlBlock$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'c':
         case 'C': {
            // CreatePackageBody
            match = createPackageBody$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CreatePackage
               match = createPackage$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // CreateFunction
                  match = createFunction$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // CreateProcedure
                     match = createProcedure$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlSource$RuleMemoStart = startIndex;
         plSqlSource$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlSource$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_SOURCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlSource$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlSource$RuleMemoStart = startIndex;
         plSqlSource$RuleMemoEnd = -1;
         plSqlSource$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlExpression : (OptionalAndExpression OrExpression*)
   protected boolean plSqlExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlExpression", index);
      }
      if (plSqlExpression$RuleMemoStart == index) {
         if (plSqlExpression$RuleMemoStart <= plSqlExpression$RuleMemoEnd) {
            index = plSqlExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_EXPRESSION, plSqlExpression$RuleMemoStart, plSqlExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (OptionalAndExpression OrExpression*)
      // OptionalAndExpression
      match = optionalAndExpression$Rule();
      if (match) {
         // OrExpression*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // OrExpression
            match = orExpression$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         plSqlExpression$RuleMemoStart = startIndex;
         plSqlExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlExpression$RuleMemoStart = startIndex;
         plSqlExpression$RuleMemoEnd = -1;
         plSqlExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrExpression : ("or" TestNoAlpha OptionalSpacing OptionalAndExpression)
   protected boolean orExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrExpression", index);
      }
      startIndex = index;
      // ("or" TestNoAlpha OptionalSpacing OptionalAndExpression)
      // "or"
      match = ignoreCaseStringMatcher("or", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // OptionalAndExpression
               match = optionalAndExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.OR_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OptionalAndExpression : (LogicalExpression AndExpression*)
   protected boolean optionalAndExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OptionalAndExpression", index);
      }
      if (optionalAndExpression$RuleMemoStart == index) {
         if (optionalAndExpression$RuleMemoStart <= optionalAndExpression$RuleMemoEnd) {
            index = optionalAndExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OPTIONAL_AND_EXPRESSION, optionalAndExpression$RuleMemoStart, optionalAndExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (optionalAndExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(optionalAndExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (LogicalExpression AndExpression*)
      // LogicalExpression
      match = logicalExpression$Rule();
      if (match) {
         // AndExpression*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // AndExpression
            match = andExpression$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         optionalAndExpression$RuleMemoStart = startIndex;
         optionalAndExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            optionalAndExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OPTIONAL_AND_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            optionalAndExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         optionalAndExpression$RuleMemoStart = startIndex;
         optionalAndExpression$RuleMemoEnd = -1;
         optionalAndExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AndExpression : ("and" TestNoAlpha OptionalSpacing LogicalExpression)
   protected boolean andExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AndExpression", index);
      }
      startIndex = index;
      // ("and" TestNoAlpha OptionalSpacing LogicalExpression)
      // "and"
      match = ignoreCaseStringMatcher("and", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // LogicalExpression
               match = logicalExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.AND_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LogicalExpression : (NotExpression | RelationalExpression)
   protected boolean logicalExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LogicalExpression", index);
      }
      if (logicalExpression$RuleMemoStart == index) {
         if (logicalExpression$RuleMemoStart <= logicalExpression$RuleMemoEnd) {
            index = logicalExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LOGICAL_EXPRESSION, logicalExpression$RuleMemoStart, logicalExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (logicalExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(logicalExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NotExpression | RelationalExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // RelationalExpression
            match = relationalExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'N':
         case 'n': {
            // NotExpression
            match = notExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RelationalExpression
               match = relationalExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         logicalExpression$RuleMemoStart = startIndex;
         logicalExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            logicalExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LOGICAL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            logicalExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         logicalExpression$RuleMemoStart = startIndex;
         logicalExpression$RuleMemoEnd = -1;
         logicalExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NotExpression : ("not" TestNoAlpha OptionalSpacing RelationalExpression)
   protected boolean notExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NotExpression", index);
      }
      if (notExpression$RuleMemoStart == index) {
         if (notExpression$RuleMemoStart <= notExpression$RuleMemoEnd) {
            index = notExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NOT_EXPRESSION, notExpression$RuleMemoStart, notExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (notExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(notExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("not" TestNoAlpha OptionalSpacing RelationalExpression)
      // "not"
      match = ignoreCaseStringMatcher("not", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // RelationalExpression
               match = relationalExpression$Rule();
            }
         }
      }
      if (match) {
         notExpression$RuleMemoStart = startIndex;
         notExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            notExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NOT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            notExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         notExpression$RuleMemoStart = startIndex;
         notExpression$RuleMemoEnd = -1;
         notExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RelationalExpression : (ComparisonExpression | InExpression | BetweenExpression | LikeExpression | IsNullExpression | NumericExpression)
   protected boolean relationalExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RelationalExpression", index);
      }
      if (relationalExpression$RuleMemoStart == index) {
         if (relationalExpression$RuleMemoStart <= relationalExpression$RuleMemoEnd) {
            index = relationalExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_EXPRESSION, relationalExpression$RuleMemoStart, relationalExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (relationalExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(relationalExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ComparisonExpression | InExpression | BetweenExpression | LikeExpression | IsNullExpression | NumericExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // ComparisonExpression
            match = comparisonExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // InExpression
               match = inExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // BetweenExpression
                  match = betweenExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // LikeExpression
                     match = likeExpression$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // IsNullExpression
                        match = isNullExpression$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // NumericExpression
                           match = numericExpression$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         relationalExpression$RuleMemoStart = startIndex;
         relationalExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            relationalExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RELATIONAL_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            relationalExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         relationalExpression$RuleMemoStart = startIndex;
         relationalExpression$RuleMemoEnd = -1;
         relationalExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ComparisonExpression : (NumericExpression RelationalOperator PlSqlExpression)
   protected boolean comparisonExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ComparisonExpression", index);
      }
      if (comparisonExpression$RuleMemoStart == index) {
         if (comparisonExpression$RuleMemoStart <= comparisonExpression$RuleMemoEnd) {
            index = comparisonExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COMPARISON_EXPRESSION, comparisonExpression$RuleMemoStart, comparisonExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (comparisonExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(comparisonExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression RelationalOperator PlSqlExpression)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // RelationalOperator
         match = relationalOperator$Rule();
         if (match) {
            // PlSqlExpression
            match = plSqlExpression$Rule();
         }
      }
      if (match) {
         comparisonExpression$RuleMemoStart = startIndex;
         comparisonExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            comparisonExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COMPARISON_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            comparisonExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         comparisonExpression$RuleMemoStart = startIndex;
         comparisonExpression$RuleMemoEnd = -1;
         comparisonExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InExpression : (NumericExpression Not? "in" TestNoAlpha OptionalSpacing PlSqlExpressionList)
   protected boolean inExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InExpression", index);
      }
      if (inExpression$RuleMemoStart == index) {
         if (inExpression$RuleMemoStart <= inExpression$RuleMemoEnd) {
            index = inExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IN_EXPRESSION, inExpression$RuleMemoStart, inExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (inExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(inExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression Not? "in" TestNoAlpha OptionalSpacing PlSqlExpressionList)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "in"
            match = ignoreCaseStringMatcher("in", 2);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // PlSqlExpressionList
                     match = plSqlExpressionList$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         inExpression$RuleMemoStart = startIndex;
         inExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IN_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         inExpression$RuleMemoStart = startIndex;
         inExpression$RuleMemoEnd = -1;
         inExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BetweenExpression : (NumericExpression Not? BetweenBounds)
   protected boolean betweenExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BetweenExpression", index);
      }
      if (betweenExpression$RuleMemoStart == index) {
         if (betweenExpression$RuleMemoStart <= betweenExpression$RuleMemoEnd) {
            index = betweenExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_EXPRESSION, betweenExpression$RuleMemoStart, betweenExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (betweenExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(betweenExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression Not? BetweenBounds)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // BetweenBounds
            match = betweenBounds$Rule();
         }
      }
      if (match) {
         betweenExpression$RuleMemoStart = startIndex;
         betweenExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            betweenExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            betweenExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         betweenExpression$RuleMemoStart = startIndex;
         betweenExpression$RuleMemoEnd = -1;
         betweenExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LikeExpression : (NumericExpression Not? "like" TestNoAlpha OptionalSpacing PlSqlExpression)
   protected boolean likeExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LikeExpression", index);
      }
      if (likeExpression$RuleMemoStart == index) {
         if (likeExpression$RuleMemoStart <= likeExpression$RuleMemoEnd) {
            index = likeExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LIKE_EXPRESSION, likeExpression$RuleMemoStart, likeExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (likeExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(likeExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression Not? "like" TestNoAlpha OptionalSpacing PlSqlExpression)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // Not?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // Not
         match = not$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // "like"
            match = ignoreCaseStringMatcher("like", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // PlSqlExpression
                     match = plSqlExpression$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         likeExpression$RuleMemoStart = startIndex;
         likeExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            likeExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LIKE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            likeExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         likeExpression$RuleMemoStart = startIndex;
         likeExpression$RuleMemoEnd = -1;
         likeExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsNullExpression : (NumericExpression "is" TestNoAlpha OptionalSpacing Nullable)
   protected boolean isNullExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsNullExpression", index);
      }
      if (isNullExpression$RuleMemoStart == index) {
         if (isNullExpression$RuleMemoStart <= isNullExpression$RuleMemoEnd) {
            index = isNullExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_NULL_EXPRESSION, isNullExpression$RuleMemoStart, isNullExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (isNullExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isNullExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression "is" TestNoAlpha OptionalSpacing Nullable)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // "is"
         match = ignoreCaseStringMatcher("is", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Nullable
                  match = nullable$Rule();
               }
            }
         }
      }
      if (match) {
         isNullExpression$RuleMemoStart = startIndex;
         isNullExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isNullExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_NULL_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isNullExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isNullExpression$RuleMemoStart = startIndex;
         isNullExpression$RuleMemoEnd = -1;
         isNullExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NumericExpression : (PlSqlMathExpression | PlSqlUnaryExpression | PlSqlAtomicExpression)
   protected boolean numericExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NumericExpression", index);
      }
      if (numericExpression$RuleMemoStart == index) {
         if (numericExpression$RuleMemoStart <= numericExpression$RuleMemoEnd) {
            index = numericExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NUMERIC_EXPRESSION, numericExpression$RuleMemoStart, numericExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (numericExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numericExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlMathExpression | PlSqlUnaryExpression | PlSqlAtomicExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+':
         case '-': {
            // PlSqlMathExpression
            match = plSqlMathExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlUnaryExpression
               match = plSqlUnaryExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlAtomicExpression
                  match = plSqlAtomicExpression$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlMathExpression
            match = plSqlMathExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlAtomicExpression
               match = plSqlAtomicExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         numericExpression$RuleMemoStart = startIndex;
         numericExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numericExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMERIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numericExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         numericExpression$RuleMemoStart = startIndex;
         numericExpression$RuleMemoEnd = -1;
         numericExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlMathExpression : (PlSqlAtomicExpression SqlMathOperator PlSqlExpression)
   protected boolean plSqlMathExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlMathExpression", index);
      }
      if (plSqlMathExpression$RuleMemoStart == index) {
         if (plSqlMathExpression$RuleMemoStart <= plSqlMathExpression$RuleMemoEnd) {
            index = plSqlMathExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_MATH_EXPRESSION, plSqlMathExpression$RuleMemoStart, plSqlMathExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlMathExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlMathExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlAtomicExpression SqlMathOperator PlSqlExpression)
      // PlSqlAtomicExpression
      match = plSqlAtomicExpression$Rule();
      if (match) {
         // SqlMathOperator
         match = sqlMathOperator$Rule();
         if (match) {
            // PlSqlExpression
            match = plSqlExpression$Rule();
         }
      }
      if (match) {
         plSqlMathExpression$RuleMemoStart = startIndex;
         plSqlMathExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlMathExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_MATH_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlMathExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlMathExpression$RuleMemoStart = startIndex;
         plSqlMathExpression$RuleMemoEnd = -1;
         plSqlMathExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlUnaryExpression : ((('+' | '-') OptionalSpacing) PlSqlExpression)
   protected boolean plSqlUnaryExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlUnaryExpression", index);
      }
      if (plSqlUnaryExpression$RuleMemoStart == index) {
         if (plSqlUnaryExpression$RuleMemoStart <= plSqlUnaryExpression$RuleMemoEnd) {
            index = plSqlUnaryExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_UNARY_EXPRESSION, plSqlUnaryExpression$RuleMemoStart, plSqlUnaryExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlUnaryExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlUnaryExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((('+' | '-') OptionalSpacing) PlSqlExpression)
      // (('+' | '-') OptionalSpacing)
      // ('+' | '-')
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         case '-': {
            ++index;
            // <EMPTY>
            match = true;
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         // PlSqlExpression
         match = plSqlExpression$Rule();
      }
      if (match) {
         plSqlUnaryExpression$RuleMemoStart = startIndex;
         plSqlUnaryExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlUnaryExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_UNARY_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlUnaryExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlUnaryExpression$RuleMemoStart = startIndex;
         plSqlUnaryExpression$RuleMemoEnd = -1;
         plSqlUnaryExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlParenthesesExpression : ('(' OptionalSpacing PlSqlExpression ')' OptionalSpacing)
   protected boolean plSqlParenthesesExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlParenthesesExpression", index);
      }
      if (plSqlParenthesesExpression$RuleMemoStart == index) {
         if (plSqlParenthesesExpression$RuleMemoStart <= plSqlParenthesesExpression$RuleMemoEnd) {
            index = plSqlParenthesesExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_PARENTHESES_EXPRESSION, plSqlParenthesesExpression$RuleMemoStart, plSqlParenthesesExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlParenthesesExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlParenthesesExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing PlSqlExpression ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlExpression
            match = plSqlExpression$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         plSqlParenthesesExpression$RuleMemoStart = startIndex;
         plSqlParenthesesExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlParenthesesExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_PARENTHESES_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlParenthesesExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlParenthesesExpression$RuleMemoStart = startIndex;
         plSqlParenthesesExpression$RuleMemoEnd = -1;
         plSqlParenthesesExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlCursorAttribute : ("sql" TestNoAlpha OptionalSpacing CursorAttribute)
   protected boolean sqlCursorAttribute$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlCursorAttribute", index);
      }
      if (sqlCursorAttribute$RuleMemoStart == index) {
         if (sqlCursorAttribute$RuleMemoStart <= sqlCursorAttribute$RuleMemoEnd) {
            index = sqlCursorAttribute$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_CURSOR_ATTRIBUTE, sqlCursorAttribute$RuleMemoStart, sqlCursorAttribute$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlCursorAttribute$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlCursorAttribute$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("sql" TestNoAlpha OptionalSpacing CursorAttribute)
      // "sql"
      match = ignoreCaseStringMatcher("sql", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CursorAttribute
               match = cursorAttribute$Rule();
            }
         }
      }
      if (match) {
         sqlCursorAttribute$RuleMemoStart = startIndex;
         sqlCursorAttribute$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlCursorAttribute$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_CURSOR_ATTRIBUTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlCursorAttribute$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlCursorAttribute$RuleMemoStart = startIndex;
         sqlCursorAttribute$RuleMemoEnd = -1;
         sqlCursorAttribute$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlObjectCursor : (PlSqlObjectIdentifier CursorAttribute)
   protected boolean plSqlObjectCursor$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlObjectCursor", index);
      }
      if (plSqlObjectCursor$RuleMemoStart == index) {
         if (plSqlObjectCursor$RuleMemoStart <= plSqlObjectCursor$RuleMemoEnd) {
            index = plSqlObjectCursor$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_CURSOR, plSqlObjectCursor$RuleMemoStart, plSqlObjectCursor$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlObjectCursor$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlObjectCursor$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlObjectIdentifier CursorAttribute)
      // PlSqlObjectIdentifier
      match = plSqlObjectIdentifier$Rule();
      if (match) {
         // CursorAttribute
         match = cursorAttribute$Rule();
      }
      if (match) {
         plSqlObjectCursor$RuleMemoStart = startIndex;
         plSqlObjectCursor$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlObjectCursor$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_CURSOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlObjectCursor$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlObjectCursor$RuleMemoStart = startIndex;
         plSqlObjectCursor$RuleMemoEnd = -1;
         plSqlObjectCursor$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlObjectCollection : (PlSqlObjectIdentifier CollectionAttribute)
   protected boolean plSqlObjectCollection$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlObjectCollection", index);
      }
      if (plSqlObjectCollection$RuleMemoStart == index) {
         if (plSqlObjectCollection$RuleMemoStart <= plSqlObjectCollection$RuleMemoEnd) {
            index = plSqlObjectCollection$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_COLLECTION, plSqlObjectCollection$RuleMemoStart, plSqlObjectCollection$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlObjectCollection$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlObjectCollection$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlObjectIdentifier CollectionAttribute)
      // PlSqlObjectIdentifier
      match = plSqlObjectIdentifier$Rule();
      if (match) {
         // CollectionAttribute
         match = collectionAttribute$Rule();
      }
      if (match) {
         plSqlObjectCollection$RuleMemoStart = startIndex;
         plSqlObjectCollection$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlObjectCollection$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_COLLECTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlObjectCollection$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlObjectCollection$RuleMemoStart = startIndex;
         plSqlObjectCollection$RuleMemoEnd = -1;
         plSqlObjectCollection$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //HostVariableCursor : (HostVariable CursorAttribute)
   protected boolean hostVariableCursor$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "HostVariableCursor", index);
      }
      if (hostVariableCursor$RuleMemoStart == index) {
         if (hostVariableCursor$RuleMemoStart <= hostVariableCursor$RuleMemoEnd) {
            index = hostVariableCursor$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.HOST_VARIABLE_CURSOR, hostVariableCursor$RuleMemoStart, hostVariableCursor$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (hostVariableCursor$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hostVariableCursor$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (HostVariable CursorAttribute)
      // HostVariable
      match = hostVariable$Rule();
      if (match) {
         // CursorAttribute
         match = cursorAttribute$Rule();
      }
      if (match) {
         hostVariableCursor$RuleMemoStart = startIndex;
         hostVariableCursor$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hostVariableCursor$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.HOST_VARIABLE_CURSOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hostVariableCursor$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         hostVariableCursor$RuleMemoStart = startIndex;
         hostVariableCursor$RuleMemoEnd = -1;
         hostVariableCursor$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAtomicExpression : (PlSqlParenthesesExpression | PlSqlLiteral | SqlCursorAttribute | PlSqlCaseExpression | PlSqlObjectCursor | PlSqlObjectCollection | PlSqlObjectIdentifier | HostVariableCursor | HostVariable)
   protected boolean plSqlAtomicExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAtomicExpression", index);
      }
      if (plSqlAtomicExpression$RuleMemoStart == index) {
         if (plSqlAtomicExpression$RuleMemoStart <= plSqlAtomicExpression$RuleMemoEnd) {
            index = plSqlAtomicExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ATOMIC_EXPRESSION, plSqlAtomicExpression$RuleMemoStart, plSqlAtomicExpression$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlAtomicExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlAtomicExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlParenthesesExpression | PlSqlLiteral | SqlCursorAttribute | PlSqlCaseExpression | PlSqlObjectCursor | PlSqlObjectCollection | PlSqlObjectIdentifier | HostVariableCursor | HostVariable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case '+':
         case '-': {
            // PlSqlLiteral
            match = plSqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'D':
         case 'd':
         case 'F':
         case 'f':
         case 'I':
         case 'i':
         case 'N':
         case 'n':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case 'T':
         case 't':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // PlSqlLiteral
            match = plSqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlObjectCursor
               match = plSqlObjectCursor$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlObjectCollection
                  match = plSqlObjectCollection$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case 'A':
         case '\u00C1':
         case 'B':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case 'E':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case 'L':
         case '\u00CC':
         case 'M':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'P':
         case 'Q':
         case 'R':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case 'U':
         case '\u00D5':
         case 'V':
         case '\u00D6':
         case 'W':
         case 'X':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case 'a':
         case '\u00E1':
         case 'b':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case 'e':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case 'l':
         case '\u00EC':
         case 'm':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'p':
         case 'q':
         case 'r':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case 'u':
         case '\u00F5':
         case 'v':
         case '\u00F6':
         case 'w':
         case 'x':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlObjectCursor
            match = plSqlObjectCursor$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlObjectCollection
               match = plSqlObjectCollection$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlObjectIdentifier
                  match = plSqlObjectIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // PlSqlCaseExpression
            match = plSqlCaseExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlObjectCursor
               match = plSqlObjectCursor$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlObjectCollection
                  match = plSqlObjectCollection$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'S':
         case 's': {
            // SqlCursorAttribute
            match = sqlCursorAttribute$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlObjectCursor
               match = plSqlObjectCursor$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlObjectCollection
                  match = plSqlObjectCollection$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case '(': {
            // PlSqlParenthesesExpression
            match = plSqlParenthesesExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case ':': {
            // HostVariableCursor
            match = hostVariableCursor$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // HostVariable
               match = hostVariable$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlAtomicExpression$RuleMemoStart = startIndex;
         plSqlAtomicExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlAtomicExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ATOMIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlAtomicExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlAtomicExpression$RuleMemoStart = startIndex;
         plSqlAtomicExpression$RuleMemoEnd = -1;
         plSqlAtomicExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseExpressionElse : ("else" TestNoAlpha OptionalSpacing PlSqlExpression)
   protected boolean caseExpressionElse$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseExpressionElse", index);
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing PlSqlExpression)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_EXPRESSION_ELSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseExpressionWhen : ("when" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlExpression)
   protected boolean caseExpressionWhen$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseExpressionWhen", index);
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlExpression)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlExpression
                           match = plSqlExpression$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_EXPRESSION_WHEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseExpressionWhenList : CaseExpressionWhen+
   protected boolean caseExpressionWhenList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseExpressionWhenList", index);
      }
      startIndex = index;
      // CaseExpressionWhen+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // CaseExpressionWhen
      match = caseExpressionWhen$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // CaseExpressionWhen
            match = caseExpressionWhen$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_EXPRESSION_WHEN_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlCaseExpression : ("case" TestNoAlpha OptionalSpacing PlSqlExpression? CaseExpressionWhenList CaseExpressionElse? "end" TestNoAlpha OptionalSpacing)
   protected boolean plSqlCaseExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlCaseExpression", index);
      }
      if (plSqlCaseExpression$RuleMemoStart == index) {
         if (plSqlCaseExpression$RuleMemoStart <= plSqlCaseExpression$RuleMemoEnd) {
            index = plSqlCaseExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_CASE_EXPRESSION, plSqlCaseExpression$RuleMemoStart, plSqlCaseExpression$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlCaseExpression$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlCaseExpression$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing PlSqlExpression? CaseExpressionWhenList CaseExpressionElse? "end" TestNoAlpha OptionalSpacing)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // CaseExpressionWhenList
                  match = caseExpressionWhenList$Rule();
                  if (match) {
                     // CaseExpressionElse?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // CaseExpressionElse
                     match = caseExpressionElse$Rule();
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                     if (match) {
                        // "end"
                        match = ignoreCaseStringMatcher("end", 3);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         plSqlCaseExpression$RuleMemoStart = startIndex;
         plSqlCaseExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlCaseExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_CASE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlCaseExpression$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlCaseExpression$RuleMemoStart = startIndex;
         plSqlCaseExpression$RuleMemoEnd = -1;
         plSqlCaseExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CollectionAttribute : ('.' OptionalSpacing (("count" TestNoAlpha OptionalSpacing) | ("first" TestNoAlpha OptionalSpacing) | ("last" TestNoAlpha OptionalSpacing) | ("limit" TestNoAlpha OptionalSpacing) | ("exists" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("next" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("prior" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression)))
   protected boolean collectionAttribute$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CollectionAttribute", index);
      }
      startIndex = index;
      // ('.' OptionalSpacing (("count" TestNoAlpha OptionalSpacing) | ("first" TestNoAlpha OptionalSpacing) | ("last" TestNoAlpha OptionalSpacing) | ("limit" TestNoAlpha OptionalSpacing) | ("exists" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("next" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("prior" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression)))
      // '.'
      match = charMatcher('.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (("count" TestNoAlpha OptionalSpacing) | ("first" TestNoAlpha OptionalSpacing) | ("last" TestNoAlpha OptionalSpacing) | ("limit" TestNoAlpha OptionalSpacing) | ("exists" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("next" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression) | ("prior" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression))
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ("count" TestNoAlpha OptionalSpacing)
            // "count"
            match = ignoreCaseStringMatcher("count", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ("first" TestNoAlpha OptionalSpacing)
               // "first"
               match = ignoreCaseStringMatcher("first", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("last" TestNoAlpha OptionalSpacing)
                  // "last"
                  match = ignoreCaseStringMatcher("last", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("limit" TestNoAlpha OptionalSpacing)
                     // "limit"
                     match = ignoreCaseStringMatcher("limit", 5);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("exists" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression)
                        // "exists"
                        match = ignoreCaseStringMatcher("exists", 6);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // PlSqlParenthesesExpression
                                 match = plSqlParenthesesExpression$Rule();
                              }
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("next" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression)
                           // "next"
                           match = ignoreCaseStringMatcher("next", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // PlSqlParenthesesExpression
                                    match = plSqlParenthesesExpression$Rule();
                                 }
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ("prior" TestNoAlpha OptionalSpacing PlSqlParenthesesExpression)
                              // "prior"
                              match = ignoreCaseStringMatcher("prior", 5);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // PlSqlParenthesesExpression
                                       match = plSqlParenthesesExpression$Rule();
                                    }
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.COLLECTION_ATTRIBUTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorAttribute : ('%' OptionalSpacing PlSqlObjectIdentifier)
   protected boolean cursorAttribute$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorAttribute", index);
      }
      if (cursorAttribute$RuleMemoStart == index) {
         if (cursorAttribute$RuleMemoStart <= cursorAttribute$RuleMemoEnd) {
            index = cursorAttribute$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_ATTRIBUTE, cursorAttribute$RuleMemoStart, cursorAttribute$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cursorAttribute$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cursorAttribute$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('%' OptionalSpacing PlSqlObjectIdentifier)
      // '%'
      match = charMatcher('%');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlObjectIdentifier
            match = plSqlObjectIdentifier$Rule();
         }
      }
      if (match) {
         cursorAttribute$RuleMemoStart = startIndex;
         cursorAttribute$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cursorAttribute$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_ATTRIBUTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cursorAttribute$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cursorAttribute$RuleMemoStart = startIndex;
         cursorAttribute$RuleMemoEnd = -1;
         cursorAttribute$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IsAsKeyword : (("is" | "as") TestNoAlpha OptionalSpacing)
   protected boolean isAsKeyword$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IsAsKeyword", index);
      }
      if (isAsKeyword$RuleMemoStart == index) {
         if (isAsKeyword$RuleMemoStart <= isAsKeyword$RuleMemoEnd) {
            index = isAsKeyword$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IS_AS_KEYWORD, isAsKeyword$RuleMemoStart, isAsKeyword$RuleMemoEnd, false, false);
               lastNode.setSibling(currentNode);
               if (isAsKeyword$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(isAsKeyword$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("is" | "as") TestNoAlpha OptionalSpacing)
      // ("is" | "as")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'i':
         case 'I': {
            ++index;
            // "s"
            if (match = buffer.matchIgnoreCaseChar(index, 's')) {
               ++index;
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // "s"
            if (match = buffer.matchIgnoreCaseChar(index, 's')) {
               ++index;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         isAsKeyword$RuleMemoStart = startIndex;
         isAsKeyword$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            isAsKeyword$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IS_AS_KEYWORD, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            isAsKeyword$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         isAsKeyword$RuleMemoStart = startIndex;
         isAsKeyword$RuleMemoEnd = -1;
         isAsKeyword$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DeclarationSection : ("declare" TestNoAlpha OptionalSpacing DeclareSection?)
   protected boolean declarationSection$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DeclarationSection", index);
      }
      if (declarationSection$RuleMemoStart == index) {
         if (declarationSection$RuleMemoStart <= declarationSection$RuleMemoEnd) {
            index = declarationSection$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DECLARATION_SECTION, declarationSection$RuleMemoStart, declarationSection$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (declarationSection$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(declarationSection$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("declare" TestNoAlpha OptionalSpacing DeclareSection?)
      // "declare"
      match = ignoreCaseStringMatcher("declare", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DeclareSection?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // DeclareSection
               match = declareSection$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         declarationSection$RuleMemoStart = startIndex;
         declarationSection$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            declarationSection$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DECLARATION_SECTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            declarationSection$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         declarationSection$RuleMemoStart = startIndex;
         declarationSection$RuleMemoEnd = -1;
         declarationSection$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //EndBlock : ("end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean endBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "EndBlock", index);
      }
      if (endBlock$RuleMemoStart == index) {
         if (endBlock$RuleMemoStart <= endBlock$RuleMemoEnd) {
            index = endBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.END_BLOCK, endBlock$RuleMemoStart, endBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (endBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(endBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         endBlock$RuleMemoStart = startIndex;
         endBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.END_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endBlock$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         endBlock$RuleMemoStart = startIndex;
         endBlock$RuleMemoEnd = -1;
         endBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PackageBody : (EndBlock | PlSqlBody)
   protected boolean packageBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PackageBody", index);
      }
      startIndex = index;
      // (EndBlock | PlSqlBody)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'b':
         case 'B': {
            // PlSqlBody
            match = plSqlBody$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'e':
         case 'E': {
            // EndBlock
            match = endBlock$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PACKAGE_BODY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CreatePackageBody : (CreateOrReplace "package" TestNoAlpha OptionalSpacing "body" TestNoAlpha OptionalSpacing SchemaObjectName IsAsKeyword DeclareSection? PackageBody ';' OptionalSpacing)
   protected boolean createPackageBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CreatePackageBody", index);
      }
      if (createPackageBody$RuleMemoStart == index) {
         if (createPackageBody$RuleMemoStart <= createPackageBody$RuleMemoEnd) {
            index = createPackageBody$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PACKAGE_BODY, createPackageBody$RuleMemoStart, createPackageBody$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createPackageBody$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createPackageBody$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CreateOrReplace "package" TestNoAlpha OptionalSpacing "body" TestNoAlpha OptionalSpacing SchemaObjectName IsAsKeyword DeclareSection? PackageBody ';' OptionalSpacing)
      // CreateOrReplace
      match = createOrReplace$Rule();
      if (match) {
         // "package"
         match = ignoreCaseStringMatcher("package", 7);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // "body"
                  match = ignoreCaseStringMatcher("body", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // SchemaObjectName
                           match = schemaObjectName$Rule();
                           if (match) {
                              // IsAsKeyword
                              match = isAsKeyword$Rule();
                              if (match) {
                                 // DeclareSection?
                                 Node lastNode_1 = currentNode;
                                 int lastIndex_1 = index;
                                 // DeclareSection
                                 match = declareSection$Rule();
                                 if (! match) {
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                                 if (match) {
                                    // PackageBody
                                    match = packageBody$Rule();
                                    if (match) {
                                       // ';'
                                       match = charMatcher(';');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         createPackageBody$RuleMemoStart = startIndex;
         createPackageBody$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createPackageBody$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PACKAGE_BODY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createPackageBody$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         createPackageBody$RuleMemoStart = startIndex;
         createPackageBody$RuleMemoEnd = -1;
         createPackageBody$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AuthIdCurrentUser : ("authid" TestNoAlpha OptionalSpacing "current_user" TestNoAlpha OptionalSpacing)
   protected boolean authIdCurrentUser$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AuthIdCurrentUser", index);
      }
      if (authIdCurrentUser$RuleMemoStart == index) {
         if (authIdCurrentUser$RuleMemoStart <= authIdCurrentUser$RuleMemoEnd) {
            index = authIdCurrentUser$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AUTH_ID_CURRENT_USER, authIdCurrentUser$RuleMemoStart, authIdCurrentUser$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (authIdCurrentUser$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(authIdCurrentUser$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("authid" TestNoAlpha OptionalSpacing "current_user" TestNoAlpha OptionalSpacing)
      // "authid"
      match = ignoreCaseStringMatcher("authid", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "current_user"
               match = ignoreCaseStringMatcher("current_user", 12);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         authIdCurrentUser$RuleMemoStart = startIndex;
         authIdCurrentUser$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            authIdCurrentUser$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AUTH_ID_CURRENT_USER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            authIdCurrentUser$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         authIdCurrentUser$RuleMemoStart = startIndex;
         authIdCurrentUser$RuleMemoEnd = -1;
         authIdCurrentUser$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AuthIdDefiner : ("authid" TestNoAlpha OptionalSpacing "definer" TestNoAlpha OptionalSpacing)
   protected boolean authIdDefiner$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AuthIdDefiner", index);
      }
      if (authIdDefiner$RuleMemoStart == index) {
         if (authIdDefiner$RuleMemoStart <= authIdDefiner$RuleMemoEnd) {
            index = authIdDefiner$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.AUTH_ID_DEFINER, authIdDefiner$RuleMemoStart, authIdDefiner$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (authIdDefiner$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(authIdDefiner$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("authid" TestNoAlpha OptionalSpacing "definer" TestNoAlpha OptionalSpacing)
      // "authid"
      match = ignoreCaseStringMatcher("authid", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "definer"
               match = ignoreCaseStringMatcher("definer", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         authIdDefiner$RuleMemoStart = startIndex;
         authIdDefiner$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            authIdDefiner$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.AUTH_ID_DEFINER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            authIdDefiner$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         authIdDefiner$RuleMemoStart = startIndex;
         authIdDefiner$RuleMemoEnd = -1;
         authIdDefiner$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //InvokerRights : (AuthIdCurrentUser | AuthIdDefiner)
   protected boolean invokerRights$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "InvokerRights", index);
      }
      if (invokerRights$RuleMemoStart == index) {
         if (invokerRights$RuleMemoStart <= invokerRights$RuleMemoEnd) {
            index = invokerRights$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INVOKER_RIGHTS, invokerRights$RuleMemoStart, invokerRights$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (invokerRights$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(invokerRights$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (AuthIdCurrentUser | AuthIdDefiner)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'a':
         case 'A': {
            // AuthIdCurrentUser
            match = authIdCurrentUser$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // AuthIdDefiner
               match = authIdDefiner$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         invokerRights$RuleMemoStart = startIndex;
         invokerRights$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            invokerRights$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INVOKER_RIGHTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            invokerRights$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         invokerRights$RuleMemoStart = startIndex;
         invokerRights$RuleMemoEnd = -1;
         invokerRights$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CreatePackage : (CreateOrReplace "package" TestNoAlpha OptionalSpacing SchemaObjectName InvokerRights? IsAsKeyword ItemList1? "end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier? ';' OptionalSpacing)
   protected boolean createPackage$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CreatePackage", index);
      }
      if (createPackage$RuleMemoStart == index) {
         if (createPackage$RuleMemoStart <= createPackage$RuleMemoEnd) {
            index = createPackage$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PACKAGE, createPackage$RuleMemoStart, createPackage$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createPackage$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createPackage$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CreateOrReplace "package" TestNoAlpha OptionalSpacing SchemaObjectName InvokerRights? IsAsKeyword ItemList1? "end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier? ';' OptionalSpacing)
      // CreateOrReplace
      match = createOrReplace$Rule();
      if (match) {
         // "package"
         match = ignoreCaseStringMatcher("package", 7);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // SchemaObjectName
                  match = schemaObjectName$Rule();
                  if (match) {
                     // InvokerRights?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // InvokerRights
                     match = invokerRights$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // IsAsKeyword
                        match = isAsKeyword$Rule();
                        if (match) {
                           // ItemList1?
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // ItemList1
                           match = itemList1$Rule();
                           if (! match) {
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                              index = lastIndex_2;
                              match = true;
                           }
                           if (match) {
                              // "end"
                              match = ignoreCaseStringMatcher("end", 3);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // PlSqlAnyIdentifier?
                                       Node lastNode_3 = currentNode;
                                       int lastIndex_3 = index;
                                       // PlSqlAnyIdentifier
                                       match = plSqlAnyIdentifier$Rule();
                                       if (! match) {
                                          lastNode_3.setSibling(null);
                                          currentNode = lastNode_3;
                                          index = lastIndex_3;
                                          match = true;
                                       }
                                       if (match) {
                                          // ';'
                                          match = charMatcher(';');
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         createPackage$RuleMemoStart = startIndex;
         createPackage$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createPackage$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PACKAGE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createPackage$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         createPackage$RuleMemoStart = startIndex;
         createPackage$RuleMemoEnd = -1;
         createPackage$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExternalCParameter : (PlSqlIdentifier PlSqlIdentifier?)
   protected boolean externalCParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExternalCParameter", index);
      }
      if (externalCParameter$RuleMemoStart == index) {
         if (externalCParameter$RuleMemoStart <= externalCParameter$RuleMemoEnd) {
            index = externalCParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXTERNAL_CPARAMETER, externalCParameter$RuleMemoStart, externalCParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (externalCParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(externalCParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier PlSqlIdentifier?)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // PlSqlIdentifier?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // PlSqlIdentifier
         match = plSqlIdentifier$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         externalCParameter$RuleMemoStart = startIndex;
         externalCParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            externalCParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXTERNAL_CPARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            externalCParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         externalCParameter$RuleMemoStart = startIndex;
         externalCParameter$RuleMemoEnd = -1;
         externalCParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExternalCParametersDeclaration : ('(' OptionalSpacing ExternalCParameter (',' OptionalSpacing ExternalCParameter)* ')' OptionalSpacing)
   protected boolean externalCParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExternalCParametersDeclaration", index);
      }
      startIndex = index;
      // ('(' OptionalSpacing ExternalCParameter (',' OptionalSpacing ExternalCParameter)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ExternalCParameter
            match = externalCParameter$Rule();
            if (match) {
               // (',' OptionalSpacing ExternalCParameter)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing ExternalCParameter)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ExternalCParameter
                        match = externalCParameter$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EXTERNAL_CPARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CallJavaSpec : ("language" TestNoAlpha OptionalSpacing "java" TestNoAlpha OptionalSpacing "name" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean callJavaSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CallJavaSpec", index);
      }
      if (callJavaSpec$RuleMemoStart == index) {
         if (callJavaSpec$RuleMemoStart <= callJavaSpec$RuleMemoEnd) {
            index = callJavaSpec$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CALL_JAVA_SPEC, callJavaSpec$RuleMemoStart, callJavaSpec$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (callJavaSpec$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(callJavaSpec$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("language" TestNoAlpha OptionalSpacing "java" TestNoAlpha OptionalSpacing "name" TestNoAlpha OptionalSpacing StringLiteral)
      // "language"
      match = ignoreCaseStringMatcher("language", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "java"
               match = ignoreCaseStringMatcher("java", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "name"
                        match = ignoreCaseStringMatcher("name", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // StringLiteral
                                 match = stringLiteral$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         callJavaSpec$RuleMemoStart = startIndex;
         callJavaSpec$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            callJavaSpec$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CALL_JAVA_SPEC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            callJavaSpec$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         callJavaSpec$RuleMemoStart = startIndex;
         callJavaSpec$RuleMemoEnd = -1;
         callJavaSpec$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlIdentifierList : (PlSqlIdentifier (',' OptionalSpacing PlSqlIdentifier)*)
   protected boolean plSqlIdentifierList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlIdentifierList", index);
      }
      startIndex = index;
      // (PlSqlIdentifier (',' OptionalSpacing PlSqlIdentifier)*)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // (',' OptionalSpacing PlSqlIdentifier)*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (',' OptionalSpacing PlSqlIdentifier)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // PlSqlIdentifier
                  match = plSqlIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_IDENTIFIER_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CallCSpec : ("language" TestNoAlpha OptionalSpacing "c" TestNoAlpha OptionalSpacing ("name" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)? "library" TestNoAlpha OptionalSpacing PlSqlIdentifier ("agent" TestNoAlpha OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlIdentifierList ')' OptionalSpacing)? ("with" TestNoAlpha OptionalSpacing "context" TestNoAlpha OptionalSpacing)? ("parameters" TestNoAlpha OptionalSpacing ExternalCParametersDeclaration)?)
   protected boolean callCSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CallCSpec", index);
      }
      if (callCSpec$RuleMemoStart == index) {
         if (callCSpec$RuleMemoStart <= callCSpec$RuleMemoEnd) {
            index = callCSpec$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CALL_CSPEC, callCSpec$RuleMemoStart, callCSpec$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (callCSpec$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(callCSpec$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("language" TestNoAlpha OptionalSpacing "c" TestNoAlpha OptionalSpacing ("name" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)? "library" TestNoAlpha OptionalSpacing PlSqlIdentifier ("agent" TestNoAlpha OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlIdentifierList ')' OptionalSpacing)? ("with" TestNoAlpha OptionalSpacing "context" TestNoAlpha OptionalSpacing)? ("parameters" TestNoAlpha OptionalSpacing ExternalCParametersDeclaration)?)
      // "language"
      match = ignoreCaseStringMatcher("language", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "c"
               match = ignoreCaseCharMatcher('c');
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ("name" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ("name" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)
                        // "name"
                        match = ignoreCaseStringMatcher("name", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // PlSqlAnyIdentifier
                                 match = plSqlAnyIdentifier$Rule();
                              }
                           }
                        }
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                        if (match) {
                           // "library"
                           match = ignoreCaseStringMatcher("library", 7);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // PlSqlIdentifier
                                    match = plSqlIdentifier$Rule();
                                    if (match) {
                                       // ("agent" TestNoAlpha OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlIdentifierList ')' OptionalSpacing)?
                                       Node lastNode_2 = currentNode;
                                       int lastIndex_2 = index;
                                       // ("agent" TestNoAlpha OptionalSpacing "in" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlIdentifierList ')' OptionalSpacing)
                                       // "agent"
                                       match = ignoreCaseStringMatcher("agent", 5);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // "in"
                                                match = ignoreCaseStringMatcher("in", 2);
                                                if (match) {
                                                   // TestNoAlpha
                                                   match = testNoAlpha$Rule();
                                                   if (match) {
                                                      // OptionalSpacing
                                                      match = optionalSpacing$Rule();
                                                      if (match) {
                                                         // '('
                                                         match = charMatcher('(');
                                                         if (match) {
                                                            // OptionalSpacing
                                                            match = optionalSpacing$Rule();
                                                            if (match) {
                                                               // PlSqlIdentifierList
                                                               match = plSqlIdentifierList$Rule();
                                                               if (match) {
                                                                  // ')'
                                                                  match = charMatcher(')');
                                                                  if (match) {
                                                                     // OptionalSpacing
                                                                     match = optionalSpacing$Rule();
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                       if (! match) {
                                          lastNode_2.setSibling(null);
                                          currentNode = lastNode_2;
                                          index = lastIndex_2;
                                          match = true;
                                       }
                                       if (match) {
                                          // ("with" TestNoAlpha OptionalSpacing "context" TestNoAlpha OptionalSpacing)?
                                          Node lastNode_3 = currentNode;
                                          int lastIndex_3 = index;
                                          // ("with" TestNoAlpha OptionalSpacing "context" TestNoAlpha OptionalSpacing)
                                          // "with"
                                          match = ignoreCaseStringMatcher("with", 4);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // "context"
                                                   match = ignoreCaseStringMatcher("context", 7);
                                                   if (match) {
                                                      // TestNoAlpha
                                                      match = testNoAlpha$Rule();
                                                      if (match) {
                                                         // OptionalSpacing
                                                         match = optionalSpacing$Rule();
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                          if (! match) {
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                             index = lastIndex_3;
                                             match = true;
                                          }
                                          if (match) {
                                             // ("parameters" TestNoAlpha OptionalSpacing ExternalCParametersDeclaration)?
                                             Node lastNode_4 = currentNode;
                                             int lastIndex_4 = index;
                                             // ("parameters" TestNoAlpha OptionalSpacing ExternalCParametersDeclaration)
                                             // "parameters"
                                             match = ignoreCaseStringMatcher("parameters", 10);
                                             if (match) {
                                                // TestNoAlpha
                                                match = testNoAlpha$Rule();
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                   if (match) {
                                                      // ExternalCParametersDeclaration
                                                      match = externalCParametersDeclaration$Rule();
                                                   }
                                                }
                                             }
                                             if (! match) {
                                                lastNode_4.setSibling(null);
                                                currentNode = lastNode_4;
                                                index = lastIndex_4;
                                                match = true;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         callCSpec$RuleMemoStart = startIndex;
         callCSpec$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            callCSpec$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CALL_CSPEC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            callCSpec$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         callCSpec$RuleMemoStart = startIndex;
         callCSpec$RuleMemoEnd = -1;
         callCSpec$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CallSpec : (CallJavaSpec | CallCSpec)
   protected boolean callSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CallSpec", index);
      }
      if (callSpec$RuleMemoStart == index) {
         if (callSpec$RuleMemoStart <= callSpec$RuleMemoEnd) {
            index = callSpec$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CALL_SPEC, callSpec$RuleMemoStart, callSpec$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (callSpec$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(callSpec$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CallJavaSpec | CallCSpec)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'l':
         case 'L': {
            // CallJavaSpec
            match = callJavaSpec$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CallCSpec
               match = callCSpec$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         callSpec$RuleMemoStart = startIndex;
         callSpec$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            callSpec$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CALL_SPEC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            callSpec$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         callSpec$RuleMemoStart = startIndex;
         callSpec$RuleMemoEnd = -1;
         callSpec$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PragmaOrStatement : (Pragma | PlSqlStatement)
   protected boolean pragmaOrStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PragmaOrStatement", index);
      }
      if (pragmaOrStatement$RuleMemoStart == index) {
         if (pragmaOrStatement$RuleMemoStart <= pragmaOrStatement$RuleMemoEnd) {
            index = pragmaOrStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_OR_STATEMENT, pragmaOrStatement$RuleMemoStart, pragmaOrStatement$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (pragmaOrStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pragmaOrStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Pragma | PlSqlStatement)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '(':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case '<':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlStatement
            match = plSqlStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'P':
         case 'p': {
            // Pragma
            match = pragma$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlStatement
               match = plSqlStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         pragmaOrStatement$RuleMemoStart = startIndex;
         pragmaOrStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragmaOrStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_OR_STATEMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragmaOrStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pragmaOrStatement$RuleMemoStart = startIndex;
         pragmaOrStatement$RuleMemoEnd = -1;
         pragmaOrStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlBodyStatements : (PragmaOrStatement ';' OptionalSpacing (PragmaOrStatement ';' OptionalSpacing)*)
   protected boolean plSqlBodyStatements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlBodyStatements", index);
      }
      startIndex = index;
      // (PragmaOrStatement ';' OptionalSpacing (PragmaOrStatement ';' OptionalSpacing)*)
      // PragmaOrStatement
      match = pragmaOrStatement$Rule();
      if (match) {
         // ';'
         match = charMatcher(';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (PragmaOrStatement ';' OptionalSpacing)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (PragmaOrStatement ';' OptionalSpacing)
                  // PragmaOrStatement
                  match = pragmaOrStatement$Rule();
                  if (match) {
                     // ';'
                     match = charMatcher(';');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_BODY_STATEMENTS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlBody : ("begin" TestNoAlpha OptionalSpacing PlSqlBodyStatements? ExceptionBlock? "end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean plSqlBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlBody", index);
      }
      if (plSqlBody$RuleMemoStart == index) {
         if (plSqlBody$RuleMemoStart <= plSqlBody$RuleMemoEnd) {
            index = plSqlBody$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_BODY, plSqlBody$RuleMemoStart, plSqlBody$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlBody$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlBody$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("begin" TestNoAlpha OptionalSpacing PlSqlBodyStatements? ExceptionBlock? "end" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "begin"
      match = ignoreCaseStringMatcher("begin", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlBodyStatements?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlBodyStatements
               match = plSqlBodyStatements$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ExceptionBlock?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ExceptionBlock
                  match = exceptionBlock$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // "end"
                     match = ignoreCaseStringMatcher("end", 3);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // PlSqlAnyIdentifier?
                              Node lastNode_3 = currentNode;
                              int lastIndex_3 = index;
                              // PlSqlAnyIdentifier
                              match = plSqlAnyIdentifier$Rule();
                              if (! match) {
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                                 index = lastIndex_3;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         plSqlBody$RuleMemoStart = startIndex;
         plSqlBody$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlBody$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_BODY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlBody$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlBody$RuleMemoStart = startIndex;
         plSqlBody$RuleMemoEnd = -1;
         plSqlBody$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FunctionBody : (DeclareSection? PlSqlBlock)
   protected boolean functionBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FunctionBody", index);
      }
      if (functionBody$RuleMemoStart == index) {
         if (functionBody$RuleMemoStart <= functionBody$RuleMemoEnd) {
            index = functionBody$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_BODY, functionBody$RuleMemoStart, functionBody$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionBody$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionBody$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (DeclareSection? PlSqlBlock)
      // DeclareSection?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // DeclareSection
      match = declareSection$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // PlSqlBlock
         match = plSqlBlock$Rule();
      }
      if (match) {
         functionBody$RuleMemoStart = startIndex;
         functionBody$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionBody$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_BODY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionBody$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         functionBody$RuleMemoStart = startIndex;
         functionBody$RuleMemoEnd = -1;
         functionBody$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CallSpecOrFunctionBody : (CallSpec | FunctionBody)
   protected boolean callSpecOrFunctionBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CallSpecOrFunctionBody", index);
      }
      if (callSpecOrFunctionBody$RuleMemoStart == index) {
         if (callSpecOrFunctionBody$RuleMemoStart <= callSpecOrFunctionBody$RuleMemoEnd) {
            index = callSpecOrFunctionBody$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CALL_SPEC_OR_FUNCTION_BODY, callSpecOrFunctionBody$RuleMemoStart, callSpecOrFunctionBody$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (callSpecOrFunctionBody$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(callSpecOrFunctionBody$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CallSpec | FunctionBody)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'L':
         case 'l': {
            // CallSpec
            match = callSpec$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FunctionBody
               match = functionBody$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '<':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // FunctionBody
            match = functionBody$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         callSpecOrFunctionBody$RuleMemoStart = startIndex;
         callSpecOrFunctionBody$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            callSpecOrFunctionBody$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CALL_SPEC_OR_FUNCTION_BODY, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            callSpecOrFunctionBody$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         callSpecOrFunctionBody$RuleMemoStart = startIndex;
         callSpecOrFunctionBody$RuleMemoEnd = -1;
         callSpecOrFunctionBody$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CreateFunction : (CreateOrReplace FunctionDefinition ';' OptionalSpacing)
   protected boolean createFunction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CreateFunction", index);
      }
      if (createFunction$RuleMemoStart == index) {
         if (createFunction$RuleMemoStart <= createFunction$RuleMemoEnd) {
            index = createFunction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CREATE_FUNCTION, createFunction$RuleMemoStart, createFunction$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createFunction$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createFunction$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CreateOrReplace FunctionDefinition ';' OptionalSpacing)
      // CreateOrReplace
      match = createOrReplace$Rule();
      if (match) {
         // FunctionDefinition
         match = functionDefinition$Rule();
         if (match) {
            // ';'
            match = charMatcher(';');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         createFunction$RuleMemoStart = startIndex;
         createFunction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createFunction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CREATE_FUNCTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createFunction$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         createFunction$RuleMemoStart = startIndex;
         createFunction$RuleMemoEnd = -1;
         createFunction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FunctionDefinition : (FunctionHeading FunctionModifier IsAsKeyword CallSpecOrFunctionBody)
   protected boolean functionDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FunctionDefinition", index);
      }
      if (functionDefinition$RuleMemoStart == index) {
         if (functionDefinition$RuleMemoStart <= functionDefinition$RuleMemoEnd) {
            index = functionDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_DEFINITION, functionDefinition$RuleMemoStart, functionDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (FunctionHeading FunctionModifier IsAsKeyword CallSpecOrFunctionBody)
      // FunctionHeading
      match = functionHeading$Rule();
      if (match) {
         // FunctionModifier
         match = functionModifier$Rule();
         if (match) {
            // IsAsKeyword
            match = isAsKeyword$Rule();
            if (match) {
               // CallSpecOrFunctionBody
               match = callSpecOrFunctionBody$Rule();
            }
         }
      }
      if (match) {
         functionDefinition$RuleMemoStart = startIndex;
         functionDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         functionDefinition$RuleMemoStart = startIndex;
         functionDefinition$RuleMemoEnd = -1;
         functionDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CreateProcedure : (CreateOrReplace ProcedureDefinition ';' OptionalSpacing)
   protected boolean createProcedure$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CreateProcedure", index);
      }
      if (createProcedure$RuleMemoStart == index) {
         if (createProcedure$RuleMemoStart <= createProcedure$RuleMemoEnd) {
            index = createProcedure$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PROCEDURE, createProcedure$RuleMemoStart, createProcedure$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createProcedure$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createProcedure$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (CreateOrReplace ProcedureDefinition ';' OptionalSpacing)
      // CreateOrReplace
      match = createOrReplace$Rule();
      if (match) {
         // ProcedureDefinition
         match = procedureDefinition$Rule();
         if (match) {
            // ';'
            match = charMatcher(';');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         createProcedure$RuleMemoStart = startIndex;
         createProcedure$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createProcedure$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CREATE_PROCEDURE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createProcedure$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         createProcedure$RuleMemoStart = startIndex;
         createProcedure$RuleMemoEnd = -1;
         createProcedure$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ProcedureDefinition : (ProcedureHeading FunctionModifier IsAsKeyword CallSpecOrFunctionBody)
   protected boolean procedureDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ProcedureDefinition", index);
      }
      if (procedureDefinition$RuleMemoStart == index) {
         if (procedureDefinition$RuleMemoStart <= procedureDefinition$RuleMemoEnd) {
            index = procedureDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_DEFINITION, procedureDefinition$RuleMemoStart, procedureDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (procedureDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(procedureDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ProcedureHeading FunctionModifier IsAsKeyword CallSpecOrFunctionBody)
      // ProcedureHeading
      match = procedureHeading$Rule();
      if (match) {
         // FunctionModifier
         match = functionModifier$Rule();
         if (match) {
            // IsAsKeyword
            match = isAsKeyword$Rule();
            if (match) {
               // CallSpecOrFunctionBody
               match = callSpecOrFunctionBody$Rule();
            }
         }
      }
      if (match) {
         procedureDefinition$RuleMemoStart = startIndex;
         procedureDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            procedureDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            procedureDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         procedureDefinition$RuleMemoStart = startIndex;
         procedureDefinition$RuleMemoEnd = -1;
         procedureDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CreateOrReplace : ("create" TestNoAlpha OptionalSpacing ("or" TestNoAlpha OptionalSpacing "replace" TestNoAlpha OptionalSpacing)?)
   protected boolean createOrReplace$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CreateOrReplace", index);
      }
      if (createOrReplace$RuleMemoStart == index) {
         if (createOrReplace$RuleMemoStart <= createOrReplace$RuleMemoEnd) {
            index = createOrReplace$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CREATE_OR_REPLACE, createOrReplace$RuleMemoStart, createOrReplace$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (createOrReplace$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(createOrReplace$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("create" TestNoAlpha OptionalSpacing ("or" TestNoAlpha OptionalSpacing "replace" TestNoAlpha OptionalSpacing)?)
      // "create"
      match = ignoreCaseStringMatcher("create", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("or" TestNoAlpha OptionalSpacing "replace" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("or" TestNoAlpha OptionalSpacing "replace" TestNoAlpha OptionalSpacing)
               // "or"
               match = ignoreCaseStringMatcher("or", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "replace"
                        match = ignoreCaseStringMatcher("replace", 7);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         createOrReplace$RuleMemoStart = startIndex;
         createOrReplace$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createOrReplace$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CREATE_OR_REPLACE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createOrReplace$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         createOrReplace$RuleMemoStart = startIndex;
         createOrReplace$RuleMemoEnd = -1;
         createOrReplace$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList1First : (TypeDefinition | FunctionDeclaration | ProcedureDeclaration | ItemDeclaration)
   protected boolean itemList1First$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList1First", index);
      }
      startIndex = index;
      // (TypeDefinition | FunctionDeclaration | ProcedureDeclaration | ItemDeclaration)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'Q':
         case 'R':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'q':
         case 'r':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // ItemDeclaration
            match = itemDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'P':
         case 'p': {
            // ProcedureDeclaration
            match = procedureDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ItemDeclaration
               match = itemDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'S':
         case 's':
         case 'T':
         case 't': {
            // TypeDefinition
            match = typeDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ItemDeclaration
               match = itemDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'F':
         case 'f': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ItemDeclaration
               match = itemDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST1_FIRST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList1Second : (TypeDefinition | ProcedureDeclaration | FunctionDeclaration | Pragma | ItemDeclaration)
   protected boolean itemList1Second$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList1Second", index);
      }
      startIndex = index;
      // (TypeDefinition | ProcedureDeclaration | FunctionDeclaration | Pragma | ItemDeclaration)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'Q':
         case 'R':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'q':
         case 'r':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // ItemDeclaration
            match = itemDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'P':
         case 'p': {
            // ProcedureDeclaration
            match = procedureDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Pragma
               match = pragma$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ItemDeclaration
                  match = itemDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'S':
         case 's':
         case 'T':
         case 't': {
            // TypeDefinition
            match = typeDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ItemDeclaration
               match = itemDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'F':
         case 'f': {
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ItemDeclaration
               match = itemDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST1_SECOND, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList1 : (ItemList1First ';' OptionalSpacing (ItemList1Second ';' OptionalSpacing)*)
   protected boolean itemList1$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList1", index);
      }
      if (itemList1$RuleMemoStart == index) {
         if (itemList1$RuleMemoStart <= itemList1$RuleMemoEnd) {
            index = itemList1$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST1, itemList1$RuleMemoStart, itemList1$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (itemList1$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(itemList1$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ItemList1First ';' OptionalSpacing (ItemList1Second ';' OptionalSpacing)*)
      // ItemList1First
      match = itemList1First$Rule();
      if (match) {
         // ';'
         match = charMatcher(';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (ItemList1Second ';' OptionalSpacing)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (ItemList1Second ';' OptionalSpacing)
                  // ItemList1Second
                  match = itemList1Second$Rule();
                  if (match) {
                     // ';'
                     match = charMatcher(';');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
         }
      }
      if (match) {
         itemList1$RuleMemoStart = startIndex;
         itemList1$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            itemList1$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST1, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            itemList1$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         itemList1$RuleMemoStart = startIndex;
         itemList1$RuleMemoEnd = -1;
         itemList1$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList2First : (FunctionDefinition | FunctionDeclaration | ProcedureDefinition | ProcedureDeclaration)
   protected boolean itemList2First$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList2First", index);
      }
      startIndex = index;
      // (FunctionDefinition | FunctionDeclaration | ProcedureDefinition | ProcedureDeclaration)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'p':
         case 'P': {
            // ProcedureDefinition
            match = procedureDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'f':
         case 'F': {
            // FunctionDefinition
            match = functionDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FunctionDeclaration
               match = functionDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST2_FIRST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList2Second : (FunctionDefinition | FunctionDeclaration | ProcedureDefinition | ProcedureDeclaration | Pragma)
   protected boolean itemList2Second$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList2Second", index);
      }
      startIndex = index;
      // (FunctionDefinition | FunctionDeclaration | ProcedureDefinition | ProcedureDeclaration | Pragma)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'p':
         case 'P': {
            // ProcedureDefinition
            match = procedureDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Pragma
                  match = pragma$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'f':
         case 'F': {
            // FunctionDefinition
            match = functionDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // FunctionDeclaration
               match = functionDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST2_SECOND, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemList2 : (ItemList2First ';' OptionalSpacing (ItemList2Second ';' OptionalSpacing)*)
   protected boolean itemList2$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemList2", index);
      }
      if (itemList2$RuleMemoStart == index) {
         if (itemList2$RuleMemoStart <= itemList2$RuleMemoEnd) {
            index = itemList2$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST2, itemList2$RuleMemoStart, itemList2$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (itemList2$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(itemList2$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ItemList2First ';' OptionalSpacing (ItemList2Second ';' OptionalSpacing)*)
      // ItemList2First
      match = itemList2First$Rule();
      if (match) {
         // ';'
         match = charMatcher(';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (ItemList2Second ';' OptionalSpacing)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (ItemList2Second ';' OptionalSpacing)
                  // ItemList2Second
                  match = itemList2Second$Rule();
                  if (match) {
                     // ';'
                     match = charMatcher(';');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
         }
      }
      if (match) {
         itemList2$RuleMemoStart = startIndex;
         itemList2$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            itemList2$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_LIST2, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            itemList2$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         itemList2$RuleMemoStart = startIndex;
         itemList2$RuleMemoEnd = -1;
         itemList2$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DeclareSection : ((ItemList1 ItemList2?) | ItemList2)
   protected boolean declareSection$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DeclareSection", index);
      }
      if (declareSection$RuleMemoStart == index) {
         if (declareSection$RuleMemoStart <= declareSection$RuleMemoEnd) {
            index = declareSection$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DECLARE_SECTION, declareSection$RuleMemoStart, declareSection$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (declareSection$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(declareSection$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((ItemList1 ItemList2?) | ItemList2)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (ItemList1 ItemList2?)
      // ItemList1
      match = itemList1$Rule();
      if (match) {
         // ItemList2?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ItemList2
         match = itemList2$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ItemList2
         match = itemList2$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         declareSection$RuleMemoStart = startIndex;
         declareSection$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            declareSection$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DECLARE_SECTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            declareSection$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         declareSection$RuleMemoStart = startIndex;
         declareSection$RuleMemoEnd = -1;
         declareSection$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TypeDefinition : (RecordTypeDefinition | RefCursorTypeDefinition | SubtypeDefinition | CollectionTypeDefinition)
   protected boolean typeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TypeDefinition", index);
      }
      if (typeDefinition$RuleMemoStart == index) {
         if (typeDefinition$RuleMemoStart <= typeDefinition$RuleMemoEnd) {
            index = typeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TYPE_DEFINITION, typeDefinition$RuleMemoStart, typeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (typeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(typeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (RecordTypeDefinition | RefCursorTypeDefinition | SubtypeDefinition | CollectionTypeDefinition)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 's':
         case 'S': {
            // SubtypeDefinition
            match = subtypeDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 't':
         case 'T': {
            // RecordTypeDefinition
            match = recordTypeDefinition$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // RefCursorTypeDefinition
               match = refCursorTypeDefinition$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // CollectionTypeDefinition
                  match = collectionTypeDefinition$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         typeDefinition$RuleMemoStart = startIndex;
         typeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            typeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            typeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         typeDefinition$RuleMemoStart = startIndex;
         typeDefinition$RuleMemoEnd = -1;
         typeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Null : ("null" TestNoAlpha OptionalSpacing)
   protected boolean null$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Null", index);
      }
      if (null$RuleMemoStart == index) {
         if (null$RuleMemoStart <= null$RuleMemoEnd) {
            index = null$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NULL, null$RuleMemoStart, null$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (null$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(null$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("null" TestNoAlpha OptionalSpacing)
      // "null"
      match = ignoreCaseStringMatcher("null", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         null$RuleMemoStart = startIndex;
         null$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            null$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NULL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            null$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         null$RuleMemoStart = startIndex;
         null$RuleMemoEnd = -1;
         null$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NotNull : ("not" TestNoAlpha OptionalSpacing "null" TestNoAlpha OptionalSpacing)
   protected boolean notNull$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NotNull", index);
      }
      if (notNull$RuleMemoStart == index) {
         if (notNull$RuleMemoStart <= notNull$RuleMemoEnd) {
            index = notNull$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NOT_NULL, notNull$RuleMemoStart, notNull$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (notNull$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(notNull$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("not" TestNoAlpha OptionalSpacing "null" TestNoAlpha OptionalSpacing)
      // "not"
      match = ignoreCaseStringMatcher("not", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "null"
               match = ignoreCaseStringMatcher("null", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         notNull$RuleMemoStart = startIndex;
         notNull$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            notNull$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NOT_NULL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            notNull$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         notNull$RuleMemoStart = startIndex;
         notNull$RuleMemoEnd = -1;
         notNull$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Nullable : (Null | NotNull)
   protected boolean nullable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Nullable", index);
      }
      if (nullable$RuleMemoStart == index) {
         if (nullable$RuleMemoStart <= nullable$RuleMemoEnd) {
            index = nullable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NULLABLE, nullable$RuleMemoStart, nullable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nullable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nullable$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Null | NotNull)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'n':
         case 'N': {
            // Null
            match = null$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // NotNull
               match = notNull$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         nullable$RuleMemoStart = startIndex;
         nullable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nullable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NULLABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nullable$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nullable$RuleMemoStart = startIndex;
         nullable$RuleMemoEnd = -1;
         nullable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SubtypeDefinition : ("subtype" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing TypeSpec PlSqlExpressionList? Nullable?)
   protected boolean subtypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SubtypeDefinition", index);
      }
      if (subtypeDefinition$RuleMemoStart == index) {
         if (subtypeDefinition$RuleMemoStart <= subtypeDefinition$RuleMemoEnd) {
            index = subtypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SUBTYPE_DEFINITION, subtypeDefinition$RuleMemoStart, subtypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (subtypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(subtypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("subtype" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing TypeSpec PlSqlExpressionList? Nullable?)
      // "subtype"
      match = ignoreCaseStringMatcher("subtype", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "is"
                  match = ignoreCaseStringMatcher("is", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // TypeSpec
                           match = typeSpec$Rule();
                           if (match) {
                              // PlSqlExpressionList?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // PlSqlExpressionList
                              match = plSqlExpressionList$Rule();
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                              if (match) {
                                 // Nullable?
                                 Node lastNode_2 = currentNode;
                                 int lastIndex_2 = index;
                                 // Nullable
                                 match = nullable$Rule();
                                 if (! match) {
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                    index = lastIndex_2;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         subtypeDefinition$RuleMemoStart = startIndex;
         subtypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            subtypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SUBTYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            subtypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         subtypeDefinition$RuleMemoStart = startIndex;
         subtypeDefinition$RuleMemoEnd = -1;
         subtypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RecordTypeDefinition : ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing "record" TestNoAlpha OptionalSpacing '(' OptionalSpacing RecordFieldDeclaration (',' OptionalSpacing RecordFieldDeclaration)* ')' OptionalSpacing)
   protected boolean recordTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RecordTypeDefinition", index);
      }
      if (recordTypeDefinition$RuleMemoStart == index) {
         if (recordTypeDefinition$RuleMemoStart <= recordTypeDefinition$RuleMemoEnd) {
            index = recordTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RECORD_TYPE_DEFINITION, recordTypeDefinition$RuleMemoStart, recordTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (recordTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(recordTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing "record" TestNoAlpha OptionalSpacing '(' OptionalSpacing RecordFieldDeclaration (',' OptionalSpacing RecordFieldDeclaration)* ')' OptionalSpacing)
      // "type"
      match = ignoreCaseStringMatcher("type", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "is"
                  match = ignoreCaseStringMatcher("is", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "record"
                           match = ignoreCaseStringMatcher("record", 6);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // '('
                                    match = charMatcher('(');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // RecordFieldDeclaration
                                          match = recordFieldDeclaration$Rule();
                                          if (match) {
                                             // (',' OptionalSpacing RecordFieldDeclaration)*
                                             Node lastNode_1;
                                             int lastIndex_1;
                                             do {
                                                lastNode_1 = currentNode;
                                                lastIndex_1 = index;
                                                // (',' OptionalSpacing RecordFieldDeclaration)
                                                // ','
                                                match = charMatcher(',');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                   if (match) {
                                                      // RecordFieldDeclaration
                                                      match = recordFieldDeclaration$Rule();
                                                   }
                                                }
                                             } while(match);
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                             index = lastIndex_1;
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         recordTypeDefinition$RuleMemoStart = startIndex;
         recordTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recordTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RECORD_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recordTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         recordTypeDefinition$RuleMemoStart = startIndex;
         recordTypeDefinition$RuleMemoEnd = -1;
         recordTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DefaultOperator : ((":=" OptionalSpacing) | ("default" TestNoAlpha OptionalSpacing))
   protected boolean defaultOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DefaultOperator", index);
      }
      startIndex = index;
      // ((":=" OptionalSpacing) | ("default" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (":=" OptionalSpacing)
      // ":="
      match = ignoreCaseStringMatcher(":=", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("default" TestNoAlpha OptionalSpacing)
         // "default"
         match = ignoreCaseStringMatcher("default", 7);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.DEFAULT_OPERATOR, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DefaultValue : (DefaultOperator PlSqlExpression)
   protected boolean defaultValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DefaultValue", index);
      }
      if (defaultValue$RuleMemoStart == index) {
         if (defaultValue$RuleMemoStart <= defaultValue$RuleMemoEnd) {
            index = defaultValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DEFAULT_VALUE, defaultValue$RuleMemoStart, defaultValue$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (defaultValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(defaultValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (DefaultOperator PlSqlExpression)
      // DefaultOperator
      match = defaultOperator$Rule();
      if (match) {
         // PlSqlExpression
         match = plSqlExpression$Rule();
      }
      if (match) {
         defaultValue$RuleMemoStart = startIndex;
         defaultValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            defaultValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DEFAULT_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            defaultValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         defaultValue$RuleMemoStart = startIndex;
         defaultValue$RuleMemoEnd = -1;
         defaultValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RecordFieldDeclaration : (PlSqlIdentifier TypeSpec Nullable? DefaultValue?)
   protected boolean recordFieldDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RecordFieldDeclaration", index);
      }
      if (recordFieldDeclaration$RuleMemoStart == index) {
         if (recordFieldDeclaration$RuleMemoStart <= recordFieldDeclaration$RuleMemoEnd) {
            index = recordFieldDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RECORD_FIELD_DECLARATION, recordFieldDeclaration$RuleMemoStart, recordFieldDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (recordFieldDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(recordFieldDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier TypeSpec Nullable? DefaultValue?)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // TypeSpec
         match = typeSpec$Rule();
         if (match) {
            // Nullable?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // Nullable
            match = nullable$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // DefaultValue?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // DefaultValue
               match = defaultValue$Rule();
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
            }
         }
      }
      if (match) {
         recordFieldDeclaration$RuleMemoStart = startIndex;
         recordFieldDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recordFieldDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RECORD_FIELD_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recordFieldDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         recordFieldDeclaration$RuleMemoStart = startIndex;
         recordFieldDeclaration$RuleMemoEnd = -1;
         recordFieldDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CollectionTypeDefinition : ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing (VarrayTypeDefinition | NestedTableTypeDefinition | AssociativeArrayTypeDefinition))
   protected boolean collectionTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CollectionTypeDefinition", index);
      }
      if (collectionTypeDefinition$RuleMemoStart == index) {
         if (collectionTypeDefinition$RuleMemoStart <= collectionTypeDefinition$RuleMemoEnd) {
            index = collectionTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.COLLECTION_TYPE_DEFINITION, collectionTypeDefinition$RuleMemoStart, collectionTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (collectionTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(collectionTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing (VarrayTypeDefinition | NestedTableTypeDefinition | AssociativeArrayTypeDefinition))
      // "type"
      match = ignoreCaseStringMatcher("type", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "is"
                  match = ignoreCaseStringMatcher("is", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // (VarrayTypeDefinition | NestedTableTypeDefinition | AssociativeArrayTypeDefinition)
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           switch(buffer.getChar(index)) {
                              case 't':
                              case 'T': {
                                 // NestedTableTypeDefinition
                                 match = nestedTableTypeDefinition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // AssociativeArrayTypeDefinition
                                    match = associativeArrayTypeDefinition$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 }
                                 break;
                              }
                              case 'v':
                              case 'V': {
                                 // VarrayTypeDefinition
                                 match = varrayTypeDefinition$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                                 break;
                              }
                              default: {
                                 match = false;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         collectionTypeDefinition$RuleMemoStart = startIndex;
         collectionTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            collectionTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.COLLECTION_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            collectionTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         collectionTypeDefinition$RuleMemoStart = startIndex;
         collectionTypeDefinition$RuleMemoEnd = -1;
         collectionTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IndexBy : ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing (("pls_integer" TestNoAlpha OptionalSpacing) | ("binary_integer" TestNoAlpha OptionalSpacing) | ("varchar2" OptionalSpacing NumericExpression)))
   protected boolean indexBy$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IndexBy", index);
      }
      startIndex = index;
      // ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing (("pls_integer" TestNoAlpha OptionalSpacing) | ("binary_integer" TestNoAlpha OptionalSpacing) | ("varchar2" OptionalSpacing NumericExpression)))
      // "index"
      match = ignoreCaseStringMatcher("index", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "by"
               match = ignoreCaseStringMatcher("by", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // (("pls_integer" TestNoAlpha OptionalSpacing) | ("binary_integer" TestNoAlpha OptionalSpacing) | ("varchar2" OptionalSpacing NumericExpression))
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // ("pls_integer" TestNoAlpha OptionalSpacing)
                        // "pls_integer"
                        match = ignoreCaseStringMatcher("pls_integer", 11);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("binary_integer" TestNoAlpha OptionalSpacing)
                           // "binary_integer"
                           match = ignoreCaseStringMatcher("binary_integer", 14);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ("varchar2" OptionalSpacing NumericExpression)
                              // "varchar2"
                              match = ignoreCaseStringMatcher("varchar2", 8);
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // NumericExpression
                                    match = numericExpression$Rule();
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.INDEX_BY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AssociativeArrayTypeDefinition : ("table" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable? IndexBy?)
   protected boolean associativeArrayTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AssociativeArrayTypeDefinition", index);
      }
      if (associativeArrayTypeDefinition$RuleMemoStart == index) {
         if (associativeArrayTypeDefinition$RuleMemoStart <= associativeArrayTypeDefinition$RuleMemoEnd) {
            index = associativeArrayTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ASSOCIATIVE_ARRAY_TYPE_DEFINITION, associativeArrayTypeDefinition$RuleMemoStart, associativeArrayTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (associativeArrayTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(associativeArrayTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("table" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable? IndexBy?)
      // "table"
      match = ignoreCaseStringMatcher("table", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "of"
               match = ignoreCaseStringMatcher("of", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // TypeSpec
                        match = typeSpec$Rule();
                        if (match) {
                           // Nullable?
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           // Nullable
                           match = nullable$Rule();
                           if (! match) {
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              index = lastIndex_1;
                              match = true;
                           }
                           if (match) {
                              // IndexBy?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // IndexBy
                              match = indexBy$Rule();
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         associativeArrayTypeDefinition$RuleMemoStart = startIndex;
         associativeArrayTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            associativeArrayTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ASSOCIATIVE_ARRAY_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            associativeArrayTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         associativeArrayTypeDefinition$RuleMemoStart = startIndex;
         associativeArrayTypeDefinition$RuleMemoEnd = -1;
         associativeArrayTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VarrayTypeDefinition : ((("varying" TestNoAlpha OptionalSpacing ("array" TestNoAlpha OptionalSpacing)?) | ("varray" TestNoAlpha OptionalSpacing)) '(' OptionalSpacing IntegerLiteral ')' OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable?)
   protected boolean varrayTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VarrayTypeDefinition", index);
      }
      if (varrayTypeDefinition$RuleMemoStart == index) {
         if (varrayTypeDefinition$RuleMemoStart <= varrayTypeDefinition$RuleMemoEnd) {
            index = varrayTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VARRAY_TYPE_DEFINITION, varrayTypeDefinition$RuleMemoStart, varrayTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (varrayTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(varrayTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("varying" TestNoAlpha OptionalSpacing ("array" TestNoAlpha OptionalSpacing)?) | ("varray" TestNoAlpha OptionalSpacing)) '(' OptionalSpacing IntegerLiteral ')' OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable?)
      // (("varying" TestNoAlpha OptionalSpacing ("array" TestNoAlpha OptionalSpacing)?) | ("varray" TestNoAlpha OptionalSpacing))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("varying" TestNoAlpha OptionalSpacing ("array" TestNoAlpha OptionalSpacing)?)
      // "varying"
      match = ignoreCaseStringMatcher("varying", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("array" TestNoAlpha OptionalSpacing)?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ("array" TestNoAlpha OptionalSpacing)
               // "array"
               match = ignoreCaseStringMatcher("array", 5);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
            }
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("varray" TestNoAlpha OptionalSpacing)
         // "varray"
         match = ignoreCaseStringMatcher("varray", 6);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IntegerLiteral
               match = integerLiteral$Rule();
               if (match) {
                  // ')'
                  match = charMatcher(')');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "of"
                        match = ignoreCaseStringMatcher("of", 2);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // TypeSpec
                                 match = typeSpec$Rule();
                                 if (match) {
                                    // Nullable?
                                    Node lastNode_3 = currentNode;
                                    int lastIndex_3 = index;
                                    // Nullable
                                    match = nullable$Rule();
                                    if (! match) {
                                       lastNode_3.setSibling(null);
                                       currentNode = lastNode_3;
                                       index = lastIndex_3;
                                       match = true;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         varrayTypeDefinition$RuleMemoStart = startIndex;
         varrayTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            varrayTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VARRAY_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            varrayTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         varrayTypeDefinition$RuleMemoStart = startIndex;
         varrayTypeDefinition$RuleMemoEnd = -1;
         varrayTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NestedTableTypeDefinition : ("table" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable? ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing TypeSpec)?)
   protected boolean nestedTableTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NestedTableTypeDefinition", index);
      }
      if (nestedTableTypeDefinition$RuleMemoStart == index) {
         if (nestedTableTypeDefinition$RuleMemoStart <= nestedTableTypeDefinition$RuleMemoEnd) {
            index = nestedTableTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NESTED_TABLE_TYPE_DEFINITION, nestedTableTypeDefinition$RuleMemoStart, nestedTableTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nestedTableTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nestedTableTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("table" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing TypeSpec Nullable? ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing TypeSpec)?)
      // "table"
      match = ignoreCaseStringMatcher("table", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "of"
               match = ignoreCaseStringMatcher("of", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // TypeSpec
                        match = typeSpec$Rule();
                        if (match) {
                           // Nullable?
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           // Nullable
                           match = nullable$Rule();
                           if (! match) {
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              index = lastIndex_1;
                              match = true;
                           }
                           if (match) {
                              // ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing TypeSpec)?
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // ("index" TestNoAlpha OptionalSpacing "by" TestNoAlpha OptionalSpacing TypeSpec)
                              // "index"
                              match = ignoreCaseStringMatcher("index", 5);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "by"
                                       match = ignoreCaseStringMatcher("by", 2);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // TypeSpec
                                                match = typeSpec$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                              if (! match) {
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 match = true;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         nestedTableTypeDefinition$RuleMemoStart = startIndex;
         nestedTableTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nestedTableTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NESTED_TABLE_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nestedTableTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nestedTableTypeDefinition$RuleMemoStart = startIndex;
         nestedTableTypeDefinition$RuleMemoEnd = -1;
         nestedTableTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RefCursorTypeDefinition : ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing "ref" TestNoAlpha OptionalSpacing "cursor" TestNoAlpha OptionalSpacing ReturnType?)
   protected boolean refCursorTypeDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RefCursorTypeDefinition", index);
      }
      if (refCursorTypeDefinition$RuleMemoStart == index) {
         if (refCursorTypeDefinition$RuleMemoStart <= refCursorTypeDefinition$RuleMemoEnd) {
            index = refCursorTypeDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.REF_CURSOR_TYPE_DEFINITION, refCursorTypeDefinition$RuleMemoStart, refCursorTypeDefinition$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (refCursorTypeDefinition$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(refCursorTypeDefinition$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("type" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "is" TestNoAlpha OptionalSpacing "ref" TestNoAlpha OptionalSpacing "cursor" TestNoAlpha OptionalSpacing ReturnType?)
      // "type"
      match = ignoreCaseStringMatcher("type", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "is"
                  match = ignoreCaseStringMatcher("is", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "ref"
                           match = ignoreCaseStringMatcher("ref", 3);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // "cursor"
                                    match = ignoreCaseStringMatcher("cursor", 6);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // ReturnType?
                                             Node lastNode_1 = currentNode;
                                             int lastIndex_1 = index;
                                             // ReturnType
                                             match = returnType$Rule();
                                             if (! match) {
                                                lastNode_1.setSibling(null);
                                                currentNode = lastNode_1;
                                                index = lastIndex_1;
                                                match = true;
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         refCursorTypeDefinition$RuleMemoStart = startIndex;
         refCursorTypeDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            refCursorTypeDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.REF_CURSOR_TYPE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            refCursorTypeDefinition$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         refCursorTypeDefinition$RuleMemoStart = startIndex;
         refCursorTypeDefinition$RuleMemoEnd = -1;
         refCursorTypeDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Numeric : ((("number" | "numeric" | "decimal" | "dec") TestNoAlpha OptionalSpacing) NumberSize)
   protected boolean numeric$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Numeric", index);
      }
      if (numeric$RuleMemoStart == index) {
         if (numeric$RuleMemoStart <= numeric$RuleMemoEnd) {
            index = numeric$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NUMERIC, numeric$RuleMemoStart, numeric$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (numeric$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(numeric$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("number" | "numeric" | "decimal" | "dec") TestNoAlpha OptionalSpacing) NumberSize)
      // (("number" | "numeric" | "decimal" | "dec") TestNoAlpha OptionalSpacing)
      // ("number" | "numeric" | "decimal" | "dec")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'n':
         case 'N': {
            ++index;
            // ("umeric" | "umber")
            match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
            if (match) {
               ++index;
               // ("meric" | "mber")
               match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
               if (match) {
                  ++index;
                  // ("eric" | "ber")
                  switch(buffer.getChar(index)) {
                     case 'b':
                     case 'B': {
                        ++index;
                        // "er"
                        if (match = ignoreCaseStringTest("er", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'e':
                     case 'E': {
                        ++index;
                        // "ric"
                        if (match = ignoreCaseStringTest("ric", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // ("ecimal" | "ec")
            match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
            if (match) {
               ++index;
               // ("cimal" | "c")
               match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
               if (match) {
                  ++index;
                  // ("imal" | <EMPTY>)
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // "mal"
                     if (match = ignoreCaseStringTest("mal", 3)) {
                        index += 3;
                     }
                  } else {
                     match = true;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // NumberSize
         match = numberSize$Rule();
      }
      if (match) {
         numeric$RuleMemoStart = startIndex;
         numeric$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numeric$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NUMERIC, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numeric$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         numeric$RuleMemoStart = startIndex;
         numeric$RuleMemoEnd = -1;
         numeric$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SmallIntPrecision : ("smallint" TestNoAlpha OptionalSpacing "precision" TestNoAlpha OptionalSpacing)
   protected boolean smallIntPrecision$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SmallIntPrecision", index);
      }
      if (smallIntPrecision$RuleMemoStart == index) {
         if (smallIntPrecision$RuleMemoStart <= smallIntPrecision$RuleMemoEnd) {
            index = smallIntPrecision$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SMALL_INT_PRECISION, smallIntPrecision$RuleMemoStart, smallIntPrecision$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (smallIntPrecision$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(smallIntPrecision$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("smallint" TestNoAlpha OptionalSpacing "precision" TestNoAlpha OptionalSpacing)
      // "smallint"
      match = ignoreCaseStringMatcher("smallint", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "precision"
               match = ignoreCaseStringMatcher("precision", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         smallIntPrecision$RuleMemoStart = startIndex;
         smallIntPrecision$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            smallIntPrecision$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SMALL_INT_PRECISION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            smallIntPrecision$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         smallIntPrecision$RuleMemoStart = startIndex;
         smallIntPrecision$RuleMemoEnd = -1;
         smallIntPrecision$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Character : ("character" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? Size?)
   protected boolean character$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Character", index);
      }
      if (character$RuleMemoStart == index) {
         if (character$RuleMemoStart <= character$RuleMemoEnd) {
            index = character$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CHARACTER, character$RuleMemoStart, character$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (character$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(character$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("character" TestNoAlpha OptionalSpacing ("varying" TestNoAlpha OptionalSpacing)? Size?)
      // "character"
      match = ignoreCaseStringMatcher("character", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("varying" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("varying" TestNoAlpha OptionalSpacing)
               // "varying"
               match = ignoreCaseStringMatcher("varying", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // Size?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Size
                  match = size$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         character$RuleMemoStart = startIndex;
         character$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            character$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CHARACTER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            character$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         character$RuleMemoStart = startIndex;
         character$RuleMemoEnd = -1;
         character$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NVarChar : ("nvarchar" TestNoAlpha OptionalSpacing Size?)
   protected boolean nVarChar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NVarChar", index);
      }
      if (nVarChar$RuleMemoStart == index) {
         if (nVarChar$RuleMemoStart <= nVarChar$RuleMemoEnd) {
            index = nVarChar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NVAR_CHAR, nVarChar$RuleMemoStart, nVarChar$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nVarChar$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nVarChar$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("nvarchar" TestNoAlpha OptionalSpacing Size?)
      // "nvarchar"
      match = ignoreCaseStringMatcher("nvarchar", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         nVarChar$RuleMemoStart = startIndex;
         nVarChar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nVarChar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NVAR_CHAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nVarChar$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nVarChar$RuleMemoStart = startIndex;
         nVarChar$RuleMemoEnd = -1;
         nVarChar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NationalCharacter : ("national" TestNoAlpha OptionalSpacing (("character" | "char") TestNoAlpha OptionalSpacing) ("varying" TestNoAlpha OptionalSpacing)? Size?)
   protected boolean nationalCharacter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NationalCharacter", index);
      }
      if (nationalCharacter$RuleMemoStart == index) {
         if (nationalCharacter$RuleMemoStart <= nationalCharacter$RuleMemoEnd) {
            index = nationalCharacter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NATIONAL_CHARACTER, nationalCharacter$RuleMemoStart, nationalCharacter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nationalCharacter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nationalCharacter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("national" TestNoAlpha OptionalSpacing (("character" | "char") TestNoAlpha OptionalSpacing) ("varying" TestNoAlpha OptionalSpacing)? Size?)
      // "national"
      match = ignoreCaseStringMatcher("national", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("character" | "char") TestNoAlpha OptionalSpacing)
               // ("character" | "char")
               int startIndex_1 = index;
               match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
               if (match) {
                  ++index;
                  // ("haracter" | "har")
                  match = buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H');
                  if (match) {
                     ++index;
                     // ("aracter" | "ar")
                     match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                     if (match) {
                        ++index;
                        // ("racter" | "r")
                        match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                        if (match) {
                           ++index;
                           // ("acter" | <EMPTY>)
                           match = buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A');
                           if (match) {
                              ++index;
                              // "cter"
                              if (match = ignoreCaseStringTest("cter", 4)) {
                                 index += 4;
                              }
                           } else {
                              match = true;
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = startIndex_1;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (match) {
                  // ("varying" TestNoAlpha OptionalSpacing)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ("varying" TestNoAlpha OptionalSpacing)
                  // "varying"
                  match = ignoreCaseStringMatcher("varying", 7);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
                  if (match) {
                     // Size?
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // Size
                     match = size$Rule();
                     if (! match) {
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                        index = lastIndex_3;
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         nationalCharacter$RuleMemoStart = startIndex;
         nationalCharacter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nationalCharacter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NATIONAL_CHARACTER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nationalCharacter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nationalCharacter$RuleMemoStart = startIndex;
         nationalCharacter$RuleMemoEnd = -1;
         nationalCharacter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Integer : ("integer" TestNoAlpha OptionalSpacing Size?)
   protected boolean integer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Integer", index);
      }
      if (integer$RuleMemoStart == index) {
         if (integer$RuleMemoStart <= integer$RuleMemoEnd) {
            index = integer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTEGER, integer$RuleMemoStart, integer$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (integer$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(integer$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("integer" TestNoAlpha OptionalSpacing Size?)
      // "integer"
      match = ignoreCaseStringMatcher("integer", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         integer$RuleMemoStart = startIndex;
         integer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTEGER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            integer$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         integer$RuleMemoStart = startIndex;
         integer$RuleMemoEnd = -1;
         integer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Int : ("int" TestNoAlpha OptionalSpacing Size?)
   protected boolean int$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Int", index);
      }
      if (int$RuleMemoStart == index) {
         if (int$RuleMemoStart <= int$RuleMemoEnd) {
            index = int$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INT, int$RuleMemoStart, int$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (int$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(int$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("int" TestNoAlpha OptionalSpacing Size?)
      // "int"
      match = ignoreCaseStringMatcher("int", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         int$RuleMemoStart = startIndex;
         int$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            int$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            int$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         int$RuleMemoStart = startIndex;
         int$RuleMemoEnd = -1;
         int$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SmallInt : ("smallint" TestNoAlpha OptionalSpacing Size?)
   protected boolean smallInt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SmallInt", index);
      }
      if (smallInt$RuleMemoStart == index) {
         if (smallInt$RuleMemoStart <= smallInt$RuleMemoEnd) {
            index = smallInt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SMALL_INT, smallInt$RuleMemoStart, smallInt$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (smallInt$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(smallInt$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("smallint" TestNoAlpha OptionalSpacing Size?)
      // "smallint"
      match = ignoreCaseStringMatcher("smallint", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         smallInt$RuleMemoStart = startIndex;
         smallInt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            smallInt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SMALL_INT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            smallInt$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         smallInt$RuleMemoStart = startIndex;
         smallInt$RuleMemoEnd = -1;
         smallInt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Real : ("real" TestNoAlpha OptionalSpacing Size?)
   protected boolean real$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Real", index);
      }
      if (real$RuleMemoStart == index) {
         if (real$RuleMemoStart <= real$RuleMemoEnd) {
            index = real$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.REAL, real$RuleMemoStart, real$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (real$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(real$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("real" TestNoAlpha OptionalSpacing Size?)
      // "real"
      match = ignoreCaseStringMatcher("real", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Size?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // Size
               match = size$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         real$RuleMemoStart = startIndex;
         real$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            real$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.REAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            real$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         real$RuleMemoStart = startIndex;
         real$RuleMemoEnd = -1;
         real$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BinaryInteger : ("binary_integer" TestNoAlpha OptionalSpacing)
   protected boolean binaryInteger$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BinaryInteger", index);
      }
      if (binaryInteger$RuleMemoStart == index) {
         if (binaryInteger$RuleMemoStart <= binaryInteger$RuleMemoEnd) {
            index = binaryInteger$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BINARY_INTEGER, binaryInteger$RuleMemoStart, binaryInteger$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (binaryInteger$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(binaryInteger$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("binary_integer" TestNoAlpha OptionalSpacing)
      // "binary_integer"
      match = ignoreCaseStringMatcher("binary_integer", 14);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         binaryInteger$RuleMemoStart = startIndex;
         binaryInteger$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            binaryInteger$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BINARY_INTEGER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            binaryInteger$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         binaryInteger$RuleMemoStart = startIndex;
         binaryInteger$RuleMemoEnd = -1;
         binaryInteger$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Natural : ("natural" TestNoAlpha OptionalSpacing)
   protected boolean natural$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Natural", index);
      }
      if (natural$RuleMemoStart == index) {
         if (natural$RuleMemoStart <= natural$RuleMemoEnd) {
            index = natural$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NATURAL, natural$RuleMemoStart, natural$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (natural$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(natural$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("natural" TestNoAlpha OptionalSpacing)
      // "natural"
      match = ignoreCaseStringMatcher("natural", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         natural$RuleMemoStart = startIndex;
         natural$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            natural$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NATURAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            natural$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         natural$RuleMemoStart = startIndex;
         natural$RuleMemoEnd = -1;
         natural$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Positive : ("positive" TestNoAlpha OptionalSpacing)
   protected boolean positive$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Positive", index);
      }
      if (positive$RuleMemoStart == index) {
         if (positive$RuleMemoStart <= positive$RuleMemoEnd) {
            index = positive$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.POSITIVE, positive$RuleMemoStart, positive$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (positive$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(positive$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("positive" TestNoAlpha OptionalSpacing)
      // "positive"
      match = ignoreCaseStringMatcher("positive", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         positive$RuleMemoStart = startIndex;
         positive$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            positive$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.POSITIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            positive$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         positive$RuleMemoStart = startIndex;
         positive$RuleMemoEnd = -1;
         positive$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Boolean : ("boolean" TestNoAlpha OptionalSpacing)
   protected boolean boolean$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Boolean", index);
      }
      if (boolean$RuleMemoStart == index) {
         if (boolean$RuleMemoStart <= boolean$RuleMemoEnd) {
            index = boolean$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BOOLEAN, boolean$RuleMemoStart, boolean$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (boolean$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(boolean$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("boolean" TestNoAlpha OptionalSpacing)
      // "boolean"
      match = ignoreCaseStringMatcher("boolean", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         boolean$RuleMemoStart = startIndex;
         boolean$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            boolean$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BOOLEAN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            boolean$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         boolean$RuleMemoStart = startIndex;
         boolean$RuleMemoEnd = -1;
         boolean$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Pls_Integer : ("pls_integer" TestNoAlpha OptionalSpacing)
   protected boolean pls_Integer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Pls_Integer", index);
      }
      if (pls_Integer$RuleMemoStart == index) {
         if (pls_Integer$RuleMemoStart <= pls_Integer$RuleMemoEnd) {
            index = pls_Integer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PLS_INTEGER, pls_Integer$RuleMemoStart, pls_Integer$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pls_Integer$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pls_Integer$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("pls_integer" TestNoAlpha OptionalSpacing)
      // "pls_integer"
      match = ignoreCaseStringMatcher("pls_integer", 11);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         pls_Integer$RuleMemoStart = startIndex;
         pls_Integer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pls_Integer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PLS_INTEGER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pls_Integer$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pls_Integer$RuleMemoStart = startIndex;
         pls_Integer$RuleMemoEnd = -1;
         pls_Integer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlDataType : (SqlDataType | BinaryInteger | Natural | Positive | Numeric | Boolean | Integer | Int | SmallInt | Real | SmallIntPrecision | Character | NVarChar | NationalCharacter | Pls_Integer)
   protected boolean plSqlDataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlDataType", index);
      }
      if (plSqlDataType$RuleMemoStart == index) {
         if (plSqlDataType$RuleMemoStart <= plSqlDataType$RuleMemoEnd) {
            index = plSqlDataType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_DATA_TYPE, plSqlDataType$RuleMemoStart, plSqlDataType$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlDataType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlDataType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlDataType | BinaryInteger | Natural | Positive | Numeric | Boolean | Integer | Int | SmallInt | Real | SmallIntPrecision | Character | NVarChar | NationalCharacter | Pls_Integer)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 't':
         case 'T':
         case 'u':
         case 'U':
         case 'v':
         case 'F':
         case 'V':
         case 'f':
         case 'l':
         case 'L': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'n':
         case 'N': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Natural
               match = natural$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Numeric
                  match = numeric$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // NVarChar
                     match = nVarChar$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // NationalCharacter
                        match = nationalCharacter$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         case 'p':
         case 'P': {
            // Positive
            match = positive$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Pls_Integer
               match = pls_Integer$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Real
               match = real$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'B':
         case 'b': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BinaryInteger
               match = binaryInteger$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Boolean
                  match = boolean$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 's':
         case 'S': {
            // SmallInt
            match = smallInt$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SmallIntPrecision
               match = smallIntPrecision$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Character
               match = character$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'D':
         case 'd': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Numeric
               match = numeric$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'I':
         case 'i': {
            // SqlDataType
            match = sqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Integer
               match = integer$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // Int
                  match = int$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlDataType$RuleMemoStart = startIndex;
         plSqlDataType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlDataType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_DATA_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlDataType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlDataType$RuleMemoStart = startIndex;
         plSqlDataType$RuleMemoEnd = -1;
         plSqlDataType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RowType : ('%' OptionalSpacing "rowtype" TestNoAlpha OptionalSpacing)
   protected boolean rowType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RowType", index);
      }
      if (rowType$RuleMemoStart == index) {
         if (rowType$RuleMemoStart <= rowType$RuleMemoEnd) {
            index = rowType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ROW_TYPE, rowType$RuleMemoStart, rowType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rowType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rowType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('%' OptionalSpacing "rowtype" TestNoAlpha OptionalSpacing)
      // '%'
      match = charMatcher('%');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "rowtype"
            match = ignoreCaseStringMatcher("rowtype", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         rowType$RuleMemoStart = startIndex;
         rowType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rowType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ROW_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rowType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rowType$RuleMemoStart = startIndex;
         rowType$RuleMemoEnd = -1;
         rowType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Type : ('%' OptionalSpacing "type" TestNoAlpha OptionalSpacing)
   protected boolean type$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Type", index);
      }
      if (type$RuleMemoStart == index) {
         if (type$RuleMemoStart <= type$RuleMemoEnd) {
            index = type$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TYPE, type$RuleMemoStart, type$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (type$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(type$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('%' OptionalSpacing "type" TestNoAlpha OptionalSpacing)
      // '%'
      match = charMatcher('%');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "type"
            match = ignoreCaseStringMatcher("type", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         type$RuleMemoStart = startIndex;
         type$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            type$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            type$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         type$RuleMemoStart = startIndex;
         type$RuleMemoEnd = -1;
         type$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorReturnType : ("return" TestNoAlpha OptionalSpacing SqlObjectIdentifier RowType)
   protected boolean cursorReturnType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorReturnType", index);
      }
      startIndex = index;
      // ("return" TestNoAlpha OptionalSpacing SqlObjectIdentifier RowType)
      // "return"
      match = ignoreCaseStringMatcher("return", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlObjectIdentifier
               match = sqlObjectIdentifier$Rule();
               if (match) {
                  // RowType
                  match = rowType$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_RETURN_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorRef : ("ref" TestNoAlpha OptionalSpacing "cursor" TestNoAlpha OptionalSpacing CursorReturnType?)
   protected boolean cursorRef$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorRef", index);
      }
      if (cursorRef$RuleMemoStart == index) {
         if (cursorRef$RuleMemoStart <= cursorRef$RuleMemoEnd) {
            index = cursorRef$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_REF, cursorRef$RuleMemoStart, cursorRef$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cursorRef$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cursorRef$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("ref" TestNoAlpha OptionalSpacing "cursor" TestNoAlpha OptionalSpacing CursorReturnType?)
      // "ref"
      match = ignoreCaseStringMatcher("ref", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "cursor"
               match = ignoreCaseStringMatcher("cursor", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // CursorReturnType?
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // CursorReturnType
                        match = cursorReturnType$Rule();
                        if (! match) {
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           index = lastIndex_1;
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cursorRef$RuleMemoStart = startIndex;
         cursorRef$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cursorRef$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_REF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cursorRef$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cursorRef$RuleMemoStart = startIndex;
         cursorRef$RuleMemoEnd = -1;
         cursorRef$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UserTypeAttribute : (RowType | Type | Size)
   protected boolean userTypeAttribute$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UserTypeAttribute", index);
      }
      startIndex = index;
      // (RowType | Type | Size)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '%': {
            // RowType
            match = rowType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // Type
               match = type$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '(': {
            // Size
            match = size$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.USER_TYPE_ATTRIBUTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UserType : (SqlObjectIdentifier UserTypeAttribute?)
   protected boolean userType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UserType", index);
      }
      if (userType$RuleMemoStart == index) {
         if (userType$RuleMemoStart <= userType$RuleMemoEnd) {
            index = userType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.USER_TYPE, userType$RuleMemoStart, userType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (userType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(userType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlObjectIdentifier UserTypeAttribute?)
      // SqlObjectIdentifier
      match = sqlObjectIdentifier$Rule();
      if (match) {
         // UserTypeAttribute?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // UserTypeAttribute
         match = userTypeAttribute$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         userType$RuleMemoStart = startIndex;
         userType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            userType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.USER_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            userType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         userType$RuleMemoStart = startIndex;
         userType$RuleMemoEnd = -1;
         userType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //TypeSpec : (PlSqlDataType | CursorRef | UserType)
   protected boolean typeSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "TypeSpec", index);
      }
      if (typeSpec$RuleMemoStart == index) {
         if (typeSpec$RuleMemoStart <= typeSpec$RuleMemoEnd) {
            index = typeSpec$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.TYPE_SPEC, typeSpec$RuleMemoStart, typeSpec$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (typeSpec$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(typeSpec$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlDataType | CursorRef | UserType)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case 'E':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case '\u00CC':
         case 'M':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'Q':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case 'W':
         case 'X':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case 'a':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case 'e':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case '\u00EC':
         case 'm':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'q':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case 'w':
         case 'x':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // UserType
            match = userType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'B':
         case 'b':
         case 'C':
         case 'c':
         case 'D':
         case 'd':
         case 'F':
         case 'f':
         case 'I':
         case 'i':
         case 'L':
         case 'l':
         case 'N':
         case 'n':
         case 'P':
         case 'p':
         case 'S':
         case 's':
         case 'T':
         case 't':
         case 'U':
         case 'u':
         case 'V':
         case 'v': {
            // PlSqlDataType
            match = plSqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // UserType
               match = userType$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'R':
         case 'r': {
            // PlSqlDataType
            match = plSqlDataType$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CursorRef
               match = cursorRef$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // UserType
                  match = userType$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         typeSpec$RuleMemoStart = startIndex;
         typeSpec$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            typeSpec$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.TYPE_SPEC, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            typeSpec$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         typeSpec$RuleMemoStart = startIndex;
         typeSpec$RuleMemoEnd = -1;
         typeSpec$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParenthesesParametersDeclaration : ('(' OptionalSpacing ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)* ')' OptionalSpacing)
   protected boolean parenthesesParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParenthesesParametersDeclaration", index);
      }
      startIndex = index;
      // ('(' OptionalSpacing ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ParameterDeclaration
            match = parameterDeclaration$Rule();
            if (match) {
               // (',' OptionalSpacing ParameterDeclaration)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing ParameterDeclaration)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ParameterDeclaration
                        match = parameterDeclaration$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PARENTHESES_PARAMETERS_DECLARATION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Out : ("out" TestNoAlpha OptionalSpacing ("nocopy" TestNoAlpha OptionalSpacing)?)
   protected boolean out$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Out", index);
      }
      if (out$RuleMemoStart == index) {
         if (out$RuleMemoStart <= out$RuleMemoEnd) {
            index = out$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OUT, out$RuleMemoStart, out$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (out$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(out$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("out" TestNoAlpha OptionalSpacing ("nocopy" TestNoAlpha OptionalSpacing)?)
      // "out"
      match = ignoreCaseStringMatcher("out", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("nocopy" TestNoAlpha OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("nocopy" TestNoAlpha OptionalSpacing)
               // "nocopy"
               match = ignoreCaseStringMatcher("nocopy", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         out$RuleMemoStart = startIndex;
         out$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            out$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OUT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            out$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         out$RuleMemoStart = startIndex;
         out$RuleMemoEnd = -1;
         out$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParameterDeclaration : (PlSqlIdentifier ("in" TestNoAlpha OptionalSpacing)? Out? TypeSpec DefaultValue?)
   protected boolean parameterDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParameterDeclaration", index);
      }
      if (parameterDeclaration$RuleMemoStart == index) {
         if (parameterDeclaration$RuleMemoStart <= parameterDeclaration$RuleMemoEnd) {
            index = parameterDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETER_DECLARATION, parameterDeclaration$RuleMemoStart, parameterDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parameterDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parameterDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier ("in" TestNoAlpha OptionalSpacing)? Out? TypeSpec DefaultValue?)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // ("in" TestNoAlpha OptionalSpacing)?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ("in" TestNoAlpha OptionalSpacing)
         // "in"
         match = ignoreCaseStringMatcher("in", 2);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // Out?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // Out
            match = out$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
            if (match) {
               // TypeSpec
               match = typeSpec$Rule();
               if (match) {
                  // DefaultValue?
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // DefaultValue
                  match = defaultValue$Rule();
                  if (! match) {
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                     index = lastIndex_3;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parameterDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETER_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parameterDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = -1;
         parameterDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorDeclaration : ("cursor" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier ParametersDeclaration "is" TestNoAlpha OptionalSpacing SelectStatement)
   protected boolean cursorDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorDeclaration", index);
      }
      if (cursorDeclaration$RuleMemoStart == index) {
         if (cursorDeclaration$RuleMemoStart <= cursorDeclaration$RuleMemoEnd) {
            index = cursorDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_DECLARATION, cursorDeclaration$RuleMemoStart, cursorDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cursorDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cursorDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("cursor" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier ParametersDeclaration "is" TestNoAlpha OptionalSpacing SelectStatement)
      // "cursor"
      match = ignoreCaseStringMatcher("cursor", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // ParametersDeclaration
                  match = parametersDeclaration$Rule();
                  if (match) {
                     // "is"
                     match = ignoreCaseStringMatcher("is", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SelectStatement
                              match = selectStatement$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         cursorDeclaration$RuleMemoStart = startIndex;
         cursorDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cursorDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cursorDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cursorDeclaration$RuleMemoStart = startIndex;
         cursorDeclaration$RuleMemoEnd = -1;
         cursorDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ItemDeclaration : (ExceptionDeclaration | ConstantDeclaration | CursorDeclaration | VariableDeclaration)
   protected boolean itemDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ItemDeclaration", index);
      }
      if (itemDeclaration$RuleMemoStart == index) {
         if (itemDeclaration$RuleMemoStart <= itemDeclaration$RuleMemoEnd) {
            index = itemDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ITEM_DECLARATION, itemDeclaration$RuleMemoStart, itemDeclaration$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (itemDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(itemDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (ExceptionDeclaration | ConstantDeclaration | CursorDeclaration | VariableDeclaration)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // ExceptionDeclaration
            match = exceptionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ConstantDeclaration
               match = constantDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // VariableDeclaration
                  match = variableDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
            }
            break;
         }
         case 'C':
         case 'c': {
            // ExceptionDeclaration
            match = exceptionDeclaration$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ConstantDeclaration
               match = constantDeclaration$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // CursorDeclaration
                  match = cursorDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // VariableDeclaration
                     match = variableDeclaration$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         itemDeclaration$RuleMemoStart = startIndex;
         itemDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            itemDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ITEM_DECLARATION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            itemDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         itemDeclaration$RuleMemoStart = startIndex;
         itemDeclaration$RuleMemoEnd = -1;
         itemDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExceptionDeclaration : (PlSqlAnyIdentifier "exception" TestNoAlpha OptionalSpacing)
   protected boolean exceptionDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExceptionDeclaration", index);
      }
      if (exceptionDeclaration$RuleMemoStart == index) {
         if (exceptionDeclaration$RuleMemoStart <= exceptionDeclaration$RuleMemoEnd) {
            index = exceptionDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXCEPTION_DECLARATION, exceptionDeclaration$RuleMemoStart, exceptionDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (exceptionDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(exceptionDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlAnyIdentifier "exception" TestNoAlpha OptionalSpacing)
      // PlSqlAnyIdentifier
      match = plSqlAnyIdentifier$Rule();
      if (match) {
         // "exception"
         match = ignoreCaseStringMatcher("exception", 9);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
      }
      if (match) {
         exceptionDeclaration$RuleMemoStart = startIndex;
         exceptionDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            exceptionDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXCEPTION_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            exceptionDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         exceptionDeclaration$RuleMemoStart = startIndex;
         exceptionDeclaration$RuleMemoEnd = -1;
         exceptionDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ConstantDeclaration : (PlSqlAnyIdentifier "constant" TestNoAlpha OptionalSpacing TypeSpec Nullable? DefaultValue)
   protected boolean constantDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ConstantDeclaration", index);
      }
      if (constantDeclaration$RuleMemoStart == index) {
         if (constantDeclaration$RuleMemoStart <= constantDeclaration$RuleMemoEnd) {
            index = constantDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONSTANT_DECLARATION, constantDeclaration$RuleMemoStart, constantDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (constantDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(constantDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlAnyIdentifier "constant" TestNoAlpha OptionalSpacing TypeSpec Nullable? DefaultValue)
      // PlSqlAnyIdentifier
      match = plSqlAnyIdentifier$Rule();
      if (match) {
         // "constant"
         match = ignoreCaseStringMatcher("constant", 8);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // TypeSpec
                  match = typeSpec$Rule();
                  if (match) {
                     // Nullable?
                     Node lastNode_1 = currentNode;
                     int lastIndex_1 = index;
                     // Nullable
                     match = nullable$Rule();
                     if (! match) {
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        index = lastIndex_1;
                        match = true;
                     }
                     if (match) {
                        // DefaultValue
                        match = defaultValue$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         constantDeclaration$RuleMemoStart = startIndex;
         constantDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            constantDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONSTANT_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            constantDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         constantDeclaration$RuleMemoStart = startIndex;
         constantDeclaration$RuleMemoEnd = -1;
         constantDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //VariableDeclaration : (PlSqlIdentifier TypeSpec Nullable? DefaultValue?)
   protected boolean variableDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "VariableDeclaration", index);
      }
      if (variableDeclaration$RuleMemoStart == index) {
         if (variableDeclaration$RuleMemoStart <= variableDeclaration$RuleMemoEnd) {
            index = variableDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VARIABLE_DECLARATION, variableDeclaration$RuleMemoStart, variableDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (variableDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(variableDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier TypeSpec Nullable? DefaultValue?)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // TypeSpec
         match = typeSpec$Rule();
         if (match) {
            // Nullable?
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // Nullable
            match = nullable$Rule();
            if (! match) {
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               match = true;
            }
            if (match) {
               // DefaultValue?
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // DefaultValue
               match = defaultValue$Rule();
               if (! match) {
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
            }
         }
      }
      if (match) {
         variableDeclaration$RuleMemoStart = startIndex;
         variableDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VARIABLE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         variableDeclaration$RuleMemoStart = startIndex;
         variableDeclaration$RuleMemoEnd = -1;
         variableDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ResultCache : ("result_cache" TestNoAlpha OptionalSpacing ("relies_on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)* ')' OptionalSpacing)?)
   protected boolean resultCache$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ResultCache", index);
      }
      if (resultCache$RuleMemoStart == index) {
         if (resultCache$RuleMemoStart <= resultCache$RuleMemoEnd) {
            index = resultCache$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RESULT_CACHE, resultCache$RuleMemoStart, resultCache$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (resultCache$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(resultCache$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("result_cache" TestNoAlpha OptionalSpacing ("relies_on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)* ')' OptionalSpacing)?)
      // "result_cache"
      match = ignoreCaseStringMatcher("result_cache", 12);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("relies_on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)* ')' OptionalSpacing)?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("relies_on" TestNoAlpha OptionalSpacing '(' OptionalSpacing SqlObjectIdentifier (',' OptionalSpacing SqlObjectIdentifier)* ')' OptionalSpacing)
               // "relies_on"
               match = ignoreCaseStringMatcher("relies_on", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '('
                        match = charMatcher('(');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // SqlObjectIdentifier
                              match = sqlObjectIdentifier$Rule();
                              if (match) {
                                 // (',' OptionalSpacing SqlObjectIdentifier)*
                                 Node lastNode_2;
                                 int lastIndex_2;
                                 do {
                                    lastNode_2 = currentNode;
                                    lastIndex_2 = index;
                                    // (',' OptionalSpacing SqlObjectIdentifier)
                                    // ','
                                    match = charMatcher(',');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // SqlObjectIdentifier
                                          match = sqlObjectIdentifier$Rule();
                                       }
                                    }
                                 } while(match);
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 index = lastIndex_2;
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         resultCache$RuleMemoStart = startIndex;
         resultCache$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            resultCache$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RESULT_CACHE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            resultCache$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         resultCache$RuleMemoStart = startIndex;
         resultCache$RuleMemoEnd = -1;
         resultCache$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FunctionDeclaration : (FunctionHeading FunctionModifier)
   protected boolean functionDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FunctionDeclaration", index);
      }
      if (functionDeclaration$RuleMemoStart == index) {
         if (functionDeclaration$RuleMemoStart <= functionDeclaration$RuleMemoEnd) {
            index = functionDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_DECLARATION, functionDeclaration$RuleMemoStart, functionDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (FunctionHeading FunctionModifier)
      // FunctionHeading
      match = functionHeading$Rule();
      if (match) {
         // FunctionModifier
         match = functionModifier$Rule();
      }
      if (match) {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = -1;
         functionDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FunctionModifier : (("deterministic" TestNoAlpha OptionalSpacing) | ("pipelined" TestNoAlpha OptionalSpacing) | ("parallel_enable" TestNoAlpha OptionalSpacing) | ResultCache | InvokerRights)*
   protected boolean functionModifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FunctionModifier", index);
      }
      if (functionModifier$RuleMemoStart == index) {
         if (functionModifier$RuleMemoStart <= functionModifier$RuleMemoEnd) {
            index = functionModifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_MODIFIER, functionModifier$RuleMemoStart, functionModifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionModifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionModifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("deterministic" TestNoAlpha OptionalSpacing) | ("pipelined" TestNoAlpha OptionalSpacing) | ("parallel_enable" TestNoAlpha OptionalSpacing) | ResultCache | InvokerRights)*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // (("deterministic" TestNoAlpha OptionalSpacing) | ("pipelined" TestNoAlpha OptionalSpacing) | ("parallel_enable" TestNoAlpha OptionalSpacing) | ResultCache | InvokerRights)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("deterministic" TestNoAlpha OptionalSpacing)
         // "deterministic"
         match = ignoreCaseStringMatcher("deterministic", 13);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            // ("pipelined" TestNoAlpha OptionalSpacing)
            // "pipelined"
            match = ignoreCaseStringMatcher("pipelined", 9);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               // ("parallel_enable" TestNoAlpha OptionalSpacing)
               // "parallel_enable"
               match = ignoreCaseStringMatcher("parallel_enable", 15);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  // ResultCache
                  match = resultCache$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     // InvokerRights
                     match = invokerRights$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
               }
            }
         }
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      functionModifier$RuleMemoStart = startIndex;
      functionModifier$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         functionModifier$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_MODIFIER, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         functionModifier$RuleMemoFirstNode = currentNode;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //ProcedureDeclaration : ProcedureHeading
   protected boolean procedureDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ProcedureDeclaration", index);
      }
      if (procedureDeclaration$RuleMemoStart == index) {
         if (procedureDeclaration$RuleMemoStart <= procedureDeclaration$RuleMemoEnd) {
            index = procedureDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_DECLARATION, procedureDeclaration$RuleMemoStart, procedureDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (procedureDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(procedureDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ProcedureHeading
      match = procedureHeading$Rule();
      if (match) {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            procedureDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            procedureDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = -1;
         procedureDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Pragma : ("pragma" TestNoAlpha OptionalSpacing (("restrict_references" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | PlSqlAnyIdentifier) (',' OptionalSpacing PragmaParam)+ ')' OptionalSpacing) | ("exception_init" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing PlSqlLiteral ')' OptionalSpacing) | ("inline" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing (("'yes'" | "'no'") OptionalSpacing) ')' OptionalSpacing) | ("autonomous_transaction" TestNoAlpha OptionalSpacing) | ("serially_reusable" TestNoAlpha OptionalSpacing) | ("builtin" TestNoAlpha OptionalSpacing PragmaParams) | ("fipsflag" TestNoAlpha OptionalSpacing PragmaParams) | ("interface" TestNoAlpha OptionalSpacing PragmaParams) | ("new_names" TestNoAlpha OptionalSpacing PragmaParams) | ("timestamp" TestNoAlpha OptionalSpacing PragmaParams)))
   protected boolean pragma$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Pragma", index);
      }
      if (pragma$RuleMemoStart == index) {
         if (pragma$RuleMemoStart <= pragma$RuleMemoEnd) {
            index = pragma$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA, pragma$RuleMemoStart, pragma$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pragma$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pragma$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("pragma" TestNoAlpha OptionalSpacing (("restrict_references" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | PlSqlAnyIdentifier) (',' OptionalSpacing PragmaParam)+ ')' OptionalSpacing) | ("exception_init" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing PlSqlLiteral ')' OptionalSpacing) | ("inline" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing (("'yes'" | "'no'") OptionalSpacing) ')' OptionalSpacing) | ("autonomous_transaction" TestNoAlpha OptionalSpacing) | ("serially_reusable" TestNoAlpha OptionalSpacing) | ("builtin" TestNoAlpha OptionalSpacing PragmaParams) | ("fipsflag" TestNoAlpha OptionalSpacing PragmaParams) | ("interface" TestNoAlpha OptionalSpacing PragmaParams) | ("new_names" TestNoAlpha OptionalSpacing PragmaParams) | ("timestamp" TestNoAlpha OptionalSpacing PragmaParams)))
      // "pragma"
      match = ignoreCaseStringMatcher("pragma", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (("restrict_references" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | PlSqlAnyIdentifier) (',' OptionalSpacing PragmaParam)+ ')' OptionalSpacing) | ("exception_init" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing PlSqlLiteral ')' OptionalSpacing) | ("inline" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing (("'yes'" | "'no'") OptionalSpacing) ')' OptionalSpacing) | ("autonomous_transaction" TestNoAlpha OptionalSpacing) | ("serially_reusable" TestNoAlpha OptionalSpacing) | ("builtin" TestNoAlpha OptionalSpacing PragmaParams) | ("fipsflag" TestNoAlpha OptionalSpacing PragmaParams) | ("interface" TestNoAlpha OptionalSpacing PragmaParams) | ("new_names" TestNoAlpha OptionalSpacing PragmaParams) | ("timestamp" TestNoAlpha OptionalSpacing PragmaParams))
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ("restrict_references" TestNoAlpha OptionalSpacing '(' OptionalSpacing (("default" TestNoAlpha OptionalSpacing) | PlSqlAnyIdentifier) (',' OptionalSpacing PragmaParam)+ ')' OptionalSpacing)
               // "restrict_references"
               match = ignoreCaseStringMatcher("restrict_references", 19);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '('
                        match = charMatcher('(');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // (("default" TestNoAlpha OptionalSpacing) | PlSqlAnyIdentifier)
                              Node lastNode_2 = currentNode;
                              int lastIndex_2 = index;
                              // ("default" TestNoAlpha OptionalSpacing)
                              // "default"
                              match = ignoreCaseStringMatcher("default", 7);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                                 // PlSqlAnyIdentifier
                                 match = plSqlAnyIdentifier$Rule();
                                 if (! match) {
                                    index = lastIndex_2;
                                    lastNode_2.setSibling(null);
                                    currentNode = lastNode_2;
                                 }
                              }
                              if (match) {
                                 // (',' OptionalSpacing PragmaParam)+
                                 Node lastNode_3 = currentNode;
                                 int lastIndex_3 = index;
                                 // (',' OptionalSpacing PragmaParam)
                                 // ','
                                 match = charMatcher(',');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // PragmaParam
                                       match = pragmaParam$Rule();
                                    }
                                 }
                                 if (match) {
                                    do {
                                       lastNode_3 = currentNode;
                                       lastIndex_3 = index;
                                       // (',' OptionalSpacing PragmaParam)
                                       // ','
                                       match = charMatcher(',');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // PragmaParam
                                             match = pragmaParam$Rule();
                                          }
                                       }
                                    } while(match);
                                    lastNode_3.setSibling(null);
                                    currentNode = lastNode_3;
                                    index = lastIndex_3;
                                    match = true;
                                 } else {
                                    lastNode_3.setSibling(null);
                                    currentNode = lastNode_3;
                                    index = lastIndex_3;
                                 }
                                 if (match) {
                                    // ')'
                                    match = charMatcher(')');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ("exception_init" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing PlSqlLiteral ')' OptionalSpacing)
                  // "exception_init"
                  match = ignoreCaseStringMatcher("exception_init", 14);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '('
                           match = charMatcher('(');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // PlSqlAnyIdentifier
                                 match = plSqlAnyIdentifier$Rule();
                                 if (match) {
                                    // ','
                                    match = charMatcher(',');
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // PlSqlLiteral
                                          match = plSqlLiteral$Rule();
                                          if (match) {
                                             // ')'
                                             match = charMatcher(')');
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ("inline" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ',' OptionalSpacing (("'yes'" | "'no'") OptionalSpacing) ')' OptionalSpacing)
                     // "inline"
                     match = ignoreCaseStringMatcher("inline", 6);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // '('
                              match = charMatcher('(');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // PlSqlAnyIdentifier
                                    match = plSqlAnyIdentifier$Rule();
                                    if (match) {
                                       // ','
                                       match = charMatcher(',');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // (("'yes'" | "'no'") OptionalSpacing)
                                             // ("'yes'" | "'no'")
                                             int startIndex_4 = index;
                                             match = buffer.matchChar(index, '\'');
                                             if (match) {
                                                ++index;
                                                // ("yes'" | "no'")
                                                switch(buffer.getChar(index)) {
                                                   case 'n':
                                                   case 'N': {
                                                      ++index;
                                                      // "o'"
                                                      if (match = ignoreCaseStringTest("o'", 2)) {
                                                         index += 2;
                                                      }
                                                      break;
                                                   }
                                                   case 'y':
                                                   case 'Y': {
                                                      ++index;
                                                      // "es'"
                                                      if (match = ignoreCaseStringTest("es'", 3)) {
                                                         index += 3;
                                                      }
                                                      break;
                                                   }
                                                   default: {
                                                      match = false;
                                                   }
                                                }
                                             }
                                             if (! match) {
                                                index = startIndex_4;
                                             } else if(! currentRuleIsAtomic) {
                                                currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
                                                currentNode = currentNode.getSibling();
                                             }
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                             }
                                             if (match) {
                                                // ')'
                                                match = charMatcher(')');
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("autonomous_transaction" TestNoAlpha OptionalSpacing)
                        // "autonomous_transaction"
                        match = ignoreCaseStringMatcher("autonomous_transaction", 22);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // ("serially_reusable" TestNoAlpha OptionalSpacing)
                           // "serially_reusable"
                           match = ignoreCaseStringMatcher("serially_reusable", 17);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // ("builtin" TestNoAlpha OptionalSpacing PragmaParams)
                              // "builtin"
                              match = ignoreCaseStringMatcher("builtin", 7);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // PragmaParams
                                       match = pragmaParams$Rule();
                                    }
                                 }
                              }
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 // ("fipsflag" TestNoAlpha OptionalSpacing PragmaParams)
                                 // "fipsflag"
                                 match = ignoreCaseStringMatcher("fipsflag", 8);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // PragmaParams
                                          match = pragmaParams$Rule();
                                       }
                                    }
                                 }
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    // ("interface" TestNoAlpha OptionalSpacing PragmaParams)
                                    // "interface"
                                    match = ignoreCaseStringMatcher("interface", 9);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // PragmaParams
                                             match = pragmaParams$Rule();
                                          }
                                       }
                                    }
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       // ("new_names" TestNoAlpha OptionalSpacing PragmaParams)
                                       // "new_names"
                                       match = ignoreCaseStringMatcher("new_names", 9);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // PragmaParams
                                                match = pragmaParams$Rule();
                                             }
                                          }
                                       }
                                       if (! match) {
                                          index = lastIndex_1;
                                          lastNode_1.setSibling(null);
                                          currentNode = lastNode_1;
                                          // ("timestamp" TestNoAlpha OptionalSpacing PragmaParams)
                                          // "timestamp"
                                          match = ignoreCaseStringMatcher("timestamp", 9);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // PragmaParams
                                                   match = pragmaParams$Rule();
                                                }
                                             }
                                          }
                                          if (! match) {
                                             index = lastIndex_1;
                                             lastNode_1.setSibling(null);
                                             currentNode = lastNode_1;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         pragma$RuleMemoStart = startIndex;
         pragma$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragma$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragma$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pragma$RuleMemoStart = startIndex;
         pragma$RuleMemoEnd = -1;
         pragma$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PragmaParams : ('(' OptionalSpacing PragmaParam (',' OptionalSpacing PragmaParam)* ')' OptionalSpacing)
   protected boolean pragmaParams$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PragmaParams", index);
      }
      if (pragmaParams$RuleMemoStart == index) {
         if (pragmaParams$RuleMemoStart <= pragmaParams$RuleMemoEnd) {
            index = pragmaParams$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_PARAMS, pragmaParams$RuleMemoStart, pragmaParams$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pragmaParams$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pragmaParams$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing PragmaParam (',' OptionalSpacing PragmaParam)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PragmaParam
            match = pragmaParam$Rule();
            if (match) {
               // (',' OptionalSpacing PragmaParam)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing PragmaParam)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // PragmaParam
                        match = pragmaParam$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         pragmaParams$RuleMemoStart = startIndex;
         pragmaParams$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragmaParams$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_PARAMS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragmaParams$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pragmaParams$RuleMemoStart = startIndex;
         pragmaParams$RuleMemoEnd = -1;
         pragmaParams$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PragmaParam : (PlSqlIdentifier | StringLiteral | ((('+' | '-') OptionalSpacing)? NumberLiteral))
   protected boolean pragmaParam$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PragmaParam", index);
      }
      if (pragmaParam$RuleMemoStart == index) {
         if (pragmaParam$RuleMemoStart <= pragmaParam$RuleMemoEnd) {
            index = pragmaParam$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_PARAM, pragmaParam$RuleMemoStart, pragmaParam$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pragmaParam$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pragmaParam$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier | StringLiteral | ((('+' | '-') OptionalSpacing)? NumberLiteral))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // StringLiteral
         match = stringLiteral$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // ((('+' | '-') OptionalSpacing)? NumberLiteral)
            // (('+' | '-') OptionalSpacing)?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // (('+' | '-') OptionalSpacing)
            // ('+' | '-')
            int startIndex_3 = index;
            switch(buffer.getChar(index)) {
               case '+': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '-': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            if (! match) {
               index = startIndex_3;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
            if (match) {
               // NumberLiteral
               match = numberLiteral$Rule();
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         pragmaParam$RuleMemoStart = startIndex;
         pragmaParam$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragmaParam$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PRAGMA_PARAM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragmaParam$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pragmaParam$RuleMemoStart = startIndex;
         pragmaParam$RuleMemoEnd = -1;
         pragmaParam$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Label : ("<<" OptionalSpacing PlSqlAnyIdentifier ">>" OptionalSpacing)
   protected boolean label$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Label", index);
      }
      startIndex = index;
      // ("<<" OptionalSpacing PlSqlAnyIdentifier ">>" OptionalSpacing)
      // "<<"
      match = ignoreCaseStringMatcher("<<", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlAnyIdentifier
            match = plSqlAnyIdentifier$Rule();
            if (match) {
               // ">>"
               match = ignoreCaseStringMatcher(">>", 2);
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.LABEL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Labels : Label*
   protected boolean labels$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Labels", index);
      }
      if (labels$RuleMemoStart == index) {
         if (labels$RuleMemoStart <= labels$RuleMemoEnd) {
            index = labels$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LABELS, labels$RuleMemoStart, labels$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (labels$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(labels$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // Label*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // Label
         match = label$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      labels$RuleMemoStart = startIndex;
      labels$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         labels$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(OracleScriptRuleType.LABELS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         labels$RuleMemoFirstNode = currentNode;
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //PlSqlStatement : (Labels (AssignStatement | CaseStatement | CloseStatement | ContinueStatement | BasicLoopStatement | ExecuteImmediateStatement | ExitStatement | FetchStatement | ForLoopStatement | ForAllStatement | GotoStatement | IfStatement | NullStatement | OpenStatement | PlSqlBlock | RaiseStatement | ReturnStatement | SqlStatement | WhileLoopStatement | PipeRowStatement | PlSqlObjectIdentifier))
   protected boolean plSqlStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlStatement", index);
      }
      if (plSqlStatement$RuleMemoStart == index) {
         if (plSqlStatement$RuleMemoStart <= plSqlStatement$RuleMemoEnd) {
            index = plSqlStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_STATEMENT, plSqlStatement$RuleMemoStart, plSqlStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Labels (AssignStatement | CaseStatement | CloseStatement | ContinueStatement | BasicLoopStatement | ExecuteImmediateStatement | ExitStatement | FetchStatement | ForLoopStatement | ForAllStatement | GotoStatement | IfStatement | NullStatement | OpenStatement | PlSqlBlock | RaiseStatement | ReturnStatement | SqlStatement | WhileLoopStatement | PipeRowStatement | PlSqlObjectIdentifier))
      // Labels
      match = labels$Rule();
      if (match) {
         // (AssignStatement | CaseStatement | CloseStatement | ContinueStatement | BasicLoopStatement | ExecuteImmediateStatement | ExitStatement | FetchStatement | ForLoopStatement | ForAllStatement | GotoStatement | IfStatement | NullStatement | OpenStatement | PlSqlBlock | RaiseStatement | ReturnStatement | SqlStatement | WhileLoopStatement | PipeRowStatement | PlSqlObjectIdentifier)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         switch(buffer.getChar(index)) {
            case 'L':
            case 'l': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // BasicLoopStatement
                  match = basicLoopStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlStatement
                     match = sqlStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlObjectIdentifier
                        match = plSqlObjectIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
               break;
            }
            case 'S':
            case 's':
            case 'U':
            case 'u':
            case 'M':
            case 'm': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlStatement
                  match = sqlStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case 'N':
            case 'n': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // NullStatement
                  match = nullStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case 'O':
            case 'o': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // OpenStatement
                  match = openStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case '\"':
            case '#':
            case '$':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case '\u00C1':
            case '\u00C2':
            case '\u00C3':
            case '\u00C4':
            case '\u00C7':
            case 'H':
            case '\u00C8':
            case '\u00C9':
            case 'J':
            case '\u00CA':
            case 'K':
            case '\u00CB':
            case '\u00CC':
            case '\u00CD':
            case '\u00CE':
            case '\u00CF':
            case 'Q':
            case '\u00D2':
            case '\u00D3':
            case 'T':
            case '\u00D4':
            case '\u00D5':
            case 'V':
            case '\u00D6':
            case 'X':
            case 'Y':
            case '\u00D9':
            case 'Z':
            case '\u00DA':
            case '\u00DB':
            case '\u00DC':
            case '_':
            case '\u00E0':
            case 'a':
            case '\u00E1':
            case '\u00E2':
            case '\u00E3':
            case '\u00E4':
            case '\u00E7':
            case 'h':
            case '\u00E8':
            case '\u00E9':
            case 'j':
            case '\u00EA':
            case 'k':
            case '\u00EB':
            case '\u00EC':
            case '\u00ED':
            case '\u00EE':
            case '\u00EF':
            case 'q':
            case '\u00F2':
            case '\u00F3':
            case 't':
            case '\u00F4':
            case '\u00F5':
            case 'v':
            case '\u00F6':
            case 'x':
            case 'y':
            case '\u00F9':
            case 'z':
            case '\u00FA':
            case '\u00FB':
            case '\u00FC': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlObjectIdentifier
                  match = plSqlObjectIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               }
               break;
            }
            case 'P':
            case 'p': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PipeRowStatement
                  match = pipeRowStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case 'R':
            case 'r': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // RaiseStatement
                  match = raiseStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ReturnStatement
                     match = returnStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // SqlStatement
                        match = sqlStatement$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // PlSqlObjectIdentifier
                           match = plSqlObjectIdentifier$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
               break;
            }
            case 'W':
            case 'w': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // SqlStatement
                  match = sqlStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // WhileLoopStatement
                     match = whileLoopStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlObjectIdentifier
                        match = plSqlObjectIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
               break;
            }
            case ':': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
               break;
            }
            case '<': {
               // PlSqlBlock
               match = plSqlBlock$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
               break;
            }
            case 'B':
            case 'b': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlBlock
                  match = plSqlBlock$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case 'C':
            case 'c': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // CaseStatement
                  match = caseStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // CloseStatement
                     match = closeStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ContinueStatement
                        match = continueStatement$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // SqlStatement
                           match = sqlStatement$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              // PlSqlObjectIdentifier
                              match = plSqlObjectIdentifier$Rule();
                              if (! match) {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                              }
                           }
                        }
                     }
                  }
               }
               break;
            }
            case 'D':
            case 'd': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlBlock
                  match = plSqlBlock$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlStatement
                     match = sqlStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlObjectIdentifier
                        match = plSqlObjectIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
               break;
            }
            case 'E':
            case 'e': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // ExecuteImmediateStatement
                  match = executeImmediateStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ExitStatement
                     match = exitStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlObjectIdentifier
                        match = plSqlObjectIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
               break;
            }
            case 'F':
            case 'f': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // FetchStatement
                  match = fetchStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // ForLoopStatement
                     match = forLoopStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ForAllStatement
                        match = forAllStatement$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                           // PlSqlObjectIdentifier
                           match = plSqlObjectIdentifier$Rule();
                           if (! match) {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                           }
                        }
                     }
                  }
               }
               break;
            }
            case 'G':
            case 'g': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // GotoStatement
                  match = gotoStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlObjectIdentifier
                     match = plSqlObjectIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
               break;
            }
            case '(': {
               // SqlStatement
               match = sqlStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
               break;
            }
            case 'I':
            case 'i': {
               // AssignStatement
               match = assignStatement$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // IfStatement
                  match = ifStatement$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // SqlStatement
                     match = sqlStatement$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlObjectIdentifier
                        match = plSqlObjectIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         plSqlStatement$RuleMemoStart = startIndex;
         plSqlStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlStatement$RuleMemoStart = startIndex;
         plSqlStatement$RuleMemoEnd = -1;
         plSqlStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //HostVariable : (':' OptionalSpacing PlSqlObjectIdentifier)
   protected boolean hostVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "HostVariable", index);
      }
      if (hostVariable$RuleMemoStart == index) {
         if (hostVariable$RuleMemoStart <= hostVariable$RuleMemoEnd) {
            index = hostVariable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.HOST_VARIABLE, hostVariable$RuleMemoStart, hostVariable$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (hostVariable$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(hostVariable$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (':' OptionalSpacing PlSqlObjectIdentifier)
      // ':'
      match = charMatcher(':');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlObjectIdentifier
            match = plSqlObjectIdentifier$Rule();
         }
      }
      if (match) {
         hostVariable$RuleMemoStart = startIndex;
         hostVariable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hostVariable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.HOST_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hostVariable$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         hostVariable$RuleMemoStart = startIndex;
         hostVariable$RuleMemoEnd = -1;
         hostVariable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //LeftValue : (HostVariable | PlSqlObjectIdentifier)
   protected boolean leftValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "LeftValue", index);
      }
      if (leftValue$RuleMemoStart == index) {
         if (leftValue$RuleMemoStart <= leftValue$RuleMemoEnd) {
            index = leftValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.LEFT_VALUE, leftValue$RuleMemoStart, leftValue$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (leftValue$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(leftValue$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (HostVariable | PlSqlObjectIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlObjectIdentifier
            match = plSqlObjectIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case ':': {
            // HostVariable
            match = hostVariable$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            leftValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.LEFT_VALUE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            leftValue$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = -1;
         leftValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AssignStatement : (LeftValue ":=" OptionalSpacing PlSqlExpression)
   protected boolean assignStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AssignStatement", index);
      }
      if (assignStatement$RuleMemoStart == index) {
         if (assignStatement$RuleMemoStart <= assignStatement$RuleMemoEnd) {
            index = assignStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ASSIGN_STATEMENT, assignStatement$RuleMemoStart, assignStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (assignStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(assignStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (LeftValue ":=" OptionalSpacing PlSqlExpression)
      // LeftValue
      match = leftValue$Rule();
      if (match) {
         // ":="
         match = ignoreCaseStringMatcher(":=", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
            }
         }
      }
      if (match) {
         assignStatement$RuleMemoStart = startIndex;
         assignStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ASSIGN_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         assignStatement$RuleMemoStart = startIndex;
         assignStatement$RuleMemoEnd = -1;
         assignStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NamedParameter : (PlSqlIdentifier "=>" OptionalSpacing PlSqlExpression)
   protected boolean namedParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NamedParameter", index);
      }
      if (namedParameter$RuleMemoStart == index) {
         if (namedParameter$RuleMemoStart <= namedParameter$RuleMemoEnd) {
            index = namedParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NAMED_PARAMETER, namedParameter$RuleMemoStart, namedParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (namedParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(namedParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier "=>" OptionalSpacing PlSqlExpression)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // "=>"
         match = ignoreCaseStringMatcher("=>", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
            }
         }
      }
      if (match) {
         namedParameter$RuleMemoStart = startIndex;
         namedParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            namedParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NAMED_PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            namedParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         namedParameter$RuleMemoStart = startIndex;
         namedParameter$RuleMemoEnd = -1;
         namedParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlFunctionParameter : (NamedParameter | PlSqlExpression | BindVariable)
   protected boolean plSqlFunctionParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlFunctionParameter", index);
      }
      if (plSqlFunctionParameter$RuleMemoStart == index) {
         if (plSqlFunctionParameter$RuleMemoStart <= plSqlFunctionParameter$RuleMemoEnd) {
            index = plSqlFunctionParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_PARAMETER, plSqlFunctionParameter$RuleMemoStart, plSqlFunctionParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlFunctionParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlFunctionParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NamedParameter | PlSqlExpression | BindVariable)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case '(':
         case '+':
         case '-': {
            // PlSqlExpression
            match = plSqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '?': {
            // BindVariable
            match = bindVariable$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // NamedParameter
            match = namedParameter$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case ':': {
            // PlSqlExpression
            match = plSqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BindVariable
               match = bindVariable$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlFunctionParameter$RuleMemoStart = startIndex;
         plSqlFunctionParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlFunctionParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlFunctionParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlFunctionParameter$RuleMemoStart = startIndex;
         plSqlFunctionParameter$RuleMemoEnd = -1;
         plSqlFunctionParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlParameters : ('(' OptionalSpacing (')'& | (PlSqlFunctionParameter (',' OptionalSpacing PlSqlFunctionParameter)*)) ')' OptionalSpacing)
   protected boolean plSqlParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlParameters", index);
      }
      if (plSqlParameters$RuleMemoStart == index) {
         if (plSqlParameters$RuleMemoStart <= plSqlParameters$RuleMemoEnd) {
            index = plSqlParameters$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS, plSqlParameters$RuleMemoStart, plSqlParameters$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlParameters$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlParameters$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing (')'& | (PlSqlFunctionParameter (',' OptionalSpacing PlSqlFunctionParameter)*)) ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (')'& | (PlSqlFunctionParameter (',' OptionalSpacing PlSqlFunctionParameter)*))
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ')'&
            // ')'
            match = buffer.matchChar(index, ')');
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // (PlSqlFunctionParameter (',' OptionalSpacing PlSqlFunctionParameter)*)
               // PlSqlFunctionParameter
               match = plSqlFunctionParameter$Rule();
               if (match) {
                  // (',' OptionalSpacing PlSqlFunctionParameter)*
                  Node lastNode_2;
                  int lastIndex_2;
                  do {
                     lastNode_2 = currentNode;
                     lastIndex_2 = index;
                     // (',' OptionalSpacing PlSqlFunctionParameter)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlFunctionParameter
                           match = plSqlFunctionParameter$Rule();
                        }
                     }
                  } while(match);
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
                  index = lastIndex_2;
                  match = true;
               }
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         plSqlParameters$RuleMemoStart = startIndex;
         plSqlParameters$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlParameters$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlParameters$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlParameters$RuleMemoStart = startIndex;
         plSqlParameters$RuleMemoEnd = -1;
         plSqlParameters$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseStatementWhen : ("when" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements)
   protected boolean caseStatementWhen$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseStatementWhen", index);
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlStatements
                           match = plSqlStatements$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_STATEMENT_WHEN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseStatementWhenList : CaseStatementWhen+
   protected boolean caseStatementWhenList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseStatementWhenList", index);
      }
      startIndex = index;
      // CaseStatementWhen+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // CaseStatementWhen
      match = caseStatementWhen$Rule();
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // CaseStatementWhen
            match = caseStatementWhen$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_STATEMENT_WHEN_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseStatementElse : ("else" TestNoAlpha OptionalSpacing PlSqlStatements)
   protected boolean caseStatementElse$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseStatementElse", index);
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing PlSqlStatements)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlStatements
               match = plSqlStatements$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_STATEMENT_ELSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CaseStatement : ("case" TestNoAlpha OptionalSpacing PlSqlExpression? CaseStatementWhenList CaseStatementElse? "end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean caseStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CaseStatement", index);
      }
      if (caseStatement$RuleMemoStart == index) {
         if (caseStatement$RuleMemoStart <= caseStatement$RuleMemoEnd) {
            index = caseStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CASE_STATEMENT, caseStatement$RuleMemoStart, caseStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (caseStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(caseStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing PlSqlExpression? CaseStatementWhenList CaseStatementElse? "end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // CaseStatementWhenList
                  match = caseStatementWhenList$Rule();
                  if (match) {
                     // CaseStatementElse?
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // CaseStatementElse
                     match = caseStatementElse$Rule();
                     if (! match) {
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                        index = lastIndex_2;
                        match = true;
                     }
                     if (match) {
                        // "end"
                        match = ignoreCaseStringMatcher("end", 3);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // "case"
                                 match = ignoreCaseStringMatcher("case", 4);
                                 if (match) {
                                    // TestNoAlpha
                                    match = testNoAlpha$Rule();
                                    if (match) {
                                       // OptionalSpacing
                                       match = optionalSpacing$Rule();
                                       if (match) {
                                          // PlSqlAnyIdentifier?
                                          Node lastNode_3 = currentNode;
                                          int lastIndex_3 = index;
                                          // PlSqlAnyIdentifier
                                          match = plSqlAnyIdentifier$Rule();
                                          if (! match) {
                                             lastNode_3.setSibling(null);
                                             currentNode = lastNode_3;
                                             index = lastIndex_3;
                                             match = true;
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         caseStatement$RuleMemoStart = startIndex;
         caseStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            caseStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CASE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            caseStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         caseStatement$RuleMemoStart = startIndex;
         caseStatement$RuleMemoEnd = -1;
         caseStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ContinueStatement : ("continue" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier? PlSqlExpression?)
   protected boolean continueStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ContinueStatement", index);
      }
      if (continueStatement$RuleMemoStart == index) {
         if (continueStatement$RuleMemoStart <= continueStatement$RuleMemoEnd) {
            index = continueStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CONTINUE_STATEMENT, continueStatement$RuleMemoStart, continueStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (continueStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(continueStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("continue" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier? PlSqlExpression?)
      // "continue"
      match = ignoreCaseStringMatcher("continue", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // PlSqlExpression?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // PlSqlExpression
                  match = plSqlExpression$Rule();
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         continueStatement$RuleMemoStart = startIndex;
         continueStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CONTINUE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         continueStatement$RuleMemoStart = startIndex;
         continueStatement$RuleMemoEnd = -1;
         continueStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CloseStatement : ("close" TestNoAlpha OptionalSpacing SqlObjectIdentifier)
   protected boolean closeStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CloseStatement", index);
      }
      if (closeStatement$RuleMemoStart == index) {
         if (closeStatement$RuleMemoStart <= closeStatement$RuleMemoEnd) {
            index = closeStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CLOSE_STATEMENT, closeStatement$RuleMemoStart, closeStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (closeStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(closeStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("close" TestNoAlpha OptionalSpacing SqlObjectIdentifier)
      // "close"
      match = ignoreCaseStringMatcher("close", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlObjectIdentifier
               match = sqlObjectIdentifier$Rule();
            }
         }
      }
      if (match) {
         closeStatement$RuleMemoStart = startIndex;
         closeStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            closeStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CLOSE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            closeStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         closeStatement$RuleMemoStart = startIndex;
         closeStatement$RuleMemoEnd = -1;
         closeStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BasicLoopStatement : ("loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean basicLoopStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BasicLoopStatement", index);
      }
      if (basicLoopStatement$RuleMemoStart == index) {
         if (basicLoopStatement$RuleMemoStart <= basicLoopStatement$RuleMemoEnd) {
            index = basicLoopStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BASIC_LOOP_STATEMENT, basicLoopStatement$RuleMemoStart, basicLoopStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (basicLoopStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(basicLoopStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "loop"
      match = ignoreCaseStringMatcher("loop", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlStatements
               match = plSqlStatements$Rule();
               if (match) {
                  // "end"
                  match = ignoreCaseStringMatcher("end", 3);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // "loop"
                           match = ignoreCaseStringMatcher("loop", 4);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // PlSqlAnyIdentifier?
                                    Node lastNode_1 = currentNode;
                                    int lastIndex_1 = index;
                                    // PlSqlAnyIdentifier
                                    match = plSqlAnyIdentifier$Rule();
                                    if (! match) {
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                       index = lastIndex_1;
                                       match = true;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         basicLoopStatement$RuleMemoStart = startIndex;
         basicLoopStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            basicLoopStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BASIC_LOOP_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            basicLoopStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         basicLoopStatement$RuleMemoStart = startIndex;
         basicLoopStatement$RuleMemoEnd = -1;
         basicLoopStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExecuteImediateOptions : ((IntoClause UsingClause?) | (BulkCollectIntoClause UsingClause?) | (UsingClause DynamicReturningClause?) | DynamicReturningClause)
   protected boolean executeImediateOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExecuteImediateOptions", index);
      }
      startIndex = index;
      // ((IntoClause UsingClause?) | (BulkCollectIntoClause UsingClause?) | (UsingClause DynamicReturningClause?) | DynamicReturningClause)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (IntoClause UsingClause?)
      // IntoClause
      match = intoClause$Rule();
      if (match) {
         // UsingClause?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // UsingClause
         match = usingClause$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // (BulkCollectIntoClause UsingClause?)
         // BulkCollectIntoClause
         match = bulkCollectIntoClause$Rule();
         if (match) {
            // UsingClause?
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // UsingClause
            match = usingClause$Rule();
            if (! match) {
               lastNode_3.setSibling(null);
               currentNode = lastNode_3;
               index = lastIndex_3;
               match = true;
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // (UsingClause DynamicReturningClause?)
            // UsingClause
            match = usingClause$Rule();
            if (match) {
               // DynamicReturningClause?
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // DynamicReturningClause
               match = dynamicReturningClause$Rule();
               if (! match) {
                  lastNode_4.setSibling(null);
                  currentNode = lastNode_4;
                  index = lastIndex_4;
                  match = true;
               }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // DynamicReturningClause
               match = dynamicReturningClause$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EXECUTE_IMEDIATE_OPTIONS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExecuteImmediateStatement : ("execute" TestNoAlpha OptionalSpacing "immediate" TestNoAlpha OptionalSpacing PlSqlExpression ExecuteImediateOptions?)
   protected boolean executeImmediateStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExecuteImmediateStatement", index);
      }
      if (executeImmediateStatement$RuleMemoStart == index) {
         if (executeImmediateStatement$RuleMemoStart <= executeImmediateStatement$RuleMemoEnd) {
            index = executeImmediateStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXECUTE_IMMEDIATE_STATEMENT, executeImmediateStatement$RuleMemoStart, executeImmediateStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (executeImmediateStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(executeImmediateStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("execute" TestNoAlpha OptionalSpacing "immediate" TestNoAlpha OptionalSpacing PlSqlExpression ExecuteImediateOptions?)
      // "execute"
      match = ignoreCaseStringMatcher("execute", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "immediate"
               match = ignoreCaseStringMatcher("immediate", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // PlSqlExpression
                        match = plSqlExpression$Rule();
                        if (match) {
                           // ExecuteImediateOptions?
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           // ExecuteImediateOptions
                           match = executeImediateOptions$Rule();
                           if (! match) {
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              index = lastIndex_1;
                              match = true;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         executeImmediateStatement$RuleMemoStart = startIndex;
         executeImmediateStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            executeImmediateStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXECUTE_IMMEDIATE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            executeImmediateStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         executeImmediateStatement$RuleMemoStart = startIndex;
         executeImmediateStatement$RuleMemoEnd = -1;
         executeImmediateStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IntoClause : ("into" TestNoAlpha OptionalSpacing LeftValue (',' OptionalSpacing LeftValue)*)
   protected boolean intoClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IntoClause", index);
      }
      if (intoClause$RuleMemoStart == index) {
         if (intoClause$RuleMemoStart <= intoClause$RuleMemoEnd) {
            index = intoClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INTO_CLAUSE, intoClause$RuleMemoStart, intoClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (intoClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(intoClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("into" TestNoAlpha OptionalSpacing LeftValue (',' OptionalSpacing LeftValue)*)
      // "into"
      match = ignoreCaseStringMatcher("into", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // LeftValue
               match = leftValue$Rule();
               if (match) {
                  // (',' OptionalSpacing LeftValue)*
                  Node lastNode_1;
                  int lastIndex_1;
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // (',' OptionalSpacing LeftValue)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // LeftValue
                           match = leftValue$Rule();
                        }
                     }
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         intoClause$RuleMemoStart = startIndex;
         intoClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            intoClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INTO_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            intoClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         intoClause$RuleMemoStart = startIndex;
         intoClause$RuleMemoEnd = -1;
         intoClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BulkCollectIntoClause : ("bulk" TestNoAlpha OptionalSpacing "collect" TestNoAlpha OptionalSpacing "into" TestNoAlpha OptionalSpacing LeftValue (',' OptionalSpacing LeftValue)*)
   protected boolean bulkCollectIntoClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BulkCollectIntoClause", index);
      }
      if (bulkCollectIntoClause$RuleMemoStart == index) {
         if (bulkCollectIntoClause$RuleMemoStart <= bulkCollectIntoClause$RuleMemoEnd) {
            index = bulkCollectIntoClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BULK_COLLECT_INTO_CLAUSE, bulkCollectIntoClause$RuleMemoStart, bulkCollectIntoClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (bulkCollectIntoClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(bulkCollectIntoClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("bulk" TestNoAlpha OptionalSpacing "collect" TestNoAlpha OptionalSpacing "into" TestNoAlpha OptionalSpacing LeftValue (',' OptionalSpacing LeftValue)*)
      // "bulk"
      match = ignoreCaseStringMatcher("bulk", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "collect"
               match = ignoreCaseStringMatcher("collect", 7);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // "into"
                        match = ignoreCaseStringMatcher("into", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // LeftValue
                                 match = leftValue$Rule();
                                 if (match) {
                                    // (',' OptionalSpacing LeftValue)*
                                    Node lastNode_1;
                                    int lastIndex_1;
                                    do {
                                       lastNode_1 = currentNode;
                                       lastIndex_1 = index;
                                       // (',' OptionalSpacing LeftValue)
                                       // ','
                                       match = charMatcher(',');
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // LeftValue
                                             match = leftValue$Rule();
                                          }
                                       }
                                    } while(match);
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                    index = lastIndex_1;
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         bulkCollectIntoClause$RuleMemoStart = startIndex;
         bulkCollectIntoClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            bulkCollectIntoClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BULK_COLLECT_INTO_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            bulkCollectIntoClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         bulkCollectIntoClause$RuleMemoStart = startIndex;
         bulkCollectIntoClause$RuleMemoEnd = -1;
         bulkCollectIntoClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UsingParameter : (("in" TestNoAlpha OptionalSpacing)? Out? PlSqlExpression)
   protected boolean usingParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UsingParameter", index);
      }
      if (usingParameter$RuleMemoStart == index) {
         if (usingParameter$RuleMemoStart <= usingParameter$RuleMemoEnd) {
            index = usingParameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.USING_PARAMETER, usingParameter$RuleMemoStart, usingParameter$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (usingParameter$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(usingParameter$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("in" TestNoAlpha OptionalSpacing)? Out? PlSqlExpression)
      // ("in" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("in" TestNoAlpha OptionalSpacing)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // Out?
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // Out
         match = out$Rule();
         if (! match) {
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            match = true;
         }
         if (match) {
            // PlSqlExpression
            match = plSqlExpression$Rule();
         }
      }
      if (match) {
         usingParameter$RuleMemoStart = startIndex;
         usingParameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            usingParameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.USING_PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            usingParameter$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         usingParameter$RuleMemoStart = startIndex;
         usingParameter$RuleMemoEnd = -1;
         usingParameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //UsingClause : ("using" TestNoAlpha OptionalSpacing UsingParameter (',' OptionalSpacing UsingParameter)*)
   protected boolean usingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "UsingClause", index);
      }
      if (usingClause$RuleMemoStart == index) {
         if (usingClause$RuleMemoStart <= usingClause$RuleMemoEnd) {
            index = usingClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.USING_CLAUSE, usingClause$RuleMemoStart, usingClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (usingClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(usingClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("using" TestNoAlpha OptionalSpacing UsingParameter (',' OptionalSpacing UsingParameter)*)
      // "using"
      match = ignoreCaseStringMatcher("using", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // UsingParameter
               match = usingParameter$Rule();
               if (match) {
                  // (',' OptionalSpacing UsingParameter)*
                  Node lastNode_1;
                  int lastIndex_1;
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // (',' OptionalSpacing UsingParameter)
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // UsingParameter
                           match = usingParameter$Rule();
                        }
                     }
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         usingClause$RuleMemoStart = startIndex;
         usingClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            usingClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.USING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            usingClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         usingClause$RuleMemoStart = startIndex;
         usingClause$RuleMemoEnd = -1;
         usingClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //DynamicReturningClause : ((("returning" | "return") TestNoAlpha OptionalSpacing) (IntoClause | BulkCollectIntoClause))
   protected boolean dynamicReturningClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "DynamicReturningClause", index);
      }
      if (dynamicReturningClause$RuleMemoStart == index) {
         if (dynamicReturningClause$RuleMemoStart <= dynamicReturningClause$RuleMemoEnd) {
            index = dynamicReturningClause$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.DYNAMIC_RETURNING_CLAUSE, dynamicReturningClause$RuleMemoStart, dynamicReturningClause$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (dynamicReturningClause$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(dynamicReturningClause$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ((("returning" | "return") TestNoAlpha OptionalSpacing) (IntoClause | BulkCollectIntoClause))
      // (("returning" | "return") TestNoAlpha OptionalSpacing)
      // ("returning" | "return")
      int startIndex_1 = index;
      match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
      if (match) {
         ++index;
         // ("eturning" | "eturn")
         match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
         if (match) {
            ++index;
            // ("turning" | "turn")
            match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
            if (match) {
               ++index;
               // ("urning" | "urn")
               match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
               if (match) {
                  ++index;
                  // ("rning" | "rn")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("ning" | "n")
                     match = buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N');
                     if (match) {
                        ++index;
                        // ("ing" | <EMPTY>)
                        match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                        if (match) {
                           ++index;
                           // "ng"
                           if (match = ignoreCaseStringTest("ng", 2)) {
                              index += 2;
                           }
                        } else {
                           match = true;
                        }
                     }
                  }
               }
            }
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // (IntoClause | BulkCollectIntoClause)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         switch(buffer.getChar(index)) {
            case 'b':
            case 'B': {
               // BulkCollectIntoClause
               match = bulkCollectIntoClause$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            case 'i':
            case 'I': {
               // IntoClause
               match = intoClause$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
               break;
            }
            default: {
               match = false;
            }
         }
      }
      if (match) {
         dynamicReturningClause$RuleMemoStart = startIndex;
         dynamicReturningClause$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dynamicReturningClause$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.DYNAMIC_RETURNING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dynamicReturningClause$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         dynamicReturningClause$RuleMemoStart = startIndex;
         dynamicReturningClause$RuleMemoEnd = -1;
         dynamicReturningClause$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExitStatement : ("exit" TestNoAlpha OptionalSpacing PlSqlIdentifier? ("when" TestNoAlpha OptionalSpacing PlSqlExpression)?)
   protected boolean exitStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExitStatement", index);
      }
      if (exitStatement$RuleMemoStart == index) {
         if (exitStatement$RuleMemoStart <= exitStatement$RuleMemoEnd) {
            index = exitStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.EXIT_STATEMENT, exitStatement$RuleMemoStart, exitStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (exitStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(exitStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("exit" TestNoAlpha OptionalSpacing PlSqlIdentifier? ("when" TestNoAlpha OptionalSpacing PlSqlExpression)?)
      // "exit"
      match = ignoreCaseStringMatcher("exit", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlIdentifier?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlIdentifier
               match = plSqlIdentifier$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
               if (match) {
                  // ("when" TestNoAlpha OptionalSpacing PlSqlExpression)?
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // ("when" TestNoAlpha OptionalSpacing PlSqlExpression)
                  // "when"
                  match = ignoreCaseStringMatcher("when", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlExpression
                           match = plSqlExpression$Rule();
                        }
                     }
                  }
                  if (! match) {
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                     index = lastIndex_2;
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         exitStatement$RuleMemoStart = startIndex;
         exitStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            exitStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.EXIT_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            exitStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         exitStatement$RuleMemoStart = startIndex;
         exitStatement$RuleMemoEnd = -1;
         exitStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Limit : ("limit" TestNoAlpha OptionalSpacing NumericExpression)
   protected boolean limit$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Limit", index);
      }
      startIndex = index;
      // ("limit" TestNoAlpha OptionalSpacing NumericExpression)
      // "limit"
      match = ignoreCaseStringMatcher("limit", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // NumericExpression
               match = numericExpression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.LIMIT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FetchStatement : ("fetch" TestNoAlpha OptionalSpacing LeftValue (IntoClause | (BulkCollectIntoClause Limit?) | ("BullkLimited" TestNoAlpha OptionalSpacing)))
   protected boolean fetchStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FetchStatement", index);
      }
      if (fetchStatement$RuleMemoStart == index) {
         if (fetchStatement$RuleMemoStart <= fetchStatement$RuleMemoEnd) {
            index = fetchStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FETCH_STATEMENT, fetchStatement$RuleMemoStart, fetchStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (fetchStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(fetchStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("fetch" TestNoAlpha OptionalSpacing LeftValue (IntoClause | (BulkCollectIntoClause Limit?) | ("BullkLimited" TestNoAlpha OptionalSpacing)))
      // "fetch"
      match = ignoreCaseStringMatcher("fetch", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // LeftValue
               match = leftValue$Rule();
               if (match) {
                  // (IntoClause | (BulkCollectIntoClause Limit?) | ("BullkLimited" TestNoAlpha OptionalSpacing))
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // IntoClause
                  match = intoClause$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // (BulkCollectIntoClause Limit?)
                     // BulkCollectIntoClause
                     match = bulkCollectIntoClause$Rule();
                     if (match) {
                        // Limit?
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // Limit
                        match = limit$Rule();
                        if (! match) {
                           lastNode_2.setSibling(null);
                           currentNode = lastNode_2;
                           index = lastIndex_2;
                           match = true;
                        }
                     }
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // ("BullkLimited" TestNoAlpha OptionalSpacing)
                        // "BullkLimited"
                        match = ignoreCaseStringMatcher("BullkLimited", 12);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         fetchStatement$RuleMemoStart = startIndex;
         fetchStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fetchStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FETCH_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fetchStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         fetchStatement$RuleMemoStart = startIndex;
         fetchStatement$RuleMemoEnd = -1;
         fetchStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForLoopStatement : ("for" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "in" TestNoAlpha OptionalSpacing ForBoundsClause "loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean forLoopStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForLoopStatement", index);
      }
      if (forLoopStatement$RuleMemoStart == index) {
         if (forLoopStatement$RuleMemoStart <= forLoopStatement$RuleMemoEnd) {
            index = forLoopStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FOR_LOOP_STATEMENT, forLoopStatement$RuleMemoStart, forLoopStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forLoopStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forLoopStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "in" TestNoAlpha OptionalSpacing ForBoundsClause "loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "in"
                  match = ignoreCaseStringMatcher("in", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ForBoundsClause
                           match = forBoundsClause$Rule();
                           if (match) {
                              // "loop"
                              match = ignoreCaseStringMatcher("loop", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // PlSqlStatements
                                       match = plSqlStatements$Rule();
                                       if (match) {
                                          // "end"
                                          match = ignoreCaseStringMatcher("end", 3);
                                          if (match) {
                                             // TestNoAlpha
                                             match = testNoAlpha$Rule();
                                             if (match) {
                                                // OptionalSpacing
                                                match = optionalSpacing$Rule();
                                                if (match) {
                                                   // "loop"
                                                   match = ignoreCaseStringMatcher("loop", 4);
                                                   if (match) {
                                                      // TestNoAlpha
                                                      match = testNoAlpha$Rule();
                                                      if (match) {
                                                         // OptionalSpacing
                                                         match = optionalSpacing$Rule();
                                                         if (match) {
                                                            // PlSqlAnyIdentifier?
                                                            Node lastNode_1 = currentNode;
                                                            int lastIndex_1 = index;
                                                            // PlSqlAnyIdentifier
                                                            match = plSqlAnyIdentifier$Rule();
                                                            if (! match) {
                                                               lastNode_1.setSibling(null);
                                                               currentNode = lastNode_1;
                                                               index = lastIndex_1;
                                                               match = true;
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forLoopStatement$RuleMemoStart = startIndex;
         forLoopStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forLoopStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_LOOP_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forLoopStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forLoopStatement$RuleMemoStart = startIndex;
         forLoopStatement$RuleMemoEnd = -1;
         forLoopStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RangeBounds : (("reverse" TestNoAlpha OptionalSpacing)? Range)
   protected boolean rangeBounds$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RangeBounds", index);
      }
      if (rangeBounds$RuleMemoStart == index) {
         if (rangeBounds$RuleMemoStart <= rangeBounds$RuleMemoEnd) {
            index = rangeBounds$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RANGE_BOUNDS, rangeBounds$RuleMemoStart, rangeBounds$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (rangeBounds$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(rangeBounds$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (("reverse" TestNoAlpha OptionalSpacing)? Range)
      // ("reverse" TestNoAlpha OptionalSpacing)?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("reverse" TestNoAlpha OptionalSpacing)
      // "reverse"
      match = ignoreCaseStringMatcher("reverse", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // Range
         match = range$Rule();
      }
      if (match) {
         rangeBounds$RuleMemoStart = startIndex;
         rangeBounds$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rangeBounds$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RANGE_BOUNDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rangeBounds$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         rangeBounds$RuleMemoStart = startIndex;
         rangeBounds$RuleMemoEnd = -1;
         rangeBounds$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorBounds : (PlSqlObjectIdentifier PlSqlExpressionList?)
   protected boolean cursorBounds$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorBounds", index);
      }
      if (cursorBounds$RuleMemoStart == index) {
         if (cursorBounds$RuleMemoStart <= cursorBounds$RuleMemoEnd) {
            index = cursorBounds$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_BOUNDS, cursorBounds$RuleMemoStart, cursorBounds$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (cursorBounds$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(cursorBounds$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlObjectIdentifier PlSqlExpressionList?)
      // PlSqlObjectIdentifier
      match = plSqlObjectIdentifier$Rule();
      if (match) {
         // PlSqlExpressionList?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // PlSqlExpressionList
         match = plSqlExpressionList$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
      }
      if (match) {
         cursorBounds$RuleMemoStart = startIndex;
         cursorBounds$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cursorBounds$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_BOUNDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cursorBounds$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         cursorBounds$RuleMemoStart = startIndex;
         cursorBounds$RuleMemoEnd = -1;
         cursorBounds$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SelectBounds : ('(' OptionalSpacing SelectStatement ')' OptionalSpacing)
   protected boolean selectBounds$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SelectBounds", index);
      }
      if (selectBounds$RuleMemoStart == index) {
         if (selectBounds$RuleMemoStart <= selectBounds$RuleMemoEnd) {
            index = selectBounds$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SELECT_BOUNDS, selectBounds$RuleMemoStart, selectBounds$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (selectBounds$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(selectBounds$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SelectStatement ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SelectStatement
            match = selectStatement$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         selectBounds$RuleMemoStart = startIndex;
         selectBounds$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectBounds$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SELECT_BOUNDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectBounds$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         selectBounds$RuleMemoStart = startIndex;
         selectBounds$RuleMemoEnd = -1;
         selectBounds$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForBoundsClause : (RangeBounds | CursorBounds | SelectBounds)
   protected boolean forBoundsClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForBoundsClause", index);
      }
      startIndex = index;
      // (RangeBounds | CursorBounds | SelectBounds)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\'':
         case ':':
         case '+':
         case '-': {
            // RangeBounds
            match = rangeBounds$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // RangeBounds
            match = rangeBounds$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // CursorBounds
               match = cursorBounds$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case '(': {
            // RangeBounds
            match = rangeBounds$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // SelectBounds
               match = selectBounds$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_BOUNDS_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForAllStatement : ("forall" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "in" TestNoAlpha OptionalSpacing ForAllBoundsClause ("save" TestNoAlpha OptionalSpacing "exceptions" TestNoAlpha OptionalSpacing)? (ExecuteImmediateStatement | SqlStatement))
   protected boolean forAllStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForAllStatement", index);
      }
      if (forAllStatement$RuleMemoStart == index) {
         if (forAllStatement$RuleMemoStart <= forAllStatement$RuleMemoEnd) {
            index = forAllStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FOR_ALL_STATEMENT, forAllStatement$RuleMemoStart, forAllStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (forAllStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(forAllStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("forall" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier "in" TestNoAlpha OptionalSpacing ForAllBoundsClause ("save" TestNoAlpha OptionalSpacing "exceptions" TestNoAlpha OptionalSpacing)? (ExecuteImmediateStatement | SqlStatement))
      // "forall"
      match = ignoreCaseStringMatcher("forall", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (match) {
                  // "in"
                  match = ignoreCaseStringMatcher("in", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // ForAllBoundsClause
                           match = forAllBoundsClause$Rule();
                           if (match) {
                              // ("save" TestNoAlpha OptionalSpacing "exceptions" TestNoAlpha OptionalSpacing)?
                              Node lastNode_1 = currentNode;
                              int lastIndex_1 = index;
                              // ("save" TestNoAlpha OptionalSpacing "exceptions" TestNoAlpha OptionalSpacing)
                              // "save"
                              match = ignoreCaseStringMatcher("save", 4);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "exceptions"
                                       match = ignoreCaseStringMatcher("exceptions", 10);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                              if (! match) {
                                 lastNode_1.setSibling(null);
                                 currentNode = lastNode_1;
                                 index = lastIndex_1;
                                 match = true;
                              }
                              if (match) {
                                 // (ExecuteImmediateStatement | SqlStatement)
                                 Node lastNode_2 = currentNode;
                                 int lastIndex_2 = index;
                                 switch(buffer.getChar(index)) {
                                    case 'c':
                                    case 'C':
                                    case 'd':
                                    case 'D':
                                    case '(':
                                    case 'i':
                                    case 'I':
                                    case 'l':
                                    case 'L':
                                    case 'm':
                                    case 'M':
                                    case 'r':
                                    case 'R':
                                    case 's':
                                    case 'S':
                                    case 'u':
                                    case 'U':
                                    case 'w':
                                    case 'W': {
                                       // SqlStatement
                                       match = sqlStatement$Rule();
                                       if (! match) {
                                          index = lastIndex_2;
                                          lastNode_2.setSibling(null);
                                          currentNode = lastNode_2;
                                       }
                                       break;
                                    }
                                    case 'e':
                                    case 'E': {
                                       // ExecuteImmediateStatement
                                       match = executeImmediateStatement$Rule();
                                       if (! match) {
                                          index = lastIndex_2;
                                          lastNode_2.setSibling(null);
                                          currentNode = lastNode_2;
                                       }
                                       break;
                                    }
                                    default: {
                                       match = false;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forAllStatement$RuleMemoStart = startIndex;
         forAllStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forAllStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_ALL_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forAllStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         forAllStatement$RuleMemoStart = startIndex;
         forAllStatement$RuleMemoEnd = -1;
         forAllStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Range : (NumericExpression ".." OptionalSpacing NumericExpression)
   protected boolean range$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Range", index);
      }
      if (range$RuleMemoStart == index) {
         if (range$RuleMemoStart <= range$RuleMemoEnd) {
            index = range$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RANGE, range$RuleMemoStart, range$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (range$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(range$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (NumericExpression ".." OptionalSpacing NumericExpression)
      // NumericExpression
      match = numericExpression$Rule();
      if (match) {
         // ".."
         match = ignoreCaseStringMatcher("..", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // NumericExpression
               match = numericExpression$Rule();
            }
         }
      }
      if (match) {
         range$RuleMemoStart = startIndex;
         range$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            range$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RANGE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            range$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         range$RuleMemoStart = startIndex;
         range$RuleMemoEnd = -1;
         range$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BetweenBounds : ("between" TestNoAlpha OptionalSpacing NumericExpression "and" TestNoAlpha OptionalSpacing NumericExpression)
   protected boolean betweenBounds$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BetweenBounds", index);
      }
      if (betweenBounds$RuleMemoStart == index) {
         if (betweenBounds$RuleMemoStart <= betweenBounds$RuleMemoEnd) {
            index = betweenBounds$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_BOUNDS, betweenBounds$RuleMemoStart, betweenBounds$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (betweenBounds$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(betweenBounds$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("between" TestNoAlpha OptionalSpacing NumericExpression "and" TestNoAlpha OptionalSpacing NumericExpression)
      // "between"
      match = ignoreCaseStringMatcher("between", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // NumericExpression
               match = numericExpression$Rule();
               if (match) {
                  // "and"
                  match = ignoreCaseStringMatcher("and", 3);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // NumericExpression
                           match = numericExpression$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         betweenBounds$RuleMemoStart = startIndex;
         betweenBounds$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            betweenBounds$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BETWEEN_BOUNDS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            betweenBounds$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         betweenBounds$RuleMemoStart = startIndex;
         betweenBounds$RuleMemoEnd = -1;
         betweenBounds$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IndicesOfCollection : ("indices" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing PlSqlAtomicExpression BetweenBounds?)
   protected boolean indicesOfCollection$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IndicesOfCollection", index);
      }
      if (indicesOfCollection$RuleMemoStart == index) {
         if (indicesOfCollection$RuleMemoStart <= indicesOfCollection$RuleMemoEnd) {
            index = indicesOfCollection$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.INDICES_OF_COLLECTION, indicesOfCollection$RuleMemoStart, indicesOfCollection$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (indicesOfCollection$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(indicesOfCollection$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("indices" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing PlSqlAtomicExpression BetweenBounds?)
      // "indices"
      match = ignoreCaseStringMatcher("indices", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "of"
               match = ignoreCaseStringMatcher("of", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // PlSqlAtomicExpression
                        match = plSqlAtomicExpression$Rule();
                        if (match) {
                           // BetweenBounds?
                           Node lastNode_1 = currentNode;
                           int lastIndex_1 = index;
                           // BetweenBounds
                           match = betweenBounds$Rule();
                           if (! match) {
                              lastNode_1.setSibling(null);
                              currentNode = lastNode_1;
                              index = lastIndex_1;
                              match = true;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         indicesOfCollection$RuleMemoStart = startIndex;
         indicesOfCollection$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            indicesOfCollection$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.INDICES_OF_COLLECTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            indicesOfCollection$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         indicesOfCollection$RuleMemoStart = startIndex;
         indicesOfCollection$RuleMemoEnd = -1;
         indicesOfCollection$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ValuesOfIndexCollection : ("values" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing PlSqlAtomicExpression)
   protected boolean valuesOfIndexCollection$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ValuesOfIndexCollection", index);
      }
      if (valuesOfIndexCollection$RuleMemoStart == index) {
         if (valuesOfIndexCollection$RuleMemoStart <= valuesOfIndexCollection$RuleMemoEnd) {
            index = valuesOfIndexCollection$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.VALUES_OF_INDEX_COLLECTION, valuesOfIndexCollection$RuleMemoStart, valuesOfIndexCollection$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (valuesOfIndexCollection$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(valuesOfIndexCollection$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("values" TestNoAlpha OptionalSpacing "of" TestNoAlpha OptionalSpacing PlSqlAtomicExpression)
      // "values"
      match = ignoreCaseStringMatcher("values", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "of"
               match = ignoreCaseStringMatcher("of", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // PlSqlAtomicExpression
                        match = plSqlAtomicExpression$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         valuesOfIndexCollection$RuleMemoStart = startIndex;
         valuesOfIndexCollection$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valuesOfIndexCollection$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.VALUES_OF_INDEX_COLLECTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valuesOfIndexCollection$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         valuesOfIndexCollection$RuleMemoStart = startIndex;
         valuesOfIndexCollection$RuleMemoEnd = -1;
         valuesOfIndexCollection$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForAllBoundsClause : (Range | IndicesOfCollection | ValuesOfIndexCollection)
   protected boolean forAllBoundsClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForAllBoundsClause", index);
      }
      startIndex = index;
      // (Range | IndicesOfCollection | ValuesOfIndexCollection)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // Range
            match = range$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'V':
         case 'v': {
            // Range
            match = range$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // ValuesOfIndexCollection
               match = valuesOfIndexCollection$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'I':
         case 'i': {
            // Range
            match = range$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // IndicesOfCollection
               match = indicesOfCollection$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_ALL_BOUNDS_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //GotoStatement : ("goto" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)
   protected boolean gotoStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "GotoStatement", index);
      }
      if (gotoStatement$RuleMemoStart == index) {
         if (gotoStatement$RuleMemoStart <= gotoStatement$RuleMemoEnd) {
            index = gotoStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.GOTO_STATEMENT, gotoStatement$RuleMemoStart, gotoStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (gotoStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(gotoStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("goto" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier)
      // "goto"
      match = ignoreCaseStringMatcher("goto", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
            }
         }
      }
      if (match) {
         gotoStatement$RuleMemoStart = startIndex;
         gotoStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            gotoStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.GOTO_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            gotoStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         gotoStatement$RuleMemoStart = startIndex;
         gotoStatement$RuleMemoEnd = -1;
         gotoStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlStatements : (PlSqlStatement ';' OptionalSpacing)+
   protected boolean plSqlStatements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlStatements", index);
      }
      if (plSqlStatements$RuleMemoStart == index) {
         if (plSqlStatements$RuleMemoStart <= plSqlStatements$RuleMemoEnd) {
            index = plSqlStatements$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_STATEMENTS, plSqlStatements$RuleMemoStart, plSqlStatements$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlStatements$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlStatements$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlStatement ';' OptionalSpacing)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (PlSqlStatement ';' OptionalSpacing)
      // PlSqlStatement
      match = plSqlStatement$Rule();
      if (match) {
         // ';'
         match = charMatcher(';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (PlSqlStatement ';' OptionalSpacing)
            // PlSqlStatement
            match = plSqlStatement$Rule();
            if (match) {
               // ';'
               match = charMatcher(';');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         plSqlStatements$RuleMemoStart = startIndex;
         plSqlStatements$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlStatements$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_STATEMENTS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlStatements$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlStatements$RuleMemoStart = startIndex;
         plSqlStatements$RuleMemoEnd = -1;
         plSqlStatements$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ElsIf : ("elsif" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements)
   protected boolean elsIf$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ElsIf", index);
      }
      startIndex = index;
      // ("elsif" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements)
      // "elsif"
      match = ignoreCaseStringMatcher("elsif", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlStatements
                           match = plSqlStatements$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ELS_IF, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ElsIfList : ElsIf*
   protected boolean elsIfList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ElsIfList", index);
      }
      startIndex = index;
      // ElsIf*
      Node lastNode_1;
      int lastIndex_1;
      do {
         lastNode_1 = currentNode;
         lastIndex_1 = index;
         // ElsIf
         match = elsIf$Rule();
      } while(match);
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      index = lastIndex_1;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(OracleScriptRuleType.ELS_IF_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      if (trace) {
         tracePath.exitRule(buffer, index, true);
      }
      return true;
   }

   //ElseBody : ("else" TestNoAlpha OptionalSpacing PlSqlStatements)
   protected boolean elseBody$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ElseBody", index);
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing PlSqlStatements)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlStatements
               match = plSqlStatements$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ELSE_BODY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Else : ElseBody?
   protected boolean else$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Else", index);
      }
      startIndex = index;
      // ElseBody?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ElseBody
      match = elseBody$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.ELSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //IfStatement : ("if" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements ElsIfList Else "end" TestNoAlpha OptionalSpacing "if" TestNoAlpha OptionalSpacing)
   protected boolean ifStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "IfStatement", index);
      }
      if (ifStatement$RuleMemoStart == index) {
         if (ifStatement$RuleMemoStart <= ifStatement$RuleMemoEnd) {
            index = ifStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IF_STATEMENT, ifStatement$RuleMemoStart, ifStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (ifStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(ifStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("if" TestNoAlpha OptionalSpacing PlSqlExpression "then" TestNoAlpha OptionalSpacing PlSqlStatements ElsIfList Else "end" TestNoAlpha OptionalSpacing "if" TestNoAlpha OptionalSpacing)
      // "if"
      match = ignoreCaseStringMatcher("if", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlStatements
                           match = plSqlStatements$Rule();
                           if (match) {
                              // ElsIfList
                              match = elsIfList$Rule();
                              if (match) {
                                 // Else
                                 match = else$Rule();
                                 if (match) {
                                    // "end"
                                    match = ignoreCaseStringMatcher("end", 3);
                                    if (match) {
                                       // TestNoAlpha
                                       match = testNoAlpha$Rule();
                                       if (match) {
                                          // OptionalSpacing
                                          match = optionalSpacing$Rule();
                                          if (match) {
                                             // "if"
                                             match = ignoreCaseStringMatcher("if", 2);
                                             if (match) {
                                                // TestNoAlpha
                                                match = testNoAlpha$Rule();
                                                if (match) {
                                                   // OptionalSpacing
                                                   match = optionalSpacing$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         ifStatement$RuleMemoStart = startIndex;
         ifStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IF_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         ifStatement$RuleMemoStart = startIndex;
         ifStatement$RuleMemoEnd = -1;
         ifStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //NullStatement : NullLiteral
   protected boolean nullStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "NullStatement", index);
      }
      if (nullStatement$RuleMemoStart == index) {
         if (nullStatement$RuleMemoStart <= nullStatement$RuleMemoEnd) {
            index = nullStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.NULL_STATEMENT, nullStatement$RuleMemoStart, nullStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (nullStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(nullStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // NullLiteral
      match = nullLiteral$Rule();
      if (match) {
         nullStatement$RuleMemoStart = startIndex;
         nullStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nullStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.NULL_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nullStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         nullStatement$RuleMemoStart = startIndex;
         nullStatement$RuleMemoEnd = -1;
         nullStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorSource : (SelectStatement | PlSqlExpression)
   protected boolean cursorSource$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorSource", index);
      }
      startIndex = index;
      // (SelectStatement | PlSqlExpression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '\'':
         case '+':
         case '-':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'T':
         case 'U':
         case 'V':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 't':
         case 'u':
         case 'v':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlExpression
            match = plSqlExpression$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 'S':
         case 's':
         case 'W':
         case 'w':
         case '(': {
            // SelectStatement
            match = selectStatement$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_SOURCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //CursorUsingClause : UsingClause?
   protected boolean cursorUsingClause$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "CursorUsingClause", index);
      }
      startIndex = index;
      // UsingClause?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // UsingClause
      match = usingClause$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.CURSOR_USING_CLAUSE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForCursorSource : ("for" TestNoAlpha OptionalSpacing CursorSource CursorUsingClause)
   protected boolean forCursorSource$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForCursorSource", index);
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing CursorSource CursorUsingClause)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CursorSource
               match = cursorSource$Rule();
               if (match) {
                  // CursorUsingClause
                  match = cursorUsingClause$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_CURSOR_SOURCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ForCursor : ForCursorSource?
   protected boolean forCursor$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ForCursor", index);
      }
      startIndex = index;
      // ForCursorSource?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ForCursorSource
      match = forCursorSource$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.FOR_CURSOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OpenStatement : ("open" TestNoAlpha OptionalSpacing PlSqlObjectIdentifier ForCursor)
   protected boolean openStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OpenStatement", index);
      }
      if (openStatement$RuleMemoStart == index) {
         if (openStatement$RuleMemoStart <= openStatement$RuleMemoEnd) {
            index = openStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.OPEN_STATEMENT, openStatement$RuleMemoStart, openStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (openStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(openStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("open" TestNoAlpha OptionalSpacing PlSqlObjectIdentifier ForCursor)
      // "open"
      match = ignoreCaseStringMatcher("open", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlObjectIdentifier
               match = plSqlObjectIdentifier$Rule();
               if (match) {
                  // ForCursor
                  match = forCursor$Rule();
               }
            }
         }
      }
      if (match) {
         openStatement$RuleMemoStart = startIndex;
         openStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            openStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.OPEN_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            openStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         openStatement$RuleMemoStart = startIndex;
         openStatement$RuleMemoEnd = -1;
         openStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //AnonymousPlSqlBlock : (DeclarationSection? PlSqlBody)
   protected boolean anonymousPlSqlBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "AnonymousPlSqlBlock", index);
      }
      if (anonymousPlSqlBlock$RuleMemoStart == index) {
         if (anonymousPlSqlBlock$RuleMemoStart <= anonymousPlSqlBlock$RuleMemoEnd) {
            index = anonymousPlSqlBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.ANONYMOUS_PL_SQL_BLOCK, anonymousPlSqlBlock$RuleMemoStart, anonymousPlSqlBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (anonymousPlSqlBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(anonymousPlSqlBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (DeclarationSection? PlSqlBody)
      // DeclarationSection?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // DeclarationSection
      match = declarationSection$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         // PlSqlBody
         match = plSqlBody$Rule();
      }
      if (match) {
         anonymousPlSqlBlock$RuleMemoStart = startIndex;
         anonymousPlSqlBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anonymousPlSqlBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.ANONYMOUS_PL_SQL_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anonymousPlSqlBlock$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         anonymousPlSqlBlock$RuleMemoStart = startIndex;
         anonymousPlSqlBlock$RuleMemoEnd = -1;
         anonymousPlSqlBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlBlock : (Labels DeclarationSection? PlSqlBody)
   protected boolean plSqlBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlBlock", index);
      }
      if (plSqlBlock$RuleMemoStart == index) {
         if (plSqlBlock$RuleMemoStart <= plSqlBlock$RuleMemoEnd) {
            index = plSqlBlock$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_BLOCK, plSqlBlock$RuleMemoStart, plSqlBlock$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlBlock$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlBlock$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (Labels DeclarationSection? PlSqlBody)
      // Labels
      match = labels$Rule();
      if (match) {
         // DeclarationSection?
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // DeclarationSection
         match = declarationSection$Rule();
         if (! match) {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         }
         if (match) {
            // PlSqlBody
            match = plSqlBody$Rule();
         }
      }
      if (match) {
         plSqlBlock$RuleMemoStart = startIndex;
         plSqlBlock$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlBlock$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlBlock$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlBlock$RuleMemoStart = startIndex;
         plSqlBlock$RuleMemoEnd = -1;
         plSqlBlock$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //RaiseStatement : ("raise" TestNoAlpha OptionalSpacing SqlObjectIdentifier?)
   protected boolean raiseStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "RaiseStatement", index);
      }
      if (raiseStatement$RuleMemoStart == index) {
         if (raiseStatement$RuleMemoStart <= raiseStatement$RuleMemoEnd) {
            index = raiseStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RAISE_STATEMENT, raiseStatement$RuleMemoStart, raiseStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (raiseStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(raiseStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("raise" TestNoAlpha OptionalSpacing SqlObjectIdentifier?)
      // "raise"
      match = ignoreCaseStringMatcher("raise", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SqlObjectIdentifier?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // SqlObjectIdentifier
               match = sqlObjectIdentifier$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         raiseStatement$RuleMemoStart = startIndex;
         raiseStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            raiseStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RAISE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            raiseStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         raiseStatement$RuleMemoStart = startIndex;
         raiseStatement$RuleMemoEnd = -1;
         raiseStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturnStatement : ("return" TestNoAlpha OptionalSpacing PlSqlExpression?)
   protected boolean returnStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturnStatement", index);
      }
      if (returnStatement$RuleMemoStart == index) {
         if (returnStatement$RuleMemoStart <= returnStatement$RuleMemoEnd) {
            index = returnStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RETURN_STATEMENT, returnStatement$RuleMemoStart, returnStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (returnStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(returnStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("return" TestNoAlpha OptionalSpacing PlSqlExpression?)
      // "return"
      match = ignoreCaseStringMatcher("return", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression?
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (! match) {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               }
            }
         }
      }
      if (match) {
         returnStatement$RuleMemoStart = startIndex;
         returnStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            returnStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURN_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            returnStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         returnStatement$RuleMemoStart = startIndex;
         returnStatement$RuleMemoEnd = -1;
         returnStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //WhileLoopStatement : ("while" TestNoAlpha OptionalSpacing PlSqlExpression "loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
   protected boolean whileLoopStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "WhileLoopStatement", index);
      }
      if (whileLoopStatement$RuleMemoStart == index) {
         if (whileLoopStatement$RuleMemoStart <= whileLoopStatement$RuleMemoEnd) {
            index = whileLoopStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.WHILE_LOOP_STATEMENT, whileLoopStatement$RuleMemoStart, whileLoopStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (whileLoopStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(whileLoopStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("while" TestNoAlpha OptionalSpacing PlSqlExpression "loop" TestNoAlpha OptionalSpacing PlSqlStatements "end" TestNoAlpha OptionalSpacing "loop" TestNoAlpha OptionalSpacing PlSqlAnyIdentifier?)
      // "while"
      match = ignoreCaseStringMatcher("while", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlExpression
               match = plSqlExpression$Rule();
               if (match) {
                  // "loop"
                  match = ignoreCaseStringMatcher("loop", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlStatements
                           match = plSqlStatements$Rule();
                           if (match) {
                              // "end"
                              match = ignoreCaseStringMatcher("end", 3);
                              if (match) {
                                 // TestNoAlpha
                                 match = testNoAlpha$Rule();
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (match) {
                                       // "loop"
                                       match = ignoreCaseStringMatcher("loop", 4);
                                       if (match) {
                                          // TestNoAlpha
                                          match = testNoAlpha$Rule();
                                          if (match) {
                                             // OptionalSpacing
                                             match = optionalSpacing$Rule();
                                             if (match) {
                                                // PlSqlAnyIdentifier?
                                                Node lastNode_1 = currentNode;
                                                int lastIndex_1 = index;
                                                // PlSqlAnyIdentifier
                                                match = plSqlAnyIdentifier$Rule();
                                                if (! match) {
                                                   lastNode_1.setSibling(null);
                                                   currentNode = lastNode_1;
                                                   index = lastIndex_1;
                                                   match = true;
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         whileLoopStatement$RuleMemoStart = startIndex;
         whileLoopStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            whileLoopStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.WHILE_LOOP_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            whileLoopStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         whileLoopStatement$RuleMemoStart = startIndex;
         whileLoopStatement$RuleMemoEnd = -1;
         whileLoopStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PipeRowStatement : ("pipe" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ')' OptionalSpacing)
   protected boolean pipeRowStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PipeRowStatement", index);
      }
      if (pipeRowStatement$RuleMemoStart == index) {
         if (pipeRowStatement$RuleMemoStart <= pipeRowStatement$RuleMemoEnd) {
            index = pipeRowStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PIPE_ROW_STATEMENT, pipeRowStatement$RuleMemoStart, pipeRowStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (pipeRowStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(pipeRowStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("pipe" TestNoAlpha OptionalSpacing "row" TestNoAlpha OptionalSpacing '(' OptionalSpacing PlSqlAnyIdentifier ')' OptionalSpacing)
      // "pipe"
      match = ignoreCaseStringMatcher("pipe", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "row"
               match = ignoreCaseStringMatcher("row", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // '('
                        match = charMatcher('(');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // PlSqlAnyIdentifier
                              match = plSqlAnyIdentifier$Rule();
                              if (match) {
                                 // ')'
                                 match = charMatcher(')');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         pipeRowStatement$RuleMemoStart = startIndex;
         pipeRowStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pipeRowStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PIPE_ROW_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pipeRowStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         pipeRowStatement$RuleMemoStart = startIndex;
         pipeRowStatement$RuleMemoEnd = -1;
         pipeRowStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SqlStatement : DmlSentence
   protected boolean sqlStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SqlStatement", index);
      }
      if (sqlStatement$RuleMemoStart == index) {
         if (sqlStatement$RuleMemoStart <= sqlStatement$RuleMemoEnd) {
            index = sqlStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.SQL_STATEMENT, sqlStatement$RuleMemoStart, sqlStatement$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (sqlStatement$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(sqlStatement$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // DmlSentence
      match = dmlSentence$Rule();
      if (match) {
         sqlStatement$RuleMemoStart = startIndex;
         sqlStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sqlStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.SQL_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sqlStatement$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         sqlStatement$RuleMemoStart = startIndex;
         sqlStatement$RuleMemoEnd = -1;
         sqlStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlExpressionList : ('(' OptionalSpacing PlSqlExpression (',' OptionalSpacing PlSqlExpression)* ')' OptionalSpacing)
   protected boolean plSqlExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlExpressionList", index);
      }
      if (plSqlExpressionList$RuleMemoStart == index) {
         if (plSqlExpressionList$RuleMemoStart <= plSqlExpressionList$RuleMemoEnd) {
            index = plSqlExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_EXPRESSION_LIST, plSqlExpressionList$RuleMemoStart, plSqlExpressionList$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlExpressionList$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlExpressionList$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing PlSqlExpression (',' OptionalSpacing PlSqlExpression)* ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlExpression
            match = plSqlExpression$Rule();
            if (match) {
               // (',' OptionalSpacing PlSqlExpression)*
               Node lastNode_1;
               int lastIndex_1;
               do {
                  lastNode_1 = currentNode;
                  lastIndex_1 = index;
                  // (',' OptionalSpacing PlSqlExpression)
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // PlSqlExpression
                        match = plSqlExpression$Rule();
                     }
                  }
               } while(match);
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               index = lastIndex_1;
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         plSqlExpressionList$RuleMemoStart = startIndex;
         plSqlExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlExpressionList$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlExpressionList$RuleMemoStart = startIndex;
         plSqlExpressionList$RuleMemoEnd = -1;
         plSqlExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //OrHandlerIdentifier : ("or" TestNoAlpha OptionalSpacing PlSqlObjectIdentifier)
   protected boolean orHandlerIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "OrHandlerIdentifier", index);
      }
      startIndex = index;
      // ("or" TestNoAlpha OptionalSpacing PlSqlObjectIdentifier)
      // "or"
      match = ignoreCaseStringMatcher("or", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // PlSqlObjectIdentifier
               match = plSqlObjectIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.OR_HANDLER_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MultipleHandlerIdentifier : (PlSqlObjectIdentifier OrHandlerIdentifier*)
   protected boolean multipleHandlerIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MultipleHandlerIdentifier", index);
      }
      if (multipleHandlerIdentifier$RuleMemoStart == index) {
         if (multipleHandlerIdentifier$RuleMemoStart <= multipleHandlerIdentifier$RuleMemoEnd) {
            index = multipleHandlerIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.MULTIPLE_HANDLER_IDENTIFIER, multipleHandlerIdentifier$RuleMemoStart, multipleHandlerIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (multipleHandlerIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(multipleHandlerIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlObjectIdentifier OrHandlerIdentifier*)
      // PlSqlObjectIdentifier
      match = plSqlObjectIdentifier$Rule();
      if (match) {
         // OrHandlerIdentifier*
         Node lastNode_1;
         int lastIndex_1;
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // OrHandlerIdentifier
            match = orHandlerIdentifier$Rule();
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         multipleHandlerIdentifier$RuleMemoStart = startIndex;
         multipleHandlerIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            multipleHandlerIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.MULTIPLE_HANDLER_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            multipleHandlerIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         multipleHandlerIdentifier$RuleMemoStart = startIndex;
         multipleHandlerIdentifier$RuleMemoEnd = -1;
         multipleHandlerIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //HandlerIdentifiers : (("others" TestNoAlpha OptionalSpacing) | ("Others" TestNoAlpha OptionalSpacing) | MultipleHandlerIdentifier)
   protected boolean handlerIdentifiers$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "HandlerIdentifiers", index);
      }
      startIndex = index;
      // (("others" TestNoAlpha OptionalSpacing) | ("Others" TestNoAlpha OptionalSpacing) | MultipleHandlerIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("others" TestNoAlpha OptionalSpacing)
      // "others"
      match = ignoreCaseStringMatcher("others", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ("Others" TestNoAlpha OptionalSpacing)
         // "Others"
         match = ignoreCaseStringMatcher("Others", 6);
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            // MultipleHandlerIdentifier
            match = multipleHandlerIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.HANDLER_IDENTIFIERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExceptionHandler : ("when" TestNoAlpha OptionalSpacing HandlerIdentifiers "then" TestNoAlpha OptionalSpacing PlSqlStatements)
   protected boolean exceptionHandler$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExceptionHandler", index);
      }
      startIndex = index;
      // ("when" TestNoAlpha OptionalSpacing HandlerIdentifiers "then" TestNoAlpha OptionalSpacing PlSqlStatements)
      // "when"
      match = ignoreCaseStringMatcher("when", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // HandlerIdentifiers
               match = handlerIdentifiers$Rule();
               if (match) {
                  // "then"
                  match = ignoreCaseStringMatcher("then", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // PlSqlStatements
                           match = plSqlStatements$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EXCEPTION_HANDLER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ExceptionBlock : ("exception" TestNoAlpha OptionalSpacing ExceptionHandler+)
   protected boolean exceptionBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ExceptionBlock", index);
      }
      startIndex = index;
      // ("exception" TestNoAlpha OptionalSpacing ExceptionHandler+)
      // "exception"
      match = ignoreCaseStringMatcher("exception", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ExceptionHandler+
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // ExceptionHandler
               match = exceptionHandler$Rule();
               if (match) {
                  do {
                     lastNode_1 = currentNode;
                     lastIndex_1 = index;
                     // ExceptionHandler
                     match = exceptionHandler$Rule();
                  } while(match);
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
                  match = true;
               } else {
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  index = lastIndex_1;
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.EXCEPTION_BLOCK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ParametersDeclaration : ParenthesesParametersDeclaration?
   protected boolean parametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ParametersDeclaration", index);
      }
      if (parametersDeclaration$RuleMemoStart == index) {
         if (parametersDeclaration$RuleMemoStart <= parametersDeclaration$RuleMemoEnd) {
            index = parametersDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS_DECLARATION, parametersDeclaration$RuleMemoStart, parametersDeclaration$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (parametersDeclaration$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(parametersDeclaration$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ParenthesesParametersDeclaration?
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ParenthesesParametersDeclaration
      match = parenthesesParametersDeclaration$Rule();
      if (! match) {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      }
      if (match) {
         parametersDeclaration$RuleMemoStart = startIndex;
         parametersDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parametersDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parametersDeclaration$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         parametersDeclaration$RuleMemoStart = startIndex;
         parametersDeclaration$RuleMemoEnd = -1;
         parametersDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ReturnType : ("return" TestNoAlpha OptionalSpacing TypeSpec)
   protected boolean returnType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ReturnType", index);
      }
      if (returnType$RuleMemoStart == index) {
         if (returnType$RuleMemoStart <= returnType$RuleMemoEnd) {
            index = returnType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.RETURN_TYPE, returnType$RuleMemoStart, returnType$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (returnType$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(returnType$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("return" TestNoAlpha OptionalSpacing TypeSpec)
      // "return"
      match = ignoreCaseStringMatcher("return", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // TypeSpec
               match = typeSpec$Rule();
            }
         }
      }
      if (match) {
         returnType$RuleMemoStart = startIndex;
         returnType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            returnType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.RETURN_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            returnType$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         returnType$RuleMemoStart = startIndex;
         returnType$RuleMemoEnd = -1;
         returnType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //FunctionHeading : ("function" TestNoAlpha OptionalSpacing SchemaObjectName ParametersDeclaration ReturnType)
   protected boolean functionHeading$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "FunctionHeading", index);
      }
      if (functionHeading$RuleMemoStart == index) {
         if (functionHeading$RuleMemoStart <= functionHeading$RuleMemoEnd) {
            index = functionHeading$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_HEADING, functionHeading$RuleMemoStart, functionHeading$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (functionHeading$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(functionHeading$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("function" TestNoAlpha OptionalSpacing SchemaObjectName ParametersDeclaration ReturnType)
      // "function"
      match = ignoreCaseStringMatcher("function", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SchemaObjectName
               match = schemaObjectName$Rule();
               if (match) {
                  // ParametersDeclaration
                  match = parametersDeclaration$Rule();
                  if (match) {
                     // ReturnType
                     match = returnType$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         functionHeading$RuleMemoStart = startIndex;
         functionHeading$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionHeading$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.FUNCTION_HEADING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionHeading$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         functionHeading$RuleMemoStart = startIndex;
         functionHeading$RuleMemoEnd = -1;
         functionHeading$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //ProcedureHeading : ("procedure" TestNoAlpha OptionalSpacing SchemaObjectName ParametersDeclaration)
   protected boolean procedureHeading$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "ProcedureHeading", index);
      }
      if (procedureHeading$RuleMemoStart == index) {
         if (procedureHeading$RuleMemoStart <= procedureHeading$RuleMemoEnd) {
            index = procedureHeading$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_HEADING, procedureHeading$RuleMemoStart, procedureHeading$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (procedureHeading$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(procedureHeading$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ("procedure" TestNoAlpha OptionalSpacing SchemaObjectName ParametersDeclaration)
      // "procedure"
      match = ignoreCaseStringMatcher("procedure", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SchemaObjectName
               match = schemaObjectName$Rule();
               if (match) {
                  // ParametersDeclaration
                  match = parametersDeclaration$Rule();
               }
            }
         }
      }
      if (match) {
         procedureHeading$RuleMemoStart = startIndex;
         procedureHeading$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            procedureHeading$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PROCEDURE_HEADING, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            procedureHeading$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         procedureHeading$RuleMemoStart = startIndex;
         procedureHeading$RuleMemoEnd = -1;
         procedureHeading$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BooleanLiteral : (BooleanPattern OptionalSpacing)
   protected boolean booleanLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BooleanLiteral", index);
      }
      if (booleanLiteral$RuleMemoStart == index) {
         if (booleanLiteral$RuleMemoStart <= booleanLiteral$RuleMemoEnd) {
            index = booleanLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.BOOLEAN_LITERAL, booleanLiteral$RuleMemoStart, booleanLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (booleanLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(booleanLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BooleanPattern OptionalSpacing)
      // BooleanPattern
      match = booleanPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         booleanLiteral$RuleMemoStart = startIndex;
         booleanLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            booleanLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.BOOLEAN_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            booleanLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         booleanLiteral$RuleMemoStart = startIndex;
         booleanLiteral$RuleMemoEnd = -1;
         booleanLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //BooleanPattern : ("true" | "false")
   protected boolean booleanPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "BooleanPattern", index);
      }
      startIndex = index;
      // ("true" | "false")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // "alse"
            if (match = ignoreCaseStringTest("alse", 4)) {
               index += 4;
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // "rue"
            if (match = ignoreCaseStringTest("rue", 3)) {
               index += 3;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.BOOLEAN_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlLiteral : (SqlLiteral | BooleanLiteral)
   protected boolean plSqlLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlLiteral", index);
      }
      if (plSqlLiteral$RuleMemoStart == index) {
         if (plSqlLiteral$RuleMemoStart <= plSqlLiteral$RuleMemoEnd) {
            index = plSqlLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_LITERAL, plSqlLiteral$RuleMemoStart, plSqlLiteral$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlLiteral$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlLiteral$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (SqlLiteral | BooleanLiteral)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'd':
         case 'D':
         case '\'':
         case 'i':
         case 'I':
         case '+':
         case '-':
         case 'n':
         case 'N':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9': {
            // SqlLiteral
            match = sqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         case 't':
         case 'T': {
            // SqlLiteral
            match = sqlLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // BooleanLiteral
               match = booleanLiteral$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         case 'f':
         case 'F': {
            // BooleanLiteral
            match = booleanLiteral$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlLiteral$RuleMemoStart = startIndex;
         plSqlLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlLiteral$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlLiteral$RuleMemoStart = startIndex;
         plSqlLiteral$RuleMemoEnd = -1;
         plSqlLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlQualifiedIdentifierRemote : (PlSqlQualifiedIdentifier DBLink PlSqlParameters* PlSqlAttributes?)
   protected boolean plSqlQualifiedIdentifierRemote$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlQualifiedIdentifierRemote", index);
      }
      if (plSqlQualifiedIdentifierRemote$RuleMemoStart == index) {
         if (plSqlQualifiedIdentifierRemote$RuleMemoStart <= plSqlQualifiedIdentifierRemote$RuleMemoEnd) {
            index = plSqlQualifiedIdentifierRemote$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER_REMOTE, plSqlQualifiedIdentifierRemote$RuleMemoStart, plSqlQualifiedIdentifierRemote$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlQualifiedIdentifierRemote$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlQualifiedIdentifierRemote$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlQualifiedIdentifier DBLink PlSqlParameters* PlSqlAttributes?)
      // PlSqlQualifiedIdentifier
      match = plSqlQualifiedIdentifier$Rule();
      if (match) {
         // DBLink
         match = dBLink$Rule();
         if (match) {
            // PlSqlParameters*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // PlSqlParameters
               match = plSqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
            // PlSqlAttributes?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // PlSqlAttributes
            match = plSqlAttributes$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         plSqlQualifiedIdentifierRemote$RuleMemoStart = startIndex;
         plSqlQualifiedIdentifierRemote$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlQualifiedIdentifierRemote$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER_REMOTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlQualifiedIdentifierRemote$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlQualifiedIdentifierRemote$RuleMemoStart = startIndex;
         plSqlQualifiedIdentifierRemote$RuleMemoEnd = -1;
         plSqlQualifiedIdentifierRemote$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlSimpleIdentifierRemote : (PlSqlSimpleIdentifier DBLink PlSqlParameters* PlSqlAttributes?)
   protected boolean plSqlSimpleIdentifierRemote$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlSimpleIdentifierRemote", index);
      }
      if (plSqlSimpleIdentifierRemote$RuleMemoStart == index) {
         if (plSqlSimpleIdentifierRemote$RuleMemoStart <= plSqlSimpleIdentifierRemote$RuleMemoEnd) {
            index = plSqlSimpleIdentifierRemote$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_REMOTE, plSqlSimpleIdentifierRemote$RuleMemoStart, plSqlSimpleIdentifierRemote$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlSimpleIdentifierRemote$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlSimpleIdentifierRemote$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlSimpleIdentifier DBLink PlSqlParameters* PlSqlAttributes?)
      // PlSqlSimpleIdentifier
      match = plSqlSimpleIdentifier$Rule();
      if (match) {
         // DBLink
         match = dBLink$Rule();
         if (match) {
            // PlSqlParameters*
            Node lastNode_1;
            int lastIndex_1;
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // PlSqlParameters
               match = plSqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
            // PlSqlAttributes?
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            // PlSqlAttributes
            match = plSqlAttributes$Rule();
            if (! match) {
               lastNode_2.setSibling(null);
               currentNode = lastNode_2;
               index = lastIndex_2;
               match = true;
            }
         }
      }
      if (match) {
         plSqlSimpleIdentifierRemote$RuleMemoStart = startIndex;
         plSqlSimpleIdentifierRemote$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlSimpleIdentifierRemote$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER_REMOTE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlSimpleIdentifierRemote$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlSimpleIdentifierRemote$RuleMemoStart = startIndex;
         plSqlSimpleIdentifierRemote$RuleMemoEnd = -1;
         plSqlSimpleIdentifierRemote$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAttributes : ('.' OptionalSpacing PlSqlAnySimpleIdentifier)+
   protected boolean plSqlAttributes$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAttributes", index);
      }
      if (plSqlAttributes$RuleMemoStart == index) {
         if (plSqlAttributes$RuleMemoStart <= plSqlAttributes$RuleMemoEnd) {
            index = plSqlAttributes$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ATTRIBUTES, plSqlAttributes$RuleMemoStart, plSqlAttributes$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlAttributes$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlAttributes$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // ('.' OptionalSpacing PlSqlAnySimpleIdentifier)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('.' OptionalSpacing PlSqlAnySimpleIdentifier)
      // '.'
      match = charMatcher('.');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PlSqlAnySimpleIdentifier
            match = plSqlAnySimpleIdentifier$Rule();
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // ('.' OptionalSpacing PlSqlAnySimpleIdentifier)
            // '.'
            match = charMatcher('.');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // PlSqlAnySimpleIdentifier
                  match = plSqlAnySimpleIdentifier$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         plSqlAttributes$RuleMemoStart = startIndex;
         plSqlAttributes$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlAttributes$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ATTRIBUTES, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlAttributes$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlAttributes$RuleMemoStart = startIndex;
         plSqlAttributes$RuleMemoEnd = -1;
         plSqlAttributes$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlQualifiedIdentifier : (PlSqlSimpleIdentifier PlSqlAttributes)
   protected boolean plSqlQualifiedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlQualifiedIdentifier", index);
      }
      if (plSqlQualifiedIdentifier$RuleMemoStart == index) {
         if (plSqlQualifiedIdentifier$RuleMemoStart <= plSqlQualifiedIdentifier$RuleMemoEnd) {
            index = plSqlQualifiedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER, plSqlQualifiedIdentifier$RuleMemoStart, plSqlQualifiedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlQualifiedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlQualifiedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlSimpleIdentifier PlSqlAttributes)
      // PlSqlSimpleIdentifier
      match = plSqlSimpleIdentifier$Rule();
      if (match) {
         // PlSqlAttributes
         match = plSqlAttributes$Rule();
      }
      if (match) {
         plSqlQualifiedIdentifier$RuleMemoStart = startIndex;
         plSqlQualifiedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlQualifiedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.QUALIFIED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlQualifiedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlQualifiedIdentifier$RuleMemoStart = startIndex;
         plSqlQualifiedIdentifier$RuleMemoEnd = -1;
         plSqlQualifiedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAnySimpleIdentifier : (PlSqlAnyParameterizedIdentifier | PlSqlAnyIdentifier)
   protected boolean plSqlAnySimpleIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAnySimpleIdentifier", index);
      }
      startIndex = index;
      // (PlSqlAnyParameterizedIdentifier | PlSqlAnyIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlAnyParameterizedIdentifier
            match = plSqlAnyParameterizedIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlAnyIdentifier
               match = plSqlAnyIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ANY_SIMPLE_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAnyParameterizedIdentifier : (PlSqlAnyIdentifier PlSqlParameters+)
   protected boolean plSqlAnyParameterizedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAnyParameterizedIdentifier", index);
      }
      if (plSqlAnyParameterizedIdentifier$RuleMemoStart == index) {
         if (plSqlAnyParameterizedIdentifier$RuleMemoStart <= plSqlAnyParameterizedIdentifier$RuleMemoEnd) {
            index = plSqlAnyParameterizedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, plSqlAnyParameterizedIdentifier$RuleMemoStart, plSqlAnyParameterizedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlAnyParameterizedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlAnyParameterizedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlAnyIdentifier PlSqlParameters+)
      // PlSqlAnyIdentifier
      match = plSqlAnyIdentifier$Rule();
      if (match) {
         // PlSqlParameters+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // PlSqlParameters
         match = plSqlParameters$Rule();
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // PlSqlParameters
               match = plSqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         plSqlAnyParameterizedIdentifier$RuleMemoStart = startIndex;
         plSqlAnyParameterizedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlAnyParameterizedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlAnyParameterizedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlAnyParameterizedIdentifier$RuleMemoStart = startIndex;
         plSqlAnyParameterizedIdentifier$RuleMemoEnd = -1;
         plSqlAnyParameterizedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlSimpleIdentifier : (PlSqlParameterizedIdentifier | PlSqlIdentifier)
   protected boolean plSqlSimpleIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlSimpleIdentifier", index);
      }
      if (plSqlSimpleIdentifier$RuleMemoStart == index) {
         if (plSqlSimpleIdentifier$RuleMemoStart <= plSqlSimpleIdentifier$RuleMemoEnd) {
            index = plSqlSimpleIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_SIMPLE_IDENTIFIER, plSqlSimpleIdentifier$RuleMemoStart, plSqlSimpleIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlSimpleIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlSimpleIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlParameterizedIdentifier | PlSqlIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '\u00C1':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case '\u00C7':
         case '\u00C8':
         case '\u00C9':
         case '\u00CA':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case '\u00CF':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case '\u00D5':
         case '\u00D6':
         case '\u00D9':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '\u00E0':
         case '\u00E1':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case '\u00E7':
         case '\u00E8':
         case '\u00E9':
         case '\u00EA':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case '\u00EF':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case '\u00F5':
         case '\u00F6':
         case '\u00F9':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlParameterizedIdentifier
            match = plSqlParameterizedIdentifier$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlIdentifier
               match = plSqlIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlSimpleIdentifier$RuleMemoStart = startIndex;
         plSqlSimpleIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlSimpleIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_SIMPLE_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlSimpleIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlSimpleIdentifier$RuleMemoStart = startIndex;
         plSqlSimpleIdentifier$RuleMemoEnd = -1;
         plSqlSimpleIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlParameterizedIdentifier : (PlSqlIdentifier PlSqlParameters+)
   protected boolean plSqlParameterizedIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlParameterizedIdentifier", index);
      }
      if (plSqlParameterizedIdentifier$RuleMemoStart == index) {
         if (plSqlParameterizedIdentifier$RuleMemoStart <= plSqlParameterizedIdentifier$RuleMemoEnd) {
            index = plSqlParameterizedIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, plSqlParameterizedIdentifier$RuleMemoStart, plSqlParameterizedIdentifier$RuleMemoEnd, true, false);
               lastNode.setSibling(currentNode);
               if (plSqlParameterizedIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlParameterizedIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlIdentifier PlSqlParameters+)
      // PlSqlIdentifier
      match = plSqlIdentifier$Rule();
      if (match) {
         // PlSqlParameters+
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // PlSqlParameters
         match = plSqlParameters$Rule();
         if (match) {
            do {
               lastNode_1 = currentNode;
               lastIndex_1 = index;
               // PlSqlParameters
               match = plSqlParameters$Rule();
            } while(match);
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
            match = true;
         } else {
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
            index = lastIndex_1;
         }
      }
      if (match) {
         plSqlParameterizedIdentifier$RuleMemoStart = startIndex;
         plSqlParameterizedIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlParameterizedIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PARAMETERIZED_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlParameterizedIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlParameterizedIdentifier$RuleMemoStart = startIndex;
         plSqlParameterizedIdentifier$RuleMemoEnd = -1;
         plSqlParameterizedIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlObjectIdentifier : (BuiltInFunctionCall | PlSqlQualifiedIdentifierRemote | PlSqlSimpleIdentifierRemote | PlSqlQualifiedIdentifier | PlSqlSimpleIdentifier)
   protected boolean plSqlObjectIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlObjectIdentifier", index);
      }
      if (plSqlObjectIdentifier$RuleMemoStart == index) {
         if (plSqlObjectIdentifier$RuleMemoStart <= plSqlObjectIdentifier$RuleMemoEnd) {
            index = plSqlObjectIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_IDENTIFIER, plSqlObjectIdentifier$RuleMemoStart, plSqlObjectIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlObjectIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlObjectIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (BuiltInFunctionCall | PlSqlQualifiedIdentifierRemote | PlSqlSimpleIdentifierRemote | PlSqlQualifiedIdentifier | PlSqlSimpleIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '\"':
         case '#':
         case '$':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case '\u00C1':
         case 'B':
         case '\u00C2':
         case '\u00C3':
         case '\u00C4':
         case 'G':
         case '\u00C7':
         case 'H':
         case '\u00C8':
         case 'I':
         case '\u00C9':
         case 'J':
         case '\u00CA':
         case 'K':
         case '\u00CB':
         case '\u00CC':
         case '\u00CD':
         case '\u00CE':
         case 'O':
         case '\u00CF':
         case 'Q':
         case '\u00D2':
         case '\u00D3':
         case '\u00D4':
         case 'U':
         case '\u00D5':
         case '\u00D6':
         case 'W':
         case 'Y':
         case '\u00D9':
         case 'Z':
         case '\u00DA':
         case '\u00DB':
         case '\u00DC':
         case '_':
         case '\u00E0':
         case '\u00E1':
         case 'b':
         case '\u00E2':
         case '\u00E3':
         case '\u00E4':
         case 'g':
         case '\u00E7':
         case 'h':
         case '\u00E8':
         case 'i':
         case '\u00E9':
         case 'j':
         case '\u00EA':
         case 'k':
         case '\u00EB':
         case '\u00EC':
         case '\u00ED':
         case '\u00EE':
         case 'o':
         case '\u00EF':
         case 'q':
         case '\u00F2':
         case '\u00F3':
         case '\u00F4':
         case 'u':
         case '\u00F5':
         case '\u00F6':
         case 'w':
         case 'y':
         case '\u00F9':
         case 'z':
         case '\u00FA':
         case '\u00FB':
         case '\u00FC': {
            // PlSqlQualifiedIdentifierRemote
            match = plSqlQualifiedIdentifierRemote$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlSimpleIdentifierRemote
               match = plSqlSimpleIdentifierRemote$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlQualifiedIdentifier
                  match = plSqlQualifiedIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlSimpleIdentifier
                     match = plSqlSimpleIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               }
            }
            break;
         }
         case 'A':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'L':
         case 'M':
         case 'N':
         case 'P':
         case 'R':
         case 'S':
         case 'T':
         case 'V':
         case 'X':
         case 'a':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'l':
         case 'm':
         case 'n':
         case 'p':
         case 'r':
         case 's':
         case 't':
         case 'v':
         case 'x': {
            // BuiltInFunctionCall
            match = builtInFunctionCall$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
               // PlSqlQualifiedIdentifierRemote
               match = plSqlQualifiedIdentifierRemote$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
                  // PlSqlSimpleIdentifierRemote
                  match = plSqlSimpleIdentifierRemote$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                     // PlSqlQualifiedIdentifier
                     match = plSqlQualifiedIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                        // PlSqlSimpleIdentifier
                        match = plSqlSimpleIdentifier$Rule();
                        if (! match) {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                           currentNode = lastNode_1;
                        }
                     }
                  }
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (match) {
         plSqlObjectIdentifier$RuleMemoStart = startIndex;
         plSqlObjectIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlObjectIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_OBJECT_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlObjectIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlObjectIdentifier$RuleMemoStart = startIndex;
         plSqlObjectIdentifier$RuleMemoEnd = -1;
         plSqlObjectIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlIdentifier : (PlSqlKeyword! PlSqlIdentifierPattern OptionalSpacing)
   protected boolean plSqlIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlIdentifier", index);
      }
      if (plSqlIdentifier$RuleMemoStart == index) {
         if (plSqlIdentifier$RuleMemoStart <= plSqlIdentifier$RuleMemoEnd) {
            index = plSqlIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_IDENTIFIER, plSqlIdentifier$RuleMemoStart, plSqlIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlKeyword! PlSqlIdentifierPattern OptionalSpacing)
      // PlSqlKeyword!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // (("all" | "alter" | "and" | "any" | "array" | "arrow" | "as" | "asc" | "at" | "begin" | "between" | "by" | "case" | "check" | "clusters" | "cluster" | "colauth" | "columns" | "compress" | "connect" | "crash" | "create" | "current" | "decimal" | "declare" | "default" | "delete" | "desc" | "distinct" | "drop" | "else" | "end" | "exception" | "exclusive" | "exists" | "fetch" | "form" | "for" | "from" | "goto" | "grant" | "group" | "having" | "identified" | "if" | "in" | "indexes" | "index" | "insert" | "intersect" | "into" | "is" | "like" | "lock" | "minus" | "mode" | "nocompress" | "not" | "nowait" | "null" | "of" | "on" | "option" | "or" | "order" | "overlaps" | "prior" | "procedure" | "public" | "range" | "record" | "resource" | "revoke" | "select" | "share" | "size" | "sql" | "start" | "subtype" | "tabauth" | "table" | "then" | "to" | "type" | "union" | "unique" | "update" | "use" | "values" | "view" | "views" | "when" | "where" | "with") TestNoAlpha)
      // ("all" | "alter" | "and" | "any" | "array" | "arrow" | "as" | "asc" | "at" | "begin" | "between" | "by" | "case" | "check" | "clusters" | "cluster" | "colauth" | "columns" | "compress" | "connect" | "crash" | "create" | "current" | "decimal" | "declare" | "default" | "delete" | "desc" | "distinct" | "drop" | "else" | "end" | "exception" | "exclusive" | "exists" | "fetch" | "form" | "for" | "from" | "goto" | "grant" | "group" | "having" | "identified" | "if" | "in" | "indexes" | "index" | "insert" | "intersect" | "into" | "is" | "like" | "lock" | "minus" | "mode" | "nocompress" | "not" | "nowait" | "null" | "of" | "on" | "option" | "or" | "order" | "overlaps" | "prior" | "procedure" | "public" | "range" | "record" | "resource" | "revoke" | "select" | "share" | "size" | "sql" | "start" | "subtype" | "tabauth" | "table" | "then" | "to" | "type" | "union" | "unique" | "update" | "use" | "values" | "view" | "views" | "when" | "where" | "with")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F': {
            ++index;
            // ("etch" | "orm" | "rom" | "or")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("rm" | "r")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("m" | <EMPTY>)
                     match = buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M');
                     if (match) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "om"
                  if (match = ignoreCaseStringTest("om", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "tch"
                  if (match = ignoreCaseStringTest("tch", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'v':
         case 'V': {
            ++index;
            // ("alues" | "iews" | "iew")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A': {
                  ++index;
                  // "lues"
                  if (match = ignoreCaseStringTest("lues", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // ("ews" | "ew")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("ws" | "w")
                     match = buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W');
                     if (match) {
                        ++index;
                        // ("s" | <EMPTY>)
                        match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                        if (match) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'g':
         case 'G': {
            ++index;
            // ("rant" | "roup" | "oto")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "to"
                  if (match = ignoreCaseStringTest("to", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("ant" | "oup")
                  switch(buffer.getChar(index)) {
                     case 'o':
                     case 'O': {
                        ++index;
                        // "up"
                        if (match = ignoreCaseStringTest("up", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'a':
                     case 'A': {
                        ++index;
                        // "nt"
                        if (match = ignoreCaseStringTest("nt", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'w':
         case 'W': {
            ++index;
            // ("here" | "hen" | "ith")
            switch(buffer.getChar(index)) {
               case 'h':
               case 'H': {
                  ++index;
                  // ("ere" | "en")
                  match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                  if (match) {
                     ++index;
                     // ("re" | "n")
                     switch(buffer.getChar(index)) {
                        case 'n':
                        case 'N': {
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        }
                        case 'r':
                        case 'R': {
                           ++index;
                           // "e"
                           if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                              ++index;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "th"
                  if (match = ignoreCaseStringTest("th", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'h':
         case 'H': {
            ++index;
            // "aving"
            if (match = ignoreCaseStringTest("aving", 5)) {
               index += 5;
            }
            break;
         }
         case 'i':
         case 'I': {
            ++index;
            // ("dentified" | "ntersect" | "ndexes" | "nsert" | "ndex" | "nto" | "f" | "n" | "s")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("tersect" | "dexes" | "sert" | "dex" | "to" | <EMPTY>)
                  switch(buffer.getChar(index)) {
                     case 's':
                     case 'S': {
                        ++index;
                        // "ert"
                        if (match = ignoreCaseStringTest("ert", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // ("ersect" | "o")
                        switch(buffer.getChar(index)) {
                           case 'o':
                           case 'O': {
                              ++index;
                              // <EMPTY>
                              match = true;
                              break;
                           }
                           case 'e':
                           case 'E': {
                              ++index;
                              // "rsect"
                              if (match = ignoreCaseStringTest("rsect", 5)) {
                                 index += 5;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 'd':
                     case 'D': {
                        ++index;
                        // ("exes" | "ex")
                        match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                        if (match) {
                           ++index;
                           // ("xes" | "x")
                           match = buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X');
                           if (match) {
                              ++index;
                              // ("es" | <EMPTY>)
                              match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                              if (match) {
                                 ++index;
                                 // "s"
                                 if (match = buffer.matchIgnoreCaseChar(index, 's')) {
                                    ++index;
                                 }
                              } else {
                                 match = true;
                              }
                           }
                        }
                        break;
                     }
                     default: {
                        match = true;
                     }
                  }
                  break;
               }
               case 'f':
               case 'F': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'd':
               case 'D': {
                  ++index;
                  // "entified"
                  if (match = ignoreCaseStringTest("entified", 8)) {
                     index += 8;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'l':
         case 'L': {
            ++index;
            // ("ike" | "ock")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "ck"
                  if (match = ignoreCaseStringTest("ck", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "ke"
                  if (match = ignoreCaseStringTest("ke", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'm':
         case 'M': {
            ++index;
            // ("inus" | "ode")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // "de"
                  if (match = ignoreCaseStringTest("de", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "nus"
                  if (match = ignoreCaseStringTest("nus", 3)) {
                     index += 3;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'n':
         case 'N': {
            ++index;
            // ("ocompress" | "owait" | "ull" | "ot")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("compress" | "wait" | "t")
                  switch(buffer.getChar(index)) {
                     case 'w':
                     case 'W': {
                        ++index;
                        // "ait"
                        if (match = ignoreCaseStringTest("ait", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "ompress"
                        if (match = ignoreCaseStringTest("ompress", 7)) {
                           index += 7;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "ll"
                  if (match = ignoreCaseStringTest("ll", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'o':
         case 'O': {
            ++index;
            // ("verlaps" | "ption" | "rder" | "f" | "n" | "r")
            switch(buffer.getChar(index)) {
               case 'v':
               case 'V': {
                  ++index;
                  // "erlaps"
                  if (match = ignoreCaseStringTest("erlaps", 6)) {
                     index += 6;
                  }
                  break;
               }
               case 'f':
               case 'F': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'n':
               case 'N': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'p':
               case 'P': {
                  ++index;
                  // "tion"
                  if (match = ignoreCaseStringTest("tion", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("der" | <EMPTY>)
                  match = buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D');
                  if (match) {
                     ++index;
                     // "er"
                     if (match = ignoreCaseStringTest("er", 2)) {
                        index += 2;
                     }
                  } else {
                     match = true;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'p':
         case 'P': {
            ++index;
            // ("rocedure" | "ublic" | "rior")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R': {
                  ++index;
                  // ("ocedure" | "ior")
                  switch(buffer.getChar(index)) {
                     case 'o':
                     case 'O': {
                        ++index;
                        // "cedure"
                        if (match = ignoreCaseStringTest("cedure", 6)) {
                           index += 6;
                        }
                        break;
                     }
                     case 'i':
                     case 'I': {
                        ++index;
                        // "or"
                        if (match = ignoreCaseStringTest("or", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "blic"
                  if (match = ignoreCaseStringTest("blic", 4)) {
                     index += 4;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'a':
         case 'A': {
            ++index;
            // ("lter" | "rray" | "rrow" | "ll" | "nd" | "ny" | "sc" | "s" | "t")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("d" | "y")
                  switch(buffer.getChar(index)) {
                     case 'y':
                     case 'Y': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case 'd':
                     case 'D': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("ray" | "row")
                  match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                  if (match) {
                     ++index;
                     // ("ay" | "ow")
                     switch(buffer.getChar(index)) {
                        case 'o':
                        case 'O': {
                           ++index;
                           // "w"
                           if (match = buffer.matchIgnoreCaseChar(index, 'w')) {
                              ++index;
                           }
                           break;
                        }
                        case 'a':
                        case 'A': {
                           ++index;
                           // "y"
                           if (match = buffer.matchIgnoreCaseChar(index, 'y')) {
                              ++index;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // ("c" | <EMPTY>)
                  match = buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C');
                  if (match) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // ("ter" | "l")
                  switch(buffer.getChar(index)) {
                     case 't':
                     case 'T': {
                        ++index;
                        // "er"
                        if (match = ignoreCaseStringTest("er", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 't':
               case 'T': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'b':
         case 'B': {
            ++index;
            // ("etween" | "egin" | "y")
            switch(buffer.getChar(index)) {
               case 'y':
               case 'Y': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("tween" | "gin")
                  switch(buffer.getChar(index)) {
                     case 'g':
                     case 'G': {
                        ++index;
                        // "in"
                        if (match = ignoreCaseStringTest("in", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 't':
                     case 'T': {
                        ++index;
                        // "ween"
                        if (match = ignoreCaseStringTest("ween", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'r':
         case 'R': {
            ++index;
            // ("esource" | "ecord" | "evoke" | "ange")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A': {
                  ++index;
                  // "nge"
                  if (match = ignoreCaseStringTest("nge", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("source" | "cord" | "voke")
                  switch(buffer.getChar(index)) {
                     case 'v':
                     case 'V': {
                        ++index;
                        // "oke"
                        if (match = ignoreCaseStringTest("oke", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "ource"
                        if (match = ignoreCaseStringTest("ource", 5)) {
                           index += 5;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // "ord"
                        if (match = ignoreCaseStringTest("ord", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'c':
         case 'C': {
            ++index;
            // ("lusters" | "ompress" | "luster" | "olauth" | "olumns" | "onnect" | "urrent" | "reate" | "heck" | "rash" | "ase")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // ("mpress" | "lauth" | "lumns" | "nnect")
                  switch(buffer.getChar(index)) {
                     case 'n':
                     case 'N': {
                        ++index;
                        // "nect"
                        if (match = ignoreCaseStringTest("nect", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // ("auth" | "umns")
                        switch(buffer.getChar(index)) {
                           case 'a':
                           case 'A': {
                              ++index;
                              // "uth"
                              if (match = ignoreCaseStringTest("uth", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           case 'u':
                           case 'U': {
                              ++index;
                              // "mns"
                              if (match = ignoreCaseStringTest("mns", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 'm':
                     case 'M': {
                        ++index;
                        // "press"
                        if (match = ignoreCaseStringTest("press", 5)) {
                           index += 5;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'h':
               case 'H': {
                  ++index;
                  // "eck"
                  if (match = ignoreCaseStringTest("eck", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // ("eate" | "ash")
                  switch(buffer.getChar(index)) {
                     case 'a':
                     case 'A': {
                        ++index;
                        // "sh"
                        if (match = ignoreCaseStringTest("sh", 2)) {
                           index += 2;
                        }
                        break;
                     }
                     case 'e':
                     case 'E': {
                        ++index;
                        // "ate"
                        if (match = ignoreCaseStringTest("ate", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // ("usters" | "uster")
                  match = buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U');
                  if (match) {
                     ++index;
                     // ("sters" | "ster")
                     match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                     if (match) {
                        ++index;
                        // ("ters" | "ter")
                        match = buffer.matchChar(index, 't') || buffer.matchChar(index, 'T');
                        if (match) {
                           ++index;
                           // ("ers" | "er")
                           match = buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E');
                           if (match) {
                              ++index;
                              // ("rs" | "r")
                              match = buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R');
                              if (match) {
                                 ++index;
                                 // ("s" | <EMPTY>)
                                 match = buffer.matchChar(index, 's') || buffer.matchChar(index, 'S');
                                 if (match) {
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              }
                           }
                        }
                     }
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "rrent"
                  if (match = ignoreCaseStringTest("rrent", 5)) {
                     index += 5;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 's':
         case 'S': {
            ++index;
            // ("ubtype" | "elect" | "hare" | "tart" | "ize" | "ql")
            switch(buffer.getChar(index)) {
               case 'h':
               case 'H': {
                  ++index;
                  // "are"
                  if (match = ignoreCaseStringTest("are", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'i':
               case 'I': {
                  ++index;
                  // "ze"
                  if (match = ignoreCaseStringTest("ze", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'q':
               case 'Q': {
                  ++index;
                  // "l"
                  if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                     ++index;
                  }
                  break;
               }
               case 't':
               case 'T': {
                  ++index;
                  // "art"
                  if (match = ignoreCaseStringTest("art", 3)) {
                     index += 3;
                  }
                  break;
               }
               case 'u':
               case 'U': {
                  ++index;
                  // "btype"
                  if (match = ignoreCaseStringTest("btype", 5)) {
                     index += 5;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // "lect"
                  if (match = ignoreCaseStringTest("lect", 4)) {
                     index += 4;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'd':
         case 'D': {
            ++index;
            // ("istinct" | "ecimal" | "eclare" | "efault" | "elete" | "esc" | "rop")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I': {
                  ++index;
                  // "stinct"
                  if (match = ignoreCaseStringTest("stinct", 6)) {
                     index += 6;
                  }
                  break;
               }
               case 'r':
               case 'R': {
                  ++index;
                  // "op"
                  if (match = ignoreCaseStringTest("op", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'e':
               case 'E': {
                  ++index;
                  // ("cimal" | "clare" | "fault" | "lete" | "sc")
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F': {
                        ++index;
                        // "ault"
                        if (match = ignoreCaseStringTest("ault", 4)) {
                           index += 4;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // ("imal" | "lare")
                        switch(buffer.getChar(index)) {
                           case 'i':
                           case 'I': {
                              ++index;
                              // "mal"
                              if (match = ignoreCaseStringTest("mal", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           case 'l':
                           case 'L': {
                              ++index;
                              // "are"
                              if (match = ignoreCaseStringTest("are", 3)) {
                                 index += 3;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     case 's':
                     case 'S': {
                        ++index;
                        // "c"
                        if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                           ++index;
                        }
                        break;
                     }
                     case 'l':
                     case 'L': {
                        ++index;
                        // "ete"
                        if (match = ignoreCaseStringTest("ete", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 't':
         case 'T': {
            ++index;
            // ("abauth" | "able" | "hen" | "ype" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case 'h':
               case 'H': {
                  ++index;
                  // "en"
                  if (match = ignoreCaseStringTest("en", 2)) {
                     index += 2;
                  }
                  break;
               }
               case 'a':
               case 'A': {
                  ++index;
                  // ("bauth" | "ble")
                  match = buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B');
                  if (match) {
                     ++index;
                     // ("auth" | "le")
                     switch(buffer.getChar(index)) {
                        case 'a':
                        case 'A': {
                           ++index;
                           // "uth"
                           if (match = ignoreCaseStringTest("uth", 3)) {
                              index += 3;
                           }
                           break;
                        }
                        case 'l':
                        case 'L': {
                           ++index;
                           // "e"
                           if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                              ++index;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'y':
               case 'Y': {
                  ++index;
                  // "pe"
                  if (match = ignoreCaseStringTest("pe", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'e':
         case 'E': {
            ++index;
            // ("xception" | "xclusive" | "xists" | "lse" | "nd")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // "d"
                  if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                     ++index;
                  }
                  break;
               }
               case 'x':
               case 'X': {
                  ++index;
                  // ("ception" | "clusive" | "ists")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I': {
                        ++index;
                        // "sts"
                        if (match = ignoreCaseStringTest("sts", 3)) {
                           index += 3;
                        }
                        break;
                     }
                     case 'c':
                     case 'C': {
                        ++index;
                        // ("eption" | "lusive")
                        switch(buffer.getChar(index)) {
                           case 'l':
                           case 'L': {
                              ++index;
                              // "usive"
                              if (match = ignoreCaseStringTest("usive", 5)) {
                                 index += 5;
                              }
                              break;
                           }
                           case 'e':
                           case 'E': {
                              ++index;
                              // "ption"
                              if (match = ignoreCaseStringTest("ption", 5)) {
                                 index += 5;
                              }
                              break;
                           }
                           default: {
                              match = false;
                           }
                        }
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  break;
               }
               case 'l':
               case 'L': {
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         case 'u':
         case 'U': {
            ++index;
            // ("nique" | "pdate" | "nion" | "se")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N': {
                  ++index;
                  // ("ique" | "ion")
                  match = buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I');
                  if (match) {
                     ++index;
                     // ("que" | "on")
                     switch(buffer.getChar(index)) {
                        case 'o':
                        case 'O': {
                           ++index;
                           // "n"
                           if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                              ++index;
                           }
                           break;
                        }
                        case 'q':
                        case 'Q': {
                           ++index;
                           // "ue"
                           if (match = ignoreCaseStringTest("ue", 2)) {
                              index += 2;
                           }
                           break;
                        }
                        default: {
                           match = false;
                        }
                     }
                  }
                  break;
               }
               case 'p':
               case 'P': {
                  ++index;
                  // "date"
                  if (match = ignoreCaseStringTest("date", 4)) {
                     index += 4;
                  }
                  break;
               }
               case 's':
               case 'S': {
                  ++index;
                  // "e"
                  if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                     ++index;
                  }
                  break;
               }
               default: {
                  match = false;
               }
            }
            break;
         }
         default: {
            match = false;
         }
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
      }
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // PlSqlIdentifierPattern
         match = plSqlIdentifierPattern$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         plSqlIdentifier$RuleMemoStart = startIndex;
         plSqlIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlIdentifier$RuleMemoStart = startIndex;
         plSqlIdentifier$RuleMemoEnd = -1;
         plSqlIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlIdentifierPattern : (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
   protected boolean plSqlIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlIdentifierPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
         if (! match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               // '_'
               match = charMatcher('_');
               if (! match) {
                  // '$'
                  match = charMatcher('$');
                  if (! match) {
                     // '#'
                     match = charMatcher('#');
                     if (! match) {
                        // ''
                        match = charMatcher('\u00C1');
                        if (! match) {
                           // ''
                           match = charMatcher('\u00C1');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C2');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C3');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C4');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C7');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C8');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C9');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00CA');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00CB');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CC');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CD');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CE');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CF');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00D2');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00D3');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D4');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D5');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D6');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D9');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00DA');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00DB');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DC');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00E0');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00E1');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E2');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E3');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E4');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E7');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E8');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E9');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00EA');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00EB');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EC');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00ED');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EE');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00EF');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00F2');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00F3');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F4');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F5');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F6');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F9');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00FA');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00FB');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FC');
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                     if (! match) {
                        // '$'
                        match = charMatcher('$');
                        if (! match) {
                           // '#'
                           match = charMatcher('#');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C1');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C1');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C2');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C3');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C4');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C7');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00C8');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00C9');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CA');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CB');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CC');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CD');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00CE');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00CF');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D2');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D3');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D4');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D5');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00D6');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00D9');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DA');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00DB');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00DC');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E0');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E1');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E2');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E3');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E4');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E7');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00E8');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00E9');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EA');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00EB');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EC');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00ED');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00EE');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00EF');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F2');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F3');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F4');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F5');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00F6');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00F9');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FA');
                                                                                                                                                               if (! match) {
                                                                                                                                                                  // ''
                                                                                                                                                                  match = charMatcher('\u00FB');
                                                                                                                                                                  if (! match) {
                                                                                                                                                                     // ''
                                                                                                                                                                     match = charMatcher('\u00FC');
                                                                                                                                                                  }
                                                                                                                                                               }
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      } else {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('"' (('\r' | '\n' | '"')! .)+ '"')
         // '"'
         match = charMatcher('\"');
         if (match) {
            // (('\r' | '\n' | '"')! .)+
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // (('\r' | '\n' | '"')! .)
            // ('\r' | '\n' | '"')!
            // ('\r' | '\n' | '"')
            int startIndex_6 = index;
            switch(buffer.getChar(index)) {
               case '\r': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_6;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
            if (match) {
               do {
                  lastNode_5 = currentNode;
                  lastIndex_5 = index;
                  // (('\r' | '\n' | '"')! .)
                  // ('\r' | '\n' | '"')!
                  // ('\r' | '\n' | '"')
                  int startIndex_7 = index;
                  switch(buffer.getChar(index)) {
                     case '\r': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\"': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\n': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  index = startIndex_7;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
               } while(match);
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
               match = true;
            } else {
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
            }
            if (match) {
               // '"'
               match = charMatcher('\"');
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAnyIdentifier : (PlSqlAnyIdentifierPattern OptionalSpacing)
   protected boolean plSqlAnyIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAnyIdentifier", index);
      }
      if (plSqlAnyIdentifier$RuleMemoStart == index) {
         if (plSqlAnyIdentifier$RuleMemoStart <= plSqlAnyIdentifier$RuleMemoEnd) {
            index = plSqlAnyIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ANY_IDENTIFIER, plSqlAnyIdentifier$RuleMemoStart, plSqlAnyIdentifier$RuleMemoEnd, true, true);
               lastNode.setSibling(currentNode);
               if (plSqlAnyIdentifier$RuleMemoFirstNode != null) {
                  currentNode.setFirstChild(plSqlAnyIdentifier$RuleMemoFirstNode.getFirstChild());
               }
            }
            if (trace) {
               tracePath.exitRule(buffer, index, true);
            }
            return true;
         } else {
            if (trace) {
               tracePath.exitRule(buffer, index, false);
            }
            return false;
         }
      }
      startIndex = index;
      // (PlSqlAnyIdentifierPattern OptionalSpacing)
      // PlSqlAnyIdentifierPattern
      match = plSqlAnyIdentifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         plSqlAnyIdentifier$RuleMemoStart = startIndex;
         plSqlAnyIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            plSqlAnyIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(OracleScriptRuleType.PL_SQL_ANY_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            plSqlAnyIdentifier$RuleMemoFirstNode = currentNode;
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         plSqlAnyIdentifier$RuleMemoStart = startIndex;
         plSqlAnyIdentifier$RuleMemoEnd = -1;
         plSqlAnyIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //PlSqlAnyIdentifierPattern : (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
   protected boolean plSqlAnyIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (trace) {
         tracePath.enterRule(buffer, "PlSqlAnyIdentifierPattern", index);
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+ | ('"' (('\r' | '\n' | '"')! .)+ '"'))
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')+
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // 'a'-'z'
      match = charRangeMatcher('a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = charRangeMatcher('A', 'Z');
         if (! match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               // '_'
               match = charMatcher('_');
               if (! match) {
                  // '$'
                  match = charMatcher('$');
                  if (! match) {
                     // '#'
                     match = charMatcher('#');
                     if (! match) {
                        // ''
                        match = charMatcher('\u00C1');
                        if (! match) {
                           // ''
                           match = charMatcher('\u00C1');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C2');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C3');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C4');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C7');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C8');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C9');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00CA');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00CB');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CC');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CD');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CE');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CF');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00D2');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00D3');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D4');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D5');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D6');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D9');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00DA');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00DB');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DC');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00E0');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00E1');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E2');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E3');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E4');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E7');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E8');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E9');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00EA');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00EB');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EC');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00ED');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EE');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00EF');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00F2');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00F3');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F4');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F5');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F6');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F9');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00FA');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00FB');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FC');
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         do {
            lastNode_2 = currentNode;
            lastIndex_2 = index;
            // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '$' | '#' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '')
            Node lastNode_4 = currentNode;
            int lastIndex_4 = index;
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                     if (! match) {
                        // '$'
                        match = charMatcher('$');
                        if (! match) {
                           // '#'
                           match = charMatcher('#');
                           if (! match) {
                              // ''
                              match = charMatcher('\u00C1');
                              if (! match) {
                                 // ''
                                 match = charMatcher('\u00C1');
                                 if (! match) {
                                    // ''
                                    match = charMatcher('\u00C2');
                                    if (! match) {
                                       // ''
                                       match = charMatcher('\u00C3');
                                       if (! match) {
                                          // ''
                                          match = charMatcher('\u00C4');
                                          if (! match) {
                                             // ''
                                             match = charMatcher('\u00C7');
                                             if (! match) {
                                                // ''
                                                match = charMatcher('\u00C8');
                                                if (! match) {
                                                   // ''
                                                   match = charMatcher('\u00C9');
                                                   if (! match) {
                                                      // ''
                                                      match = charMatcher('\u00CA');
                                                      if (! match) {
                                                         // ''
                                                         match = charMatcher('\u00CB');
                                                         if (! match) {
                                                            // ''
                                                            match = charMatcher('\u00CC');
                                                            if (! match) {
                                                               // ''
                                                               match = charMatcher('\u00CD');
                                                               if (! match) {
                                                                  // ''
                                                                  match = charMatcher('\u00CE');
                                                                  if (! match) {
                                                                     // ''
                                                                     match = charMatcher('\u00CF');
                                                                     if (! match) {
                                                                        // ''
                                                                        match = charMatcher('\u00D2');
                                                                        if (! match) {
                                                                           // ''
                                                                           match = charMatcher('\u00D3');
                                                                           if (! match) {
                                                                              // ''
                                                                              match = charMatcher('\u00D4');
                                                                              if (! match) {
                                                                                 // ''
                                                                                 match = charMatcher('\u00D5');
                                                                                 if (! match) {
                                                                                    // ''
                                                                                    match = charMatcher('\u00D6');
                                                                                    if (! match) {
                                                                                       // ''
                                                                                       match = charMatcher('\u00D9');
                                                                                       if (! match) {
                                                                                          // ''
                                                                                          match = charMatcher('\u00DA');
                                                                                          if (! match) {
                                                                                             // ''
                                                                                             match = charMatcher('\u00DB');
                                                                                             if (! match) {
                                                                                                // ''
                                                                                                match = charMatcher('\u00DC');
                                                                                                if (! match) {
                                                                                                   // ''
                                                                                                   match = charMatcher('\u00E0');
                                                                                                   if (! match) {
                                                                                                      // ''
                                                                                                      match = charMatcher('\u00E1');
                                                                                                      if (! match) {
                                                                                                         // ''
                                                                                                         match = charMatcher('\u00E2');
                                                                                                         if (! match) {
                                                                                                            // ''
                                                                                                            match = charMatcher('\u00E3');
                                                                                                            if (! match) {
                                                                                                               // ''
                                                                                                               match = charMatcher('\u00E4');
                                                                                                               if (! match) {
                                                                                                                  // ''
                                                                                                                  match = charMatcher('\u00E7');
                                                                                                                  if (! match) {
                                                                                                                     // ''
                                                                                                                     match = charMatcher('\u00E8');
                                                                                                                     if (! match) {
                                                                                                                        // ''
                                                                                                                        match = charMatcher('\u00E9');
                                                                                                                        if (! match) {
                                                                                                                           // ''
                                                                                                                           match = charMatcher('\u00EA');
                                                                                                                           if (! match) {
                                                                                                                              // ''
                                                                                                                              match = charMatcher('\u00EB');
                                                                                                                              if (! match) {
                                                                                                                                 // ''
                                                                                                                                 match = charMatcher('\u00EC');
                                                                                                                                 if (! match) {
                                                                                                                                    // ''
                                                                                                                                    match = charMatcher('\u00ED');
                                                                                                                                    if (! match) {
                                                                                                                                       // ''
                                                                                                                                       match = charMatcher('\u00EE');
                                                                                                                                       if (! match) {
                                                                                                                                          // ''
                                                                                                                                          match = charMatcher('\u00EF');
                                                                                                                                          if (! match) {
                                                                                                                                             // ''
                                                                                                                                             match = charMatcher('\u00F2');
                                                                                                                                             if (! match) {
                                                                                                                                                // ''
                                                                                                                                                match = charMatcher('\u00F3');
                                                                                                                                                if (! match) {
                                                                                                                                                   // ''
                                                                                                                                                   match = charMatcher('\u00F4');
                                                                                                                                                   if (! match) {
                                                                                                                                                      // ''
                                                                                                                                                      match = charMatcher('\u00F5');
                                                                                                                                                      if (! match) {
                                                                                                                                                         // ''
                                                                                                                                                         match = charMatcher('\u00F6');
                                                                                                                                                         if (! match) {
                                                                                                                                                            // ''
                                                                                                                                                            match = charMatcher('\u00F9');
                                                                                                                                                            if (! match) {
                                                                                                                                                               // ''
                                                                                                                                                               match = charMatcher('\u00FA');
                                                                                                                                                               if (! match) {
                                                                                                                                                                  // ''
                                                                                                                                                                  match = charMatcher('\u00FB');
                                                                                                                                                                  if (! match) {
                                                                                                                                                                     // ''
                                                                                                                                                                     match = charMatcher('\u00FC');
                                                                                                                                                                  }
                                                                                                                                                               }
                                                                                                                                                            }
                                                                                                                                                         }
                                                                                                                                                      }
                                                                                                                                                   }
                                                                                                                                                }
                                                                                                                                             }
                                                                                                                                          }
                                                                                                                                       }
                                                                                                                                    }
                                                                                                                                 }
                                                                                                                              }
                                                                                                                           }
                                                                                                                        }
                                                                                                                     }
                                                                                                                  }
                                                                                                               }
                                                                                                            }
                                                                                                         }
                                                                                                      }
                                                                                                   }
                                                                                                }
                                                                                             }
                                                                                          }
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         } while(match);
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
         match = true;
      } else {
         lastNode_2.setSibling(null);
         currentNode = lastNode_2;
         index = lastIndex_2;
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // ('"' (('\r' | '\n' | '"')! .)+ '"')
         // '"'
         match = charMatcher('\"');
         if (match) {
            // (('\r' | '\n' | '"')! .)+
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // (('\r' | '\n' | '"')! .)
            // ('\r' | '\n' | '"')!
            // ('\r' | '\n' | '"')
            int startIndex_6 = index;
            switch(buffer.getChar(index)) {
               case '\r': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\"': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               case '\n': {
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               }
               default: {
                  match = false;
               }
            }
            index = startIndex_6;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
            }
            if (match) {
               do {
                  lastNode_5 = currentNode;
                  lastIndex_5 = index;
                  // (('\r' | '\n' | '"')! .)
                  // ('\r' | '\n' | '"')!
                  // ('\r' | '\n' | '"')
                  int startIndex_7 = index;
                  switch(buffer.getChar(index)) {
                     case '\r': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\"': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     case '\n': {
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     }
                     default: {
                        match = false;
                     }
                  }
                  index = startIndex_7;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                  }
               } while(match);
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
               match = true;
            } else {
               lastNode_5.setSibling(null);
               currentNode = lastNode_5;
               index = lastIndex_5;
            }
            if (match) {
               // '"'
               match = charMatcher('\"');
            }
         }
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //Script : (OptionalSpacing MultiplesSQLSentence OptionalSpacing <EOI>)
   protected boolean script$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "Script", index);
      }
      startIndex = index;
      // (OptionalSpacing MultiplesSQLSentence OptionalSpacing <EOI>)
      // OptionalSpacing
      match = optionalSpacing$Rule();
      if (match) {
         // MultiplesSQLSentence
         match = multiplesSQLSentence$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // <EOI>
               match = eoi();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SCRIPT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //MultiplesSQLSentence : (SQLSentence OptionalSpacing ('/' OptionalSpacing)* OptionalSpacing)+
   protected boolean multiplesSQLSentence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "MultiplesSQLSentence", index);
      }
      startIndex = index;
      // (SQLSentence OptionalSpacing ('/' OptionalSpacing)* OptionalSpacing)+
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (SQLSentence OptionalSpacing ('/' OptionalSpacing)* OptionalSpacing)
      // SQLSentence
      match = sQLSentence$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ('/' OptionalSpacing)*
            Node lastNode_2;
            int lastIndex_2;
            do {
               lastNode_2 = currentNode;
               lastIndex_2 = index;
               // ('/' OptionalSpacing)
               // '/'
               match = charMatcher('/');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            } while(match);
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            index = lastIndex_2;
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         do {
            lastNode_1 = currentNode;
            lastIndex_1 = index;
            // (SQLSentence OptionalSpacing ('/' OptionalSpacing)* OptionalSpacing)
            // SQLSentence
            match = sQLSentence$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ('/' OptionalSpacing)*
                  Node lastNode_3;
                  int lastIndex_3;
                  do {
                     lastNode_3 = currentNode;
                     lastIndex_3 = index;
                     // ('/' OptionalSpacing)
                     // '/'
                     match = charMatcher('/');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                     }
                  } while(match);
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
                  index = lastIndex_3;
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         } while(match);
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
         match = true;
      } else {
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         index = lastIndex_1;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.MULTIPLES_SQLSENTENCE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }

   //SQLSentence : ((DmlSentence ';' OptionalSpacing) | PlSqlSource)
   protected boolean sQLSentence$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (trace) {
         tracePath.enterRule(buffer, "SQLSentence", index);
      }
      startIndex = index;
      // ((DmlSentence ';' OptionalSpacing) | PlSqlSource)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (DmlSentence ';' OptionalSpacing)
      // DmlSentence
      match = dmlSentence$Rule();
      if (match) {
         // ';'
         match = charMatcher(';');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (! match) {
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         // PlSqlSource
         match = plSqlSource$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(OracleScriptRuleType.SQLSENTENCE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         if (trace) {
            tracePath.exitRule(buffer, index, true);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         if (trace) {
            tracePath.exitRule(buffer, index, false);
         }
         return false;
      }
   }
}
