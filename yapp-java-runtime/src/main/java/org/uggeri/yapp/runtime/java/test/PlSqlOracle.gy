grammar PlSqlOracle;

/*********************************************************************************
                               "main" PARSER rules
*********************************************************************************/

PlSqlProgram : PlSqlSource EOI;

SqlSentence : DmlSentence EOI;

/**********************************************************************************
                              "sql" rules
**********************************************************************************/

DmlSentence : SelectStatement
            | UpdateStatement
            | InsertStatement
            | DeleteStatement
            | CommitStatement
            | MergeStatement
            | LockTableStatement
            | RollbacklStatement
            | SavepointStatement
            | SetTransactionStatement;

SelectStatement : SubqueryFactoringClause?
                  Subquery
                  ForUpdateClause?;

UpdateStatement : "update" Hint?
                  (OnlyDmlTableExpresionClause | DmlTableExpressionClause) Alias?
                  UpdateSetClause
                  WhereClause?
                  ReturningClause?;

InsertStatement : SingleTableInsert
                | MultiTableInsert;

DeleteStatement : "delete" Hint?
                  "from"? (OnlyDmlTableExpresionClause | DmlTableExpressionClause) Alias?
                  WhereClause?
                  ReturningClause?
                  ErrorLogingClause?;

CommitStatement : "commit" "work"? CommitOptions?;

MergeStatement : "merge" Hint?
                 "into" TableName Alias?
                 "using" (Subquery | TableName)? Alias?
                 "on" '(' SqlCondition ')'
                 ((MergeUpdateClause MergeInsertClause)
                  | (MergeInsertClause MergeUpdateClause)
                  | MergeInsertClause
                  | MergeUpdateClause
                 )?
                 ErrorLogingClause?;

LockTableStatement : "lock" "table" (TablePartitionName | TableSubPartitionName | TableName)
                     "in" LockMode
                     "mode" WaitMode?;

RollbacklStatement : "rollback" "work"? RollbackOptions?;

SavePointName : SqlAnyIdentifier;

SavepointStatement : "savepoint" SavePointName;

SetTransactionStatement : "set" "transaction" SetTransactionOptions;

WaitMode : "wait" | "nowait";

CommitComment : "comment" StringLiteral;

WriteMode : "write" WaitMode? ("immediate" | "batch")?;

ForceCommit : "force" ( (StringLiteral (',' NumberLiteral)?)
                      | ("corrupt_xid" StringLiteral)
                      | "corrupt_xid_all"
                      );

NormalCommit : CommitComment WriteMode
             | CommitComment
             | WriteMode;

CommitOptions : NormalCommit | ForceCommit;

TablePartitionName : TableName "partition" (PartitionName | PartitionKey);

TableSubPartitionName : TableName "subpartition" (PartitionName | PartitionKey);

TableName : SchemaObjectName DbLink?;

Rowshare : "row" "share";

RowExclusive : "row" "exclusive";

shareRowExclusive : "share" "row" "exclusive";

shareUpdate : "share" "update";

Share : "share";

Exclusive : "exclusive";

LockMode : Rowshare
         | RowExclusive
         | shareRowExclusive
         | shareUpdate
         | Share
         | Exclusive;

ToSavePoint : "to" "savepoint"? SavePointName;

ForceRollback : "force" StringLiteral;

RollbackOptions : ToSavePoint
                | ForceRollback;

TransactionName : "name" StringLiteral;

UseRollbackSegment : "use" "rollback" "segment" SqlAnyIdentifier;

IsolationLevel : "isolation" "level" ("serializable" | ("read" "commited"));

ReadOnly : "read" "only";

ReadWrite : "read" "write";

ReadMode : ReadOnly | ReadWrite;

SetTransactionOptions : ((ReadMode
                         | IsolationLevel
                         | UseRollbackSegment
                         ) TransactionName?)
                      | TransactionName;

SubqueryFactoringClause : "with" SubqueryFactoringSource (',' SubqueryFactoringSource)*;

Subquery : (EnclosedSubquery | QueryBlock) UnionClause? OrderByClause?;

ForUpdateClause : "for" "update" ("of" TableName)? WaitClause?;

MergeUpdateClause : "when" "matched" "then" "update" UpdateSetClause WhereClause? ("delete" WhereClause)?;

UpdateSetClause : "set" (ObjectSetValue | ColumnSetValueList);

WhereClause : "where" (CurrentOf | SqlCondition);

MergeInsertClause : "when" "not" "matched" "then" "insert" ColumnsList ValuesClause WhereClause?;

ColumnsList : '(' ColumnName (',' ColumnName)* ')';

RecordName : SqlQualifiedIdentifier;

ValuesClause : "values" (ValuesClauseList | RecordName);

Hint : BlockHint | LineHint;

SchemaObjectName : (Schema '.')? Object;

Alias : SqlAnyIdentifier;

SqlCondition : NotCondition
             | AndCondition
             | OrCondition
             | ConditionExpression;

ErrorLogingClause : "log" "errors"
                    ("into" TableName)? ('(' SqlSimpleExpression ')')?
                    RejectLimit?;

ListAllFields : TableName '.' '*';

SelectListExpressionElement : SqlExpression ColumnAlias?;

SqlExpression : SqlMathExpression | OptionalSqlTimeExpression;

SqlMathExpression : OptionalSqlTimeExpression SqlMathOperator SqlExpression;

@SkipNode              
OptionalSqlTimeExpression : SqlTimeExpression | OptionalSqlUnaryExpression;

SqlTimeExpression : OptionalSqlUnaryExpression TimeExpression;
              
@SkipNode              
OptionalSqlUnaryExpression : SqlUnaryExpression | SqlAtomicExpression;

SqlUnaryExpression : SqlUnaryOperator SqlExpression;
              
@SkipNode
SqlAtomicExpression : ParenthesesSqlExpression
                    | SqlCaseExpression
                    | CursorExpression
                    | PlaceHolderExpression
                    | TypeConstructorExpression
                    | Subquery
                    | BuiltInFunctionCall
                    | SqlSimpleExpression
                    | SysDate
                    | ModelExpression;
              
ColumnAlias : "as"? Alias;

SelectListElement : ListAllFields
                  | SelectListExpressionElement;

CommaSelectListElement : ',' SelectListElement;

ZeroOrMoreCommaSelectListElement : CommaSelectListElement*;

ListOfSelectListElement : SelectListElement ZeroOrMoreCommaSelectListElement;

SelectList : '*' | ListOfSelectListElement;

SubqueryReadOnlyRestriction : "read" "only";

SubqueryCheckConstraintName : ("constant" SqlAnyIdentifier)?;

SubqueryCheckOptionRestriction : "check" "option" SubqueryCheckConstraintName;

SubqueryRestrictionType : SubqueryReadOnlyRestriction | SubqueryCheckOptionRestriction;

SubqueryRestriction : ("with" SubqueryRestrictionType)?;

Seed : "seed" '(' NumberLiteral ')';

SampleClause : "sample" "block"? SampleNumber Seed?;

SampleNumber : '(' NumberLiteral ')';

TableOrView : (TablePartitionName | TableSubPartitionName | TableName) SampleClause?;

QueryTableExpression : TableOrView
                     | Subquery
                     | TableCollectionExpression;

TableCollectionExpression : "table" '(' CollectionExpression ')' '(+)'?;

DbLink : '@' SqlAnyIdentifier SqlParameters*;

CollectionExpression : SqlExpression;

SqlMathOperator : '**' | '*' | '/' | '+' | '-' | '||' | "mod";

ParenthesesSqlExpression : '(' SqlExpression ')';

SqlUnaryOperator : '+' | '-' | "prior" | "connect_by_root";

SqlCaseExpression : "case"
                    (SqlSearchedCaseExpression | SqlSimpleCaseExpression) SqlCaseExpressionElse?
                    "end" "case"?;

CursorExpression : "cursor" '(' Subquery ')';

PlaceHolderExpression : BindVariable ("indicator"? BindVariable)?;

TypeName : SchemaObjectName;

TypeConstructorExpression : "new" TypeName '(' SqlExpressionList ')';

BuiltInFunctionCall : AnalyticFunctionCall
                    | Cast
                    | Chr
                    | ClusterId
                    | ClusterProbability
                    | ClusterSet
                    | CumeDistAggregate
                    | Decompose
                    | DenseRankAggregate
                    | Extract
                    | FeatureId
                    | FeatureSet
                    | FeatureValue
                    | FirstValue
                    | LastValue
                    | Lead
                    | Max
                    | Median
                    | Min
                    | NTile
                    | PercentRankAggregate
                    | PercentRankAnalytic
                    | Prediction
                    | PredictionBounds
                    | PredictionCost
                    | PredictionDetails
                    | PredictionProbability
                    | PredictionSet
                    | RankAggregate
                    | RankAnalytic
                    | Translate
                    | Treat
                    | Trim
                    | XmlAgg
                    | XmlCast
                    | XmlColAttVal
                    | XmlElement
                    | XmlExists
                    | XmlForest
                    | XmlParse
                    | XmlPI
                    | XmlQuery
                    | XmlRoot
                    | XmlTable;

SqlSimpleExpression : SqlLiteral
                    | RowNum
                    | RowId
                    | Level
                    | SqlOuterJoinObject
                    | BuiltInFunctionCall
                    | SqlQualifiedIdentifier;

SysDate : "sysdate";

ModelExpression : (AnalyticFunctionCall ('[' (CellReferenceArgumentsList | MultiColumnForLoop) ']')?)
                | (SqlQualifiedIdentifier '[' ConditionOrExpressionList ']');

TimeExpression : ("at" ("local" | ("time" "zone" ("dbtimezone" | "sessiontimezone" | StringLiteral | SqlExpression))))
               | (("day" '(' OneDigit ')' "to" "second" ('(' OneDigit ')')?) | ("year" '(' OneDigit ')' "to" "month"));

SqlSearchedCaseExpression : SqlWhenConditionThen*;

SqlSimpleCaseExpression : SqlExpression SqlWhenExpressionThen*;

SqlCaseExpressionElse : "else" SqlExpression;

SqlWhenExpressionThen : "when" SqlExpression "then" SqlExpression;

SqlWhenConditionThen : "when" SqlCondition "then" SqlExpression;

RowNum : "rownum";

IdentifiedRowId : TypeName '.' "rowid";

RowId : IdentifiedRowId | "rowid";

Level : "level";

SqlOuterJoinObject : ColumnName '(+)';

SqlLiteral : NumberLiteral
           | StringLiteral
           | DateLiteral
           | TimestampLiteral
           | IntervalDayToSecondLiteral
           | IntervalYearToMonthLiteral
           | "null";

OrderByFunctionClause : "order" "by" OrderByArguments;

OrderByArguments : OrderByArgument (',' OrderByArgument)*;

Avg : "avg" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

DistinctExpression : "distinct" SqlExpression;

AllExpression : "all" SqlExpression;

AnalyticOverClause : "over" '(' QueryPartitionClause? (OrderByClause WindowingClause?)? ')';

Cast : "cast" '(' (("multiset" '(' Subquery ')') | SqlExpression) AsDataType ')';

AsDataType : "as" SqlDataType;

Chr : "chr" '(' SqlExpression ("using" "nchar_cs")? ')';

MiningAttributeClause : "using" SelectList;

ModelName : SchemaObjectName;

ClusterId : "cluster_id" '(' ModelName MiningAttributeClause ')';

ClusterProbability : "cluster_probability" '(' ModelName (',' SqlExpression)? MiningAttributeClause ')';

ClusterSet : "cluster_set" '(' ModelName (',' SqlExpression)? (',' SqlExpression)? MiningAttributeClause ')';

Corr : "corr" '(' SqlExpression SqlExpression ')' AnalyticOverClause?;

Count : "count" '(' ('*' | DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

CovarPop : "covar_pop" '(' SqlExpression SqlExpression ')' AnalyticOverClause?;

CovarSamp : "covar_samp" '(' SqlExpression SqlExpression ')' AnalyticOverClause?;

CumeDistAnalytic : "cume_dist" '(' ')' "over" '(' QueryPartitionClause? OrderByClause ')';

QueryPartitionClause : "partition" "by" SqlExpressionList;

OrderByClause : "order" "siblings"? "by" OrderByArguments;

CumeDistAggregate : "cume_dist" SqlParameters "with" "group" '(' OrderByFunctionClause ')';

SqlParameters : '(' (SqlFunctionParameter (',' SqlFunctionParameter)*)? ')';

Decompose : "decompose" '(' SqlExpression ("canonical" | "compatibility")? ')';

DenseRankAggregate : "dense_rank" SqlParameters "with" "group" '(' OrderByFunctionClause ')';

DenseRankAnalytic : "dense_rank" '(' ')' "over" '(' QueryPartitionClause? OrderByClause ')';

OverQueryPartitionClause : "over" QueryPartitionClause;

OverParenthesesQueryPartitionClause : "over" '(' QueryPartitionClause ')';

DenseRankClause : "keep" '(' "dense_rank" ("first" | "last") OrderByFunctionClause OverQueryPartitionClause? ')';

DataToExtract : "year"
              | "month"
              | "day"
              | "hour"
              | "minute"
              | "second"
              | "timezone_hour"
              | "timezone_minute"
              | "timezone_region"
              | "timezone_abbr";

Extract : "extract" '(' DataToExtract "from" SqlExpression ')';

FeatureId : "feature_id" '(' ModelName MiningAttributeClause ')';

FeatureSet : "feature_set" '(' ModelName (',' SqlExpression)? (',' SqlExpression)? MiningAttributeClause ')';

FeatureValue : "feature_value" '(' ModelName (',' SqlExpression)? MiningAttributeClause ')';

IgnoreNulls : "ignore" "nulls";

FirstValue : "first_value" '(' SqlExpression IgnoreNulls? ')' AnalyticOverClause;

Lag : "lag" '(' SqlExpression (',' SqlExpression)? (',' SqlExpression)? ')' "over" '(' QueryPartitionClause? OrderByClause ')';

LastValue : "last_value" '(' SqlExpression IgnoreNulls? ')' AnalyticOverClause;

Lead : "lead" '(' SqlExpression (',' NumberLiteral)? (',' NumberLiteral)? ')' "over" '(' QueryPartitionClause? OrderByClause ')';

Max : "max" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

Median : "median" '(' SqlExpression ')' OverParenthesesQueryPartitionClause?;

Min : "min" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

NTile : "ntile" '(' SqlExpression ')' "over" '(' QueryPartitionClause? OrderByClause ')';

PercentRankAggregate : "percent_rank" SqlParameters
                       "within" "group" '(' OrderByFunctionClause ')';

PercentRankAnalytic : "percent_rank" '(' ')' "over" '(' QueryPartitionClause? OrderByClause ')';

PercentileCont : "percentile_cont" '(' SqlExpression ')'
                 "within" "group" '(' "order" "by" SqlExpression ("asc" | "desc")? ')' OverParenthesesQueryPartitionClause?;

PercentileDisc : "percentile_disc" '(' SqlExpression ')'
                 "within" "group" '(' "order" "by" SqlExpression ("asc" | "desc")? ')' OverParenthesesQueryPartitionClause?;

CostMatrixClauseValues : '(' SqlExpressionList ')' "values" '(' ParenthesesSqlExpressionList ')';

SqlExpressionList : SqlExpression (',' SqlExpression)*;

ParenthesesSqlExpressionList : '(' SqlExpressionList ')';

CostMatrixClauseModel : "model" "auto"?;

CostMatrixClause : "cost" (CostMatrixClauseModel | CostMatrixClauseValues);

Prediction : "prediction" '(' ModelName CostMatrixClause? MiningAttributeClause ')';

PredictionBounds : "prediction_bounds" '(' ModelName (',' SqlExpression)? (',' SqlExpression)? MiningAttributeClause ')';

PredictionCost : "prediction_cost" '(' ModelName (',' SqlExpression)? CostMatrixClause MiningAttributeClause ')';

PredictionDetails : "prediction_details" '(' ModelName MiningAttributeClause ')';

PredictionProbability : "prediction_probability" '(' ModelName MiningAttributeClause ')';

PredictionSet : "prediction_set" '(' ModelName (',' SqlExpression)? (',' SqlExpression)? CostMatrixClause? MiningAttributeClause ')';

RankAggregate : "rank" SqlParameters "within" "group" '(' OrderByFunctionClause ')';

RankAnalytic : "rank" '(' ')' "over" '(' QueryPartitionClause? OrderByClause ')';

RatioToReport : "ratio_to_report" ParenthesesSqlExpression "over" '(' QueryPartitionClause? ')';

RegrLinearFunctions : ("regr_avg" | "regr_intercept" | "regr_count" | "regr_r2" | "regr_avgx" | "regr_avgy" | "regr_sxx" | "regr_syy" | "regr_sxy") '(' SqlExpression ',' SqlExpression ')' AnalyticOverClause?;

RowNumber : "row_number" '(' ')' "over" '(' QueryPartitionClause? OrderByClause ')';

StdDev : "stddev" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

StdDevPop : "stddev_pop" '(' SqlExpression ')' AnalyticOverClause?;

StdDevSamp : "stddev_samp" '(' SqlExpression ')' AnalyticOverClause?;

Sum : "sum" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

Translate : "translate" '(' SqlExpression "using" ("char_cs" | "nchar_cs") ')';

Treat : "treat" '(' SqlExpression "as" "ref"? TypeName ')';

TrimMode : (("leading" SqlExpression) | ("trailing" SqlExpression) | ("both" SqlExpression) | "leading" | "trailing" | "both" | SqlExpression) "from";

Trim : "trim" '(' TrimMode? SqlExpression ')';

VarPop : "var_pop" '(' SqlExpression ')' AnalyticOverClause?;

VarSamp : "var_samp" '(' SqlExpression ')' AnalyticOverClause?;

Variance : "variance" '(' (DistinctExpression | AllExpression | SqlExpression) ')' AnalyticOverClause?;

XmlAgg : "xmlagg" '(' SqlExpression OrderByClause? ')';

XmlAlias : "as" (("evalname" SqlExpression) | Alias);

XmlCast : "xmlcast" '(' SqlExpression "as" SqlDataType ')';

BinaryFloat : "binary_float";

BinaryDouble : "binary_double";

DateDataType : "date";

BLobDataType : "blob";

NCLobDataType : "nclob";

BFileDataType : "bfile";

RowIdDataType : "rowid";

SqlDataType : BinaryFloat
            | BinaryDouble
            | DateDataType
            | NumberDataType
            | IntervalDayToSecondDataType
            | IntervalYearToMonthDataType
            | TimeDataType
            | TimestampDataType
            | RefXmlDataType
            | FloatDataType
            | CharDataType
            | NCharDataType
            | NVarChar2DataType
            | VarChar2DataType
            | VarCharDataType
            | LongRawDataType
            | RawDataType
            | BLobDataType
            | CLobDataType
            | NCLobDataType
            | BFileDataType
            | RowIdDataType
            | URowIdDataType;

XmlPar : SqlExpression XmlAlias?;

XmlColAttVal : "xmlcolattval" '(' XmlPar (',' XmlPar)* ')';

XmlAttributesClause : "xmlattributes" '(' ("entityescaping" | "noentityescaping")? ("schemacheck" | "noschemacheck")? XmlPar (',' XmlPar)* ')';

XmlElement : "xmlelement" '(' ("entityescaping" | "noentityescaping")? (("evalname" SqlExpression) | ("name" SqlAnyIdentifier) | SqlAnyIdentifier) (',' XmlAttributesClause)? (',' SqlExpression AsAlias?)* ')';

AsAlias : "as" Alias;

AliasedExpression : SqlExpression AsAlias?;

XmlPassingClause : "passing" ("by" "value")? AliasedExpression (',' AliasedExpression)*;

XmlExists : "xmlexists" '(' StringLiteral XmlPassingClause? ')';

XmlForest : "xmlforest" '(' XmlPar (',' XmlPar)* ')';

XmlParse : "xmlparse" '(' ("document" | "content") SqlExpression "wellformed"? ')';

XmlPI : "xmlpi" '(' (("evalname" SqlExpression) | ("name" SqlAnyIdentifier) | SqlAnyIdentifier) (',' SqlExpression)? ')';

XmlQuery : "xmlquery" '(' SqlExpression XmlPassingClause? "returning" "content" ("null" "on" "empty")? ')';

XmlRoot : "xmlroot" '(' SqlExpression ',' "version" (("no" "value") | SqlExpression) (',' "standalone" ("yes" | ("no" "value")))? ')';

XmlSerialize : "xmlparse" '(' ("document" | "content") SqlExpression AsDataType? ("encoding" SqlExpression)? ("version" StringLiteral)? (("no" "indent") | ("indent" ("size" '=' SqlExpression)?))? (("hide" | "show") "defaults")? ')';

XmlNamespacesArg : StringLiteral AsAlias;

XmlNamespacesArgs : XmlNamespacesArg (',' XmlNamespacesArg)*;

XmlNamespacesClause : "xmlnamespaces" '(' XmlNamespacesArgs? ("default" StringLiteral)? ')';

XmlTableColumn : SqlIdentifier (("for" "ordinality") | (SqlDataType ("path" StringLiteral)? ("default" SqlExpression)?));

XmlTableOptions : XmlPassingClause? ("columns" XmlTableColumn (',' XmlTableColumn)*)?;

XmlTable : "xmltable" '(' XmlNamespacesClause? SqlExpression XmlTableOptions ')';

AnalyticFunctionCall : Avg
                     | Corr
                     | Count
                     | CovarPop
                     | CovarSamp
                     | CumeDistAnalytic
                     | DenseRankAnalytic
                     | Lag
                     | PercentileCont
                     | PercentileDisc
                     | RatioToReport
                     | RegrLinearFunctions
                     | RowNumber
                     | StdDev
                     | StdDevPop
                     | StdDevSamp
                     | Sum
                     | VarPop
                     | VarSamp
                     | Variance;

SqlIdentifiedFunctionParameter : SqlAnyIdentifier '=>' SqlExpression;

SqlFunctionParameter : SqlIdentifiedFunctionParameter | SqlExpression;

UnboundedPreceding : "unbounded" "preceding";

UnboundedFollowing : "unbounded" "following";

CurrentRow : "current" "row";

Preceding : SqlExpression "preceding";

Following : SqlExpression "following";

BetweenWindowingClause : "between" (UnboundedPreceding | CurrentRow | Preceding | Following) "and" (UnboundedFollowing | CurrentRow | Preceding | Following);

WindowingClause : ("rows" | "range") (BetweenWindowingClause | UnboundedPreceding | CurrentRow | Preceding);

CellReferenceArgumentsList : CellReferenceArgument (',' CellReferenceArgument)*;

MultiColumnForLoop : "for" '(' SqlColumnsList ')' "in" '(' (ParenthesesLiteralListList | Subquery) ')';

ConditionOrExpressionList : ConditionOrExpression (',' ConditionOrExpression)*;

ConditionOrExpression : SqlCondition | SqlExpression;

CellReferenceArgument : SqlCondition | SqlExpression | SingleColumnForLoop;

SingleColumnForLoop : "for" SqlIdentifier (ForIn | ForLike);

BindVariable : '?' | (':' (SqlAnyIdentifier | NumberLiteral));

PivotForClause : "for" (ColumnName | ('(' SqlColumnsList ')'));

SqlColumnsList : ColumnName (',' ColumnName)*;

AnyList : "any" (',' "any")*;

PivotInExpressionList : PivotInExpression (',' PivotInExpression)*;

PivotInExpression : SqlExpressionList AsOptionalAlias?;

AsOptionalAlias : "as"? Alias;

PivotInClause : "in" '(' (AnyList | Subquery | PivotInExpressionList) ')';

PivotClause : "pivot" "xml"? '(' SqlAnyIdentifier '(' SqlExpression ')' AsOptionalAlias? PivotForClause PivotInClause ')';

IncludeNulls : "include" "nulls";

ExcludeNulls : "exclude" "nulls";

UnpivotClause : "unpivot" (IncludeNulls | ExcludeNulls)? '(' (ColumnName | ColumnsList) PivotForClause UnpivotInClause ')';

UnpivotInClause : "in" '(' UnpivotInClauseList ')';

UnpivotInClauseList : UnpivotInElement (',' UnpivotInElement)*;

UnpivotInElement : (ColumnName | ColumnsList) ("as" (SqlLiteral | ParenthesesLiteralList))?;

ParenthesesLiteralList : '(' SqlLiteralList ')';

SqlLiteralList : SqlLiteral (',' SqlLiteral)*;

ParenthesesLiteralListList : ParenthesesLiteralList (',' ParenthesesLiteralList)*;

Schema : SqlIdentifier;

Table : SqlIdentifier;

Object : SqlIdentifier;

Column : SqlIdentifier;

ColumnName : ((Schema '.')? Table '.')? Column;

OnlyQueryTableExpression : "only" '(' QueryTableExpression ')';

QueryTableExpressionPivotClause : QueryTableExpression PivotClause;

QueryTableExpressionUnpivotClause : QueryTableExpression UnpivotClause;

QueryTableExpressionType : OnlyQueryTableExpression | QueryTableExpressionPivotClause | QueryTableExpressionUnpivotClause | QueryTableExpression;

TableReference : QueryTableExpressionType FlashbackQueryClause? Alias?;

FlashbackQueryClause : VersionsBetween? "as" "of" ("scn" | "timestamp") SqlExpression;

VersionsBetween : "versions" "between" ("scn" | "timestamp") ("minvalue" | SqlExpression) "and" ("maxvalue" | SqlExpression);

NotCondition : "not" SqlCondition;

AndCondition : ConditionExpression "and" SqlCondition;

OrCondition : ConditionExpression "or" SqlCondition;

ConditionExpression : ExistsCondition
                    | IsCondition
                    | RelationalCondition
                    | RelationalGroupCondition
                    | InCondition
                    | IsASetCondition
                    | IsAnyCondition
                    | IsEmptyCondition
                    | IsOfTypeCondition
                    | IsPresentCondition
                    | LikeCondition
                    | RegexCondition
                    | MemberCondition
                    | BetweenCondition
                    | SubMultiSetCondition
                    | EqualsPathCondition
                    | UnderPathCondition
                    | ParenthesesCondition;

ParenthesesCondition : '(' SqlCondition ')';

ExistsCondition : "exists" '(' Subquery ')';

IsCondition : SqlExpression "is" "not"? IsConditionOption;

RelationalOperator : '=' | '<>' | '!=' | '^=' | '~=' | '>=' | '<=' | '>' | '<';

RelationalCondition : "prior"? SqlExpression RelationalOperator "prior"? SqlExpression;

RelationalGroupCondition : EqualityGroupCondition | AnyRelationalGroupCondition;

InCondition : InExpressionList "not"? "in" ParenthesesSqlExpressionList;

NestedTableName : SqlQualifiedIdentifier;

IsASetCondition : NestedTableName "is" "not"? "a" "set";

IsAnyCondition : ObjectIs? "any";

IsEmptyCondition : ObjectIs "not"? "empty";

IsOfTypeCondition : SqlExpression "is" "not"? "of" "type"? '(' IsOfTypeList ')';

CellReference : SqlQualifiedIdentifier;

IsPresentCondition : CellReference "is" "present";

LikeCondition : SqlExpression "not"? LikeOperator SqlExpression Escape?;

RegexCondition : "regexp_like" '(' SqlExpression ',' SqlExpression MatchParam? ')';

MemberCondition : SqlExpression "not"? "member" "of"? NestedTableName;

BetweenCondition : SqlExpression "not"? "between" SqlExpression "and" SqlExpression;

SubMultiSetCondition : NestedTableName "not"? "ubmultiset" "of"? NestedTableName;

EqualsPathCondition : "equals_path" '(' ColumnName ',' IdentifierOrStringLiteral CorrelationInteger? ')';

UnderPathCondition : "under_path" '(' ColumnName UnderPathLevels? ',' IdentifierOrStringLiteral CorrelationInteger ')';

IsConditionOption : "null" | "nan" | "infinite";

GroupConditionCoverageType : "any" | "some" | "all";

EqualityOperator : '=' | '<>' | '!=' | '^=' | '~=';

EqualityGroupCondition : ParenthesesSqlExpressionList EqualityOperator GroupConditionCoverageType? ParenthesesSqlExpressionList;

AnyRelationalGroupCondition : SqlExpression RelationalOperator GroupConditionCoverageType ParenthesesSqlExpressionList;

InExpressionList : ParenthesesSqlExpressionList | SqlExpression;

ObjectIs : ColumnName "is";

IsOfTypeList : IsTypeOfObject (',' IsTypeOfObject)*;

IsTypeOfObject : "only"? TypeName;

LikeOperator : "like" | "likec" | "like2" | "like4";

Escape : "escape" SqlExpression;

MatchParam : ',' StringLiteral;

CorrelationInteger : ',' NumberLiteral;

IdentifierOrStringLiteral : StringLiteral | SqlIdentifier;

UnderPathLevels : ',' NumberLiteral;

OnCondition : "on" SqlCondition;

Using : "using" '(' SqlColumnsList ')';

InnerCrossJoinClause : ("inner"? "join" TableReference (OnCondition | Using)) | (("cross" | ("natural" "inner"?)) "join" TableReference);

NaturalOuterJoin : "natural" OuterJoinType? "join";

OuterJoinType : ("full" | "left" | "right") "outer"?;

NormalOuterJoin : OuterJoinType "join";

OuterJoinClause : QueryPartitionClause? (NaturalOuterJoin | NormalOuterJoin) TableReference QueryPartitionClause? (OnCondition | Using);

JoinClauseType : InnerCrossJoinClause | OuterJoinClause;

JoinClause : JoinClauseType*;

FromArgument : TableReference JoinClause;

FromClause : "from" FromArgument (',' FromArgument)*;

CurrentOf : "current" "of" RecordName;

BulkCollect : "bulk" "collect";

SelectIntoClause : BulkCollect? "into" (('(' VariableList ')') | VariableList);

VariableList : Variable (',' Variable)*;

Distinct : "distinct" | "unique" | "all";

UnionType : "union" "all" | ("union" | "intersect" | "minus");

UnionClause : UnionType Subquery;

QueryBlock : "select" Hint? Distinct? SelectList SelectIntoClause? FromClause WhereClause? HierarchicalQueryClause? GroupByClause? HavingClause? ModelClause?;

HierarchicalQueryClause : ConnectBy | StartWith;

GroupByClause : "group" "by" GroupByArguments HavingClause?;

HavingClause : "having" SqlCondition;

ModelClause : "model" CellReferenceOptions ReturnRowsClause ReferenceModel MainModel;

EnclosedSubquery : '(' Subquery ')';

NoCycleOption : "nocycle"?;

StartWithCondition : "start" "with" SqlCondition;

ConnectByCondition : "connect" "by" NoCycleOption SqlCondition;

ConnectBy : ConnectByCondition StartWithCondition?;

StartWith : StartWithCondition ConnectByCondition;

GroupByArgument : RollupCubeClause | GroupingSetsClause | SqlExpression;

RollupCubeClause : ("rollup" | "cube") '(' GroupingExpressionList ')';

GroupingSetsClause : "grouping" "sets" '(' GroupingSetsClauseArguments ')';

GroupByArguments : GroupByArgument (',' GroupByArgument)*;

GroupingExpressionList : SqlExpressionList (',' SqlExpressionList)*;

GroupingSetsClauseArguments : GroupingSetsClauseArgument (',' GroupingSetsClauseArgument)*;

GroupingSetsClauseArgument : RollupCubeClause | GroupingExpressionList;

CellReferenceOptions : (("ignore" | "keep") "nav")? ("unique" ("dimension" | ("single" "reference")))?;

ReturnRowsClause : ("return" ("updated" | "all") "rows")?;

ReferenceModel : ("reference" ModelName "on" '(' Subquery ')' ModelColumnClause CellReferenceOptions)*;

MainModel : ("main" ModelName)? ModelColumnClause CellReferenceOptions ModelRulesClause;

ModelColumnClause : ModelColumnPartition? "dimension" "by" '(' ModelColumnList ')' "measures" '(' ModelColumnList ')';

ModelColumnPartition : QueryPartitionClause SqlIdentifier?;

ModelColumnList : ModelColumn (',' ModelColumn)*;

ModelColumn : SqlExpression AsOptionalAlias?;

ModelRulesClause : ModelRulesUpdate ModelRulesIterate? '(' ModelRulesClauseCellAssignmentList ')';

ModelRulesUpdate : ("rules" ("update" | ("upsert" "all"?))? (("automatic" | "sequential") "order")?)?;

UntilCondition : "until" '(' SqlCondition ')';

ModelRulesIterate : "iterate" '(' NumberLiteral ')' UntilCondition?;

ModelRulesClauseCellAssignmentList : ModelRulesClauseCellAssignment (',' ModelRulesClauseCellAssignment)*;

ModelRulesClauseCellAssignment : ("update" | ("upsert" "all"?))? CellAssignment OrderByClause? '=' SqlExpression;

CellAssignment : SqlAnyIdentifier '[' (CellAssignmentArgumentsList | MultiColumnForLoop) ']';

CellAssignmentArgumentsList : CellAssignmentArgument (',' CellAssignmentArgument)*;

CellAssignmentArgument : SqlCondition | SqlExpression | SingleColumnForLoop;

ForIn : "in" '(' (SqlLiteralList | Subquery) ')';

LikeString : "like" StringLiteral;

ForLike : LikeString? "from" SqlLiteral "to" SqlLiteral ("increment" | "decrement") SqlLiteral;

Order : "asc" | "desc";

NullsOrder : "nulls" ("first" | "last");

OrderByArg : NumberLiteral | SqlExpression;

OrderByArgument : OrderByArg Order? NullsOrder?;

SubqueryFactoringSource : SqlIdentifier "as" '(' Subquery ')';

WaitClause : "nowait" | ("wait" NumberLiteral) | ("skip" "locked");

OnlyDmlTableExpresionClause : "only" '(' DmlTableExpressionClause ')';

DmlTableExpressionClause : TablePartitionName | TableSubPartitionName | TableName | SubqueryDmlExpression | TableCollectionExpression;

ReturningClause : ("returning" | "return") SqlExpressionList BulkCollect? "into" ReturnIntoVariablesList;

PartitionName : '(' SqlAnyIdentifier ')';

PartitionKey : "for" '(' SqlExpression ')';

SubqueryDmlExpression : '(' Subquery SubqueryRestriction ')';

ObjectSetValue : "value" '(' Alias ')' '=' (('(' Subquery ')') | SqlExpression);

ColumnSetValueList : ColumnSetValue (',' ColumnSetValue)*;

ColumnsGroupSetValue : ColumnsList '=' '(' Subquery ')';

SingleColumnSetValue : ColumnName '=' ("default" | ('(' Subquery ')') | SqlExpression);

ColumnSetValue : ColumnsGroupSetValue | SingleColumnSetValue;

ReturnIntoVariablesList : ReturnIntoVariable (',' ReturnIntoVariable)*;

Variable : SqlQualifiedIdentifier;

ReturnIntoVariable : BindVariable | Variable;

SingleTableInsert : "insert" Hint? InsertIntoClause SingleInsertSource ErrorLogingClause?;

MultiTableInsert : "insert" Hint? (MultiIntoClause | ConditionalInsertClause) Subquery;

Values : ValuesClause ReturningClause?;

SingleInsertSource : Values | Subquery;

InsertIntoClause : "into" DmlTableExpressionClause Alias? ColumnsList?;

InsertInto : InsertIntoClause ValuesClause? ErrorLogingClause?;

MultiIntoClause : "all" InsertInto*;

ConditionalInsertClause : ("all" | "first")? ConditionalInsertWhenList ConditionalInsertElse?;

InsertIntoValuesClause : InsertIntoClause ValuesClause?;

ConditionalInsertWhen : "when" SqlCondition "then" InsertIntoValuesClause*;

ConditionalInsertElse : "else" InsertIntoValuesClause*;

ConditionalInsertWhenList : ConditionalInsertWhen*;

ValueClauseData : "default" | SqlExpression;

ValuesClauseList : '(' ValueClauseData (',' ValueClauseData)* ')';

RejectLimit : "reject" "limit" ("unlimited" | NumberLiteral);

Size : '(' NumberLiteral ')';

CharSetName : SqlAnyIdentifier;

CharSetDefinition : ("character" "set" CharSetName CharSetAttr)?;

CharSetAttr : ('%' "charset")?;

CharSize : '(' NumberLiteral ("byte" | "char")? ')';

VarChar2DataType : "varchar2" CharSize? CharSetDefinition;

VarCharDataType : "varchar" CharSize? CharSetDefinition;

CharDataType : "char" "varying"? CharSize? CharSetDefinition;

Precision : NumberLiteral;

NumberSize : ('(' Precision (',' NumberLiteral)? ')')?;

NumberDataType : "number" NumberSize;

FloatDataType : "float" Size?;

TimestampDataType : "timestamp" Size? ("with" "local"? "time" "zone")?;

IntervalDayToSecondLeadingPrecision : '(' NumberLiteral (',' NumberLiteral)? ')';

IntervalDayToSecondLiteral : "interval" IntervalDayToSecondSpec ("day" | "hour" | "minute" | "seconds") IntervalDayToSecondLeadingPrecision ("to" ("day" | "hour" | "minute" | ("second" NumberLiteral?)))?;

IntervalYearToMonthLiteral : ("interval" StringLiteral "year" Size? ("to" "month")?) | ("interval" StringLiteral "month" Size? ("to" "year")?);

IntervalDayToSecondSpec : '\'' ((NumberLiteral TimeExpression) | TimeExpression | NumberLiteral) '\'';

IntervalDayToSecondDataType : "interval" "day" Size? "to" "second" Size?;

IntervalYearToMonthDataType : "interval" "year" Size? "to" "month";

TimeDataType : "time" Size? ("with" "local"? "time" "zone")?;

RefXmlDataType : "ref" "xmltype";

NCharDataType : "nchar" "varying"? Size?;

NVarChar2DataType : "nvarchar2" Size?;

LongRawDataType : "long" "raw"? Size?;

RawDataType : "raw" Size?;

CLobDataType : "clob" CharSetDefinition;

URowIdDataType : "urowid" Size?;

SqlQualifiedIdentifier : SqlAnySimpleIdentifier ('.' SqlAnySimpleIdentifier)* DbLink?;

SqlAnySimpleIdentifier : SqlAnyIdentifier SqlParameters*;

SqlAnyIdentifier : Keyword | SqlIdentifier;

/*********************************************************************************
                                  PL-SQL rules
*********************************************************************************/

PlSqlSource : CreatePackageBody
            | CreatePackage
            | CreateFunction
            | CreateProcedure
            | AnonymousPlSqlBlock;

CreatePackageBody : CreateOrReplace "package" "body" SchemaObjectName IsAsKeyword
                    DeclareSection? PackageBody ';';

CreatePackage : CreateOrReplace "package" SchemaObjectName InvokerRights IsAsKeyword
                ItemList1?
                "end" SqlAnyIdentifier? ';';

CreateFunction : CreateOrReplace FunctionHeading InvokerRights IsAsKeyword
                 CallSpecOrPlsqlBlock ';';

CreateProcedure : CreateOrReplace ProcedureHeading InvokerRights IsAsKeyword
                  CallSpecOrPlsqlBlock ';';

AnonymousPlSqlBlock : DeclarationSection? PlSqlBody;

PlSqlExpression : PlSqlOrExpression | OptionalPlSqlAndExpression;

PlSqlOrExpression : OptionalPlSqlAndExpression "or" PlSqlExpression;

@SkipNode
OptionalPlSqlAndExpression : PlSqlAndExpression | OptionalPlSqlMathExpression;

PlSqlAndExpression : OptionalPlSqlMathExpression "and" OptionalPlSqlAndExpression;

@SkipNode
OptionalPlSqlMathExpression : PlSqlMathExpression | OptionalPlSqlRelationalExpression;

PlSqlMathExpression : OptionalPlSqlRelationalExpression SqlMathOperator OptionalPlSqlMathExpression;

@SkipNode
OptionalPlSqlRelationalExpression : PlSqlRelationalExpression | PlSqlCompoundExpression;

PlSqlRelationalExpression : PlSqlCompoundExpression RelationalOperator OptionalPlSqlRelationalExpression;

@SkipNode
PlSqlCompoundExpression : PlSqlInExpression
                        | PlSqlBetweenExpression
                        | PlSqlLikeExpression
                        | PlSqlIsNullExpression
                        | OptionalPlSqlPrefixedExpression;

PlSqlInExpression : OptionalPlSqlPrefixedExpression "not"? "in" PlSqlExpressionList;

PlSqlBetweenExpression : OptionalPlSqlPrefixedExpression "not"? BetweenBounds;

PlSqlLikeExpression : OptionalPlSqlPrefixedExpression "not"? LikeOperator PlSqlExpression;

PlSqlIsNullExpression : OptionalPlSqlPrefixedExpression "is" Nullable;

@SkipNode
OptionalPlSqlPrefixedExpression : PlSqlPrefixedExpression | PlSqlAtomicExpression;

PlSqlPrefixedExpression : Sign PlSqlExpression;

Sign : "not"
     | '+'
     | '-';

PlSqlExpressionList : '(' PlSqlExpression (',' PlSqlExpression)* ')';

BetweenBounds : "between" PlSqlExpression "and" PlSqlExpression;

Nullable : "null"
         | NotNull;

@SkipNode
PlSqlAtomicExpression : PlSqlParenthesesExpression
                      | PlSqlLiteral
                      | SqlCursorAttribute
                      | PlSqlCaseExpression
                      | PlSqlObjectCursor
                      | PlSqlObjectCollection
                      | BuiltInFunctionCall
                      | SqlQualifiedIdentifier
                      | HostVariableCursor
                      | HostVariable;

PlSqlParenthesesExpression : '(' PlSqlExpression ')';

SqlCursorAttribute : "sql" CursorAttribute;

CursorAttribute : '%' (("bulk_rowcount" PlSqlParenthesesExpression) | "found" | "isopen" | "notfound" | "rowcount");

PlSqlObjectCursor : Variable CursorAttribute;

PlSqlObjectCollection : Variable CollectionAttribute;

CollectionAttribute : '.' ("count" | "first" | "last" | "limit" | ("exists" PlSqlParenthesesExpression) | ("next" PlSqlParenthesesExpression) | ("prior" PlSqlParenthesesExpression));

HostVariableCursor : HostVariable CursorAttribute;

HostVariable : ':' Variable;

PlSqlLiteral : SqlLiteral | BooleanLiteral;

PlSqlCaseExpression : "case" PlSqlExpression? CaseExpressionWhenList CaseExpressionElse? "end";

CaseExpressionElse : "else" PlSqlExpression;

CaseExpressionWhen : "when" PlSqlExpression "then" PlSqlExpression;

CaseExpressionWhenList : CaseExpressionWhen*;

IsAsKeyword : "is" | "as";

DeclarationSection : "declare" DeclareSection?;

DeclareSection : (ItemList1 ItemList2?) | ItemList2;

EndBlock : "end" SqlAnyIdentifier?;

PackageBody : EndBlock | PlSqlBody;

PlSqlBody : "begin" PlSqlBodyStatements? ExceptionBlock? "end" SqlAnyIdentifier?;

CreateOrReplace : "create" ("or" "replace")?;

AuthIdCurrentUser : "authid" "current_user";

AuthIdDefiner : "authid" "definer";

InvokerRights : (AuthIdCurrentUser | AuthIdDefiner)?;

ItemList1 : ItemList1First ';' (ItemList1Second ';')*;

ExternalCParameter : SqlAnyIdentifier SqlAnyIdentifier?;

ExternalCParametersDeclaration : '(' ExternalCParameter (',' ExternalCParameter)* ')';

CallJavaSpec : "language" "java" "name" StringLiteral;

CallCSpec : "language" "c" ("name" SqlAnyIdentifier)? "library" SqlAnyIdentifier ("agent" "in" '(' SqlAnyIdentifier (',' SqlAnyIdentifier)* ')')? ("with" "context")? ("parameters" ExternalCParametersDeclaration)?;

CallSpec : CallJavaSpec | CallCSpec;

PlSqlBodyStatements : PlSqlStatement ';' ((Pragma | PlSqlStatement) ';')*;

PlSqlStatement : Label* (AssignStatement
                        | CaseStatement
                        | CloseStatement
                        | ContinueStatement
                        | BasicLoopStatement
                        | ExecuteImmediateStatement
                        | ExitStatement
                        | FetchStatement
                        | ForLoopStatement
                        | ForAllStatement
                        | GotoStatement
                        | ifStatement
                        | NullStatement
                        | OpenStatement
                        | PlSqlBlock
                        | RaiseStatement
                        | ReturnStatement
                        | SqlStatement
                        | WhileLoopStatement
                        | PipeRowStatement
                        | BuiltInFunctionCall
                        | SqlQualifiedIdentifier);

Pragma : "pragma" (("restrict_references" '(' ("default" | SqlAnyIdentifier) (',' PragmaParam)* ')') |
                   ("exception_init" '(' SqlAnyIdentifier ',' PlSqlLiteral ')') |
                   "autonomous_transaction" |
                   "serially_reusable" |
                   ("builtin" PragmaParams) |
                   ("flipsflag" PragmaParams) |
                   ("interface" PragmaParams) |
                   ("new_names" PragmaParams) |
                   ("timestamp" PragmaParams));

ExceptionBlock : "exception" ExceptionHandler*;

CallSpecOrPlsqlBlock : CallSpec | PlSqlBlock;

PlSqlBlock : Label* DeclarationSection? PlSqlBody;

FunctionHeading : "function" SchemaObjectName ParenthesesParametersDeclaration? ReturnType;

ProcedureHeading : "procedure" SchemaObjectName ParenthesesParametersDeclaration?;

ItemList1First : TypeDefinition
               | FunctionDeclaration
               | ProcedureDeclaration
               | ItemDeclaration;

TypeDefinition : RecordTypeDefinition
               | RefCursorTypeDefinition
               | SubtypeDefinition
               | CollectionTypeDefinition;

FunctionDeclaration : FunctionHeading FunctionModifier;

ProcedureDeclaration : ProcedureHeading;

ItemDeclaration : ExceptionDeclaration
                | ConstantDeclaration
                | CursorDeclaration
                | VariableDeclaration;

ItemList1Second : TypeDefinition
                | ProcedureDeclaration
                | FunctionDeclaration
                | Pragma
                | ItemDeclaration;

ItemList2First : FunctionDefinition
               | FunctionDeclaration
               | ProcedureDefinition
               | ProcedureDeclaration;

FunctionDefinition : FunctionHeading FunctionModifier IsAsKeyword
                     DeclareSection?
                     CallSpecOrPlsqlBlock;

ProcedureDefinition : ProcedureHeading IsAsKeyword
                      DeclareSection?
                      CallSpecOrPlsqlBlock;

ItemList2Second : FunctionDefinition
                | FunctionDeclaration
                | ProcedureDefinition
                | ProcedureDeclaration
                | Pragma;

ItemList2 : ItemList2First ';' (ItemList2Second ';')*;

TypeDefinitionName : SqlAnyIdentifier;

RecordTypeDefinition : "type" TypeDefinitionName "is" "record"
                       '('
                       RecordFieldDeclaration (',' RecordFieldDeclaration)*
                       ')';

RefCursorTypeDefinition : "type" TypeDefinitionName "is" "ref" "cursor" ReturnType?;

SubtypeDefinition : "subtype" TypeDefinitionName "is" TypeSpec PlSqlExpressionList? Nullable?;

CollectionTypeDefinition : "type" TypeDefinitionName "is" (VarrayTypeDefinition | NestedTableTypeDefinition | AssociativeArrayTypeDefinition);

NotNull : "not" "null";

TypeSpec : PlSqlDataType
         | CursorRef
         | UserType;

RecordFieldDeclaration : SqlAnyIdentifier TypeSpec Nullable? DefaultValue?;

DefaultOperator : ':=' | "default";

DefaultValue : DefaultOperator PlSqlExpression;

VarrayTypeDefinition : (("varying" "array"?) | "varray") '(' NumberLiteral ')' "of" TypeSpec Nullable?;

NestedTableTypeDefinition : "table" "of" TypeSpec Nullable? ("index" "by" TypeSpec)?;

AssociativeArrayTypeDefinition : "table" "of" TypeSpec Nullable? OptionalIndexBy;

IndexBy : "index" "by" ("pls_integer" | "binary_integer" | ("varchar2" PlSqlExpression));

OptionalIndexBy : IndexBy?;

ReturnType : "return" TypeSpec;

NumericDataType : ("number" | "numeric" | "decimal" | "dec") NumberSize;

SmallIntPrecisionDataType : "smallint" "precision";

CharacterDataType : "character" "varying"? Size?;

NVarCharDataType : "nvarchar" Size?;

NationalCharacterDataType : "national" ("character" | "char") "varying"? Size?;

IntegerDataType : "integer" Size?;

IntDataType : "int" Size?;

SmallIntDataType : "smallint" Size?;

RealDataType : "real" Size?;

BinaryIntegerDataType : "binary_integer";

NaturalDataType : "natural";

PositiveDataType : "positive";

BooleanDataType : "boolean";

Pls_integerDataType : "pls_integer";

PlSqlDataType : SqlDataType
              | BinaryIntegerDataType
              | NaturalDataType
              | PositiveDataType
              | NumericDataType
              | BooleanDataType
              | IntegerDataType
              | IntDataType
              | SmallIntDataType
              | RealDataType
              | SmallIntPrecisionDataType
              | CharacterDataType
              | NVarCharDataType
              | NationalCharacterDataType
              | Pls_integerDataType;

RowType : '%' "rowtype";

Type : '%' "type";

CursorReturnType : "return" Variable RowType;

CursorRef : "ref" "cursor" CursorReturnType?;

UserTypeAttribute : RowType
                  | Type
                  | Size;

UserTypeName : SqlQualifiedIdentifier;

UserType : UserTypeName UserTypeAttribute?;

ParenthesesParametersDeclaration : '(' ParameterDeclaration (',' ParameterDeclaration)* ')';

ParameterDeclaration : SqlAnyIdentifier "in"? Out? TypeSpec DefaultValue?;

Out : "out" "nocopy"?;

CursorDeclaration : "cursor" SqlAnyIdentifier ParenthesesParametersDeclaration? "is" SelectStatement;

ExceptionDeclaration : SqlAnyIdentifier "exception";

ConstantDeclaration : SqlAnyIdentifier "constant" TypeSpec Nullable? DefaultValue;

VariableDeclaration : SqlAnyIdentifier TypeSpec Nullable? DefaultValue?;

ResultCache : "result_cache" ("relies_on" '(' TableName (',' TableName)* ')')?;

FunctionModifier : ("deterministic" | "pipelined" | "parallel_enable" | ResultCache)*;

PragmaParam : SqlAnyIdentifier | StringLiteral | (('+' | '-')? NumberLiteral);

PragmaParams : '(' PragmaParam (',' PragmaParam)* ')';

Label : '<<' SqlAnyIdentifier '>>';

AssignStatement : LeftValue ':=' PlSqlExpression;

CaseStatement : "case" PlSqlExpression? CaseStatementWhenList CaseStatementElse? "end" "case" SqlAnyIdentifier?;

CloseStatement : "close" Variable;

ContinueStatement : "continue" SqlAnyIdentifier? PlSqlExpression?;

BasicLoopStatement : "loop" PlSqlStatements "end" "loop" SqlAnyIdentifier?;

ExecuteImmediateStatement : "execute" "immediate" PlSqlExpression ExecuteImediateOptions?;

ExitStatement : "exit" SqlAnyIdentifier? ("when" PlSqlExpression)?;

FetchStatement : "fetch" LeftValue (IntoClause | (BulkCollectIntoClause Limit?));

ForLoopStatement : "for" SqlAnyIdentifier "in" ForBoundsClause "loop" PlSqlStatements "end" "loop" SqlAnyIdentifier?;

ForAllStatement : "forall" SqlAnyIdentifier "in" ForAllBoundsClause (ExecuteImmediateStatement | SqlStatement) ("save" "exceptions")?;

GotoStatement : "goto" SqlAnyIdentifier;

ifStatement : "if" PlSqlExpression "then" PlSqlStatements ElsIf* ElseBlock? "end" "if";

NullStatement : "null";

OpenStatement : "open" Variable ForCursor;

RaiseStatement : "raise" Variable?;

ReturnStatement : "return" PlSqlExpression?;

SqlStatement : DmlSentence;

WhileLoopStatement : "while" PlSqlExpression "loop" PlSqlStatements "end" "loop" SqlAnyIdentifier?;

PipeRowStatement : "pipe" "row" '(' SqlAnyIdentifier ')';

LeftValue : HostVariable | Variable;

CaseStatementWhen : "when" PlSqlExpression "then" PlSqlStatements;

PlSqlStatements : (PlSqlStatement ';')*;

CaseStatementWhenList : CaseStatementWhen*;

CaseStatementElse : "else" PlSqlStatements;

ExecuteImediateOptions : (IntoClause UsingClause?)
                       | (BulkCollectIntoClause UsingClause?)
                       | (UsingClause DynamicReturningClause?)
                       | DynamicReturningClause;

IntoClause : "into" LeftValue (',' LeftValue)*;

UsingClause : "using" UsingParameter (',' UsingParameter)*;

BulkCollectIntoClause : "bulk" "collect" "into" LeftValue (',' LeftValue)*;

DynamicReturningClause : ("returning" | "return") (IntoClause | BulkCollectIntoClause);

UsingParameter : "in"? Out? PlSqlExpression;

Limit : "limit" PlSqlExpression;

ForBoundsClause : RangeBounds | CursorBounds | SelectBounds;

RangeBounds : "reverse"? Range;

Range : PlSqlExpression '..' PlSqlExpression;

CursorBounds : Variable PlSqlExpressionList?;

SelectBounds : '(' SelectStatement ')';

ForAllBoundsClause : Range
                   | IndicesOfCollection
                   | ValuesOfIndexCollection;

IndicesOfCollection : "indices" "of" PlSqlAtomicExpression BetweenBounds?;

ValuesOfIndexCollection : "values" "of" PlSqlAtomicExpression;

ElsIf : "elsif" PlSqlExpression "then" PlSqlStatements;

ElseBlock : "else" PlSqlStatements;

CursorSource : SelectStatement
             | PlSqlExpression;

CursorUsingClause : UsingClause?;

ForCursorSource : "for" CursorSource CursorUsingClause;

ForCursor : ForCursorSource?;

OrHandlerIdentifier : "or" Variable;

MultipleHandlerIdentifier : Variable OrHandlerIdentifier*;

HandlerIdentifiers : "others" | MultipleHandlerIdentifier;

ExceptionHandler : "when" HandlerIdentifiers "then" PlSqlStatements;

BooleanLiteral : "true" | "false";

/*********************************************************************************
                              COMMON rules
*********************************************************************************/
Keyword : "access" | "add" | "all" | "alter" | "and" | "any" | "as" | "asc" | "at" | "automatic" | "audit" | "avg" | "a" | "batch" | "between" | "block" |
          "bulk" | "byte" | "by" | "canonical" | "case" | "cast" | "char" | "check" | "chr" | "cluster_id" | "cluster_probability" | "cluster_set" |
          "cluster" | "collect" | "column" | "comment" | "commited" | "commit" | "compatibility" | "compress" | "connect_by_root" | "connect" |
          "constant" | "content" | "corrupt_xid_all" | "corrupt_xid" | "corr" | "count" | "covar_pop" | "covar_samp" | "cume_dist" | "cursor" |
          "create" | "current" | "date" | "day" | "dbtimezone" | "decimal" | "decompose" | "decrement" | "default" | "dense_rank" | "desc" | "dimension" |
          "distinct" | "document" | "drop" | "else" | "end" | "empty" | "errors" | "exclusive" | "exists" | "extract" | "file" | "first" | "float" | "following" |
          "force" | "for" | "grant" | "group" | "having" | "hour" | "identified" | "ignore" | "immediate" | "indicator" | "increment" | "index" | "inner" | "interval" |
          "in" | "initialvinsert" | "insert" | "integer" | "intersect" | "isolation" | "is" | "iterate" | "join" | "keep" | "last" | "level" | "like" | "local" |
          "locked" | "lock" | "log" | "long" | "matched" | "maxextents" | "minus" | "minute" | "mslabel" | "modify" | "model" | "mode" | "mod" | "month" | "multiset" |
          "name" | "natural" | "nchar_cs" | "new" | "noaudit" | "nocompress" | "not" | "nowait" | "no" | "nulls" | "null" | "number" | "of" | "offline" | "online" | "only" |
          "option" | "or" | "order" | "over" | "partition" | "passing" | "percent_rank" | "pctfree" | "preceding" | "present" | "prior" | "privileges" | "public" |
          "range" | "rank" | "raw" | "read" | "reference" | "ref" | "rename" | "resource" | "returning" | "return" | "revoke" | "rollback" | "row" | "rowid" | "rownum" |
          "rows" | "rules" | "sample" | "savepoint" | "seconds" | "second" | "seed" | "segment" | "select" | "serializable" | "sessiontimezone" | "session" |
          "set" | "share" | "siblings" | "size" | "skip" | "smallint" | "some" | "start" | "subpartition" | "successful" | "synonym" | "sysdate" | "timestamp" |
          "timezone_hour" | "timezone_minute" | "timezone_region" | "timezone_abbr" | "trailing" | "transaction" | "table" | "then" | "time" | "to" |
          "trigger" | "type" | "uid" | "unbounded" | "union" | "unique" | "until" | "upsert" | "user" | "use" | "validate" | "values" | "value" | "varchar" |
          "varchar2" | "varying" | "view" | "wait" | "within" | "xmlparse" | "year" | "zone" | "whenever" | "when" | "where" | "with" | "write" | "updated" | "update" |
          "delete" | "from" | "work" | "merge" | "into" | "using" | "on" | "feature_id" | "feature_set" | "feature_value" | "first_value" | "lag" | "last_value" |
          "lead" | "max" | "median" | "min" | "ntile" | "percentile_cont" | "percentile_disc" | "auto" | "cost" | "prediction" | "prediction_bounds" | "prediction_cost" |
          "prediction_details" | "prediction_probability" | "prediction_set" | "ratio_to_report" | "regr_avg" | "regr_intercept" | "regr_count" | "regr_r2" |
          "regr_avgx" | "regr_avgy" | "regr_sxx" | "regr_syy" | "regr_sxy" | "row_number" | "stddev" | "stddev_pop" | "stddev_samp" | "sum" | "translate" | "char_cs" |
          "treat" | "leading" | "both" | "trim" | "var_pop" | "var_samp" | "variance" | "xmlagg" | "evalname" | "xmlcast" | "binary_float" | "binary_double" | "blob" |
          "nclob" | "bfile" | "xmlcolattval" | "xmlattributes" | "entityescaping" | "noentityescaping" | "schemacheck" | "noschemacheck" | "xmlelement" |
          "xmlexists" | "xmlforest" | "wellformed" | "xmlpi" | "xmlquery" | "xmlroot" | "version" | "standalone" | "yes" | "encoding" | "indent" | "hide" | "show" |
          "defaults" | "xmlnamespaces" | "ordinality" | "path" | "columns" | "xmltable" | "pivot" | "xml" | "include" | "exclude" | "unpivot" | "scn" | "versions" |
          "minvalue" | "maxvalue" | "regexp_like" | "member" | "ubmultiset" | "equals_path" | "under_path" | "nan" | "infinite" | "likec" | "like2" | "like4" |
          "escape" | "cross" | "full" | "left" | "right" | "outer" | "nocycle" | "rollup" | "cube" | "grouping" | "sets" | "nav" | "single" | "main" | "measures" | "sequential" |
          "reject" | "limit" | "unlimited" | "character" | "charset" | "xmltype" | "nchar" | "nvarchar2" | "clob" | "urowid" | "package" | "body" | "sql" | "bulk_rowcount" |
          "found" | "isopen" | "notfound" | "rowcount" | "next" | "declare" | "begin" | "replace" | "authid" | "current_user" | "definer" | "language" | "java" | "c" |
          "library" | "agent" | "context" | "parameters" | "pragma" | "restrict_references" | "exception_init" | "autonomous_transaction" | "serially_reusable" |
          "builtin" | "fipsflag" | "interface" | "new_names" | "exception" | "function" | "procedure" | "record" | "subtype" | "array" | "varray" | "pls_integer" | "binary_integer" |
          "numeric" | "dec" | "precision" | "nvarchar" | "national" | "int" | "real" | "positive" | "boolean" | "rowtype" | "out" | "nocopy" | "result_cache" | "relies_on" | "deterministic" |
          "pipelined" | "parallel_enable" | "close" | "continue" | "loop" | "execute" | "exit" | "fetch" | "forall" | "save" | "exceptions" | "goto" | "if" | "open" | "raise" | "while" |
          "pipe" | "reverse" | "indices" | "elsif" | "others" | "true" | "false" | "arrow" | "clusters" | "colauth" | "crash" | "form" | "indexes" | "overlaps" | "tabauth" |
          "views" | "flipsflag";


@Fragment
Space : ' ' | '\t' | '\f';

WS : (' ' | '\t' | '\r' | '\n' | '\f')+;

@Atomic
BlockHint : '/*+' ('*/'! .)* '*/';

@Atomic
LineHint : '--+' (('\r' | '\n')!.)*;

@Atomic
BlockComment : '/*' ('*/'! .)* '*/';

@Atomic
LineComment : '--' (('\r' | '\n')!.)*;

@Fragment
Exponent : "E" ('+' | '-')? [0-9]+ "D"?;

@Fragment
UnsignedNumber : ([0-9]+ '.' [0-9]+)
               | [0-9]+
               | ('.' [0-9]+);

@Atomic               
NumberLiteral : UnsignedNumber Exponent?;


StringLiteral : "N"? ('\'' (('\n' | '\r' | '\'')! .)* '\'');

@Atomic
DateLiteral : 'date' '\'' Space* ([0-9] [0-9] [0-9] [0-9]) Space* '-' Space* ([0-9] [0-9]) Space* '-' Space* ([0-9] [0-9]) Space* '\'';

@Atomic
TimestampLiteral : "timestamp" '\'' Space* ([0-9] [0-9] [0-9] [0-9]) Space* '-' Space* ([0-9] [0-9]) Space* '-' Space* ([0-9] [0-9]) Space* ([0-9] [0-9]) Space* ':' Space* ([0-9] [0-9]) Space* ':' Space* ([0-9] [0-9]) Space* '\'';

@Fragment
OneDigit : [0-9];

@Atomic
SqlIdentifier : (([a-z] | [A-Z]) ([a-z] | [A-Z] | [0-9] | '_' | '$' | '#')*)
              | ('"' (('\n' | '\r' | '"')! .)+ '"');
