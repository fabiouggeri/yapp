/***************************************************
 * PEG Parser - Generated By YAPP Parser Generator *
 ***************************************************/

package org.uggeri.yapp.runtime.java.test;

import org.uggeri.yapp.runtime.java.parser.Parser;
import org.uggeri.yapp.runtime.java.parser.Rule;
import org.uggeri.yapp.runtime.java.parser.RuleProfile;
import org.uggeri.yapp.runtime.java.buffer.InputBuffer;
import org.uggeri.yapp.runtime.java.node.Node;
import org.uggeri.yapp.runtime.java.node.NodeImpl;
import org.uggeri.yapp.runtime.java.parser.ParserError;
import org.uggeri.yapp.runtime.java.trace.TraceParser;
import java.util.Collections;
import java.util.Collection;
import java.util.Arrays;
import java.util.Map;

public class HarbourUnprocessedParser implements Parser {

   private int index = 0;

   private InputBuffer buffer;

   private boolean currentRuleIsAtomic = false;

   private Node currentNode = new NodeImpl(null, 0, 0, false, false);

   private int statement$RuleMemoStart = -1;
   private int statement$RuleMemoEnd;
   private Node statement$RuleMemoFirstNode;
   private Node statement$RuleMemoLastNode;
   private int localVariablesDeclaration$RuleMemoStart = -1;
   private int localVariablesDeclaration$RuleMemoEnd;
   private Node localVariablesDeclaration$RuleMemoFirstNode;
   private Node localVariablesDeclaration$RuleMemoLastNode;
   private int functionDeclaration$RuleMemoStart = -1;
   private int functionDeclaration$RuleMemoEnd;
   private Node functionDeclaration$RuleMemoFirstNode;
   private Node functionDeclaration$RuleMemoLastNode;
   private int procedureDeclaration$RuleMemoStart = -1;
   private int procedureDeclaration$RuleMemoEnd;
   private Node procedureDeclaration$RuleMemoFirstNode;
   private Node procedureDeclaration$RuleMemoLastNode;
   private int methodDefinition$RuleMemoStart = -1;
   private int methodDefinition$RuleMemoEnd;
   private Node methodDefinition$RuleMemoFirstNode;
   private Node methodDefinition$RuleMemoLastNode;
   private int createClass$RuleMemoStart = -1;
   private int createClass$RuleMemoEnd;
   private Node createClass$RuleMemoFirstNode;
   private Node createClass$RuleMemoLastNode;
   private int endClass$RuleMemoStart = -1;
   private int endClass$RuleMemoEnd;
   private Node endClass$RuleMemoFirstNode;
   private Node endClass$RuleMemoLastNode;
   private int classBodyStmt$RuleMemoStart = -1;
   private int classBodyStmt$RuleMemoEnd;
   private Node classBodyStmt$RuleMemoFirstNode;
   private Node classBodyStmt$RuleMemoLastNode;
   private int sectionScope$RuleMemoStart = -1;
   private int sectionScope$RuleMemoEnd;
   private Node sectionScope$RuleMemoFirstNode;
   private Node sectionScope$RuleMemoLastNode;
   private int memberScope$RuleMemoStart = -1;
   private int memberScope$RuleMemoEnd;
   private Node memberScope$RuleMemoFirstNode;
   private Node memberScope$RuleMemoLastNode;
   private int methodMember$RuleMemoStart = -1;
   private int methodMember$RuleMemoEnd;
   private Node methodMember$RuleMemoFirstNode;
   private Node methodMember$RuleMemoLastNode;
   private int fieldMember$RuleMemoStart = -1;
   private int fieldMember$RuleMemoEnd;
   private Node fieldMember$RuleMemoFirstNode;
   private Node fieldMember$RuleMemoLastNode;
   private int inLineExpression$RuleMemoStart = -1;
   private int inLineExpression$RuleMemoEnd;
   private Node inLineExpression$RuleMemoFirstNode;
   private Node inLineExpression$RuleMemoLastNode;
   private int variable$RuleMemoStart = -1;
   private int variable$RuleMemoEnd;
   private Node variable$RuleMemoFirstNode;
   private Node variable$RuleMemoLastNode;
   private int staticVariablesDeclaration$RuleMemoStart = -1;
   private int staticVariablesDeclaration$RuleMemoEnd;
   private Node staticVariablesDeclaration$RuleMemoFirstNode;
   private Node staticVariablesDeclaration$RuleMemoLastNode;
   private int fieldsDeclaration$RuleMemoStart = -1;
   private int fieldsDeclaration$RuleMemoEnd;
   private Node fieldsDeclaration$RuleMemoFirstNode;
   private Node fieldsDeclaration$RuleMemoLastNode;
   private int classDeclaration$RuleMemoStart = -1;
   private int classDeclaration$RuleMemoEnd;
   private Node classDeclaration$RuleMemoFirstNode;
   private Node classDeclaration$RuleMemoLastNode;
   private int oldStyleParametersDeclaration$RuleMemoStart = -1;
   private int oldStyleParametersDeclaration$RuleMemoEnd;
   private Node oldStyleParametersDeclaration$RuleMemoFirstNode;
   private Node oldStyleParametersDeclaration$RuleMemoLastNode;
   private int declareStatement$RuleMemoStart = -1;
   private int declareStatement$RuleMemoEnd;
   private Node declareStatement$RuleMemoFirstNode;
   private Node declareStatement$RuleMemoLastNode;
   private int exitStmt$RuleMemoStart = -1;
   private int exitStmt$RuleMemoEnd;
   private Node exitStmt$RuleMemoFirstNode;
   private Node exitStmt$RuleMemoLastNode;
   private int loopStmt$RuleMemoStart = -1;
   private int loopStmt$RuleMemoEnd;
   private Node loopStmt$RuleMemoFirstNode;
   private Node loopStmt$RuleMemoLastNode;
   private int directive$RuleMemoStart = -1;
   private int directive$RuleMemoEnd;
   private Node directive$RuleMemoFirstNode;
   private Node directive$RuleMemoLastNode;
   private int lineDirective$RuleMemoStart = -1;
   private int lineDirective$RuleMemoEnd;
   private Node lineDirective$RuleMemoFirstNode;
   private Node lineDirective$RuleMemoLastNode;
   private int includeDirective$RuleMemoStart = -1;
   private int includeDirective$RuleMemoEnd;
   private Node includeDirective$RuleMemoFirstNode;
   private Node includeDirective$RuleMemoLastNode;
   private int defineDirective$RuleMemoStart = -1;
   private int defineDirective$RuleMemoEnd;
   private Node defineDirective$RuleMemoFirstNode;
   private Node defineDirective$RuleMemoLastNode;
   private int translateDirective$RuleMemoStart = -1;
   private int translateDirective$RuleMemoEnd;
   private Node translateDirective$RuleMemoFirstNode;
   private Node translateDirective$RuleMemoLastNode;
   private int xTranslateDirective$RuleMemoStart = -1;
   private int xTranslateDirective$RuleMemoEnd;
   private Node xTranslateDirective$RuleMemoFirstNode;
   private Node xTranslateDirective$RuleMemoLastNode;
   private int xCommandDirective$RuleMemoStart = -1;
   private int xCommandDirective$RuleMemoEnd;
   private Node xCommandDirective$RuleMemoFirstNode;
   private Node xCommandDirective$RuleMemoLastNode;
   private int commandDirective$RuleMemoStart = -1;
   private int commandDirective$RuleMemoEnd;
   private Node commandDirective$RuleMemoFirstNode;
   private Node commandDirective$RuleMemoLastNode;
   private int ifDefDirective$RuleMemoStart = -1;
   private int ifDefDirective$RuleMemoEnd;
   private Node ifDefDirective$RuleMemoFirstNode;
   private Node ifDefDirective$RuleMemoLastNode;
   private int ifDirective$RuleMemoStart = -1;
   private int ifDirective$RuleMemoEnd;
   private Node ifDirective$RuleMemoFirstNode;
   private Node ifDirective$RuleMemoLastNode;
   private int ifNDefDirective$RuleMemoStart = -1;
   private int ifNDefDirective$RuleMemoEnd;
   private Node ifNDefDirective$RuleMemoFirstNode;
   private Node ifNDefDirective$RuleMemoLastNode;
   private int elseDirective$RuleMemoStart = -1;
   private int elseDirective$RuleMemoEnd;
   private Node elseDirective$RuleMemoFirstNode;
   private Node elseDirective$RuleMemoLastNode;
   private int endIfDirective$RuleMemoStart = -1;
   private int endIfDirective$RuleMemoEnd;
   private Node endIfDirective$RuleMemoFirstNode;
   private Node endIfDirective$RuleMemoLastNode;
   private int pragmaDirective$RuleMemoStart = -1;
   private int pragmaDirective$RuleMemoEnd;
   private Node pragmaDirective$RuleMemoFirstNode;
   private Node pragmaDirective$RuleMemoLastNode;
   private int undefDirective$RuleMemoStart = -1;
   private int undefDirective$RuleMemoEnd;
   private Node undefDirective$RuleMemoFirstNode;
   private Node undefDirective$RuleMemoLastNode;
   private int stdoutDirective$RuleMemoStart = -1;
   private int stdoutDirective$RuleMemoEnd;
   private Node stdoutDirective$RuleMemoFirstNode;
   private Node stdoutDirective$RuleMemoLastNode;
   private int errorDirective$RuleMemoStart = -1;
   private int errorDirective$RuleMemoEnd;
   private Node errorDirective$RuleMemoFirstNode;
   private Node errorDirective$RuleMemoLastNode;
   private int anyToken$RuleMemoStart = -1;
   private int anyToken$RuleMemoEnd;
   private Node anyToken$RuleMemoFirstNode;
   private Node anyToken$RuleMemoLastNode;
   private int separator$RuleMemoStart = -1;
   private int separator$RuleMemoEnd;
   private Node separator$RuleMemoFirstNode;
   private Node separator$RuleMemoLastNode;
   private int cmdComplementation$RuleMemoStart = -1;
   private int cmdComplementation$RuleMemoEnd;
   private Node cmdComplementation$RuleMemoFirstNode;
   private Node cmdComplementation$RuleMemoLastNode;
   private int unknownIdentifier$RuleMemoStart = -1;
   private int unknownIdentifier$RuleMemoEnd;
   private Node unknownIdentifier$RuleMemoFirstNode;
   private Node unknownIdentifier$RuleMemoLastNode;
   private int beginProducer$RuleMemoStart = -1;
   private int beginProducer$RuleMemoEnd;
   private Node beginProducer$RuleMemoFirstNode;
   private Node beginProducer$RuleMemoLastNode;
   private int endProducer$RuleMemoStart = -1;
   private int endProducer$RuleMemoEnd;
   private Node endProducer$RuleMemoFirstNode;
   private Node endProducer$RuleMemoLastNode;
   private int beginTransaction$RuleMemoStart = -1;
   private int beginTransaction$RuleMemoEnd;
   private Node beginTransaction$RuleMemoFirstNode;
   private Node beginTransaction$RuleMemoLastNode;
   private int commitTransaction$RuleMemoStart = -1;
   private int commitTransaction$RuleMemoEnd;
   private Node commitTransaction$RuleMemoFirstNode;
   private Node commitTransaction$RuleMemoLastNode;
   private int rollbackTransaction$RuleMemoStart = -1;
   private int rollbackTransaction$RuleMemoEnd;
   private Node rollbackTransaction$RuleMemoFirstNode;
   private Node rollbackTransaction$RuleMemoLastNode;
   private int useAs$RuleMemoStart = -1;
   private int useAs$RuleMemoEnd;
   private Node useAs$RuleMemoFirstNode;
   private Node useAs$RuleMemoLastNode;
   private int useAlias$RuleMemoStart = -1;
   private int useAlias$RuleMemoEnd;
   private Node useAlias$RuleMemoFirstNode;
   private Node useAlias$RuleMemoLastNode;
   private int useAsPrecision$RuleMemoStart = -1;
   private int useAsPrecision$RuleMemoEnd;
   private Node useAsPrecision$RuleMemoFirstNode;
   private Node useAsPrecision$RuleMemoLastNode;
   private int useArea$RuleMemoStart = -1;
   private int useArea$RuleMemoEnd;
   private Node useArea$RuleMemoFirstNode;
   private Node useArea$RuleMemoLastNode;
   private int useCodepage$RuleMemoStart = -1;
   private int useCodepage$RuleMemoEnd;
   private Node useCodepage$RuleMemoFirstNode;
   private Node useCodepage$RuleMemoLastNode;
   private int oldStyleCommands$RuleMemoStart = -1;
   private int oldStyleCommands$RuleMemoEnd;
   private Node oldStyleCommands$RuleMemoFirstNode;
   private Node oldStyleCommands$RuleMemoLastNode;
   private int arrobaGetSay$RuleMemoStart = -1;
   private int arrobaGetSay$RuleMemoEnd;
   private Node arrobaGetSay$RuleMemoFirstNode;
   private Node arrobaGetSay$RuleMemoLastNode;
   private int setCmd$RuleMemoStart = -1;
   private int setCmd$RuleMemoEnd;
   private Node setCmd$RuleMemoFirstNode;
   private Node setCmd$RuleMemoLastNode;
   private int readCmd$RuleMemoStart = -1;
   private int readCmd$RuleMemoEnd;
   private Node readCmd$RuleMemoFirstNode;
   private Node readCmd$RuleMemoLastNode;
   private int clsCmd$RuleMemoStart = -1;
   private int clsCmd$RuleMemoEnd;
   private Node clsCmd$RuleMemoFirstNode;
   private Node clsCmd$RuleMemoLastNode;
   private int clearCmd$RuleMemoStart = -1;
   private int clearCmd$RuleMemoEnd;
   private Node clearCmd$RuleMemoFirstNode;
   private Node clearCmd$RuleMemoLastNode;
   private int keyboardCmd$RuleMemoStart = -1;
   private int keyboardCmd$RuleMemoEnd;
   private Node keyboardCmd$RuleMemoFirstNode;
   private Node keyboardCmd$RuleMemoLastNode;
   private int waitCmd$RuleMemoStart = -1;
   private int waitCmd$RuleMemoEnd;
   private Node waitCmd$RuleMemoFirstNode;
   private Node waitCmd$RuleMemoLastNode;
   private int acceptCmd$RuleMemoStart = -1;
   private int acceptCmd$RuleMemoEnd;
   private Node acceptCmd$RuleMemoFirstNode;
   private Node acceptCmd$RuleMemoLastNode;
   private int inputCmd$RuleMemoStart = -1;
   private int inputCmd$RuleMemoEnd;
   private Node inputCmd$RuleMemoFirstNode;
   private Node inputCmd$RuleMemoLastNode;
   private int releaseCmd$RuleMemoStart = -1;
   private int releaseCmd$RuleMemoEnd;
   private Node releaseCmd$RuleMemoFirstNode;
   private Node releaseCmd$RuleMemoLastNode;
   private int restoreCmd$RuleMemoStart = -1;
   private int restoreCmd$RuleMemoEnd;
   private Node restoreCmd$RuleMemoFirstNode;
   private Node restoreCmd$RuleMemoLastNode;
   private int saveCmd$RuleMemoStart = -1;
   private int saveCmd$RuleMemoEnd;
   private Node saveCmd$RuleMemoFirstNode;
   private Node saveCmd$RuleMemoLastNode;
   private int joinCmd$RuleMemoStart = -1;
   private int joinCmd$RuleMemoEnd;
   private Node joinCmd$RuleMemoFirstNode;
   private Node joinCmd$RuleMemoLastNode;
   private int ejectCmd$RuleMemoStart = -1;
   private int ejectCmd$RuleMemoEnd;
   private Node ejectCmd$RuleMemoFirstNode;
   private Node ejectCmd$RuleMemoLastNode;
   private int eraseCmd$RuleMemoStart = -1;
   private int eraseCmd$RuleMemoEnd;
   private Node eraseCmd$RuleMemoFirstNode;
   private Node eraseCmd$RuleMemoLastNode;
   private int deleteCmd$RuleMemoStart = -1;
   private int deleteCmd$RuleMemoEnd;
   private Node deleteCmd$RuleMemoFirstNode;
   private Node deleteCmd$RuleMemoLastNode;
   private int renameCmd$RuleMemoStart = -1;
   private int renameCmd$RuleMemoEnd;
   private Node renameCmd$RuleMemoFirstNode;
   private Node renameCmd$RuleMemoLastNode;
   private int copyCmd$RuleMemoStart = -1;
   private int copyCmd$RuleMemoEnd;
   private Node copyCmd$RuleMemoFirstNode;
   private Node copyCmd$RuleMemoLastNode;
   private int dirCmd$RuleMemoStart = -1;
   private int dirCmd$RuleMemoEnd;
   private Node dirCmd$RuleMemoFirstNode;
   private Node dirCmd$RuleMemoLastNode;
   private int typeCmd$RuleMemoStart = -1;
   private int typeCmd$RuleMemoEnd;
   private Node typeCmd$RuleMemoFirstNode;
   private Node typeCmd$RuleMemoLastNode;
   private int requestCmd$RuleMemoStart = -1;
   private int requestCmd$RuleMemoEnd;
   private Node requestCmd$RuleMemoFirstNode;
   private Node requestCmd$RuleMemoLastNode;
   private int cancelCmd$RuleMemoStart = -1;
   private int cancelCmd$RuleMemoEnd;
   private Node cancelCmd$RuleMemoFirstNode;
   private Node cancelCmd$RuleMemoLastNode;
   private int quitCmd$RuleMemoStart = -1;
   private int quitCmd$RuleMemoEnd;
   private Node quitCmd$RuleMemoFirstNode;
   private Node quitCmd$RuleMemoLastNode;
   private int runCmd$RuleMemoStart = -1;
   private int runCmd$RuleMemoEnd;
   private Node runCmd$RuleMemoFirstNode;
   private Node runCmd$RuleMemoLastNode;
   private int outCmd$RuleMemoStart = -1;
   private int outCmd$RuleMemoEnd;
   private Node outCmd$RuleMemoFirstNode;
   private Node outCmd$RuleMemoLastNode;
   private int closeCmd$RuleMemoStart = -1;
   private int closeCmd$RuleMemoEnd;
   private Node closeCmd$RuleMemoFirstNode;
   private Node closeCmd$RuleMemoLastNode;
   private int selectCmd$RuleMemoStart = -1;
   private int selectCmd$RuleMemoEnd;
   private Node selectCmd$RuleMemoFirstNode;
   private Node selectCmd$RuleMemoLastNode;
   private int appendCmd$RuleMemoStart = -1;
   private int appendCmd$RuleMemoEnd;
   private Node appendCmd$RuleMemoFirstNode;
   private Node appendCmd$RuleMemoLastNode;
   private int packCmd$RuleMemoStart = -1;
   private int packCmd$RuleMemoEnd;
   private Node packCmd$RuleMemoFirstNode;
   private Node packCmd$RuleMemoLastNode;
   private int zapCmd$RuleMemoStart = -1;
   private int zapCmd$RuleMemoEnd;
   private Node zapCmd$RuleMemoFirstNode;
   private Node zapCmd$RuleMemoLastNode;
   private int unlockCmd$RuleMemoStart = -1;
   private int unlockCmd$RuleMemoEnd;
   private Node unlockCmd$RuleMemoFirstNode;
   private Node unlockCmd$RuleMemoLastNode;
   private int commitCmd$RuleMemoStart = -1;
   private int commitCmd$RuleMemoEnd;
   private Node commitCmd$RuleMemoFirstNode;
   private Node commitCmd$RuleMemoLastNode;
   private int gotoCmd$RuleMemoStart = -1;
   private int gotoCmd$RuleMemoEnd;
   private Node gotoCmd$RuleMemoFirstNode;
   private Node gotoCmd$RuleMemoLastNode;
   private int goCmd$RuleMemoStart = -1;
   private int goCmd$RuleMemoEnd;
   private Node goCmd$RuleMemoFirstNode;
   private Node goCmd$RuleMemoLastNode;
   private int skipCmd$RuleMemoStart = -1;
   private int skipCmd$RuleMemoEnd;
   private Node skipCmd$RuleMemoFirstNode;
   private Node skipCmd$RuleMemoLastNode;
   private int findCmd$RuleMemoStart = -1;
   private int findCmd$RuleMemoEnd;
   private Node findCmd$RuleMemoFirstNode;
   private Node findCmd$RuleMemoLastNode;
   private int continueCmd$RuleMemoStart = -1;
   private int continueCmd$RuleMemoEnd;
   private Node continueCmd$RuleMemoFirstNode;
   private Node continueCmd$RuleMemoLastNode;
   private int seekCmd$RuleMemoStart = -1;
   private int seekCmd$RuleMemoEnd;
   private Node seekCmd$RuleMemoFirstNode;
   private Node seekCmd$RuleMemoLastNode;
   private int locateCmd$RuleMemoStart = -1;
   private int locateCmd$RuleMemoEnd;
   private Node locateCmd$RuleMemoFirstNode;
   private Node locateCmd$RuleMemoLastNode;
   private int replaceCmd$RuleMemoStart = -1;
   private int replaceCmd$RuleMemoEnd;
   private Node replaceCmd$RuleMemoFirstNode;
   private Node replaceCmd$RuleMemoLastNode;
   private int recallCmd$RuleMemoStart = -1;
   private int recallCmd$RuleMemoEnd;
   private Node recallCmd$RuleMemoFirstNode;
   private Node recallCmd$RuleMemoLastNode;
   private int createCmd$RuleMemoStart = -1;
   private int createCmd$RuleMemoEnd;
   private Node createCmd$RuleMemoFirstNode;
   private Node createCmd$RuleMemoLastNode;
   private int sortCmd$RuleMemoStart = -1;
   private int sortCmd$RuleMemoEnd;
   private Node sortCmd$RuleMemoFirstNode;
   private Node sortCmd$RuleMemoLastNode;
   private int totalCmd$RuleMemoStart = -1;
   private int totalCmd$RuleMemoEnd;
   private Node totalCmd$RuleMemoFirstNode;
   private Node totalCmd$RuleMemoLastNode;
   private int updateCmd$RuleMemoStart = -1;
   private int updateCmd$RuleMemoEnd;
   private Node updateCmd$RuleMemoFirstNode;
   private Node updateCmd$RuleMemoLastNode;
   private int countCmd$RuleMemoStart = -1;
   private int countCmd$RuleMemoEnd;
   private Node countCmd$RuleMemoFirstNode;
   private Node countCmd$RuleMemoLastNode;
   private int sumCmd$RuleMemoStart = -1;
   private int sumCmd$RuleMemoEnd;
   private Node sumCmd$RuleMemoFirstNode;
   private Node sumCmd$RuleMemoLastNode;
   private int averageCmd$RuleMemoStart = -1;
   private int averageCmd$RuleMemoEnd;
   private Node averageCmd$RuleMemoFirstNode;
   private Node averageCmd$RuleMemoLastNode;
   private int listCmd$RuleMemoStart = -1;
   private int listCmd$RuleMemoEnd;
   private Node listCmd$RuleMemoFirstNode;
   private Node listCmd$RuleMemoLastNode;
   private int displayCmd$RuleMemoStart = -1;
   private int displayCmd$RuleMemoEnd;
   private Node displayCmd$RuleMemoFirstNode;
   private Node displayCmd$RuleMemoLastNode;
   private int reportCmd$RuleMemoStart = -1;
   private int reportCmd$RuleMemoEnd;
   private Node reportCmd$RuleMemoFirstNode;
   private Node reportCmd$RuleMemoLastNode;
   private int labelCmd$RuleMemoStart = -1;
   private int labelCmd$RuleMemoEnd;
   private Node labelCmd$RuleMemoFirstNode;
   private Node labelCmd$RuleMemoLastNode;
   private int indexOnCmd$RuleMemoStart = -1;
   private int indexOnCmd$RuleMemoEnd;
   private Node indexOnCmd$RuleMemoFirstNode;
   private Node indexOnCmd$RuleMemoLastNode;
   private int reindexCmd$RuleMemoStart = -1;
   private int reindexCmd$RuleMemoEnd;
   private Node reindexCmd$RuleMemoFirstNode;
   private Node reindexCmd$RuleMemoLastNode;
   private int qOutCommand$RuleMemoStart = -1;
   private int qOutCommand$RuleMemoEnd;
   private Node qOutCommand$RuleMemoFirstNode;
   private Node qOutCommand$RuleMemoLastNode;
   private int menuToCmd$RuleMemoStart = -1;
   private int menuToCmd$RuleMemoEnd;
   private Node menuToCmd$RuleMemoFirstNode;
   private Node menuToCmd$RuleMemoLastNode;
   private int ignoreLine$RuleMemoStart = -1;
   private int ignoreLine$RuleMemoEnd;
   private Node ignoreLine$RuleMemoFirstNode;
   private Node ignoreLine$RuleMemoLastNode;
   private int variableDeclarationList$RuleMemoStart = -1;
   private int variableDeclarationList$RuleMemoEnd;
   private Node variableDeclarationList$RuleMemoFirstNode;
   private Node variableDeclarationList$RuleMemoLastNode;
   private int parametersDeclarationList$RuleMemoStart = -1;
   private int parametersDeclarationList$RuleMemoEnd;
   private Node parametersDeclarationList$RuleMemoFirstNode;
   private Node parametersDeclarationList$RuleMemoLastNode;
   private int variableDefinition$RuleMemoStart = -1;
   private int variableDefinition$RuleMemoEnd;
   private Node variableDefinition$RuleMemoFirstNode;
   private Node variableDefinition$RuleMemoLastNode;
   private int assignmentOperator$RuleMemoStart = -1;
   private int assignmentOperator$RuleMemoEnd;
   private Node assignmentOperator$RuleMemoFirstNode;
   private Node assignmentOperator$RuleMemoLastNode;
   private int expressionAsType$RuleMemoStart = -1;
   private int expressionAsType$RuleMemoEnd;
   private Node expressionAsType$RuleMemoFirstNode;
   private Node expressionAsType$RuleMemoLastNode;
   private int asType$RuleMemoStart = -1;
   private int asType$RuleMemoEnd;
   private Node asType$RuleMemoFirstNode;
   private Node asType$RuleMemoLastNode;
   private int valuesList$RuleMemoStart = -1;
   private int valuesList$RuleMemoEnd;
   private Node valuesList$RuleMemoFirstNode;
   private Node valuesList$RuleMemoLastNode;
   private int identifierList$RuleMemoStart = -1;
   private int identifierList$RuleMemoEnd;
   private Node identifierList$RuleMemoFirstNode;
   private Node identifierList$RuleMemoLastNode;
   private int memvarDeclaration$RuleMemoStart = -1;
   private int memvarDeclaration$RuleMemoEnd;
   private Node memvarDeclaration$RuleMemoFirstNode;
   private Node memvarDeclaration$RuleMemoLastNode;
   private int aliasIdentifier$RuleMemoStart = -1;
   private int aliasIdentifier$RuleMemoEnd;
   private Node aliasIdentifier$RuleMemoFirstNode;
   private Node aliasIdentifier$RuleMemoLastNode;
   private int expressionList$RuleMemoStart = -1;
   private int expressionList$RuleMemoEnd;
   private Node expressionList$RuleMemoFirstNode;
   private Node expressionList$RuleMemoLastNode;
   private int macro$RuleMemoStart = -1;
   private int macro$RuleMemoEnd;
   private Node macro$RuleMemoFirstNode;
   private Node macro$RuleMemoLastNode;
   private int aliasedExpression$RuleMemoStart = -1;
   private int aliasedExpression$RuleMemoEnd;
   private Node aliasedExpression$RuleMemoFirstNode;
   private Node aliasedExpression$RuleMemoLastNode;
   private int parenthesesExpressionList$RuleMemoStart = -1;
   private int parenthesesExpressionList$RuleMemoEnd;
   private Node parenthesesExpressionList$RuleMemoFirstNode;
   private Node parenthesesExpressionList$RuleMemoLastNode;
   private int qualifiedVariable$RuleMemoStart = -1;
   private int qualifiedVariable$RuleMemoEnd;
   private Node qualifiedVariable$RuleMemoFirstNode;
   private Node qualifiedVariable$RuleMemoLastNode;
   private int macroFunctionCall$RuleMemoStart = -1;
   private int macroFunctionCall$RuleMemoEnd;
   private Node macroFunctionCall$RuleMemoFirstNode;
   private Node macroFunctionCall$RuleMemoLastNode;
   private int parParameters$RuleMemoStart = -1;
   private int parParameters$RuleMemoEnd;
   private Node parParameters$RuleMemoFirstNode;
   private Node parParameters$RuleMemoLastNode;
   private int simpleFunctionCall$RuleMemoStart = -1;
   private int simpleFunctionCall$RuleMemoEnd;
   private Node simpleFunctionCall$RuleMemoFirstNode;
   private Node simpleFunctionCall$RuleMemoLastNode;
   private int anySimpleFunctionCall$RuleMemoStart = -1;
   private int anySimpleFunctionCall$RuleMemoEnd;
   private Node anySimpleFunctionCall$RuleMemoFirstNode;
   private Node anySimpleFunctionCall$RuleMemoLastNode;
   private int ignoreRestOfLine$RuleMemoStart = -1;
   private int ignoreRestOfLine$RuleMemoEnd;
   private Node ignoreRestOfLine$RuleMemoFirstNode;
   private Node ignoreRestOfLine$RuleMemoLastNode;
   private int ifInLine$RuleMemoStart = -1;
   private int ifInLine$RuleMemoEnd;
   private Node ifInLine$RuleMemoFirstNode;
   private Node ifInLine$RuleMemoLastNode;
   private int ifBegin$RuleMemoStart = -1;
   private int ifBegin$RuleMemoEnd;
   private Node ifBegin$RuleMemoFirstNode;
   private Node ifBegin$RuleMemoLastNode;
   private int condition$RuleMemoStart = -1;
   private int condition$RuleMemoEnd;
   private Node condition$RuleMemoFirstNode;
   private Node condition$RuleMemoLastNode;
   private int ifEnd$RuleMemoStart = -1;
   private int ifEnd$RuleMemoEnd;
   private Node ifEnd$RuleMemoFirstNode;
   private Node ifEnd$RuleMemoLastNode;
   private int endKeyword$RuleMemoStart = -1;
   private int endKeyword$RuleMemoEnd;
   private Node endKeyword$RuleMemoFirstNode;
   private Node endKeyword$RuleMemoLastNode;
   private int doWhileBegin$RuleMemoStart = -1;
   private int doWhileBegin$RuleMemoEnd;
   private Node doWhileBegin$RuleMemoFirstNode;
   private Node doWhileBegin$RuleMemoLastNode;
   private int doWhileEnd$RuleMemoStart = -1;
   private int doWhileEnd$RuleMemoEnd;
   private Node doWhileEnd$RuleMemoFirstNode;
   private Node doWhileEnd$RuleMemoLastNode;
   private int forNextBegin$RuleMemoStart = -1;
   private int forNextBegin$RuleMemoEnd;
   private Node forNextBegin$RuleMemoFirstNode;
   private Node forNextBegin$RuleMemoLastNode;
   private int forNextEnd$RuleMemoStart = -1;
   private int forNextEnd$RuleMemoEnd;
   private Node forNextEnd$RuleMemoFirstNode;
   private Node forNextEnd$RuleMemoLastNode;
   private int beginSequenceBegin$RuleMemoStart = -1;
   private int beginSequenceBegin$RuleMemoEnd;
   private Node beginSequenceBegin$RuleMemoFirstNode;
   private Node beginSequenceBegin$RuleMemoLastNode;
   private int doCaseBegin$RuleMemoStart = -1;
   private int doCaseBegin$RuleMemoEnd;
   private Node doCaseBegin$RuleMemoFirstNode;
   private Node doCaseBegin$RuleMemoLastNode;
   private int doCaseEnd$RuleMemoStart = -1;
   private int doCaseEnd$RuleMemoEnd;
   private Node doCaseEnd$RuleMemoFirstNode;
   private Node doCaseEnd$RuleMemoLastNode;
   private int forEachBegin$RuleMemoStart = -1;
   private int forEachBegin$RuleMemoEnd;
   private Node forEachBegin$RuleMemoFirstNode;
   private Node forEachBegin$RuleMemoLastNode;
   private int forEachEnd$RuleMemoStart = -1;
   private int forEachEnd$RuleMemoEnd;
   private Node forEachEnd$RuleMemoFirstNode;
   private Node forEachEnd$RuleMemoLastNode;
   private int switchBegin$RuleMemoStart = -1;
   private int switchBegin$RuleMemoEnd;
   private Node switchBegin$RuleMemoFirstNode;
   private Node switchBegin$RuleMemoLastNode;
   private int switchEnd$RuleMemoStart = -1;
   private int switchEnd$RuleMemoEnd;
   private Node switchEnd$RuleMemoFirstNode;
   private Node switchEnd$RuleMemoLastNode;
   private int tryCatchBegin$RuleMemoStart = -1;
   private int tryCatchBegin$RuleMemoEnd;
   private Node tryCatchBegin$RuleMemoFirstNode;
   private Node tryCatchBegin$RuleMemoLastNode;
   private int tryCatchEnd$RuleMemoStart = -1;
   private int tryCatchEnd$RuleMemoEnd;
   private Node tryCatchEnd$RuleMemoFirstNode;
   private Node tryCatchEnd$RuleMemoLastNode;
   private int finallyBlockBegin$RuleMemoStart = -1;
   private int finallyBlockBegin$RuleMemoEnd;
   private Node finallyBlockBegin$RuleMemoFirstNode;
   private Node finallyBlockBegin$RuleMemoLastNode;
   private int return$RuleMemoStart = -1;
   private int return$RuleMemoEnd;
   private Node return$RuleMemoFirstNode;
   private Node return$RuleMemoLastNode;
   private int break$RuleMemoStart = -1;
   private int break$RuleMemoEnd;
   private Node break$RuleMemoFirstNode;
   private Node break$RuleMemoLastNode;
   private int classMemberDeclaration$RuleMemoStart = -1;
   private int classMemberDeclaration$RuleMemoEnd;
   private Node classMemberDeclaration$RuleMemoFirstNode;
   private Node classMemberDeclaration$RuleMemoLastNode;
   private int publicVariableDeclaration$RuleMemoStart = -1;
   private int publicVariableDeclaration$RuleMemoEnd;
   private Node publicVariableDeclaration$RuleMemoFirstNode;
   private Node publicVariableDeclaration$RuleMemoLastNode;
   private int privateVariableDeclaration$RuleMemoStart = -1;
   private int privateVariableDeclaration$RuleMemoEnd;
   private Node privateVariableDeclaration$RuleMemoFirstNode;
   private Node privateVariableDeclaration$RuleMemoLastNode;
   private int external$RuleMemoStart = -1;
   private int external$RuleMemoEnd;
   private Node external$RuleMemoFirstNode;
   private Node external$RuleMemoLastNode;
   private int announce$RuleMemoStart = -1;
   private int announce$RuleMemoEnd;
   private Node announce$RuleMemoFirstNode;
   private Node announce$RuleMemoLastNode;
   private int request$RuleMemoStart = -1;
   private int request$RuleMemoEnd;
   private Node request$RuleMemoFirstNode;
   private Node request$RuleMemoLastNode;
   private int throw$RuleMemoStart = -1;
   private int throw$RuleMemoEnd;
   private Node throw$RuleMemoFirstNode;
   private Node throw$RuleMemoLastNode;
   private int statementAssignmentExpression$RuleMemoStart = -1;
   private int statementAssignmentExpression$RuleMemoEnd;
   private Node statementAssignmentExpression$RuleMemoFirstNode;
   private Node statementAssignmentExpression$RuleMemoLastNode;
   private int selfExpression$RuleMemoStart = -1;
   private int selfExpression$RuleMemoEnd;
   private Node selfExpression$RuleMemoFirstNode;
   private Node selfExpression$RuleMemoLastNode;
   private int aliasedMacro$RuleMemoStart = -1;
   private int aliasedMacro$RuleMemoEnd;
   private Node aliasedMacro$RuleMemoFirstNode;
   private Node aliasedMacro$RuleMemoLastNode;
   private int qualifiedExpression$RuleMemoStart = -1;
   private int qualifiedExpression$RuleMemoEnd;
   private Node qualifiedExpression$RuleMemoFirstNode;
   private Node qualifiedExpression$RuleMemoLastNode;
   private int keywordsFunctionCall$RuleMemoStart = -1;
   private int keywordsFunctionCall$RuleMemoEnd;
   private Node keywordsFunctionCall$RuleMemoFirstNode;
   private Node keywordsFunctionCall$RuleMemoLastNode;
   private int methodDeclaration$RuleMemoStart = -1;
   private int methodDeclaration$RuleMemoEnd;
   private Node methodDeclaration$RuleMemoFirstNode;
   private Node methodDeclaration$RuleMemoLastNode;
   private int parParametersDeclaration$RuleMemoStart = -1;
   private int parParametersDeclaration$RuleMemoEnd;
   private Node parParametersDeclaration$RuleMemoFirstNode;
   private Node parParametersDeclaration$RuleMemoLastNode;
   private int attributeListDeclaration$RuleMemoStart = -1;
   private int attributeListDeclaration$RuleMemoEnd;
   private Node attributeListDeclaration$RuleMemoFirstNode;
   private Node attributeListDeclaration$RuleMemoLastNode;
   private int macroVar$RuleMemoStart = -1;
   private int macroVar$RuleMemoEnd;
   private Node macroVar$RuleMemoFirstNode;
   private Node macroVar$RuleMemoLastNode;
   private int macroExpression$RuleMemoStart = -1;
   private int macroExpression$RuleMemoEnd;
   private Node macroExpression$RuleMemoFirstNode;
   private Node macroExpression$RuleMemoLastNode;
   private int functionReference$RuleMemoStart = -1;
   private int functionReference$RuleMemoEnd;
   private Node functionReference$RuleMemoFirstNode;
   private Node functionReference$RuleMemoLastNode;
   private int valueByReference$RuleMemoStart = -1;
   private int valueByReference$RuleMemoEnd;
   private Node valueByReference$RuleMemoFirstNode;
   private Node valueByReference$RuleMemoLastNode;
   private int aliasedField$RuleMemoStart = -1;
   private int aliasedField$RuleMemoEnd;
   private Node aliasedField$RuleMemoFirstNode;
   private Node aliasedField$RuleMemoLastNode;
   private int parameter$RuleMemoStart = -1;
   private int parameter$RuleMemoEnd;
   private Node parameter$RuleMemoFirstNode;
   private Node parameter$RuleMemoLastNode;
   private int parametersList$RuleMemoStart = -1;
   private int parametersList$RuleMemoEnd;
   private Node parametersList$RuleMemoFirstNode;
   private Node parametersList$RuleMemoLastNode;
   private int optionalParametersList$RuleMemoStart = -1;
   private int optionalParametersList$RuleMemoEnd;
   private Node optionalParametersList$RuleMemoFirstNode;
   private Node optionalParametersList$RuleMemoLastNode;
   private int elseIfBegin$RuleMemoStart = -1;
   private int elseIfBegin$RuleMemoEnd;
   private Node elseIfBegin$RuleMemoFirstNode;
   private Node elseIfBegin$RuleMemoLastNode;
   private int elseBegin$RuleMemoStart = -1;
   private int elseBegin$RuleMemoEnd;
   private Node elseBegin$RuleMemoFirstNode;
   private Node elseBegin$RuleMemoLastNode;
   private int otherwiseBegin$RuleMemoStart = -1;
   private int otherwiseBegin$RuleMemoEnd;
   private Node otherwiseBegin$RuleMemoFirstNode;
   private Node otherwiseBegin$RuleMemoLastNode;
   private int doCaseOptionBegin$RuleMemoStart = -1;
   private int doCaseOptionBegin$RuleMemoEnd;
   private Node doCaseOptionBegin$RuleMemoFirstNode;
   private Node doCaseOptionBegin$RuleMemoLastNode;
   private int codeBlockLiteral$RuleMemoStart = -1;
   private int codeBlockLiteral$RuleMemoEnd;
   private Node codeBlockLiteral$RuleMemoFirstNode;
   private Node codeBlockLiteral$RuleMemoLastNode;
   private int beginSequenceEnd$RuleMemoStart = -1;
   private int beginSequenceEnd$RuleMemoEnd;
   private Node beginSequenceEnd$RuleMemoFirstNode;
   private Node beginSequenceEnd$RuleMemoLastNode;
   private int recoverBegin$RuleMemoStart = -1;
   private int recoverBegin$RuleMemoEnd;
   private Node recoverBegin$RuleMemoFirstNode;
   private Node recoverBegin$RuleMemoLastNode;
   private int alwaysBegin$RuleMemoStart = -1;
   private int alwaysBegin$RuleMemoEnd;
   private Node alwaysBegin$RuleMemoFirstNode;
   private Node alwaysBegin$RuleMemoLastNode;
   private int parenthesesSwitchConstant$RuleMemoStart = -1;
   private int parenthesesSwitchConstant$RuleMemoEnd;
   private Node parenthesesSwitchConstant$RuleMemoFirstNode;
   private Node parenthesesSwitchConstant$RuleMemoLastNode;
   private int switchConstant$RuleMemoStart = -1;
   private int switchConstant$RuleMemoEnd;
   private Node switchConstant$RuleMemoFirstNode;
   private Node switchConstant$RuleMemoLastNode;
   private int logicalLiteral$RuleMemoStart = -1;
   private int logicalLiteral$RuleMemoEnd;
   private Node logicalLiteral$RuleMemoFirstNode;
   private Node logicalLiteral$RuleMemoLastNode;
   private int switchOptionBegin$RuleMemoStart = -1;
   private int switchOptionBegin$RuleMemoEnd;
   private Node switchOptionBegin$RuleMemoFirstNode;
   private Node switchOptionBegin$RuleMemoLastNode;
   private int switchDefaultBegin$RuleMemoStart = -1;
   private int switchDefaultBegin$RuleMemoEnd;
   private Node switchDefaultBegin$RuleMemoFirstNode;
   private Node switchDefaultBegin$RuleMemoLastNode;
   private int catchBlockBegin$RuleMemoStart = -1;
   private int catchBlockBegin$RuleMemoEnd;
   private Node catchBlockBegin$RuleMemoFirstNode;
   private Node catchBlockBegin$RuleMemoLastNode;
   private int arrayLiteral$RuleMemoStart = -1;
   private int arrayLiteral$RuleMemoEnd;
   private Node arrayLiteral$RuleMemoFirstNode;
   private Node arrayLiteral$RuleMemoLastNode;
   private int hashItem$RuleMemoStart = -1;
   private int hashItem$RuleMemoEnd;
   private Node hashItem$RuleMemoFirstNode;
   private Node hashItem$RuleMemoLastNode;
   private int hashItemsList$RuleMemoStart = -1;
   private int hashItemsList$RuleMemoEnd;
   private Node hashItemsList$RuleMemoFirstNode;
   private Node hashItemsList$RuleMemoLastNode;
   private int hashItems$RuleMemoStart = -1;
   private int hashItems$RuleMemoEnd;
   private Node hashItems$RuleMemoFirstNode;
   private Node hashItems$RuleMemoLastNode;
   private int hashLiteral$RuleMemoStart = -1;
   private int hashLiteral$RuleMemoEnd;
   private Node hashLiteral$RuleMemoFirstNode;
   private Node hashLiteral$RuleMemoLastNode;
   private int nilValue$RuleMemoStart = -1;
   private int nilValue$RuleMemoEnd;
   private Node nilValue$RuleMemoFirstNode;
   private Node nilValue$RuleMemoLastNode;
   private int literal$RuleMemoStart = -1;
   private int literal$RuleMemoEnd;
   private Node literal$RuleMemoFirstNode;
   private Node literal$RuleMemoLastNode;
   private int dateTimeLiteral$RuleMemoStart = -1;
   private int dateTimeLiteral$RuleMemoEnd;
   private Node dateTimeLiteral$RuleMemoFirstNode;
   private Node dateTimeLiteral$RuleMemoLastNode;
   private int timeLiteral$RuleMemoStart = -1;
   private int timeLiteral$RuleMemoEnd;
   private Node timeLiteral$RuleMemoFirstNode;
   private Node timeLiteral$RuleMemoLastNode;
   private int integerNumber$RuleMemoStart = -1;
   private int integerNumber$RuleMemoEnd;
   private Node integerNumber$RuleMemoFirstNode;
   private Node integerNumber$RuleMemoLastNode;
   private int timePattern$RuleMemoStart = -1;
   private int timePattern$RuleMemoEnd;
   private Node timePattern$RuleMemoFirstNode;
   private Node timePattern$RuleMemoLastNode;
   private int datePattern$RuleMemoStart = -1;
   private int datePattern$RuleMemoEnd;
   private Node datePattern$RuleMemoFirstNode;
   private Node datePattern$RuleMemoLastNode;
   private int indexItem$RuleMemoStart = -1;
   private int indexItem$RuleMemoEnd;
   private Node indexItem$RuleMemoFirstNode;
   private Node indexItem$RuleMemoLastNode;
   private int assignOperator$RuleMemoStart = -1;
   private int assignOperator$RuleMemoEnd;
   private Node assignOperator$RuleMemoFirstNode;
   private Node assignOperator$RuleMemoLastNode;
   private int expression$RuleMemoStart = -1;
   private int expression$RuleMemoEnd;
   private Node expression$RuleMemoFirstNode;
   private Node expression$RuleMemoLastNode;
   private int assignmentExpression$RuleMemoStart = -1;
   private int assignmentExpression$RuleMemoEnd;
   private Node assignmentExpression$RuleMemoFirstNode;
   private Node assignmentExpression$RuleMemoLastNode;
   private int conditionalExpression$RuleMemoStart = -1;
   private int conditionalExpression$RuleMemoEnd;
   private Node conditionalExpression$RuleMemoFirstNode;
   private Node conditionalExpression$RuleMemoLastNode;
   private int comparisonExpression$RuleMemoStart = -1;
   private int comparisonExpression$RuleMemoEnd;
   private Node comparisonExpression$RuleMemoFirstNode;
   private Node comparisonExpression$RuleMemoLastNode;
   private int mathExpression$RuleMemoStart = -1;
   private int mathExpression$RuleMemoEnd;
   private Node mathExpression$RuleMemoFirstNode;
   private Node mathExpression$RuleMemoLastNode;
   private int prefixedExpression$RuleMemoStart = -1;
   private int prefixedExpression$RuleMemoEnd;
   private Node prefixedExpression$RuleMemoFirstNode;
   private Node prefixedExpression$RuleMemoLastNode;
   private int postfixedExpression$RuleMemoStart = -1;
   private int postfixedExpression$RuleMemoEnd;
   private Node postfixedExpression$RuleMemoFirstNode;
   private Node postfixedExpression$RuleMemoLastNode;
   private int primaryExpression$RuleMemoStart = -1;
   private int primaryExpression$RuleMemoEnd;
   private Node primaryExpression$RuleMemoFirstNode;
   private Node primaryExpression$RuleMemoLastNode;
   private int atomicExpression$RuleMemoStart = -1;
   private int atomicExpression$RuleMemoEnd;
   private Node atomicExpression$RuleMemoFirstNode;
   private Node atomicExpression$RuleMemoLastNode;
   private int keyboardCall$RuleMemoStart = -1;
   private int keyboardCall$RuleMemoEnd;
   private Node keyboardCall$RuleMemoFirstNode;
   private Node keyboardCall$RuleMemoLastNode;
   private int clearTypehead$RuleMemoStart = -1;
   private int clearTypehead$RuleMemoEnd;
   private Node clearTypehead$RuleMemoFirstNode;
   private Node clearTypehead$RuleMemoLastNode;
   private int arrayAccess$RuleMemoStart = -1;
   private int arrayAccess$RuleMemoEnd;
   private Node arrayAccess$RuleMemoFirstNode;
   private Node arrayAccess$RuleMemoLastNode;
   private int leftValue$RuleMemoStart = -1;
   private int leftValue$RuleMemoEnd;
   private Node leftValue$RuleMemoFirstNode;
   private Node leftValue$RuleMemoLastNode;
   private int parameterDeclaration$RuleMemoStart = -1;
   private int parameterDeclaration$RuleMemoEnd;
   private Node parameterDeclaration$RuleMemoFirstNode;
   private Node parameterDeclaration$RuleMemoLastNode;
   private int functionModifier$RuleMemoStart = -1;
   private int functionModifier$RuleMemoEnd;
   private Node functionModifier$RuleMemoFirstNode;
   private Node functionModifier$RuleMemoLastNode;
   private int stringLiteral$RuleMemoStart = -1;
   private int stringLiteral$RuleMemoEnd;
   private Node stringLiteral$RuleMemoFirstNode;
   private Node stringLiteral$RuleMemoLastNode;
   private int numberLiteral$RuleMemoStart = -1;
   private int numberLiteral$RuleMemoEnd;
   private Node numberLiteral$RuleMemoFirstNode;
   private Node numberLiteral$RuleMemoLastNode;
   private int dataType$RuleMemoStart = -1;
   private int dataType$RuleMemoEnd;
   private Node dataType$RuleMemoFirstNode;
   private Node dataType$RuleMemoLastNode;
   private int array$RuleMemoStart = -1;
   private int array$RuleMemoEnd;
   private Node array$RuleMemoFirstNode;
   private Node array$RuleMemoLastNode;
   private int class$RuleMemoStart = -1;
   private int class$RuleMemoEnd;
   private Node class$RuleMemoFirstNode;
   private Node class$RuleMemoLastNode;
   private int asDataType$RuleMemoStart = -1;
   private int asDataType$RuleMemoEnd;
   private Node asDataType$RuleMemoFirstNode;
   private Node asDataType$RuleMemoLastNode;
   private int anyIdentifier$RuleMemoStart = -1;
   private int anyIdentifier$RuleMemoEnd;
   private Node anyIdentifier$RuleMemoFirstNode;
   private Node anyIdentifier$RuleMemoLastNode;
   private int identifier$RuleMemoStart = -1;
   private int identifier$RuleMemoEnd;
   private Node identifier$RuleMemoFirstNode;
   private Node identifier$RuleMemoLastNode;
   private int identifierPattern$RuleMemoStart = -1;
   private int identifierPattern$RuleMemoEnd;
   private Node identifierPattern$RuleMemoFirstNode;
   private Node identifierPattern$RuleMemoLastNode;
   private int whitespace$RuleMemoStart = -1;
   private int whitespace$RuleMemoEnd;
   private Node whitespace$RuleMemoFirstNode;
   private Node whitespace$RuleMemoLastNode;
   private int lineComment$RuleMemoStart = -1;
   private int lineComment$RuleMemoEnd;
   private Node lineComment$RuleMemoFirstNode;
   private Node lineComment$RuleMemoLastNode;
   private int blockComment$RuleMemoStart = -1;
   private int blockComment$RuleMemoEnd;
   private Node blockComment$RuleMemoFirstNode;
   private Node blockComment$RuleMemoLastNode;
   private int aloneLineComment$RuleMemoStart = -1;
   private int aloneLineComment$RuleMemoEnd;
   private Node aloneLineComment$RuleMemoFirstNode;
   private Node aloneLineComment$RuleMemoLastNode;
   private int endStmt$RuleMemoStart = -1;
   private int endStmt$RuleMemoEnd;
   private Node endStmt$RuleMemoFirstNode;
   private Node endStmt$RuleMemoLastNode;
   private int spacing$RuleMemoStart = -1;
   private int spacing$RuleMemoEnd;
   private Node spacing$RuleMemoFirstNode;
   private Node spacing$RuleMemoLastNode;
   private int continueNL$RuleMemoStart = -1;
   private int continueNL$RuleMemoEnd;
   private Node continueNL$RuleMemoFirstNode;
   private Node continueNL$RuleMemoLastNode;
   private int testNoAlpha$RuleMemoStart = -1;
   private int testNoAlpha$RuleMemoEnd;
   private Node testNoAlpha$RuleMemoFirstNode;
   private Node testNoAlpha$RuleMemoLastNode;
   private int optionalSpacing$RuleMemoStart = -1;
   private int optionalSpacing$RuleMemoEnd;
   private Node optionalSpacing$RuleMemoFirstNode;
   private Node optionalSpacing$RuleMemoLastNode;

   private int[] newArrayInt(final int size) {
      final int[] array = new int[size];
      Arrays.fill(array, -1);
      return array;
   }

   protected boolean charMatcher(char c) {
      if (buffer.matchChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean ignoreCaseCharMatcher(char c) {
      if (buffer.matchIgnoreCaseChar(index, c)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean stringMatcher(String str, int strLen) {
      if (buffer.matchString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean ignoreCaseStringMatcher(String str, int strLen) {
      if (buffer.matchIgnoreCaseString(index, str, strLen)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + strLen, false, false));
            currentNode = currentNode.getSibling();
         }
         index += strLen;
         return true;
      }
      return false;
   }

   protected boolean partialIgnoreCaseStringMatcher(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + i, false, false));
         currentNode = currentNode.getSibling();
      }
      index += i;
      return true;
   }

   protected boolean charRangeMatcher(char charIni, char charEnd) {
      if (buffer.matchCharRange(index, charIni, charEnd)) {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean anyCharMatcher() {
      if (buffer.getChar(index) != '\0') {
         if (! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, index, index + 1, false, false));
            currentNode = currentNode.getSibling();
         }
         ++index;
         return true;
      }
      return false;
   }

   protected boolean eoi() {
      if (buffer.getChar(index) == '\0') {
         return true;
      }
      return false;
   }

   protected boolean charTest(char c) {
      return buffer.getChar(index) == c;
   }

   protected boolean ignoreCaseCharTest(char c) {
      return buffer.matchIgnoreCaseChar(index, c);
   }

   protected boolean stringTest(String str, int strLen) {
      return buffer.matchString(index, str, strLen);
   }

   protected boolean partialStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean ignoreCaseStringTest(String str, int strLen) {
      return buffer.matchIgnoreCaseString(index, str, strLen);
   }

   protected boolean partialIgnoreCaseStringTest(String str, int strLen, int minLen) {
      int i;
      for (i = 0; i < strLen; i++) {
         if (! buffer.matchIgnoreCaseChar(index + i, str.charAt(i))) {
            if (i < minLen) {
               return false;
            } else {
               break;
            }
         }
      }
      return true;
   }

   protected boolean charRangeTest(char charIni, char charEnd) {
      return buffer.matchCharRange(index, charIni, charEnd);
   }

   protected boolean anyCharTest() {
      return buffer.getChar(index) != '\0';
   }

   protected boolean eoiTest() {
      return buffer.getChar(index) == '\0';
   }
   @Override
   public Map<Rule, RuleProfile> getProfilesMap() {
      return Collections.emptyMap();
   }

   @Override
   public void setProfilesMap(Map<Rule, RuleProfile> profilesMap) {
   }

   @Override
   public Collection<ParserError> getMismatches() {
      return Collections.emptyList();
   }

   @Override
   public void setTraceParser(TraceParser tracePath) {
   }

   @Override
   public void setTrace(boolean trace) {
   }

   private Node lastChild(Node node) {
      Node child = node.getFirstChild();
      if (child != null) {
         while (child.getSibling() != null) {
            child = child.getSibling();
         }
      }
      return child;
   }

   private Node removeNode(Node parent, Node left, Node node) {
      if (node.getFirstChild() != null) {
         if (node.getSibling() != null) {
            lastChild(node).setSibling(node.getSibling());
         }
         if (left == null) {
            parent.setFirstChild(node.getFirstChild());
         } else {
            left.setSibling(node.getFirstChild());
         }
         return node.getFirstChild();
      } else if (left == null) {
         parent.setFirstChild(node.getSibling());
      } else {
         left.setSibling(node.getSibling());
      }
      return node.getSibling();
   }

   private void removeSkipedNodes(Node node) {
      if (node != null) {
         Node leftNode = null;
         Node child = node.getFirstChild();
         while (child != null) {
            if (child.isSkiped()) {
               child = removeNode(node, leftNode, child);
            } else {
               removeSkipedNodes(child);
               leftNode = child;
               child = child.getSibling();
            }
         }
      }
   }

   @Override
   public Node parse(InputBuffer inputBuffer) {
      buffer = inputBuffer;
      if (harbourProgram$Rule()) {
         removeSkipedNodes(currentNode);
         return currentNode;
      } else {
         return null;
      }
   }


   //HarbourProgram : (Statements <EOI>)
   protected boolean harbourProgram$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Statements <EOI>)
      // Statements
      match = statements$Rule();
      if (match) {
         // <EOI>
         match = eoi();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HARBOUR_PROGRAM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statements : ((OptionalSpacing ((Statement EndStmt) | (IgnoreLine EndStmt) | EndStmt))* OptionalSpacing (Statement | IgnoreLine)?)
   protected boolean statements$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((OptionalSpacing ((Statement EndStmt) | (IgnoreLine EndStmt) | EndStmt))* OptionalSpacing (Statement | IgnoreLine)?)
      // (OptionalSpacing ((Statement EndStmt) | (IgnoreLine EndStmt) | EndStmt))*
      do {
         // (OptionalSpacing ((Statement EndStmt) | (IgnoreLine EndStmt) | EndStmt))
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ((Statement EndStmt) | (IgnoreLine EndStmt) | EndStmt)
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '#':
               case '&':
               case '\'':
               case '(':
               case '*':
               case '+':
               case '-':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case '?':
               case '@':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{':
                  // (Statement EndStmt)
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // Statement
                  match = statement$Rule();
                  if (match) {
                     // EndStmt
                     match = endStmt$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  }
                  if (! match) {
                     // (IgnoreLine EndStmt)
                     Node lastNode_3 = currentNode;
                     int lastIndex_3 = index;
                     // IgnoreLine
                     match = ignoreLine$Rule();
                     if (match) {
                        // EndStmt
                        match = endStmt$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     }
                  }
                  break;
               case '\n':
               case ';':
               case '\r':
                  // EndStmt
                  match = endStmt$Rule();
                  if (! match) {
                     // (IgnoreLine EndStmt)
                     Node lastNode_4 = currentNode;
                     int lastIndex_4 = index;
                     // IgnoreLine
                     match = ignoreLine$Rule();
                     if (match) {
                        // EndStmt
                        match = endStmt$Rule();
                        if (! match) {
                           index = lastIndex_4;
                           lastNode_4.setSibling(null);
                           currentNode = lastNode_4;
                        }
                     }
                  }
                  break;
               default:
                  // (IgnoreLine EndStmt)
                  Node lastNode_5 = currentNode;
                  int lastIndex_5 = index;
                  // IgnoreLine
                  match = ignoreLine$Rule();
                  if (match) {
                     // EndStmt
                     match = endStmt$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                  }
            }
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         }
      } while(match);
      // OptionalSpacing
      match = optionalSpacing$Rule();
      if (match) {
         // (Statement | IgnoreLine)?
         // (Statement | IgnoreLine)
         switch(buffer.getChar(index)) {
            case '!':
            case '\"':
            case '#':
            case '&':
            case '\'':
            case '(':
            case '*':
            case '+':
            case '-':
            case '.':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case ':':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case '{':
               // Statement
               match = statement$Rule();
               if (! match) {
                  // IgnoreLine
                  match = ignoreLine$Rule();
               }
               break;
            default:
               // IgnoreLine
               match = ignoreLine$Rule();
         }
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENTS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Statement : (LocalVariablesDeclaration | FunctionDeclaration | ProcedureDeclaration | MethodDefinition | StaticVariablesDeclaration | FieldsDeclaration | CreateClass | ClassBodyStmt | EndClass | ClassDeclaration | OldStyleParametersDeclaration | DeclareStatement | IfInLine | IfBegin | ElseIfBegin | ElseBegin | IfEnd | DoWhileBegin | DoWhileEnd | ForNextBegin | ForNextEnd | BeginSequenceBegin | RecoverBegin | AlwaysBegin | BeginSequenceEnd | DoCaseBegin | DoCaseOptionBegin | OtherwiseBegin | DoCaseEnd | ForEachBegin | ForEachEnd | SwitchBegin | SwitchOptionBegin | SwitchDefaultBegin | SwitchEnd | TryCatchBegin | CatchBlockBegin | FinallyBlockBegin | TryCatchEnd | EndKeyword | Return | Break | ClassMemberDeclaration | MemvarDeclaration | ExitStmt | LoopStmt | PublicVariableDeclaration | PrivateVariableDeclaration | External | Announce | Request | Throw | StatementAssignmentExpression | SelfExpression | PrefixedExpression | PostfixedExpression | AliasedExpression | AliasedMacro | QualifiedExpression | BeginTransaction | CommitTransaction | BeginProducer | EndProducer | RollbackTransaction | UseAs | UseArea | MacroFunctionCall | KeywordsFunctionCall | SimpleFunctionCall | KeyboardCall | Macro | ParenthesesExpressionList | AloneLineComment | Directive | OldStyleCommands)
   protected boolean statement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (statement$RuleMemoStart == index) {
         if (statement$RuleMemoStart <= statement$RuleMemoEnd) {
            index = statement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (statement$RuleMemoStart == statement$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT, statement$RuleMemoStart, statement$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(statement$RuleMemoFirstNode != null) {
                  lastNode.setSibling(statement$RuleMemoFirstNode);
                  currentNode = statement$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LocalVariablesDeclaration | FunctionDeclaration | ProcedureDeclaration | MethodDefinition | StaticVariablesDeclaration | FieldsDeclaration | CreateClass | ClassBodyStmt | EndClass | ClassDeclaration | OldStyleParametersDeclaration | DeclareStatement | IfInLine | IfBegin | ElseIfBegin | ElseBegin | IfEnd | DoWhileBegin | DoWhileEnd | ForNextBegin | ForNextEnd | BeginSequenceBegin | RecoverBegin | AlwaysBegin | BeginSequenceEnd | DoCaseBegin | DoCaseOptionBegin | OtherwiseBegin | DoCaseEnd | ForEachBegin | ForEachEnd | SwitchBegin | SwitchOptionBegin | SwitchDefaultBegin | SwitchEnd | TryCatchBegin | CatchBlockBegin | FinallyBlockBegin | TryCatchEnd | EndKeyword | Return | Break | ClassMemberDeclaration | MemvarDeclaration | ExitStmt | LoopStmt | PublicVariableDeclaration | PrivateVariableDeclaration | External | Announce | Request | Throw | StatementAssignmentExpression | SelfExpression | PrefixedExpression | PostfixedExpression | AliasedExpression | AliasedMacro | QualifiedExpression | BeginTransaction | CommitTransaction | BeginProducer | EndProducer | RollbackTransaction | UseAs | UseArea | MacroFunctionCall | KeywordsFunctionCall | SimpleFunctionCall | KeyboardCall | Macro | ParenthesesExpressionList | AloneLineComment | Directive | OldStyleCommands)
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-':
            // PrefixedExpression
            match = prefixedExpression$Rule();
            break;
         case '.':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PrefixedExpression
               match = prefixedExpression$Rule();
               if (! match) {
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     // QualifiedExpression
                     match = qualifiedExpression$Rule();
                  }
               }
            }
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                           }
                        }
                     }
                  }
               }
            }
            break;
         case ':':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // SelfExpression
               match = selfExpression$Rule();
               if (! match) {
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     // QualifiedExpression
                     match = qualifiedExpression$Rule();
                  }
               }
            }
            break;
         case '@':
         case '?':
            // OldStyleCommands
            match = oldStyleCommands$Rule();
            break;
         case 'A':
         case 'a':
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               // AlwaysBegin
               match = alwaysBegin$Rule();
               if (! match) {
                  // Announce
                  match = announce$Rule();
                  if (! match) {
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    // MacroFunctionCall
                                    match = macroFunctionCall$Rule();
                                    if (! match) {
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             // OldStyleCommands
                                             match = oldStyleCommands$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'B':
         case 'b':
            // BeginSequenceBegin
            match = beginSequenceBegin$Rule();
            if (! match) {
               // Break
               match = break$Rule();
               if (! match) {
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 // BeginTransaction
                                 match = beginTransaction$Rule();
                                 if (! match) {
                                    // BeginProducer
                                    match = beginProducer$Rule();
                                    if (! match) {
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                // Macro
                                                match = macro$Rule();
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'C':
         case 'c':
            // MethodDefinition
            match = methodDefinition$Rule();
            if (! match) {
               // CreateClass
               match = createClass$Rule();
               if (! match) {
                  // ClassBodyStmt
                  match = classBodyStmt$Rule();
                  if (! match) {
                     // DoCaseOptionBegin
                     match = doCaseOptionBegin$Rule();
                     if (! match) {
                        // SwitchOptionBegin
                        match = switchOptionBegin$Rule();
                        if (! match) {
                           // CatchBlockBegin
                           match = catchBlockBegin$Rule();
                           if (! match) {
                              // StatementAssignmentExpression
                              match = statementAssignmentExpression$Rule();
                              if (! match) {
                                 // PostfixedExpression
                                 match = postfixedExpression$Rule();
                                 if (! match) {
                                    // AliasedExpression
                                    match = aliasedExpression$Rule();
                                    if (! match) {
                                       // AliasedMacro
                                       match = aliasedMacro$Rule();
                                       if (! match) {
                                          // QualifiedExpression
                                          match = qualifiedExpression$Rule();
                                          if (! match) {
                                             // CommitTransaction
                                             match = commitTransaction$Rule();
                                             if (! match) {
                                                // MacroFunctionCall
                                                match = macroFunctionCall$Rule();
                                                if (! match) {
                                                   // KeywordsFunctionCall
                                                   match = keywordsFunctionCall$Rule();
                                                   if (! match) {
                                                      // SimpleFunctionCall
                                                      match = simpleFunctionCall$Rule();
                                                      if (! match) {
                                                         // Macro
                                                         match = macro$Rule();
                                                         if (! match) {
                                                            // OldStyleCommands
                                                            match = oldStyleCommands$Rule();
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'D':
         case 'd':
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               // DeclareStatement
               match = declareStatement$Rule();
               if (! match) {
                  // DoWhileBegin
                  match = doWhileBegin$Rule();
                  if (! match) {
                     // DoCaseBegin
                     match = doCaseBegin$Rule();
                     if (! match) {
                        // SwitchDefaultBegin
                        match = switchDefaultBegin$Rule();
                        if (! match) {
                           // StatementAssignmentExpression
                           match = statementAssignmentExpression$Rule();
                           if (! match) {
                              // PostfixedExpression
                              match = postfixedExpression$Rule();
                              if (! match) {
                                 // AliasedExpression
                                 match = aliasedExpression$Rule();
                                 if (! match) {
                                    // AliasedMacro
                                    match = aliasedMacro$Rule();
                                    if (! match) {
                                       // QualifiedExpression
                                       match = qualifiedExpression$Rule();
                                       if (! match) {
                                          // MacroFunctionCall
                                          match = macroFunctionCall$Rule();
                                          if (! match) {
                                             // KeywordsFunctionCall
                                             match = keywordsFunctionCall$Rule();
                                             if (! match) {
                                                // SimpleFunctionCall
                                                match = simpleFunctionCall$Rule();
                                                if (! match) {
                                                   // Macro
                                                   match = macro$Rule();
                                                   if (! match) {
                                                      // OldStyleCommands
                                                      match = oldStyleCommands$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'E':
         case 'e':
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  // ClassBodyStmt
                  match = classBodyStmt$Rule();
                  if (! match) {
                     // EndClass
                     match = endClass$Rule();
                     if (! match) {
                        // ElseIfBegin
                        match = elseIfBegin$Rule();
                        if (! match) {
                           // ElseBegin
                           match = elseBegin$Rule();
                           if (! match) {
                              // IfEnd
                              match = ifEnd$Rule();
                              if (! match) {
                                 // DoWhileEnd
                                 match = doWhileEnd$Rule();
                                 if (! match) {
                                    // ForNextEnd
                                    match = forNextEnd$Rule();
                                    if (! match) {
                                       // BeginSequenceEnd
                                       match = beginSequenceEnd$Rule();
                                       if (! match) {
                                          // DoCaseEnd
                                          match = doCaseEnd$Rule();
                                          if (! match) {
                                             // SwitchEnd
                                             match = switchEnd$Rule();
                                             if (! match) {
                                                // TryCatchEnd
                                                match = tryCatchEnd$Rule();
                                                if (! match) {
                                                   // EndKeyword
                                                   match = endKeyword$Rule();
                                                   if (! match) {
                                                      // ExitStmt
                                                      match = exitStmt$Rule();
                                                      if (! match) {
                                                         // External
                                                         match = external$Rule();
                                                         if (! match) {
                                                            // StatementAssignmentExpression
                                                            match = statementAssignmentExpression$Rule();
                                                            if (! match) {
                                                               // PostfixedExpression
                                                               match = postfixedExpression$Rule();
                                                               if (! match) {
                                                                  // AliasedExpression
                                                                  match = aliasedExpression$Rule();
                                                                  if (! match) {
                                                                     // AliasedMacro
                                                                     match = aliasedMacro$Rule();
                                                                     if (! match) {
                                                                        // QualifiedExpression
                                                                        match = qualifiedExpression$Rule();
                                                                        if (! match) {
                                                                           // EndProducer
                                                                           match = endProducer$Rule();
                                                                           if (! match) {
                                                                              // MacroFunctionCall
                                                                              match = macroFunctionCall$Rule();
                                                                              if (! match) {
                                                                                 // KeywordsFunctionCall
                                                                                 match = keywordsFunctionCall$Rule();
                                                                                 if (! match) {
                                                                                    // SimpleFunctionCall
                                                                                    match = simpleFunctionCall$Rule();
                                                                                    if (! match) {
                                                                                       // Macro
                                                                                       match = macro$Rule();
                                                                                       if (! match) {
                                                                                          // OldStyleCommands
                                                                                          match = oldStyleCommands$Rule();
                                                                                       }
                                                                                    }
                                                                                 }
                                                                              }
                                                                           }
                                                                        }
                                                                     }
                                                                  }
                                                               }
                                                            }
                                                         }
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'F':
         case 'f':
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               // FieldsDeclaration
               match = fieldsDeclaration$Rule();
               if (! match) {
                  // ForNextBegin
                  match = forNextBegin$Rule();
                  if (! match) {
                     // ForEachBegin
                     match = forEachBegin$Rule();
                     if (! match) {
                        // FinallyBlockBegin
                        match = finallyBlockBegin$Rule();
                        if (! match) {
                           // StatementAssignmentExpression
                           match = statementAssignmentExpression$Rule();
                           if (! match) {
                              // PostfixedExpression
                              match = postfixedExpression$Rule();
                              if (! match) {
                                 // AliasedExpression
                                 match = aliasedExpression$Rule();
                                 if (! match) {
                                    // AliasedMacro
                                    match = aliasedMacro$Rule();
                                    if (! match) {
                                       // QualifiedExpression
                                       match = qualifiedExpression$Rule();
                                       if (! match) {
                                          // MacroFunctionCall
                                          match = macroFunctionCall$Rule();
                                          if (! match) {
                                             // KeywordsFunctionCall
                                             match = keywordsFunctionCall$Rule();
                                             if (! match) {
                                                // SimpleFunctionCall
                                                match = simpleFunctionCall$Rule();
                                                if (! match) {
                                                   // Macro
                                                   match = macro$Rule();
                                                   if (! match) {
                                                      // OldStyleCommands
                                                      match = oldStyleCommands$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'Q':
         case 'q':
         case 'G':
         case 'g':
         case 'J':
         case 'Z':
         case 'j':
         case 'z':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    // OldStyleCommands
                                    match = oldStyleCommands$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'V':
         case 'v':
         case 'H':
         case 'h':
            // ClassBodyStmt
            match = classBodyStmt$Rule();
            if (! match) {
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    // Macro
                                    match = macro$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'I':
         case 'i':
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  // IfInLine
                  match = ifInLine$Rule();
                  if (! match) {
                     // IfBegin
                     match = ifBegin$Rule();
                     if (! match) {
                        // StatementAssignmentExpression
                        match = statementAssignmentExpression$Rule();
                        if (! match) {
                           // PostfixedExpression
                           match = postfixedExpression$Rule();
                           if (! match) {
                              // AliasedExpression
                              match = aliasedExpression$Rule();
                              if (! match) {
                                 // AliasedMacro
                                 match = aliasedMacro$Rule();
                                 if (! match) {
                                    // QualifiedExpression
                                    match = qualifiedExpression$Rule();
                                    if (! match) {
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   // OldStyleCommands
                                                   match = oldStyleCommands$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'K':
         case 'k':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 // KeyboardCall
                                 match = keyboardCall$Rule();
                                 if (! match) {
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       // OldStyleCommands
                                       match = oldStyleCommands$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'L':
         case 'l':
            // LocalVariablesDeclaration
            match = localVariablesDeclaration$Rule();
            if (! match) {
               // LoopStmt
               match = loopStmt$Rule();
               if (! match) {
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    // KeywordsFunctionCall
                                    match = keywordsFunctionCall$Rule();
                                    if (! match) {
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             // OldStyleCommands
                                             match = oldStyleCommands$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'M':
         case 'm':
            // MethodDefinition
            match = methodDefinition$Rule();
            if (! match) {
               // ClassBodyStmt
               match = classBodyStmt$Rule();
               if (! match) {
                  // MemvarDeclaration
                  match = memvarDeclaration$Rule();
                  if (! match) {
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    // MacroFunctionCall
                                    match = macroFunctionCall$Rule();
                                    if (! match) {
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             // OldStyleCommands
                                             match = oldStyleCommands$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'N':
         case 'n':
            // ForNextEnd
            match = forNextEnd$Rule();
            if (! match) {
               // ForEachEnd
               match = forEachEnd$Rule();
               if (! match) {
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       // Macro
                                       match = macro$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'O':
         case 'o':
            // OtherwiseBegin
            match = otherwiseBegin$Rule();
            if (! match) {
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 // KeywordsFunctionCall
                                 match = keywordsFunctionCall$Rule();
                                 if (! match) {
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       // Macro
                                       match = macro$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'P':
         case 'p':
            // ProcedureDeclaration
            match = procedureDeclaration$Rule();
            if (! match) {
               // ClassBodyStmt
               match = classBodyStmt$Rule();
               if (! match) {
                  // OldStyleParametersDeclaration
                  match = oldStyleParametersDeclaration$Rule();
                  if (! match) {
                     // PublicVariableDeclaration
                     match = publicVariableDeclaration$Rule();
                     if (! match) {
                        // PrivateVariableDeclaration
                        match = privateVariableDeclaration$Rule();
                        if (! match) {
                           // StatementAssignmentExpression
                           match = statementAssignmentExpression$Rule();
                           if (! match) {
                              // PostfixedExpression
                              match = postfixedExpression$Rule();
                              if (! match) {
                                 // AliasedExpression
                                 match = aliasedExpression$Rule();
                                 if (! match) {
                                    // AliasedMacro
                                    match = aliasedMacro$Rule();
                                    if (! match) {
                                       // QualifiedExpression
                                       match = qualifiedExpression$Rule();
                                       if (! match) {
                                          // MacroFunctionCall
                                          match = macroFunctionCall$Rule();
                                          if (! match) {
                                             // KeywordsFunctionCall
                                             match = keywordsFunctionCall$Rule();
                                             if (! match) {
                                                // SimpleFunctionCall
                                                match = simpleFunctionCall$Rule();
                                                if (! match) {
                                                   // Macro
                                                   match = macro$Rule();
                                                   if (! match) {
                                                      // OldStyleCommands
                                                      match = oldStyleCommands$Rule();
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'R':
         case 'r':
            // RecoverBegin
            match = recoverBegin$Rule();
            if (! match) {
               // Return
               match = return$Rule();
               if (! match) {
                  // Request
                  match = request$Rule();
                  if (! match) {
                     // StatementAssignmentExpression
                     match = statementAssignmentExpression$Rule();
                     if (! match) {
                        // PostfixedExpression
                        match = postfixedExpression$Rule();
                        if (! match) {
                           // AliasedExpression
                           match = aliasedExpression$Rule();
                           if (! match) {
                              // AliasedMacro
                              match = aliasedMacro$Rule();
                              if (! match) {
                                 // QualifiedExpression
                                 match = qualifiedExpression$Rule();
                                 if (! match) {
                                    // RollbackTransaction
                                    match = rollbackTransaction$Rule();
                                    if (! match) {
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   // OldStyleCommands
                                                   match = oldStyleCommands$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'S':
         case 's':
            // FunctionDeclaration
            match = functionDeclaration$Rule();
            if (! match) {
               // ProcedureDeclaration
               match = procedureDeclaration$Rule();
               if (! match) {
                  // StaticVariablesDeclaration
                  match = staticVariablesDeclaration$Rule();
                  if (! match) {
                     // SwitchBegin
                     match = switchBegin$Rule();
                     if (! match) {
                        // StatementAssignmentExpression
                        match = statementAssignmentExpression$Rule();
                        if (! match) {
                           // PostfixedExpression
                           match = postfixedExpression$Rule();
                           if (! match) {
                              // AliasedExpression
                              match = aliasedExpression$Rule();
                              if (! match) {
                                 // AliasedMacro
                                 match = aliasedMacro$Rule();
                                 if (! match) {
                                    // QualifiedExpression
                                    match = qualifiedExpression$Rule();
                                    if (! match) {
                                       // MacroFunctionCall
                                       match = macroFunctionCall$Rule();
                                       if (! match) {
                                          // KeywordsFunctionCall
                                          match = keywordsFunctionCall$Rule();
                                          if (! match) {
                                             // SimpleFunctionCall
                                             match = simpleFunctionCall$Rule();
                                             if (! match) {
                                                // Macro
                                                match = macro$Rule();
                                                if (! match) {
                                                   // OldStyleCommands
                                                   match = oldStyleCommands$Rule();
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'T':
         case 't':
            // TryCatchBegin
            match = tryCatchBegin$Rule();
            if (! match) {
               // Throw
               match = throw$Rule();
               if (! match) {
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    // KeywordsFunctionCall
                                    match = keywordsFunctionCall$Rule();
                                    if (! match) {
                                       // SimpleFunctionCall
                                       match = simpleFunctionCall$Rule();
                                       if (! match) {
                                          // Macro
                                          match = macro$Rule();
                                          if (! match) {
                                             // OldStyleCommands
                                             match = oldStyleCommands$Rule();
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'U':
         case 'u':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // UseAs
                           match = useAs$Rule();
                           if (! match) {
                              // UseArea
                              match = useArea$Rule();
                              if (! match) {
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       // Macro
                                       match = macro$Rule();
                                       if (! match) {
                                          // OldStyleCommands
                                          match = oldStyleCommands$Rule();
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'W':
         case 'w':
            // DoWhileBegin
            match = doWhileBegin$Rule();
            if (! match) {
               // StatementAssignmentExpression
               match = statementAssignmentExpression$Rule();
               if (! match) {
                  // PostfixedExpression
                  match = postfixedExpression$Rule();
                  if (! match) {
                     // AliasedExpression
                     match = aliasedExpression$Rule();
                     if (! match) {
                        // AliasedMacro
                        match = aliasedMacro$Rule();
                        if (! match) {
                           // QualifiedExpression
                           match = qualifiedExpression$Rule();
                           if (! match) {
                              // MacroFunctionCall
                              match = macroFunctionCall$Rule();
                              if (! match) {
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    // Macro
                                    match = macro$Rule();
                                    if (! match) {
                                       // OldStyleCommands
                                       match = oldStyleCommands$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'X':
         case 'x':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // KeywordsFunctionCall
                              match = keywordsFunctionCall$Rule();
                              if (! match) {
                                 // SimpleFunctionCall
                                 match = simpleFunctionCall$Rule();
                                 if (! match) {
                                    // Macro
                                    match = macro$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'Y':
         case 'y':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // SimpleFunctionCall
                              match = simpleFunctionCall$Rule();
                              if (! match) {
                                 // Macro
                                 match = macro$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case '\"':
         case '\'':
         case '[':
         case '{':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // QualifiedExpression
                  match = qualifiedExpression$Rule();
               }
            }
            break;
         case '_':
            // ClassDeclaration
            match = classDeclaration$Rule();
            if (! match) {
               // ClassMemberDeclaration
               match = classMemberDeclaration$Rule();
               if (! match) {
                  // StatementAssignmentExpression
                  match = statementAssignmentExpression$Rule();
                  if (! match) {
                     // PostfixedExpression
                     match = postfixedExpression$Rule();
                     if (! match) {
                        // AliasedExpression
                        match = aliasedExpression$Rule();
                        if (! match) {
                           // AliasedMacro
                           match = aliasedMacro$Rule();
                           if (! match) {
                              // QualifiedExpression
                              match = qualifiedExpression$Rule();
                              if (! match) {
                                 // MacroFunctionCall
                                 match = macroFunctionCall$Rule();
                                 if (! match) {
                                    // SimpleFunctionCall
                                    match = simpleFunctionCall$Rule();
                                    if (! match) {
                                       // Macro
                                       match = macro$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case '#':
            // Directive
            match = directive$Rule();
            break;
         case '(':
            // StatementAssignmentExpression
            match = statementAssignmentExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // AliasedExpression
                  match = aliasedExpression$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // QualifiedExpression
                        match = qualifiedExpression$Rule();
                        if (! match) {
                           // ParenthesesExpressionList
                           match = parenthesesExpressionList$Rule();
                        }
                     }
                  }
               }
            }
            break;
         case '*':
            // AloneLineComment
            match = aloneLineComment$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         statement$RuleMemoStart = startIndex;
         statement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            statement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            statement$RuleMemoFirstNode = currentNode;
            statement$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         statement$RuleMemoStart = startIndex;
         statement$RuleMemoEnd = -1;
         statement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LocalVariablesDeclaration : (("local" | "loca") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean localVariablesDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (localVariablesDeclaration$RuleMemoStart == index) {
         if (localVariablesDeclaration$RuleMemoStart <= localVariablesDeclaration$RuleMemoEnd) {
            index = localVariablesDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (localVariablesDeclaration$RuleMemoStart == localVariablesDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCAL_VARIABLES_DECLARATION, localVariablesDeclaration$RuleMemoStart, localVariablesDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(localVariablesDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(localVariablesDeclaration$RuleMemoFirstNode);
                  currentNode = localVariablesDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("local" | "loca") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("local" | "loca")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
         ++index;
         // ("ocal" | "oca")
         if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
            ++index;
            // ("cal" | "ca")
            if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
               ++index;
               // ("al" | "a")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("l" | <EMPTY>)
                  if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         localVariablesDeclaration$RuleMemoStart = startIndex;
         localVariablesDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            localVariablesDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCAL_VARIABLES_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            localVariablesDeclaration$RuleMemoFirstNode = currentNode;
            localVariablesDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         localVariablesDeclaration$RuleMemoStart = startIndex;
         localVariablesDeclaration$RuleMemoEnd = -1;
         localVariablesDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionDeclaration : (FunctionModifier ("function" | "functio" | "functi" | "funct" | "func") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
   protected boolean functionDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionDeclaration$RuleMemoStart == index) {
         if (functionDeclaration$RuleMemoStart <= functionDeclaration$RuleMemoEnd) {
            index = functionDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (functionDeclaration$RuleMemoStart == functionDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_DECLARATION, functionDeclaration$RuleMemoStart, functionDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(functionDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(functionDeclaration$RuleMemoFirstNode);
                  currentNode = functionDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (FunctionModifier ("function" | "functio" | "functi" | "funct" | "func") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
      // FunctionModifier
      match = functionModifier$Rule();
      if (match) {
         // ("function" | "functio" | "functi" | "funct" | "func")
         int startIndex_1 = index;
         if (buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F')) {
            ++index;
            // ("unction" | "unctio" | "uncti" | "unct" | "unc")
            if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
               ++index;
               // ("nction" | "nctio" | "ncti" | "nct" | "nc")
               if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                  ++index;
                  // ("ction" | "ctio" | "cti" | "ct" | "c")
                  if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                     ++index;
                     // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                     if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                        ++index;
                        // ("ion" | "io" | "i" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // ("on" | "o" | <EMPTY>)
                           if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                              ++index;
                              // "n"
                              if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
         if (! match) {
            index = startIndex_1;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // ParParametersDeclaration?
                     // ParParametersDeclaration
                     parParametersDeclaration$Rule();
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionDeclaration$RuleMemoFirstNode = currentNode;
            functionDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         functionDeclaration$RuleMemoStart = startIndex;
         functionDeclaration$RuleMemoEnd = -1;
         functionDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ProcedureDeclaration : (FunctionModifier ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
   protected boolean procedureDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (procedureDeclaration$RuleMemoStart == index) {
         if (procedureDeclaration$RuleMemoStart <= procedureDeclaration$RuleMemoEnd) {
            index = procedureDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (procedureDeclaration$RuleMemoStart == procedureDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PROCEDURE_DECLARATION, procedureDeclaration$RuleMemoStart, procedureDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(procedureDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(procedureDeclaration$RuleMemoFirstNode);
                  currentNode = procedureDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (FunctionModifier ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc") TestNoAlpha OptionalSpacing Identifier ParParametersDeclaration?)
      // FunctionModifier
      match = functionModifier$Rule();
      if (match) {
         // ("procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc")
         int startIndex_1 = index;
         if (buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P')) {
            ++index;
            // ("rocedure" | "rocedur" | "rocedu" | "roced" | "roce" | "roc")
            if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
               ++index;
               // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
               if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                  ++index;
                  // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                  if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                     ++index;
                     // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                        if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                           ++index;
                           // ("ure" | "ur" | "u" | <EMPTY>)
                           if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                              ++index;
                              // ("re" | "r" | <EMPTY>)
                              if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
         if (! match) {
            index = startIndex_1;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Identifier
                  match = identifier$Rule();
                  if (match) {
                     // ParParametersDeclaration?
                     // ParParametersDeclaration
                     parParametersDeclaration$Rule();
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            procedureDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PROCEDURE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            procedureDeclaration$RuleMemoFirstNode = currentNode;
            procedureDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         procedureDeclaration$RuleMemoStart = startIndex;
         procedureDeclaration$RuleMemoEnd = -1;
         procedureDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MethodDefinition : ((("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing) (("procedure" | "function") TestNoAlpha OptionalSpacing)? AnyIdentifier ParParametersDeclaration ClassOwner?)
   protected boolean methodDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodDefinition$RuleMemoStart == index) {
         if (methodDefinition$RuleMemoStart <= methodDefinition$RuleMemoEnd) {
            index = methodDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (methodDefinition$RuleMemoStart == methodDefinition$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DEFINITION, methodDefinition$RuleMemoStart, methodDefinition$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(methodDefinition$RuleMemoFirstNode != null) {
                  lastNode.setSibling(methodDefinition$RuleMemoFirstNode);
                  currentNode = methodDefinition$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing) (("procedure" | "function") TestNoAlpha OptionalSpacing)? AnyIdentifier ParParametersDeclaration ClassOwner?)
      // (("method" | "classmethod" | "constructor") TestNoAlpha OptionalSpacing)
      // ("method" | "classmethod" | "constructor")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'c':
         case 'C':
            ++index;
            // ("lassmethod" | "onstructor")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // "nstructor"
                  if (match = ignoreCaseStringTest("nstructor", 9)) {
                     index += 9;
                  }
                  break;
               case 'l':
               case 'L':
                  ++index;
                  // "assmethod"
                  if (match = ignoreCaseStringTest("assmethod", 9)) {
                     index += 9;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'm':
         case 'M':
            ++index;
            // "ethod"
            if (match = ignoreCaseStringTest("ethod", 5)) {
               index += 5;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // (("procedure" | "function") TestNoAlpha OptionalSpacing)?
         // (("procedure" | "function") TestNoAlpha OptionalSpacing)
         Node lastNode_2 = currentNode;
         int lastIndex_2 = index;
         // ("procedure" | "function")
         int startIndex_3 = index;
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F':
               ++index;
               // "unction"
               if (match = ignoreCaseStringTest("unction", 7)) {
                  index += 7;
               }
               break;
            case 'p':
            case 'P':
               ++index;
               // "rocedure"
               if (match = ignoreCaseStringTest("rocedure", 8)) {
                  index += 8;
               }
               break;
            default:
               match = false;
         }
         if (! match) {
            index = startIndex_3;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // TestNoAlpha
            match = testNoAlpha$Rule();
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (! match) {
                  index = lastIndex_2;
                  lastNode_2.setSibling(null);
                  currentNode = lastNode_2;
               }
            } else {
               index = lastIndex_2;
               lastNode_2.setSibling(null);
            }
         }
         // AnyIdentifier
         match = anyIdentifier$Rule();
         if (match) {
            // ParParametersDeclaration
            match = parParametersDeclaration$Rule();
            if (match) {
               // ClassOwner?
               // ClassOwner
               classOwner$Rule();
               match = true;
            }
         }
      }
      if (match) {
         methodDefinition$RuleMemoStart = startIndex;
         methodDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodDefinition$RuleMemoFirstNode = currentNode;
            methodDefinition$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         methodDefinition$RuleMemoStart = startIndex;
         methodDefinition$RuleMemoEnd = -1;
         methodDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassOwner : ("class" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean classOwner$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("class" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "class"
      match = ignoreCaseStringMatcher("class", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_OWNER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CreateClass : (("create" TestNoAlpha OptionalSpacing)? "class" TestNoAlpha OptionalSpacing AnyIdentifier ("from" TestNoAlpha OptionalSpacing IdentifierList)?)
   protected boolean createClass$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (createClass$RuleMemoStart == index) {
         if (createClass$RuleMemoStart <= createClass$RuleMemoEnd) {
            index = createClass$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (createClass$RuleMemoStart == createClass$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CLASS, createClass$RuleMemoStart, createClass$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(createClass$RuleMemoFirstNode != null) {
                  lastNode.setSibling(createClass$RuleMemoFirstNode);
                  currentNode = createClass$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("create" TestNoAlpha OptionalSpacing)? "class" TestNoAlpha OptionalSpacing AnyIdentifier ("from" TestNoAlpha OptionalSpacing IdentifierList)?)
      // ("create" TestNoAlpha OptionalSpacing)?
      // ("create" TestNoAlpha OptionalSpacing)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "create"
      match = ignoreCaseStringMatcher("create", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      // "class"
      match = ignoreCaseStringMatcher("class", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
               if (match) {
                  // ("from" TestNoAlpha OptionalSpacing IdentifierList)?
                  // ("from" TestNoAlpha OptionalSpacing IdentifierList)
                  Node lastNode_2 = currentNode;
                  int lastIndex_2 = index;
                  // "from"
                  match = ignoreCaseStringMatcher("from", 4);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // IdentifierList
                           match = identifierList$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                        } else {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                        }
                     } else {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                     }
                  }
                  match = true;
               }
            }
         }
      }
      if (match) {
         createClass$RuleMemoStart = startIndex;
         createClass$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createClass$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CLASS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createClass$RuleMemoFirstNode = currentNode;
            createClass$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         createClass$RuleMemoStart = startIndex;
         createClass$RuleMemoEnd = -1;
         createClass$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndClass : ("endclass" TestNoAlpha OptionalSpacing)
   protected boolean endClass$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endClass$RuleMemoStart == index) {
         if (endClass$RuleMemoStart <= endClass$RuleMemoEnd) {
            index = endClass$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (endClass$RuleMemoStart == endClass$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_CLASS, endClass$RuleMemoStart, endClass$RuleMemoEnd, false, false);
                  lastNode.setSibling(currentNode);
               } else if(endClass$RuleMemoFirstNode != null) {
                  lastNode.setSibling(endClass$RuleMemoFirstNode);
                  currentNode = endClass$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("endclass" TestNoAlpha OptionalSpacing)
      // "endclass"
      match = ignoreCaseStringMatcher("endclass", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         endClass$RuleMemoStart = startIndex;
         endClass$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endClass$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_CLASS, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endClass$RuleMemoFirstNode = currentNode;
            endClass$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         endClass$RuleMemoStart = startIndex;
         endClass$RuleMemoEnd = -1;
         endClass$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassBodyStmt : (SectionScope | MethodMember | FieldMember)
   protected boolean classBodyStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classBodyStmt$RuleMemoStart == index) {
         if (classBodyStmt$RuleMemoStart <= classBodyStmt$RuleMemoEnd) {
            index = classBodyStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (classBodyStmt$RuleMemoStart == classBodyStmt$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_BODY_STMT, classBodyStmt$RuleMemoStart, classBodyStmt$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(classBodyStmt$RuleMemoFirstNode != null) {
                  lastNode.setSibling(classBodyStmt$RuleMemoFirstNode);
                  currentNode = classBodyStmt$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SectionScope | MethodMember | FieldMember)
      switch(buffer.getChar(index)) {
         case 'm':
         case 'M':
            // MethodMember
            match = methodMember$Rule();
            break;
         case 'p':
         case 'P':
            // SectionScope
            match = sectionScope$Rule();
            if (! match) {
               // MethodMember
               match = methodMember$Rule();
            }
            break;
         case 'a':
         case 'A':
         case 'c':
         case 'C':
            // MethodMember
            match = methodMember$Rule();
            if (! match) {
               // FieldMember
               match = fieldMember$Rule();
            }
            break;
         case 'd':
         case 'D':
            // FieldMember
            match = fieldMember$Rule();
            break;
         case 'e':
         case 'E':
         case 'h':
         case 'H':
            // SectionScope
            match = sectionScope$Rule();
            break;
         case 'v':
         case 'V':
            // SectionScope
            match = sectionScope$Rule();
            if (! match) {
               // FieldMember
               match = fieldMember$Rule();
            }
            break;
         default:
            match = false;
      }
      if (match) {
         classBodyStmt$RuleMemoStart = startIndex;
         classBodyStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classBodyStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_BODY_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classBodyStmt$RuleMemoFirstNode = currentNode;
            classBodyStmt$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         classBodyStmt$RuleMemoStart = startIndex;
         classBodyStmt$RuleMemoEnd = -1;
         classBodyStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SectionScope : (MemberScope ':' OptionalSpacing)
   protected boolean sectionScope$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sectionScope$RuleMemoStart == index) {
         if (sectionScope$RuleMemoStart <= sectionScope$RuleMemoEnd) {
            index = sectionScope$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (sectionScope$RuleMemoStart == sectionScope$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SECTION_SCOPE, sectionScope$RuleMemoStart, sectionScope$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(sectionScope$RuleMemoFirstNode != null) {
                  lastNode.setSibling(sectionScope$RuleMemoFirstNode);
                  currentNode = sectionScope$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MemberScope ':' OptionalSpacing)
      // MemberScope
      match = memberScope$Rule();
      if (match) {
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         sectionScope$RuleMemoStart = startIndex;
         sectionScope$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sectionScope$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SECTION_SCOPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sectionScope$RuleMemoFirstNode = currentNode;
            sectionScope$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         sectionScope$RuleMemoStart = startIndex;
         sectionScope$RuleMemoEnd = -1;
         sectionScope$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemberScope : (("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published") TestNoAlpha OptionalSpacing)
   protected boolean memberScope$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (memberScope$RuleMemoStart == index) {
         if (memberScope$RuleMemoStart <= memberScope$RuleMemoEnd) {
            index = memberScope$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (memberScope$RuleMemoStart == memberScope$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPE, memberScope$RuleMemoStart, memberScope$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(memberScope$RuleMemoFirstNode != null) {
                  lastNode.setSibling(memberScope$RuleMemoFirstNode);
                  currentNode = memberScope$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published") TestNoAlpha OptionalSpacing)
      // ("hidden" | "export" | "exported" | "visible" | "public" | "private" | "protected" | "published")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'v':
         case 'V':
            ++index;
            // "isible"
            if (match = ignoreCaseStringTest("isible", 6)) {
               index += 6;
            }
            break;
         case 'h':
         case 'H':
            ++index;
            // "idden"
            if (match = ignoreCaseStringTest("idden", 5)) {
               index += 5;
            }
            break;
         case 'p':
         case 'P':
            ++index;
            // ("rotected" | "ublished" | "rivate" | "ublic")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R':
                  ++index;
                  // ("otected" | "ivate")
                  switch(buffer.getChar(index)) {
                     case 'o':
                     case 'O':
                        ++index;
                        // "tected"
                        if (match = ignoreCaseStringTest("tected", 6)) {
                           index += 6;
                        }
                        break;
                     case 'i':
                     case 'I':
                        ++index;
                        // "vate"
                        if (match = ignoreCaseStringTest("vate", 4)) {
                           index += 4;
                        }
                        break;
                     default:
                        match = false;
                  }
                  break;
               case 'u':
               case 'U':
                  ++index;
                  // ("blished" | "blic")
                  if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
                     ++index;
                     // ("lished" | "lic")
                     if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                        ++index;
                        // ("ished" | "ic")
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // ("shed" | "c")
                           switch(buffer.getChar(index)) {
                              case 's':
                              case 'S':
                                 ++index;
                                 // "hed"
                                 if (match = ignoreCaseStringTest("hed", 3)) {
                                    index += 3;
                                 }
                                 break;
                              case 'c':
                              case 'C':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              default:
                                 match = false;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'e':
         case 'E':
            ++index;
            // ("xported" | "xport")
            if (buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X')) {
               ++index;
               // ("ported" | "port")
               if (buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P')) {
                  ++index;
                  // ("orted" | "ort")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("rted" | "rt")
                     if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                        ++index;
                        // ("ted" | "t")
                        if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                           ++index;
                           // ("ed" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // "d"
                              if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                                 ++index;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         memberScope$RuleMemoStart = startIndex;
         memberScope$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            memberScope$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_SCOPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            memberScope$RuleMemoFirstNode = currentNode;
            memberScope$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         memberScope$RuleMemoStart = startIndex;
         memberScope$RuleMemoEnd = -1;
         memberScope$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MethodMember : ((("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing) AnyIdentifier ParParametersDeclaration ("constructor" TestNoAlpha OptionalSpacing)? AsDataType? MemberScope* InLineExpression?)
   protected boolean methodMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodMember$RuleMemoStart == index) {
         if (methodMember$RuleMemoStart <= methodMember$RuleMemoEnd) {
            index = methodMember$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (methodMember$RuleMemoStart == methodMember$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_MEMBER, methodMember$RuleMemoStart, methodMember$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(methodMember$RuleMemoFirstNode != null) {
                  lastNode.setSibling(methodMember$RuleMemoFirstNode);
                  currentNode = methodMember$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing) AnyIdentifier ParParametersDeclaration ("constructor" TestNoAlpha OptionalSpacing)? AsDataType? MemberScope* InLineExpression?)
      // (("method" | "classmethod" | "constructor" | "procedure" | "assign") TestNoAlpha OptionalSpacing)
      // ("method" | "classmethod" | "constructor" | "procedure" | "assign")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'p':
         case 'P':
            ++index;
            // "rocedure"
            if (match = ignoreCaseStringTest("rocedure", 8)) {
               index += 8;
            }
            break;
         case 'a':
         case 'A':
            ++index;
            // "ssign"
            if (match = ignoreCaseStringTest("ssign", 5)) {
               index += 5;
            }
            break;
         case 'c':
         case 'C':
            ++index;
            // ("lassmethod" | "onstructor")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // "nstructor"
                  if (match = ignoreCaseStringTest("nstructor", 9)) {
                     index += 9;
                  }
                  break;
               case 'l':
               case 'L':
                  ++index;
                  // "assmethod"
                  if (match = ignoreCaseStringTest("assmethod", 9)) {
                     index += 9;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'm':
         case 'M':
            ++index;
            // "ethod"
            if (match = ignoreCaseStringTest("ethod", 5)) {
               index += 5;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // AnyIdentifier
         match = anyIdentifier$Rule();
         if (match) {
            // ParParametersDeclaration
            match = parParametersDeclaration$Rule();
            if (match) {
               // ("constructor" TestNoAlpha OptionalSpacing)?
               // ("constructor" TestNoAlpha OptionalSpacing)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // "constructor"
               match = ignoreCaseStringMatcher("constructor", 11);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
               // AsDataType?
               // AsDataType
               asDataType$Rule();
               // MemberScope*
               do {
                  // MemberScope
                  match = memberScope$Rule();
               } while(match);
               // InLineExpression?
               // InLineExpression
               inLineExpression$Rule();
               match = true;
            }
         }
      }
      if (match) {
         methodMember$RuleMemoStart = startIndex;
         methodMember$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodMember$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodMember$RuleMemoFirstNode = currentNode;
            methodMember$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         methodMember$RuleMemoStart = startIndex;
         methodMember$RuleMemoEnd = -1;
         methodMember$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FieldMember : ((("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing) AnyIdentifier AsDataType? InitFieldMember? IsInObject? MemberScope* InLineExpression?)
   protected boolean fieldMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (fieldMember$RuleMemoStart == index) {
         if (fieldMember$RuleMemoStart <= fieldMember$RuleMemoEnd) {
            index = fieldMember$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (fieldMember$RuleMemoStart == fieldMember$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELD_MEMBER, fieldMember$RuleMemoStart, fieldMember$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(fieldMember$RuleMemoFirstNode != null) {
                  lastNode.setSibling(fieldMember$RuleMemoFirstNode);
                  currentNode = fieldMember$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing) AnyIdentifier AsDataType? InitFieldMember? IsInObject? MemberScope* InLineExpression?)
      // (("data" | "var" | "classvar" | "access") TestNoAlpha OptionalSpacing)
      // ("data" | "var" | "classvar" | "access")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'v':
         case 'V':
            ++index;
            // "ar"
            if (match = ignoreCaseStringTest("ar", 2)) {
               index += 2;
            }
            break;
         case 'a':
         case 'A':
            ++index;
            // "ccess"
            if (match = ignoreCaseStringTest("ccess", 5)) {
               index += 5;
            }
            break;
         case 'c':
         case 'C':
            ++index;
            // "lassvar"
            if (match = ignoreCaseStringTest("lassvar", 7)) {
               index += 7;
            }
            break;
         case 'd':
         case 'D':
            ++index;
            // "ata"
            if (match = ignoreCaseStringTest("ata", 3)) {
               index += 3;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // AnyIdentifier
         match = anyIdentifier$Rule();
         if (match) {
            // AsDataType?
            // AsDataType
            asDataType$Rule();
            // InitFieldMember?
            // InitFieldMember
            initFieldMember$Rule();
            // IsInObject?
            // IsInObject
            isInObject$Rule();
            // MemberScope*
            do {
               // MemberScope
               match = memberScope$Rule();
            } while(match);
            // InLineExpression?
            // InLineExpression
            inLineExpression$Rule();
            match = true;
         }
      }
      if (match) {
         fieldMember$RuleMemoStart = startIndex;
         fieldMember$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fieldMember$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fieldMember$RuleMemoFirstNode = currentNode;
            fieldMember$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         fieldMember$RuleMemoStart = startIndex;
         fieldMember$RuleMemoEnd = -1;
         fieldMember$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InLineExpression : ("inline" TestNoAlpha OptionalSpacing ExpressionList)
   protected boolean inLineExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (inLineExpression$RuleMemoStart == index) {
         if (inLineExpression$RuleMemoStart <= inLineExpression$RuleMemoEnd) {
            index = inLineExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (inLineExpression$RuleMemoStart == inLineExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_LINE_EXPRESSION, inLineExpression$RuleMemoStart, inLineExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(inLineExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(inLineExpression$RuleMemoFirstNode);
                  currentNode = inLineExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("inline" TestNoAlpha OptionalSpacing ExpressionList)
      // "inline"
      match = ignoreCaseStringMatcher("inline", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ExpressionList
               match = expressionList$Rule();
            }
         }
      }
      if (match) {
         inLineExpression$RuleMemoStart = startIndex;
         inLineExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inLineExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_LINE_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inLineExpression$RuleMemoFirstNode = currentNode;
            inLineExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         inLineExpression$RuleMemoStart = startIndex;
         inLineExpression$RuleMemoEnd = -1;
         inLineExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InitFieldMember : ("init" TestNoAlpha OptionalSpacing Expression)
   protected boolean initFieldMember$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("init" TestNoAlpha OptionalSpacing Expression)
      // "init"
      match = ignoreCaseStringMatcher("init", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INIT_FIELD_MEMBER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IsInObject : ("is" TestNoAlpha OptionalSpacing AnyIdentifier "in" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean isInObject$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("is" TestNoAlpha OptionalSpacing AnyIdentifier "in" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "is"
      match = ignoreCaseStringMatcher("is", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
               if (match) {
                  // "in"
                  match = ignoreCaseStringMatcher("in", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // AnyIdentifier
                           match = anyIdentifier$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IS_IN_OBJECT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Variable : (VariablePattern OptionalSpacing)
   protected boolean variable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variable$RuleMemoStart == index) {
         if (variable$RuleMemoStart <= variable$RuleMemoEnd) {
            index = variable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (variable$RuleMemoStart == variable$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, variable$RuleMemoStart, variable$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(variable$RuleMemoFirstNode != null) {
                  lastNode.setSibling(variable$RuleMemoFirstNode);
                  currentNode = variable$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (VariablePattern OptionalSpacing)
      // VariablePattern
      match = variablePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         variable$RuleMemoStart = startIndex;
         variable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variable$RuleMemoFirstNode = currentNode;
            variable$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         variable$RuleMemoStart = startIndex;
         variable$RuleMemoEnd = -1;
         variable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariablePattern : (IdentifierPattern (('(' | '->') OptionalSpacing)!)
   protected boolean variablePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdentifierPattern (('(' | '->') OptionalSpacing)!)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // (('(' | '->') OptionalSpacing)!
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         boolean lastAtomic_1 = currentRuleIsAtomic;
         // (('(' | '->') OptionalSpacing)
         // ('(' | '->')
         int startIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '-':
               ++index;
               // '>'
               if (match = buffer.matchChar(index, '>')) {
                  ++index;
               }
               break;
            case '(':
               ++index;
               // <EMPTY>
               match = true;
               break;
            default:
               match = false;
         }
         if (! match) {
            index = startIndex_2;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         currentRuleIsAtomic = lastAtomic_1;
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         match = ! match;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StaticVariablesDeclaration : (("static" | "stati" | "stat") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean staticVariablesDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (staticVariablesDeclaration$RuleMemoStart == index) {
         if (staticVariablesDeclaration$RuleMemoStart <= staticVariablesDeclaration$RuleMemoEnd) {
            index = staticVariablesDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (staticVariablesDeclaration$RuleMemoStart == staticVariablesDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATIC_VARIABLES_DECLARATION, staticVariablesDeclaration$RuleMemoStart, staticVariablesDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(staticVariablesDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(staticVariablesDeclaration$RuleMemoFirstNode);
                  currentNode = staticVariablesDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("static" | "stati" | "stat") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("static" | "stati" | "stat")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
         ++index;
         // ("tatic" | "tati" | "tat")
         if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
            ++index;
            // ("atic" | "ati" | "at")
            if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
               ++index;
               // ("tic" | "ti" | "t")
               if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                  ++index;
                  // ("ic" | "i" | <EMPTY>)
                  if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                     ++index;
                     // "c"
                     if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         staticVariablesDeclaration$RuleMemoStart = startIndex;
         staticVariablesDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            staticVariablesDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATIC_VARIABLES_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            staticVariablesDeclaration$RuleMemoFirstNode = currentNode;
            staticVariablesDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         staticVariablesDeclaration$RuleMemoStart = startIndex;
         staticVariablesDeclaration$RuleMemoEnd = -1;
         staticVariablesDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FieldsDeclaration : (("field" | "fiel") TestNoAlpha OptionalSpacing IdentifierList InTable?)
   protected boolean fieldsDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (fieldsDeclaration$RuleMemoStart == index) {
         if (fieldsDeclaration$RuleMemoStart <= fieldsDeclaration$RuleMemoEnd) {
            index = fieldsDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (fieldsDeclaration$RuleMemoStart == fieldsDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELDS_DECLARATION, fieldsDeclaration$RuleMemoStart, fieldsDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(fieldsDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(fieldsDeclaration$RuleMemoFirstNode);
                  currentNode = fieldsDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("field" | "fiel") TestNoAlpha OptionalSpacing IdentifierList InTable?)
      // ("field" | "fiel")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F')) {
         ++index;
         // ("ield" | "iel")
         if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
            ++index;
            // ("eld" | "el")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("ld" | "l")
               if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                  ++index;
                  // ("d" | <EMPTY>)
                  if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
               if (match) {
                  // InTable?
                  // InTable
                  inTable$Rule();
                  match = true;
               }
            }
         }
      }
      if (match) {
         fieldsDeclaration$RuleMemoStart = startIndex;
         fieldsDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            fieldsDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIELDS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            fieldsDeclaration$RuleMemoFirstNode = currentNode;
            fieldsDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         fieldsDeclaration$RuleMemoStart = startIndex;
         fieldsDeclaration$RuleMemoEnd = -1;
         fieldsDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassDeclaration : ("_HB_CLASS" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean classDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classDeclaration$RuleMemoStart == index) {
         if (classDeclaration$RuleMemoStart <= classDeclaration$RuleMemoEnd) {
            index = classDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (classDeclaration$RuleMemoStart == classDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_DECLARATION, classDeclaration$RuleMemoStart, classDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(classDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(classDeclaration$RuleMemoFirstNode);
                  currentNode = classDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("_HB_CLASS" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "_HB_CLASS"
      match = ignoreCaseStringMatcher("_HB_CLASS", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         classDeclaration$RuleMemoStart = startIndex;
         classDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classDeclaration$RuleMemoFirstNode = currentNode;
            classDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         classDeclaration$RuleMemoStart = startIndex;
         classDeclaration$RuleMemoEnd = -1;
         classDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OldStyleParametersDeclaration : (("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para") TestNoAlpha OptionalSpacing ParametersDeclarationList)
   protected boolean oldStyleParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (oldStyleParametersDeclaration$RuleMemoStart == index) {
         if (oldStyleParametersDeclaration$RuleMemoStart <= oldStyleParametersDeclaration$RuleMemoEnd) {
            index = oldStyleParametersDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (oldStyleParametersDeclaration$RuleMemoStart == oldStyleParametersDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_PARAMETERS_DECLARATION, oldStyleParametersDeclaration$RuleMemoStart, oldStyleParametersDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(oldStyleParametersDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(oldStyleParametersDeclaration$RuleMemoFirstNode);
                  currentNode = oldStyleParametersDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para") TestNoAlpha OptionalSpacing ParametersDeclarationList)
      // ("parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P')) {
         ++index;
         // ("arameters" | "arameter" | "aramete" | "aramet" | "arame" | "aram" | "ara")
         if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
            ++index;
            // ("rameters" | "rameter" | "ramete" | "ramet" | "rame" | "ram" | "ra")
            if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
               ++index;
               // ("ameters" | "ameter" | "amete" | "amet" | "ame" | "am" | "a")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("meters" | "meter" | "mete" | "met" | "me" | "m" | <EMPTY>)
                  if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                     ++index;
                     // ("eters" | "eter" | "ete" | "et" | "e" | <EMPTY>)
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // ("ters" | "ter" | "te" | "t" | <EMPTY>)
                        if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                           ++index;
                           // ("ers" | "er" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("rs" | "r" | <EMPTY>)
                              if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                 ++index;
                                 // "s"
                                 if (match = buffer.matchIgnoreCaseChar(index, 's')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ParametersDeclarationList
               match = parametersDeclarationList$Rule();
            }
         }
      }
      if (match) {
         oldStyleParametersDeclaration$RuleMemoStart = startIndex;
         oldStyleParametersDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            oldStyleParametersDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_PARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            oldStyleParametersDeclaration$RuleMemoFirstNode = currentNode;
            oldStyleParametersDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         oldStyleParametersDeclaration$RuleMemoStart = startIndex;
         oldStyleParametersDeclaration$RuleMemoEnd = -1;
         oldStyleParametersDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DeclareStatement : (("declare" | "declar" | "decla" | "decl") TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean declareStatement$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (declareStatement$RuleMemoStart == index) {
         if (declareStatement$RuleMemoStart <= declareStatement$RuleMemoEnd) {
            index = declareStatement$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (declareStatement$RuleMemoStart == declareStatement$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DECLARE_STATEMENT, declareStatement$RuleMemoStart, declareStatement$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(declareStatement$RuleMemoFirstNode != null) {
                  lastNode.setSibling(declareStatement$RuleMemoFirstNode);
                  currentNode = declareStatement$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("declare" | "declar" | "decla" | "decl") TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // ("declare" | "declar" | "decla" | "decl")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
         ++index;
         // ("eclare" | "eclar" | "ecla" | "ecl")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("clare" | "clar" | "cla" | "cl")
            if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
               ++index;
               // ("lare" | "lar" | "la" | "l")
               if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                  ++index;
                  // ("are" | "ar" | "a" | <EMPTY>)
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("re" | "r" | <EMPTY>)
                     if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                        ++index;
                        // "e"
                        if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IgnoreRestOfLine
               match = ignoreRestOfLine$Rule();
            }
         }
      }
      if (match) {
         declareStatement$RuleMemoStart = startIndex;
         declareStatement$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            declareStatement$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DECLARE_STATEMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            declareStatement$RuleMemoFirstNode = currentNode;
            declareStatement$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         declareStatement$RuleMemoStart = startIndex;
         declareStatement$RuleMemoEnd = -1;
         declareStatement$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExitStmt : ("exit" TestNoAlpha OptionalSpacing)
   protected boolean exitStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (exitStmt$RuleMemoStart == index) {
         if (exitStmt$RuleMemoStart <= exitStmt$RuleMemoEnd) {
            index = exitStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (exitStmt$RuleMemoStart == exitStmt$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXIT_STMT, exitStmt$RuleMemoStart, exitStmt$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(exitStmt$RuleMemoFirstNode != null) {
                  lastNode.setSibling(exitStmt$RuleMemoFirstNode);
                  currentNode = exitStmt$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("exit" TestNoAlpha OptionalSpacing)
      // "exit"
      match = ignoreCaseStringMatcher("exit", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         exitStmt$RuleMemoStart = startIndex;
         exitStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            exitStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXIT_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            exitStmt$RuleMemoFirstNode = currentNode;
            exitStmt$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         exitStmt$RuleMemoStart = startIndex;
         exitStmt$RuleMemoEnd = -1;
         exitStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LoopStmt : ("loop" TestNoAlpha OptionalSpacing)
   protected boolean loopStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (loopStmt$RuleMemoStart == index) {
         if (loopStmt$RuleMemoStart <= loopStmt$RuleMemoEnd) {
            index = loopStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (loopStmt$RuleMemoStart == loopStmt$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOOP_STMT, loopStmt$RuleMemoStart, loopStmt$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(loopStmt$RuleMemoFirstNode != null) {
                  lastNode.setSibling(loopStmt$RuleMemoFirstNode);
                  currentNode = loopStmt$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("loop" TestNoAlpha OptionalSpacing)
      // "loop"
      match = ignoreCaseStringMatcher("loop", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         loopStmt$RuleMemoStart = startIndex;
         loopStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            loopStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOOP_STMT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            loopStmt$RuleMemoFirstNode = currentNode;
            loopStmt$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         loopStmt$RuleMemoStart = startIndex;
         loopStmt$RuleMemoEnd = -1;
         loopStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Directive : (IncludeDirective | DefineDirective | TranslateDirective | XTranslateDirective | XCommandDirective | CommandDirective | IfDefDirective | IfDirective | IfNDefDirective | ElseDirective | EndIfDirective | PragmaDirective | UndefDirective | StdoutDirective | ErrorDirective | LineDirective)
   protected boolean directive$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (directive$RuleMemoStart == index) {
         if (directive$RuleMemoStart <= directive$RuleMemoEnd) {
            index = directive$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (directive$RuleMemoStart == directive$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIRECTIVE, directive$RuleMemoStart, directive$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(directive$RuleMemoFirstNode != null) {
                  lastNode.setSibling(directive$RuleMemoFirstNode);
                  currentNode = directive$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IncludeDirective | DefineDirective | TranslateDirective | XTranslateDirective | XCommandDirective | CommandDirective | IfDefDirective | IfDirective | IfNDefDirective | ElseDirective | EndIfDirective | PragmaDirective | UndefDirective | StdoutDirective | ErrorDirective | LineDirective)
      switch(buffer.getChar(index)) {
         case '#':
            // IncludeDirective
            match = includeDirective$Rule();
            if (! match) {
               // DefineDirective
               match = defineDirective$Rule();
               if (! match) {
                  // TranslateDirective
                  match = translateDirective$Rule();
                  if (! match) {
                     // XTranslateDirective
                     match = xTranslateDirective$Rule();
                     if (! match) {
                        // XCommandDirective
                        match = xCommandDirective$Rule();
                        if (! match) {
                           // CommandDirective
                           match = commandDirective$Rule();
                           if (! match) {
                              // IfDefDirective
                              match = ifDefDirective$Rule();
                              if (! match) {
                                 // IfDirective
                                 match = ifDirective$Rule();
                                 if (! match) {
                                    // IfNDefDirective
                                    match = ifNDefDirective$Rule();
                                    if (! match) {
                                       // ElseDirective
                                       match = elseDirective$Rule();
                                       if (! match) {
                                          // EndIfDirective
                                          match = endIfDirective$Rule();
                                          if (! match) {
                                             // PragmaDirective
                                             match = pragmaDirective$Rule();
                                             if (! match) {
                                                // UndefDirective
                                                match = undefDirective$Rule();
                                                if (! match) {
                                                   // StdoutDirective
                                                   match = stdoutDirective$Rule();
                                                   if (! match) {
                                                      // ErrorDirective
                                                      match = errorDirective$Rule();
                                                      if (! match) {
                                                         // LineDirective
                                                         match = lineDirective$Rule();
                                                      }
                                                   }
                                                }
                                             }
                                          }
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         directive$RuleMemoStart = startIndex;
         directive$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            directive$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            directive$RuleMemoFirstNode = currentNode;
            directive$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         directive$RuleMemoStart = startIndex;
         directive$RuleMemoEnd = -1;
         directive$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineDirective : ('#' OptionalSpacing "line" TestNoAlpha OptionalSpacing NumberLiteral StringLiteral)
   protected boolean lineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (lineDirective$RuleMemoStart == index) {
         if (lineDirective$RuleMemoStart <= lineDirective$RuleMemoEnd) {
            index = lineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (lineDirective$RuleMemoStart == lineDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_DIRECTIVE, lineDirective$RuleMemoStart, lineDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(lineDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(lineDirective$RuleMemoFirstNode);
                  currentNode = lineDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "line" TestNoAlpha OptionalSpacing NumberLiteral StringLiteral)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "line"
            match = ignoreCaseStringMatcher("line", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // NumberLiteral
                     match = numberLiteral$Rule();
                     if (match) {
                        // StringLiteral
                        match = stringLiteral$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            lineDirective$RuleMemoFirstNode = currentNode;
            lineDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         lineDirective$RuleMemoStart = startIndex;
         lineDirective$RuleMemoEnd = -1;
         lineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IncludeDirective : ('#' OptionalSpacing "include" TestNoAlpha OptionalSpacing StringLiteral)
   protected boolean includeDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (includeDirective$RuleMemoStart == index) {
         if (includeDirective$RuleMemoStart <= includeDirective$RuleMemoEnd) {
            index = includeDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (includeDirective$RuleMemoStart == includeDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.INCLUDE_DIRECTIVE, includeDirective$RuleMemoStart, includeDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(includeDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(includeDirective$RuleMemoFirstNode);
                  currentNode = includeDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "include" TestNoAlpha OptionalSpacing StringLiteral)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "include"
            match = ignoreCaseStringMatcher("include", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // StringLiteral
                     match = stringLiteral$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            includeDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INCLUDE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            includeDirective$RuleMemoFirstNode = currentNode;
            includeDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         includeDirective$RuleMemoStart = startIndex;
         includeDirective$RuleMemoEnd = -1;
         includeDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DefineDirective : ('#' OptionalSpacing "define" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean defineDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (defineDirective$RuleMemoStart == index) {
         if (defineDirective$RuleMemoStart <= defineDirective$RuleMemoEnd) {
            index = defineDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (defineDirective$RuleMemoStart == defineDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFINE_DIRECTIVE, defineDirective$RuleMemoStart, defineDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(defineDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(defineDirective$RuleMemoFirstNode);
                  currentNode = defineDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "define" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "define"
            match = ignoreCaseStringMatcher("define", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            defineDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DEFINE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            defineDirective$RuleMemoFirstNode = currentNode;
            defineDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         defineDirective$RuleMemoStart = startIndex;
         defineDirective$RuleMemoEnd = -1;
         defineDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TranslateDirective : ('#' OptionalSpacing "translate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean translateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (translateDirective$RuleMemoStart == index) {
         if (translateDirective$RuleMemoStart <= translateDirective$RuleMemoEnd) {
            index = translateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (translateDirective$RuleMemoStart == translateDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRANSLATE_DIRECTIVE, translateDirective$RuleMemoStart, translateDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(translateDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(translateDirective$RuleMemoFirstNode);
                  currentNode = translateDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "translate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "translate"
            match = ignoreCaseStringMatcher("translate", 9);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            translateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            translateDirective$RuleMemoFirstNode = currentNode;
            translateDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         translateDirective$RuleMemoStart = startIndex;
         translateDirective$RuleMemoEnd = -1;
         translateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XTranslateDirective : ('#' OptionalSpacing "xtranslate" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xTranslateDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xTranslateDirective$RuleMemoStart == index) {
         if (xTranslateDirective$RuleMemoStart <= xTranslateDirective$RuleMemoEnd) {
            index = xTranslateDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (xTranslateDirective$RuleMemoStart == xTranslateDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.XTRANSLATE_DIRECTIVE, xTranslateDirective$RuleMemoStart, xTranslateDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(xTranslateDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(xTranslateDirective$RuleMemoFirstNode);
                  currentNode = xTranslateDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xtranslate" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xtranslate"
            match = ignoreCaseStringMatcher("xtranslate", 10);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xTranslateDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XTRANSLATE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xTranslateDirective$RuleMemoFirstNode = currentNode;
            xTranslateDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         xTranslateDirective$RuleMemoStart = startIndex;
         xTranslateDirective$RuleMemoEnd = -1;
         xTranslateDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //XCommandDirective : ('#' OptionalSpacing "xcommand" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean xCommandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (xCommandDirective$RuleMemoStart == index) {
         if (xCommandDirective$RuleMemoStart <= xCommandDirective$RuleMemoEnd) {
            index = xCommandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (xCommandDirective$RuleMemoStart == xCommandDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.XCOMMAND_DIRECTIVE, xCommandDirective$RuleMemoStart, xCommandDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(xCommandDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(xCommandDirective$RuleMemoFirstNode);
                  currentNode = xCommandDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "xcommand" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "xcommand"
            match = ignoreCaseStringMatcher("xcommand", 8);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            xCommandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.XCOMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            xCommandDirective$RuleMemoFirstNode = currentNode;
            xCommandDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         xCommandDirective$RuleMemoStart = startIndex;
         xCommandDirective$RuleMemoEnd = -1;
         xCommandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommandDirective : ('#' OptionalSpacing "command" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean commandDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commandDirective$RuleMemoStart == index) {
         if (commandDirective$RuleMemoStart <= commandDirective$RuleMemoEnd) {
            index = commandDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (commandDirective$RuleMemoStart == commandDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMAND_DIRECTIVE, commandDirective$RuleMemoStart, commandDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(commandDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(commandDirective$RuleMemoFirstNode);
                  currentNode = commandDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "command" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "command"
            match = ignoreCaseStringMatcher("command", 7);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commandDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMAND_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commandDirective$RuleMemoFirstNode = currentNode;
            commandDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         commandDirective$RuleMemoStart = startIndex;
         commandDirective$RuleMemoEnd = -1;
         commandDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDefDirective : ('#' OptionalSpacing "ifdef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifDefDirective$RuleMemoStart == index) {
         if (ifDefDirective$RuleMemoStart <= ifDefDirective$RuleMemoEnd) {
            index = ifDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifDefDirective$RuleMemoStart == ifDefDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DEF_DIRECTIVE, ifDefDirective$RuleMemoStart, ifDefDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifDefDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifDefDirective$RuleMemoFirstNode);
                  currentNode = ifDefDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ifdef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ifdef"
            match = ignoreCaseStringMatcher("ifdef", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifDefDirective$RuleMemoFirstNode = currentNode;
            ifDefDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifDefDirective$RuleMemoStart = startIndex;
         ifDefDirective$RuleMemoEnd = -1;
         ifDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfDirective : ('#' OptionalSpacing "if" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifDirective$RuleMemoStart == index) {
         if (ifDirective$RuleMemoStart <= ifDirective$RuleMemoEnd) {
            index = ifDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifDirective$RuleMemoStart == ifDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DIRECTIVE, ifDirective$RuleMemoStart, ifDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifDirective$RuleMemoFirstNode);
                  currentNode = ifDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "if" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "if"
            match = ignoreCaseStringMatcher("if", 2);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifDirective$RuleMemoStart = startIndex;
         ifDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifDirective$RuleMemoFirstNode = currentNode;
            ifDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifDirective$RuleMemoStart = startIndex;
         ifDirective$RuleMemoEnd = -1;
         ifDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfNDefDirective : ('#' OptionalSpacing "ifndef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean ifNDefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifNDefDirective$RuleMemoStart == index) {
         if (ifNDefDirective$RuleMemoStart <= ifNDefDirective$RuleMemoEnd) {
            index = ifNDefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifNDefDirective$RuleMemoStart == ifNDefDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_NDEF_DIRECTIVE, ifNDefDirective$RuleMemoStart, ifNDefDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifNDefDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifNDefDirective$RuleMemoFirstNode);
                  currentNode = ifNDefDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "ifndef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "ifndef"
            match = ignoreCaseStringMatcher("ifndef", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifNDefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_NDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifNDefDirective$RuleMemoFirstNode = currentNode;
            ifNDefDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifNDefDirective$RuleMemoStart = startIndex;
         ifNDefDirective$RuleMemoEnd = -1;
         ifNDefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseDirective : ('#' OptionalSpacing "else" TestNoAlpha OptionalSpacing)
   protected boolean elseDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseDirective$RuleMemoStart == index) {
         if (elseDirective$RuleMemoStart <= elseDirective$RuleMemoEnd) {
            index = elseDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (elseDirective$RuleMemoStart == elseDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_DIRECTIVE, elseDirective$RuleMemoStart, elseDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(elseDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(elseDirective$RuleMemoFirstNode);
                  currentNode = elseDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "else" TestNoAlpha OptionalSpacing)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "else"
            match = ignoreCaseStringMatcher("else", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseDirective$RuleMemoFirstNode = currentNode;
            elseDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         elseDirective$RuleMemoStart = startIndex;
         elseDirective$RuleMemoEnd = -1;
         elseDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndIfDirective : ('#' OptionalSpacing "endif" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
   protected boolean endIfDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endIfDirective$RuleMemoStart == index) {
         if (endIfDirective$RuleMemoStart <= endIfDirective$RuleMemoEnd) {
            index = endIfDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (endIfDirective$RuleMemoStart == endIfDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_IF_DIRECTIVE, endIfDirective$RuleMemoStart, endIfDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(endIfDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(endIfDirective$RuleMemoFirstNode);
                  currentNode = endIfDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "endif" TestNoAlpha OptionalSpacing IgnoreRestOfLine)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "endif"
            match = ignoreCaseStringMatcher("endif", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // IgnoreRestOfLine
                     match = ignoreRestOfLine$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endIfDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_IF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endIfDirective$RuleMemoFirstNode = currentNode;
            endIfDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         endIfDirective$RuleMemoStart = startIndex;
         endIfDirective$RuleMemoEnd = -1;
         endIfDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PragmaDirective : ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean pragmaDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (pragmaDirective$RuleMemoStart == index) {
         if (pragmaDirective$RuleMemoStart <= pragmaDirective$RuleMemoEnd) {
            index = pragmaDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (pragmaDirective$RuleMemoStart == pragmaDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRAGMA_DIRECTIVE, pragmaDirective$RuleMemoStart, pragmaDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(pragmaDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(pragmaDirective$RuleMemoFirstNode);
                  currentNode = pragmaDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "pragma"
            match = ignoreCaseStringMatcher("pragma", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         pragmaDirective$RuleMemoStart = startIndex;
         pragmaDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            pragmaDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRAGMA_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            pragmaDirective$RuleMemoFirstNode = currentNode;
            pragmaDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         pragmaDirective$RuleMemoStart = startIndex;
         pragmaDirective$RuleMemoEnd = -1;
         pragmaDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UndefDirective : ('#' OptionalSpacing "undef" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean undefDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (undefDirective$RuleMemoStart == index) {
         if (undefDirective$RuleMemoStart <= undefDirective$RuleMemoEnd) {
            index = undefDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (undefDirective$RuleMemoStart == undefDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNDEF_DIRECTIVE, undefDirective$RuleMemoStart, undefDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(undefDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(undefDirective$RuleMemoFirstNode);
                  currentNode = undefDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "undef" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "undef"
            match = ignoreCaseStringMatcher("undef", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            undefDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNDEF_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            undefDirective$RuleMemoFirstNode = currentNode;
            undefDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         undefDirective$RuleMemoStart = startIndex;
         undefDirective$RuleMemoEnd = -1;
         undefDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StdoutDirective : ('#' OptionalSpacing "stdout" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean stdoutDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (stdoutDirective$RuleMemoStart == index) {
         if (stdoutDirective$RuleMemoStart <= stdoutDirective$RuleMemoEnd) {
            index = stdoutDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (stdoutDirective$RuleMemoStart == stdoutDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.STDOUT_DIRECTIVE, stdoutDirective$RuleMemoStart, stdoutDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(stdoutDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(stdoutDirective$RuleMemoFirstNode);
                  currentNode = stdoutDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "stdout" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "stdout"
            match = ignoreCaseStringMatcher("stdout", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         stdoutDirective$RuleMemoStart = startIndex;
         stdoutDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stdoutDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STDOUT_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stdoutDirective$RuleMemoFirstNode = currentNode;
            stdoutDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         stdoutDirective$RuleMemoStart = startIndex;
         stdoutDirective$RuleMemoEnd = -1;
         stdoutDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ErrorDirective : ('#' OptionalSpacing "error" TestNoAlpha OptionalSpacing AnyToken*)
   protected boolean errorDirective$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (errorDirective$RuleMemoStart == index) {
         if (errorDirective$RuleMemoStart <= errorDirective$RuleMemoEnd) {
            index = errorDirective$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (errorDirective$RuleMemoStart == errorDirective$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERROR_DIRECTIVE, errorDirective$RuleMemoStart, errorDirective$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(errorDirective$RuleMemoFirstNode != null) {
                  lastNode.setSibling(errorDirective$RuleMemoFirstNode);
                  currentNode = errorDirective$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('#' OptionalSpacing "error" TestNoAlpha OptionalSpacing AnyToken*)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "error"
            match = ignoreCaseStringMatcher("error", 5);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyToken*
                     do {
                        // AnyToken
                        match = anyToken$Rule();
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            errorDirective$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERROR_DIRECTIVE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            errorDirective$RuleMemoFirstNode = currentNode;
            errorDirective$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         errorDirective$RuleMemoStart = startIndex;
         errorDirective$RuleMemoEnd = -1;
         errorDirective$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyToken : (AnyIdentifier | Spacing | Separator | StringLiteral | LogicalLiteral | NumberLiteral | TimeLiteral | DateTimeLiteral | (';' OptionalSpacing) | BlockComment | LineComment)
   protected boolean anyToken$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyToken$RuleMemoStart == index) {
         if (anyToken$RuleMemoStart <= anyToken$RuleMemoEnd) {
            index = anyToken$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (anyToken$RuleMemoStart == anyToken$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_TOKEN, anyToken$RuleMemoStart, anyToken$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(anyToken$RuleMemoFirstNode != null) {
                  lastNode.setSibling(anyToken$RuleMemoFirstNode);
                  currentNode = anyToken$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier | Spacing | Separator | StringLiteral | LogicalLiteral | NumberLiteral | TimeLiteral | DateTimeLiteral | (';' OptionalSpacing) | BlockComment | LineComment)
      switch(buffer.getChar(index)) {
         case '@':
         case '!':
         case '#':
         case '$':
         case '%':
         case '(':
         case ')':
         case '*':
         case '+':
         case ',':
         case '-':
         case ':':
         case '<':
         case '\\':
         case '|':
         case '=':
         case ']':
         case '}':
         case '>':
         case '^':
         case '~':
         case '?':
            // Separator
            match = separator$Rule();
            break;
         case '.':
            // Separator
            match = separator$Rule();
            if (! match) {
               // LogicalLiteral
               match = logicalLiteral$Rule();
               if (! match) {
                  // NumberLiteral
                  match = numberLiteral$Rule();
               }
            }
            break;
         case '/':
            // Spacing
            match = spacing$Rule();
            if (! match) {
               // Separator
               match = separator$Rule();
               if (! match) {
                  // BlockComment
                  match = blockComment$Rule();
                  if (! match) {
                     // LineComment
                     match = lineComment$Rule();
                  }
               }
            }
            break;
         case '0':
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               // TimeLiteral
               match = timeLiteral$Rule();
               if (! match) {
                  // DateTimeLiteral
                  match = dateTimeLiteral$Rule();
               }
            }
            break;
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               // TimeLiteral
               match = timeLiteral$Rule();
            }
            break;
         case ';':
            // Spacing
            match = spacing$Rule();
            if (! match) {
               // (';' OptionalSpacing)
               // ';'
               match = charMatcher(';');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         case '[':
            // Separator
            match = separator$Rule();
            if (! match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
            break;
         case '{':
            // Separator
            match = separator$Rule();
            if (! match) {
               // DateTimeLiteral
               match = dateTimeLiteral$Rule();
            }
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // AnyIdentifier
            match = anyIdentifier$Rule();
            break;
         case '\"':
         case '\'':
            // StringLiteral
            match = stringLiteral$Rule();
            break;
         case 'D':
         case 'd':
            // AnyIdentifier
            match = anyIdentifier$Rule();
            if (! match) {
               // DateTimeLiteral
               match = dateTimeLiteral$Rule();
            }
            break;
         case 'E':
         case 'e':
            // AnyIdentifier
            match = anyIdentifier$Rule();
            if (! match) {
               // StringLiteral
               match = stringLiteral$Rule();
            }
            break;
         case '&':
            // Spacing
            match = spacing$Rule();
            if (! match) {
               // Separator
               match = separator$Rule();
               if (! match) {
                  // LineComment
                  match = lineComment$Rule();
               }
            }
            break;
         case ' ':
         case '\t':
         case '\f':
            // Spacing
            match = spacing$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         anyToken$RuleMemoStart = startIndex;
         anyToken$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyToken$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_TOKEN, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyToken$RuleMemoFirstNode = currentNode;
            anyToken$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         anyToken$RuleMemoStart = startIndex;
         anyToken$RuleMemoEnd = -1;
         anyToken$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Separator : ((',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#') OptionalSpacing)
   protected boolean separator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (separator$RuleMemoStart == index) {
         if (separator$RuleMemoStart <= separator$RuleMemoEnd) {
            index = separator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (separator$RuleMemoStart == separator$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEPARATOR, separator$RuleMemoStart, separator$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(separator$RuleMemoFirstNode != null) {
                  lastNode.setSibling(separator$RuleMemoFirstNode);
                  currentNode = separator$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#') OptionalSpacing)
      // (',' | '[' | ']' | '(' | ')' | '=' | '>' | '<' | ':' | '.' | '@' | '|' | '+' | '-' | '*' | '/' | '%' | '^' | '~' | '&' | '!' | '$' | '\' | '{' | '}' | '?' | '#')
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case '+':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ',':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '-':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '.':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '/':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ':':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '{':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '<':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '|':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '=':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '}':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '>':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '~':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '?':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '@':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '[':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\\':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ']':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '^':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '!':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '#':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '$':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '%':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '&':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '(':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ')':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '*':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            separator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEPARATOR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            separator$RuleMemoFirstNode = currentNode;
            separator$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         separator$RuleMemoStart = startIndex;
         separator$RuleMemoEnd = -1;
         separator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CmdComplementation : (AnySimpleFunctionCall | UnknownIdentifier | PrimaryExpression | Separator)*
   protected boolean cmdComplementation$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (cmdComplementation$RuleMemoStart == index) {
         if (cmdComplementation$RuleMemoStart <= cmdComplementation$RuleMemoEnd) {
            index = cmdComplementation$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (cmdComplementation$RuleMemoStart == cmdComplementation$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CMD_COMPLEMENTATION, cmdComplementation$RuleMemoStart, cmdComplementation$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(cmdComplementation$RuleMemoFirstNode != null) {
                  lastNode.setSibling(cmdComplementation$RuleMemoFirstNode);
                  currentNode = cmdComplementation$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnySimpleFunctionCall | UnknownIdentifier | PrimaryExpression | Separator)*
      do {
         // (AnySimpleFunctionCall | UnknownIdentifier | PrimaryExpression | Separator)
         switch(buffer.getChar(index)) {
            case '!':
            case '&':
            case '(':
            case ':':
            case '+':
            case '[':
            case '{':
            case '-':
            case '.':
               // PrimaryExpression
               match = primaryExpression$Rule();
               if (! match) {
                  // Separator
                  match = separator$Rule();
               }
               break;
            case '@':
            case '#':
            case '$':
            case '%':
            case ')':
            case '*':
            case ',':
            case '/':
            case '<':
            case '\\':
            case '|':
            case '=':
            case ']':
            case '}':
            case '>':
            case '^':
            case '~':
            case '?':
               // Separator
               match = separator$Rule();
               break;
            case '0':
            case '1':
            case '2':
            case '\"':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '\'':
            case '8':
            case '9':
               // PrimaryExpression
               match = primaryExpression$Rule();
               break;
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
               // AnySimpleFunctionCall
               match = anySimpleFunctionCall$Rule();
               if (! match) {
                  // UnknownIdentifier
                  match = unknownIdentifier$Rule();
                  if (! match) {
                     // PrimaryExpression
                     match = primaryExpression$Rule();
                  }
               }
               break;
            default:
               match = false;
         }
      } while(match);
      cmdComplementation$RuleMemoStart = startIndex;
      cmdComplementation$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         cmdComplementation$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.CMD_COMPLEMENTATION, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         cmdComplementation$RuleMemoFirstNode = currentNode;
         cmdComplementation$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //UnknownIdentifier : (UnknownIdentifierPattern OptionalSpacing)
   protected boolean unknownIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (unknownIdentifier$RuleMemoStart == index) {
         if (unknownIdentifier$RuleMemoStart <= unknownIdentifier$RuleMemoEnd) {
            index = unknownIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (unknownIdentifier$RuleMemoStart == unknownIdentifier$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, unknownIdentifier$RuleMemoStart, unknownIdentifier$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(unknownIdentifier$RuleMemoFirstNode != null) {
                  lastNode.setSibling(unknownIdentifier$RuleMemoFirstNode);
                  currentNode = unknownIdentifier$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UnknownIdentifierPattern OptionalSpacing)
      // UnknownIdentifierPattern
      match = unknownIdentifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         unknownIdentifier$RuleMemoStart = startIndex;
         unknownIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unknownIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unknownIdentifier$RuleMemoFirstNode = currentNode;
            unknownIdentifier$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         unknownIdentifier$RuleMemoStart = startIndex;
         unknownIdentifier$RuleMemoEnd = -1;
         unknownIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UnknownIdentifierPattern : (IdentifierPattern (('(' | '->') OptionalSpacing)!)
   protected boolean unknownIdentifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IdentifierPattern (('(' | '->') OptionalSpacing)!)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // (('(' | '->') OptionalSpacing)!
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         boolean lastAtomic_1 = currentRuleIsAtomic;
         // (('(' | '->') OptionalSpacing)
         // ('(' | '->')
         int startIndex_2 = index;
         switch(buffer.getChar(index)) {
            case '-':
               ++index;
               // '>'
               if (match = buffer.matchChar(index, '>')) {
                  ++index;
               }
               break;
            case '(':
               ++index;
               // <EMPTY>
               match = true;
               break;
            default:
               match = false;
         }
         if (! match) {
            index = startIndex_2;
         } else if(! currentRuleIsAtomic) {
            currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
            currentNode = currentNode.getSibling();
         }
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         currentRuleIsAtomic = lastAtomic_1;
         index = lastIndex_1;
         lastNode_1.setSibling(null);
         currentNode = lastNode_1;
         match = ! match;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNKNOWN_IDENTIFIER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginProducer : ("begin" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)? ("wait" TestNoAlpha OptionalSpacing)?)
   protected boolean beginProducer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginProducer$RuleMemoStart == index) {
         if (beginProducer$RuleMemoStart <= beginProducer$RuleMemoEnd) {
            index = beginProducer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (beginProducer$RuleMemoStart == beginProducer$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_PRODUCER, beginProducer$RuleMemoStart, beginProducer$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(beginProducer$RuleMemoFirstNode != null) {
                  lastNode.setSibling(beginProducer$RuleMemoFirstNode);
                  currentNode = beginProducer$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("begin" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)? ("wait" TestNoAlpha OptionalSpacing)?)
      // "begin"
      match = ignoreCaseStringMatcher("begin", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "producer"
               match = ignoreCaseStringMatcher("producer", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)?
                        // ("transaction" TestNoAlpha OptionalSpacing IntegerNumber)
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // "transaction"
                        match = ignoreCaseStringMatcher("transaction", 11);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (match) {
                                 // IntegerNumber
                                 match = integerNumber$Rule();
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              } else {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                              }
                           } else {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                           }
                        }
                        match = true;
                        // ("wait" TestNoAlpha OptionalSpacing)?
                        // ("wait" TestNoAlpha OptionalSpacing)
                        Node lastNode_2 = currentNode;
                        int lastIndex_2 = index;
                        // "wait"
                        match = ignoreCaseStringMatcher("wait", 4);
                        if (match) {
                           // TestNoAlpha
                           match = testNoAlpha$Rule();
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                              }
                           } else {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                           }
                        }
                        match = true;
                     }
                  }
               }
            }
         }
      }
      if (match) {
         beginProducer$RuleMemoStart = startIndex;
         beginProducer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginProducer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_PRODUCER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginProducer$RuleMemoFirstNode = currentNode;
            beginProducer$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         beginProducer$RuleMemoStart = startIndex;
         beginProducer$RuleMemoEnd = -1;
         beginProducer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndProducer : ("end" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing)
   protected boolean endProducer$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endProducer$RuleMemoStart == index) {
         if (endProducer$RuleMemoStart <= endProducer$RuleMemoEnd) {
            index = endProducer$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (endProducer$RuleMemoStart == endProducer$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_PRODUCER, endProducer$RuleMemoStart, endProducer$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(endProducer$RuleMemoFirstNode != null) {
                  lastNode.setSibling(endProducer$RuleMemoFirstNode);
                  currentNode = endProducer$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "producer" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "producer"
               match = ignoreCaseStringMatcher("producer", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         endProducer$RuleMemoStart = startIndex;
         endProducer$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endProducer$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_PRODUCER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endProducer$RuleMemoFirstNode = currentNode;
            endProducer$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         endProducer$RuleMemoStart = startIndex;
         endProducer$RuleMemoEnd = -1;
         endProducer$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginTransaction : ("begin" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean beginTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginTransaction$RuleMemoStart == index) {
         if (beginTransaction$RuleMemoStart <= beginTransaction$RuleMemoEnd) {
            index = beginTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (beginTransaction$RuleMemoStart == beginTransaction$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_TRANSACTION, beginTransaction$RuleMemoStart, beginTransaction$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(beginTransaction$RuleMemoFirstNode != null) {
                  lastNode.setSibling(beginTransaction$RuleMemoFirstNode);
                  currentNode = beginTransaction$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("begin" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "begin"
      match = ignoreCaseStringMatcher("begin", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         beginTransaction$RuleMemoStart = startIndex;
         beginTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginTransaction$RuleMemoFirstNode = currentNode;
            beginTransaction$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         beginTransaction$RuleMemoStart = startIndex;
         beginTransaction$RuleMemoEnd = -1;
         beginTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommitTransaction : ("commit" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean commitTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commitTransaction$RuleMemoStart == index) {
         if (commitTransaction$RuleMemoStart <= commitTransaction$RuleMemoEnd) {
            index = commitTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (commitTransaction$RuleMemoStart == commitTransaction$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_TRANSACTION, commitTransaction$RuleMemoStart, commitTransaction$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(commitTransaction$RuleMemoFirstNode != null) {
                  lastNode.setSibling(commitTransaction$RuleMemoFirstNode);
                  currentNode = commitTransaction$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("commit" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "commit"
      match = ignoreCaseStringMatcher("commit", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         commitTransaction$RuleMemoStart = startIndex;
         commitTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commitTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commitTransaction$RuleMemoFirstNode = currentNode;
            commitTransaction$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         commitTransaction$RuleMemoStart = startIndex;
         commitTransaction$RuleMemoEnd = -1;
         commitTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RollbackTransaction : ("rollback" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
   protected boolean rollbackTransaction$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (rollbackTransaction$RuleMemoStart == index) {
         if (rollbackTransaction$RuleMemoStart <= rollbackTransaction$RuleMemoEnd) {
            index = rollbackTransaction$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (rollbackTransaction$RuleMemoStart == rollbackTransaction$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ROLLBACK_TRANSACTION, rollbackTransaction$RuleMemoStart, rollbackTransaction$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(rollbackTransaction$RuleMemoFirstNode != null) {
                  lastNode.setSibling(rollbackTransaction$RuleMemoFirstNode);
                  currentNode = rollbackTransaction$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("rollback" TestNoAlpha OptionalSpacing "transaction" TestNoAlpha OptionalSpacing)
      // "rollback"
      match = ignoreCaseStringMatcher("rollback", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "transaction"
               match = ignoreCaseStringMatcher("transaction", 11);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         rollbackTransaction$RuleMemoStart = startIndex;
         rollbackTransaction$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            rollbackTransaction$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ROLLBACK_TRANSACTION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            rollbackTransaction$RuleMemoFirstNode = currentNode;
            rollbackTransaction$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         rollbackTransaction$RuleMemoStart = startIndex;
         rollbackTransaction$RuleMemoEnd = -1;
         rollbackTransaction$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAs : (UseAsDatabase UseAsCommand UseAsParams UseAlias UseAsOptions)
   protected boolean useAs$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAs$RuleMemoStart == index) {
         if (useAs$RuleMemoStart <= useAs$RuleMemoEnd) {
            index = useAs$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (useAs$RuleMemoStart == useAs$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS, useAs$RuleMemoStart, useAs$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(useAs$RuleMemoFirstNode != null) {
                  lastNode.setSibling(useAs$RuleMemoFirstNode);
                  currentNode = useAs$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UseAsDatabase UseAsCommand UseAsParams UseAlias UseAsOptions)
      // UseAsDatabase
      match = useAsDatabase$Rule();
      if (match) {
         // UseAsCommand
         match = useAsCommand$Rule();
         if (match) {
            // UseAsParams
            match = useAsParams$Rule();
            if (match) {
               // UseAlias
               match = useAlias$Rule();
               if (match) {
                  // UseAsOptions
                  match = useAsOptions$Rule();
               }
            }
         }
      }
      if (match) {
         useAs$RuleMemoStart = startIndex;
         useAs$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useAs$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useAs$RuleMemoFirstNode = currentNode;
            useAs$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         useAs$RuleMemoStart = startIndex;
         useAs$RuleMemoEnd = -1;
         useAs$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsDatabase : ("use" TestNoAlpha OptionalSpacing AliasIdentifier)
   protected boolean useAsDatabase$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("use" TestNoAlpha OptionalSpacing AliasIdentifier)
      // "use"
      match = ignoreCaseStringMatcher("use", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AliasIdentifier
               match = aliasIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_DATABASE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsCommand : ("as" TestNoAlpha OptionalSpacing UseAsType Expression)
   protected boolean useAsCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing UseAsType Expression)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // UseAsType
               match = useAsType$Rule();
               if (match) {
                  // Expression
                  match = expression$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_COMMAND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsType : (("fun" | "proc") TestNoAlpha OptionalSpacing)?
   protected boolean useAsType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("fun" | "proc") TestNoAlpha OptionalSpacing)?
      // (("fun" | "proc") TestNoAlpha OptionalSpacing)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // ("fun" | "proc")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F':
            ++index;
            // "un"
            if (match = ignoreCaseStringTest("un", 2)) {
               index += 2;
            }
            break;
         case 'p':
         case 'P':
            ++index;
            // "roc"
            if (match = ignoreCaseStringTest("roc", 3)) {
               index += 3;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_TYPE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseAsParams : ("with" TestNoAlpha OptionalSpacing Expression)?
   protected boolean useAsParams$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing Expression)?
      // ("with" TestNoAlpha OptionalSpacing Expression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PARAMS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseAlias : ("alias" TestNoAlpha OptionalSpacing AliasIdentifier)?
   protected boolean useAlias$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAlias$RuleMemoStart == index) {
         if (useAlias$RuleMemoStart <= useAlias$RuleMemoEnd) {
            index = useAlias$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (useAlias$RuleMemoStart == useAlias$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_ALIAS, useAlias$RuleMemoStart, useAlias$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(useAlias$RuleMemoFirstNode != null) {
                  lastNode.setSibling(useAlias$RuleMemoFirstNode);
                  currentNode = useAlias$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("alias" TestNoAlpha OptionalSpacing AliasIdentifier)?
      // ("alias" TestNoAlpha OptionalSpacing AliasIdentifier)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "alias"
      match = ignoreCaseStringMatcher("alias", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AliasIdentifier
               match = aliasIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      useAlias$RuleMemoStart = startIndex;
      useAlias$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         useAlias$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_ALIAS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         useAlias$RuleMemoFirstNode = currentNode;
         useAlias$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //UseAsPrecision : ("precision" TestNoAlpha OptionalSpacing Expression)
   protected boolean useAsPrecision$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useAsPrecision$RuleMemoStart == index) {
         if (useAsPrecision$RuleMemoStart <= useAsPrecision$RuleMemoEnd) {
            index = useAsPrecision$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (useAsPrecision$RuleMemoStart == useAsPrecision$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PRECISION, useAsPrecision$RuleMemoStart, useAsPrecision$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(useAsPrecision$RuleMemoFirstNode != null) {
                  lastNode.setSibling(useAsPrecision$RuleMemoFirstNode);
                  currentNode = useAsPrecision$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("precision" TestNoAlpha OptionalSpacing Expression)
      // "precision"
      match = ignoreCaseStringMatcher("precision", 9);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         useAsPrecision$RuleMemoStart = startIndex;
         useAsPrecision$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useAsPrecision$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_PRECISION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useAsPrecision$RuleMemoFirstNode = currentNode;
            useAsPrecision$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         useAsPrecision$RuleMemoStart = startIndex;
         useAsPrecision$RuleMemoEnd = -1;
         useAsPrecision$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAsOptions : (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))*
   protected boolean useAsOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))*
      do {
         // (("new" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseAsPrecision | ("scrollable" TestNoAlpha OptionalSpacing) | ("permanent" TestNoAlpha OptionalSpacing) | ("overwrite" TestNoAlpha OptionalSpacing) | ("c1logical" TestNoAlpha OptionalSpacing))
         switch(buffer.getChar(index)) {
            case 'n':
            case 'N':
               // ("new" TestNoAlpha OptionalSpacing)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // "new"
               match = ignoreCaseStringMatcher("new", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               }
               break;
            case 'o':
            case 'O':
               // ("overwrite" TestNoAlpha OptionalSpacing)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // "overwrite"
               match = ignoreCaseStringMatcher("overwrite", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
               break;
            case 'p':
            case 'P':
               // UseAsPrecision
               match = useAsPrecision$Rule();
               if (! match) {
                  // ("permanent" TestNoAlpha OptionalSpacing)
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // "permanent"
                  match = ignoreCaseStringMatcher("permanent", 9);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (! match) {
                           index = lastIndex_3;
                           lastNode_3.setSibling(null);
                           currentNode = lastNode_3;
                        }
                     } else {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                     }
                  }
               }
               break;
            case 'r':
            case 'R':
               // ("readonly" TestNoAlpha OptionalSpacing)
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // "readonly"
               match = ignoreCaseStringMatcher("readonly", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_4;
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                     }
                  } else {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                  }
               }
               break;
            case 's':
            case 'S':
               // ("shared" TestNoAlpha OptionalSpacing)
               Node lastNode_5 = currentNode;
               int lastIndex_5 = index;
               // "shared"
               match = ignoreCaseStringMatcher("shared", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_5;
                        lastNode_5.setSibling(null);
                        currentNode = lastNode_5;
                     }
                  } else {
                     index = lastIndex_5;
                     lastNode_5.setSibling(null);
                  }
               }
               if (! match) {
                  // ("scrollable" TestNoAlpha OptionalSpacing)
                  Node lastNode_6 = currentNode;
                  int lastIndex_6 = index;
                  // "scrollable"
                  match = ignoreCaseStringMatcher("scrollable", 10);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (! match) {
                           index = lastIndex_6;
                           lastNode_6.setSibling(null);
                           currentNode = lastNode_6;
                        }
                     } else {
                        index = lastIndex_6;
                        lastNode_6.setSibling(null);
                     }
                  }
               }
               break;
            case 'c':
            case 'C':
               // ("c1logical" TestNoAlpha OptionalSpacing)
               Node lastNode_7 = currentNode;
               int lastIndex_7 = index;
               // "c1logical"
               match = ignoreCaseStringMatcher("c1logical", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_7;
                        lastNode_7.setSibling(null);
                        currentNode = lastNode_7;
                     }
                  } else {
                     index = lastIndex_7;
                     lastNode_7.setSibling(null);
                  }
               }
               break;
            case 'e':
            case 'E':
               // ("exclusive" TestNoAlpha OptionalSpacing)
               Node lastNode_8 = currentNode;
               int lastIndex_8 = index;
               // "exclusive"
               match = ignoreCaseStringMatcher("exclusive", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_8;
                        lastNode_8.setSibling(null);
                        currentNode = lastNode_8;
                     }
                  } else {
                     index = lastIndex_8;
                     lastNode_8.setSibling(null);
                  }
               }
               break;
            default:
               match = false;
         }
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AS_OPTIONS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseArea : (UseDatabase UseAreaVia UseAlias UseOptions UseIndexes)
   protected boolean useArea$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useArea$RuleMemoStart == index) {
         if (useArea$RuleMemoStart <= useArea$RuleMemoEnd) {
            index = useArea$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (useArea$RuleMemoStart == useArea$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA, useArea$RuleMemoStart, useArea$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(useArea$RuleMemoFirstNode != null) {
                  lastNode.setSibling(useArea$RuleMemoFirstNode);
                  currentNode = useArea$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (UseDatabase UseAreaVia UseAlias UseOptions UseIndexes)
      // UseDatabase
      match = useDatabase$Rule();
      if (match) {
         // UseAreaVia
         match = useAreaVia$Rule();
         if (match) {
            // UseAlias
            match = useAlias$Rule();
            if (match) {
               // UseOptions
               match = useOptions$Rule();
               if (match) {
                  // UseIndexes
                  match = useIndexes$Rule();
               }
            }
         }
      }
      if (match) {
         useArea$RuleMemoStart = startIndex;
         useArea$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useArea$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useArea$RuleMemoFirstNode = currentNode;
            useArea$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         useArea$RuleMemoStart = startIndex;
         useArea$RuleMemoEnd = -1;
         useArea$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseDatabase : ("use" TestNoAlpha OptionalSpacing AliasIdentifier)
   protected boolean useDatabase$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("use" TestNoAlpha OptionalSpacing AliasIdentifier)
      // "use"
      match = ignoreCaseStringMatcher("use", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AliasIdentifier
               match = aliasIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_DATABASE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseAreaVia : ("via" TestNoAlpha OptionalSpacing Expression)?
   protected boolean useAreaVia$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("via" TestNoAlpha OptionalSpacing Expression)?
      // ("via" TestNoAlpha OptionalSpacing Expression)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "via"
      match = ignoreCaseStringMatcher("via", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_AREA_VIA, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseCodepage : ("codepage" TestNoAlpha OptionalSpacing Expression)
   protected boolean useCodepage$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (useCodepage$RuleMemoStart == index) {
         if (useCodepage$RuleMemoStart <= useCodepage$RuleMemoEnd) {
            index = useCodepage$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (useCodepage$RuleMemoStart == useCodepage$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_CODEPAGE, useCodepage$RuleMemoStart, useCodepage$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(useCodepage$RuleMemoFirstNode != null) {
                  lastNode.setSibling(useCodepage$RuleMemoFirstNode);
                  currentNode = useCodepage$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("codepage" TestNoAlpha OptionalSpacing Expression)
      // "codepage"
      match = ignoreCaseStringMatcher("codepage", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         useCodepage$RuleMemoStart = startIndex;
         useCodepage$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            useCodepage$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_CODEPAGE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            useCodepage$RuleMemoFirstNode = currentNode;
            useCodepage$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         useCodepage$RuleMemoStart = startIndex;
         useCodepage$RuleMemoEnd = -1;
         useCodepage$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UseOptions : (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)*
   protected boolean useOptions$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)*
      do {
         // (("new" TestNoAlpha OptionalSpacing) | ("exclusive" TestNoAlpha OptionalSpacing) | ("shared" TestNoAlpha OptionalSpacing) | ("readonly" TestNoAlpha OptionalSpacing) | UseCodepage)
         switch(buffer.getChar(index)) {
            case 'n':
            case 'N':
               // ("new" TestNoAlpha OptionalSpacing)
               Node lastNode_1 = currentNode;
               int lastIndex_1 = index;
               // "new"
               match = ignoreCaseStringMatcher("new", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  } else {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                  }
               }
               break;
            case 'r':
            case 'R':
               // ("readonly" TestNoAlpha OptionalSpacing)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // "readonly"
               match = ignoreCaseStringMatcher("readonly", 8);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
               break;
            case 's':
            case 'S':
               // ("shared" TestNoAlpha OptionalSpacing)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // "shared"
               match = ignoreCaseStringMatcher("shared", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                  } else {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                  }
               }
               break;
            case 'c':
            case 'C':
               // UseCodepage
               match = useCodepage$Rule();
               break;
            case 'e':
            case 'E':
               // ("exclusive" TestNoAlpha OptionalSpacing)
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // "exclusive"
               match = ignoreCaseStringMatcher("exclusive", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (! match) {
                        index = lastIndex_4;
                        lastNode_4.setSibling(null);
                        currentNode = lastNode_4;
                     }
                  } else {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                  }
               }
               break;
            default:
               match = false;
         }
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_OPTIONS, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //UseIndexes : ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)?
   protected boolean useIndexes$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)?
      // ("index" TestNoAlpha OptionalSpacing Expression (',' OptionalSpacing Expression)*)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "index"
      match = ignoreCaseStringMatcher("index", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
               if (match) {
                  // (',' OptionalSpacing Expression)*
                  do {
                     // (',' OptionalSpacing Expression)
                     Node lastNode_2 = currentNode;
                     int lastIndex_2 = index;
                     // ','
                     match = charMatcher(',');
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Expression
                           match = expression$Rule();
                           if (! match) {
                              index = lastIndex_2;
                              lastNode_2.setSibling(null);
                              currentNode = lastNode_2;
                           }
                        } else {
                           index = lastIndex_2;
                           lastNode_2.setSibling(null);
                        }
                     }
                  } while(match);
                  match = true;
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USE_INDEXES, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //OldStyleCommands : (ArrobaGetSay | SetCmd | ReadCmd | ClearCmd | ClsCmd | KeyboardCmd | WaitCmd | AcceptCmd | InputCmd | ReleaseCmd | RestoreCmd | SaveCmd | JoinCmd | EjectCmd | EraseCmd | DeleteCmd | RenameCmd | CopyCmd | DirCmd | TypeCmd | RequestCmd | CancelCmd | QuitCmd | RunCmd | OutCmd | CloseCmd | SelectCmd | AppendCmd | PackCmd | ZapCmd | UnlockCmd | CommitCmd | GotoCmd | GoCmd | SkipCmd | FindCmd | ContinueCmd | SeekCmd | LocateCmd | ReplaceCmd | RecallCmd | CreateCmd | SortCmd | TotalCmd | UpdateCmd | CountCmd | SumCmd | AverageCmd | ListCmd | DisplayCmd | ReportCmd | LabelCmd | IndexOnCmd | ReindexCmd | QOutCommand | MenuToCmd)
   protected boolean oldStyleCommands$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (oldStyleCommands$RuleMemoStart == index) {
         if (oldStyleCommands$RuleMemoStart <= oldStyleCommands$RuleMemoEnd) {
            index = oldStyleCommands$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (oldStyleCommands$RuleMemoStart == oldStyleCommands$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_COMMANDS, oldStyleCommands$RuleMemoStart, oldStyleCommands$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(oldStyleCommands$RuleMemoFirstNode != null) {
                  lastNode.setSibling(oldStyleCommands$RuleMemoFirstNode);
                  currentNode = oldStyleCommands$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ArrobaGetSay | SetCmd | ReadCmd | ClearCmd | ClsCmd | KeyboardCmd | WaitCmd | AcceptCmd | InputCmd | ReleaseCmd | RestoreCmd | SaveCmd | JoinCmd | EjectCmd | EraseCmd | DeleteCmd | RenameCmd | CopyCmd | DirCmd | TypeCmd | RequestCmd | CancelCmd | QuitCmd | RunCmd | OutCmd | CloseCmd | SelectCmd | AppendCmd | PackCmd | ZapCmd | UnlockCmd | CommitCmd | GotoCmd | GoCmd | SkipCmd | FindCmd | ContinueCmd | SeekCmd | LocateCmd | ReplaceCmd | RecallCmd | CreateCmd | SortCmd | TotalCmd | UpdateCmd | CountCmd | SumCmd | AverageCmd | ListCmd | DisplayCmd | ReportCmd | LabelCmd | IndexOnCmd | ReindexCmd | QOutCommand | MenuToCmd)
      switch(buffer.getChar(index)) {
         case 'k':
         case 'K':
            // KeyboardCmd
            match = keyboardCmd$Rule();
            break;
         case 'l':
         case 'L':
            // LocateCmd
            match = locateCmd$Rule();
            if (! match) {
               // ListCmd
               match = listCmd$Rule();
               if (! match) {
                  // LabelCmd
                  match = labelCmd$Rule();
               }
            }
            break;
         case 'm':
         case 'M':
            // MenuToCmd
            match = menuToCmd$Rule();
            break;
         case 'p':
         case 'P':
            // PackCmd
            match = packCmd$Rule();
            break;
         case 'q':
         case 'Q':
            // QuitCmd
            match = quitCmd$Rule();
            if (! match) {
               // OutCmd
               match = outCmd$Rule();
            }
            break;
         case 'r':
         case 'R':
            // ReadCmd
            match = readCmd$Rule();
            if (! match) {
               // ReleaseCmd
               match = releaseCmd$Rule();
               if (! match) {
                  // RestoreCmd
                  match = restoreCmd$Rule();
                  if (! match) {
                     // RenameCmd
                     match = renameCmd$Rule();
                     if (! match) {
                        // RequestCmd
                        match = requestCmd$Rule();
                        if (! match) {
                           // RunCmd
                           match = runCmd$Rule();
                           if (! match) {
                              // ReplaceCmd
                              match = replaceCmd$Rule();
                              if (! match) {
                                 // RecallCmd
                                 match = recallCmd$Rule();
                                 if (! match) {
                                    // ReportCmd
                                    match = reportCmd$Rule();
                                    if (! match) {
                                       // ReindexCmd
                                       match = reindexCmd$Rule();
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 's':
         case 'S':
            // SetCmd
            match = setCmd$Rule();
            if (! match) {
               // SaveCmd
               match = saveCmd$Rule();
               if (! match) {
                  // SelectCmd
                  match = selectCmd$Rule();
                  if (! match) {
                     // SkipCmd
                     match = skipCmd$Rule();
                     if (! match) {
                        // SeekCmd
                        match = seekCmd$Rule();
                        if (! match) {
                           // SortCmd
                           match = sortCmd$Rule();
                           if (! match) {
                              // SumCmd
                              match = sumCmd$Rule();
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 't':
         case 'T':
            // TypeCmd
            match = typeCmd$Rule();
            if (! match) {
               // TotalCmd
               match = totalCmd$Rule();
            }
            break;
         case 'u':
         case 'U':
            // UnlockCmd
            match = unlockCmd$Rule();
            if (! match) {
               // UpdateCmd
               match = updateCmd$Rule();
            }
            break;
         case 'w':
         case 'W':
            // WaitCmd
            match = waitCmd$Rule();
            break;
         case 'z':
         case 'Z':
            // ZapCmd
            match = zapCmd$Rule();
            break;
         case '?':
            // QOutCommand
            match = qOutCommand$Rule();
            break;
         case '@':
            // ArrobaGetSay
            match = arrobaGetSay$Rule();
            break;
         case 'A':
         case 'a':
            // AcceptCmd
            match = acceptCmd$Rule();
            if (! match) {
               // AppendCmd
               match = appendCmd$Rule();
               if (! match) {
                  // AverageCmd
                  match = averageCmd$Rule();
               }
            }
            break;
         case 'C':
         case 'c':
            // ClearCmd
            match = clearCmd$Rule();
            if (! match) {
               // ClsCmd
               match = clsCmd$Rule();
               if (! match) {
                  // CopyCmd
                  match = copyCmd$Rule();
                  if (! match) {
                     // CancelCmd
                     match = cancelCmd$Rule();
                     if (! match) {
                        // CloseCmd
                        match = closeCmd$Rule();
                        if (! match) {
                           // CommitCmd
                           match = commitCmd$Rule();
                           if (! match) {
                              // ContinueCmd
                              match = continueCmd$Rule();
                              if (! match) {
                                 // CreateCmd
                                 match = createCmd$Rule();
                                 if (! match) {
                                    // CountCmd
                                    match = countCmd$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'D':
         case 'd':
            // DeleteCmd
            match = deleteCmd$Rule();
            if (! match) {
               // DirCmd
               match = dirCmd$Rule();
               if (! match) {
                  // DisplayCmd
                  match = displayCmd$Rule();
               }
            }
            break;
         case 'E':
         case 'e':
            // EjectCmd
            match = ejectCmd$Rule();
            if (! match) {
               // EraseCmd
               match = eraseCmd$Rule();
               if (! match) {
                  // RunCmd
                  match = runCmd$Rule();
               }
            }
            break;
         case 'F':
         case 'f':
            // FindCmd
            match = findCmd$Rule();
            break;
         case 'G':
         case 'g':
            // GotoCmd
            match = gotoCmd$Rule();
            if (! match) {
               // GoCmd
               match = goCmd$Rule();
            }
            break;
         case 'I':
         case 'i':
            // InputCmd
            match = inputCmd$Rule();
            if (! match) {
               // IndexOnCmd
               match = indexOnCmd$Rule();
            }
            break;
         case 'J':
         case 'j':
            // JoinCmd
            match = joinCmd$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         oldStyleCommands$RuleMemoStart = startIndex;
         oldStyleCommands$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            oldStyleCommands$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OLD_STYLE_COMMANDS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            oldStyleCommands$RuleMemoFirstNode = currentNode;
            oldStyleCommands$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         oldStyleCommands$RuleMemoStart = startIndex;
         oldStyleCommands$RuleMemoEnd = -1;
         oldStyleCommands$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrobaGetSay : ('@' OptionalSpacing CmdComplementation)
   protected boolean arrobaGetSay$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrobaGetSay$RuleMemoStart == index) {
         if (arrobaGetSay$RuleMemoStart <= arrobaGetSay$RuleMemoEnd) {
            index = arrobaGetSay$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (arrobaGetSay$RuleMemoStart == arrobaGetSay$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARROBA_GET_SAY, arrobaGetSay$RuleMemoStart, arrobaGetSay$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(arrobaGetSay$RuleMemoFirstNode != null) {
                  lastNode.setSibling(arrobaGetSay$RuleMemoFirstNode);
                  currentNode = arrobaGetSay$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing CmdComplementation)
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // CmdComplementation
            match = cmdComplementation$Rule();
         }
      }
      if (match) {
         arrobaGetSay$RuleMemoStart = startIndex;
         arrobaGetSay$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrobaGetSay$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARROBA_GET_SAY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrobaGetSay$RuleMemoFirstNode = currentNode;
            arrobaGetSay$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         arrobaGetSay$RuleMemoStart = startIndex;
         arrobaGetSay$RuleMemoEnd = -1;
         arrobaGetSay$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SetCmd : ("set" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean setCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (setCmd$RuleMemoStart == index) {
         if (setCmd$RuleMemoStart <= setCmd$RuleMemoEnd) {
            index = setCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (setCmd$RuleMemoStart == setCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SET_CMD, setCmd$RuleMemoStart, setCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(setCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(setCmd$RuleMemoFirstNode);
                  currentNode = setCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("set" TestNoAlpha OptionalSpacing CmdComplementation)
      // "set"
      match = ignoreCaseStringMatcher("set", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         setCmd$RuleMemoStart = startIndex;
         setCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            setCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SET_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            setCmd$RuleMemoFirstNode = currentNode;
            setCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         setCmd$RuleMemoStart = startIndex;
         setCmd$RuleMemoEnd = -1;
         setCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReadCmd : ("read" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean readCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (readCmd$RuleMemoStart == index) {
         if (readCmd$RuleMemoStart <= readCmd$RuleMemoEnd) {
            index = readCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (readCmd$RuleMemoStart == readCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.READ_CMD, readCmd$RuleMemoStart, readCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(readCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(readCmd$RuleMemoFirstNode);
                  currentNode = readCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("read" TestNoAlpha OptionalSpacing CmdComplementation)
      // "read"
      match = ignoreCaseStringMatcher("read", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         readCmd$RuleMemoStart = startIndex;
         readCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            readCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.READ_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            readCmd$RuleMemoFirstNode = currentNode;
            readCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         readCmd$RuleMemoStart = startIndex;
         readCmd$RuleMemoEnd = -1;
         readCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClsCmd : ("cls" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean clsCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clsCmd$RuleMemoStart == index) {
         if (clsCmd$RuleMemoStart <= clsCmd$RuleMemoEnd) {
            index = clsCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (clsCmd$RuleMemoStart == clsCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLS_CMD, clsCmd$RuleMemoStart, clsCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(clsCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(clsCmd$RuleMemoFirstNode);
                  currentNode = clsCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("cls" TestNoAlpha OptionalSpacing CmdComplementation)
      // "cls"
      match = ignoreCaseStringMatcher("cls", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         clsCmd$RuleMemoStart = startIndex;
         clsCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clsCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLS_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clsCmd$RuleMemoFirstNode = currentNode;
            clsCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         clsCmd$RuleMemoStart = startIndex;
         clsCmd$RuleMemoEnd = -1;
         clsCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClearCmd : ("clear" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean clearCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clearCmd$RuleMemoStart == index) {
         if (clearCmd$RuleMemoStart <= clearCmd$RuleMemoEnd) {
            index = clearCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (clearCmd$RuleMemoStart == clearCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_CMD, clearCmd$RuleMemoStart, clearCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(clearCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(clearCmd$RuleMemoFirstNode);
                  currentNode = clearCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("clear" TestNoAlpha OptionalSpacing CmdComplementation)
      // "clear"
      match = ignoreCaseStringMatcher("clear", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         clearCmd$RuleMemoStart = startIndex;
         clearCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clearCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clearCmd$RuleMemoFirstNode = currentNode;
            clearCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         clearCmd$RuleMemoStart = startIndex;
         clearCmd$RuleMemoEnd = -1;
         clearCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeyboardCmd : ("keyboard" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean keyboardCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keyboardCmd$RuleMemoStart == index) {
         if (keyboardCmd$RuleMemoStart <= keyboardCmd$RuleMemoEnd) {
            index = keyboardCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (keyboardCmd$RuleMemoStart == keyboardCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CMD, keyboardCmd$RuleMemoStart, keyboardCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(keyboardCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(keyboardCmd$RuleMemoFirstNode);
                  currentNode = keyboardCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("keyboard" TestNoAlpha OptionalSpacing CmdComplementation)
      // "keyboard"
      match = ignoreCaseStringMatcher("keyboard", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         keyboardCmd$RuleMemoStart = startIndex;
         keyboardCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keyboardCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keyboardCmd$RuleMemoFirstNode = currentNode;
            keyboardCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         keyboardCmd$RuleMemoStart = startIndex;
         keyboardCmd$RuleMemoEnd = -1;
         keyboardCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WaitCmd : ("wait" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean waitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (waitCmd$RuleMemoStart == index) {
         if (waitCmd$RuleMemoStart <= waitCmd$RuleMemoEnd) {
            index = waitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (waitCmd$RuleMemoStart == waitCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.WAIT_CMD, waitCmd$RuleMemoStart, waitCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(waitCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(waitCmd$RuleMemoFirstNode);
                  currentNode = waitCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("wait" TestNoAlpha OptionalSpacing CmdComplementation)
      // "wait"
      match = ignoreCaseStringMatcher("wait", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         waitCmd$RuleMemoStart = startIndex;
         waitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            waitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WAIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            waitCmd$RuleMemoFirstNode = currentNode;
            waitCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         waitCmd$RuleMemoStart = startIndex;
         waitCmd$RuleMemoEnd = -1;
         waitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AcceptCmd : ("accept" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean acceptCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (acceptCmd$RuleMemoStart == index) {
         if (acceptCmd$RuleMemoStart <= acceptCmd$RuleMemoEnd) {
            index = acceptCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (acceptCmd$RuleMemoStart == acceptCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ACCEPT_CMD, acceptCmd$RuleMemoStart, acceptCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(acceptCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(acceptCmd$RuleMemoFirstNode);
                  currentNode = acceptCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("accept" TestNoAlpha OptionalSpacing CmdComplementation)
      // "accept"
      match = ignoreCaseStringMatcher("accept", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         acceptCmd$RuleMemoStart = startIndex;
         acceptCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            acceptCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ACCEPT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            acceptCmd$RuleMemoFirstNode = currentNode;
            acceptCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         acceptCmd$RuleMemoStart = startIndex;
         acceptCmd$RuleMemoEnd = -1;
         acceptCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InputCmd : ("input" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean inputCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (inputCmd$RuleMemoStart == index) {
         if (inputCmd$RuleMemoStart <= inputCmd$RuleMemoEnd) {
            index = inputCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (inputCmd$RuleMemoStart == inputCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.INPUT_CMD, inputCmd$RuleMemoStart, inputCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(inputCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(inputCmd$RuleMemoFirstNode);
                  currentNode = inputCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("input" TestNoAlpha OptionalSpacing CmdComplementation)
      // "input"
      match = ignoreCaseStringMatcher("input", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         inputCmd$RuleMemoStart = startIndex;
         inputCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            inputCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INPUT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            inputCmd$RuleMemoFirstNode = currentNode;
            inputCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         inputCmd$RuleMemoStart = startIndex;
         inputCmd$RuleMemoEnd = -1;
         inputCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReleaseCmd : ("release" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean releaseCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (releaseCmd$RuleMemoStart == index) {
         if (releaseCmd$RuleMemoStart <= releaseCmd$RuleMemoEnd) {
            index = releaseCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (releaseCmd$RuleMemoStart == releaseCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELEASE_CMD, releaseCmd$RuleMemoStart, releaseCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(releaseCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(releaseCmd$RuleMemoFirstNode);
                  currentNode = releaseCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("release" TestNoAlpha OptionalSpacing CmdComplementation)
      // "release"
      match = ignoreCaseStringMatcher("release", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         releaseCmd$RuleMemoStart = startIndex;
         releaseCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            releaseCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RELEASE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            releaseCmd$RuleMemoFirstNode = currentNode;
            releaseCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         releaseCmd$RuleMemoStart = startIndex;
         releaseCmd$RuleMemoEnd = -1;
         releaseCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RestoreCmd : ("restore" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean restoreCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (restoreCmd$RuleMemoStart == index) {
         if (restoreCmd$RuleMemoStart <= restoreCmd$RuleMemoEnd) {
            index = restoreCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (restoreCmd$RuleMemoStart == restoreCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RESTORE_CMD, restoreCmd$RuleMemoStart, restoreCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(restoreCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(restoreCmd$RuleMemoFirstNode);
                  currentNode = restoreCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("restore" TestNoAlpha OptionalSpacing CmdComplementation)
      // "restore"
      match = ignoreCaseStringMatcher("restore", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         restoreCmd$RuleMemoStart = startIndex;
         restoreCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            restoreCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RESTORE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            restoreCmd$RuleMemoFirstNode = currentNode;
            restoreCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         restoreCmd$RuleMemoStart = startIndex;
         restoreCmd$RuleMemoEnd = -1;
         restoreCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SaveCmd : ("save" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean saveCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (saveCmd$RuleMemoStart == index) {
         if (saveCmd$RuleMemoStart <= saveCmd$RuleMemoEnd) {
            index = saveCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (saveCmd$RuleMemoStart == saveCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SAVE_CMD, saveCmd$RuleMemoStart, saveCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(saveCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(saveCmd$RuleMemoFirstNode);
                  currentNode = saveCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("save" TestNoAlpha OptionalSpacing CmdComplementation)
      // "save"
      match = ignoreCaseStringMatcher("save", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         saveCmd$RuleMemoStart = startIndex;
         saveCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            saveCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SAVE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            saveCmd$RuleMemoFirstNode = currentNode;
            saveCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         saveCmd$RuleMemoStart = startIndex;
         saveCmd$RuleMemoEnd = -1;
         saveCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //JoinCmd : ("join" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean joinCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (joinCmd$RuleMemoStart == index) {
         if (joinCmd$RuleMemoStart <= joinCmd$RuleMemoEnd) {
            index = joinCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (joinCmd$RuleMemoStart == joinCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.JOIN_CMD, joinCmd$RuleMemoStart, joinCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(joinCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(joinCmd$RuleMemoFirstNode);
                  currentNode = joinCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("join" TestNoAlpha OptionalSpacing CmdComplementation)
      // "join"
      match = ignoreCaseStringMatcher("join", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         joinCmd$RuleMemoStart = startIndex;
         joinCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            joinCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.JOIN_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            joinCmd$RuleMemoFirstNode = currentNode;
            joinCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         joinCmd$RuleMemoStart = startIndex;
         joinCmd$RuleMemoEnd = -1;
         joinCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EjectCmd : ("eject" TestNoAlpha OptionalSpacing)
   protected boolean ejectCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ejectCmd$RuleMemoStart == index) {
         if (ejectCmd$RuleMemoStart <= ejectCmd$RuleMemoEnd) {
            index = ejectCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ejectCmd$RuleMemoStart == ejectCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EJECT_CMD, ejectCmd$RuleMemoStart, ejectCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ejectCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ejectCmd$RuleMemoFirstNode);
                  currentNode = ejectCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("eject" TestNoAlpha OptionalSpacing)
      // "eject"
      match = ignoreCaseStringMatcher("eject", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         ejectCmd$RuleMemoStart = startIndex;
         ejectCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ejectCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EJECT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ejectCmd$RuleMemoFirstNode = currentNode;
            ejectCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ejectCmd$RuleMemoStart = startIndex;
         ejectCmd$RuleMemoEnd = -1;
         ejectCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EraseCmd : ("erase" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean eraseCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (eraseCmd$RuleMemoStart == index) {
         if (eraseCmd$RuleMemoStart <= eraseCmd$RuleMemoEnd) {
            index = eraseCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (eraseCmd$RuleMemoStart == eraseCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERASE_CMD, eraseCmd$RuleMemoStart, eraseCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(eraseCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(eraseCmd$RuleMemoFirstNode);
                  currentNode = eraseCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("erase" TestNoAlpha OptionalSpacing CmdComplementation)
      // "erase"
      match = ignoreCaseStringMatcher("erase", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         eraseCmd$RuleMemoStart = startIndex;
         eraseCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            eraseCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ERASE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            eraseCmd$RuleMemoFirstNode = currentNode;
            eraseCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         eraseCmd$RuleMemoStart = startIndex;
         eraseCmd$RuleMemoEnd = -1;
         eraseCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DeleteCmd : ("delete" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean deleteCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (deleteCmd$RuleMemoStart == index) {
         if (deleteCmd$RuleMemoStart <= deleteCmd$RuleMemoEnd) {
            index = deleteCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (deleteCmd$RuleMemoStart == deleteCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DELETE_CMD, deleteCmd$RuleMemoStart, deleteCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(deleteCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(deleteCmd$RuleMemoFirstNode);
                  currentNode = deleteCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("delete" TestNoAlpha OptionalSpacing CmdComplementation)
      // "delete"
      match = ignoreCaseStringMatcher("delete", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         deleteCmd$RuleMemoStart = startIndex;
         deleteCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            deleteCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DELETE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            deleteCmd$RuleMemoFirstNode = currentNode;
            deleteCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         deleteCmd$RuleMemoStart = startIndex;
         deleteCmd$RuleMemoEnd = -1;
         deleteCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RenameCmd : ("rename" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean renameCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (renameCmd$RuleMemoStart == index) {
         if (renameCmd$RuleMemoStart <= renameCmd$RuleMemoEnd) {
            index = renameCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (renameCmd$RuleMemoStart == renameCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RENAME_CMD, renameCmd$RuleMemoStart, renameCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(renameCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(renameCmd$RuleMemoFirstNode);
                  currentNode = renameCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("rename" TestNoAlpha OptionalSpacing CmdComplementation)
      // "rename"
      match = ignoreCaseStringMatcher("rename", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         renameCmd$RuleMemoStart = startIndex;
         renameCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            renameCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RENAME_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            renameCmd$RuleMemoFirstNode = currentNode;
            renameCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         renameCmd$RuleMemoStart = startIndex;
         renameCmd$RuleMemoEnd = -1;
         renameCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CopyCmd : ("copy" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean copyCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (copyCmd$RuleMemoStart == index) {
         if (copyCmd$RuleMemoStart <= copyCmd$RuleMemoEnd) {
            index = copyCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (copyCmd$RuleMemoStart == copyCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COPY_CMD, copyCmd$RuleMemoStart, copyCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(copyCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(copyCmd$RuleMemoFirstNode);
                  currentNode = copyCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("copy" TestNoAlpha OptionalSpacing CmdComplementation)
      // "copy"
      match = ignoreCaseStringMatcher("copy", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         copyCmd$RuleMemoStart = startIndex;
         copyCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            copyCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COPY_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            copyCmd$RuleMemoFirstNode = currentNode;
            copyCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         copyCmd$RuleMemoStart = startIndex;
         copyCmd$RuleMemoEnd = -1;
         copyCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DirCmd : ("dir" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean dirCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dirCmd$RuleMemoStart == index) {
         if (dirCmd$RuleMemoStart <= dirCmd$RuleMemoEnd) {
            index = dirCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (dirCmd$RuleMemoStart == dirCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIR_CMD, dirCmd$RuleMemoStart, dirCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(dirCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(dirCmd$RuleMemoFirstNode);
                  currentNode = dirCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("dir" TestNoAlpha OptionalSpacing CmdComplementation)
      // "dir"
      match = ignoreCaseStringMatcher("dir", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         dirCmd$RuleMemoStart = startIndex;
         dirCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dirCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DIR_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dirCmd$RuleMemoFirstNode = currentNode;
            dirCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         dirCmd$RuleMemoStart = startIndex;
         dirCmd$RuleMemoEnd = -1;
         dirCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TypeCmd : ("type" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean typeCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (typeCmd$RuleMemoStart == index) {
         if (typeCmd$RuleMemoStart <= typeCmd$RuleMemoEnd) {
            index = typeCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (typeCmd$RuleMemoStart == typeCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TYPE_CMD, typeCmd$RuleMemoStart, typeCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(typeCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(typeCmd$RuleMemoFirstNode);
                  currentNode = typeCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("type" TestNoAlpha OptionalSpacing CmdComplementation)
      // "type"
      match = ignoreCaseStringMatcher("type", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         typeCmd$RuleMemoStart = startIndex;
         typeCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            typeCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TYPE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            typeCmd$RuleMemoFirstNode = currentNode;
            typeCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         typeCmd$RuleMemoStart = startIndex;
         typeCmd$RuleMemoEnd = -1;
         typeCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RequestCmd : ("request" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean requestCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (requestCmd$RuleMemoStart == index) {
         if (requestCmd$RuleMemoStart <= requestCmd$RuleMemoEnd) {
            index = requestCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (requestCmd$RuleMemoStart == requestCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST_CMD, requestCmd$RuleMemoStart, requestCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(requestCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(requestCmd$RuleMemoFirstNode);
                  currentNode = requestCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("request" TestNoAlpha OptionalSpacing CmdComplementation)
      // "request"
      match = ignoreCaseStringMatcher("request", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         requestCmd$RuleMemoStart = startIndex;
         requestCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            requestCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            requestCmd$RuleMemoFirstNode = currentNode;
            requestCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         requestCmd$RuleMemoStart = startIndex;
         requestCmd$RuleMemoEnd = -1;
         requestCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CancelCmd : ("cancel" TestNoAlpha OptionalSpacing)
   protected boolean cancelCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (cancelCmd$RuleMemoStart == index) {
         if (cancelCmd$RuleMemoStart <= cancelCmd$RuleMemoEnd) {
            index = cancelCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (cancelCmd$RuleMemoStart == cancelCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CANCEL_CMD, cancelCmd$RuleMemoStart, cancelCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(cancelCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(cancelCmd$RuleMemoFirstNode);
                  currentNode = cancelCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("cancel" TestNoAlpha OptionalSpacing)
      // "cancel"
      match = ignoreCaseStringMatcher("cancel", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         cancelCmd$RuleMemoStart = startIndex;
         cancelCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            cancelCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CANCEL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            cancelCmd$RuleMemoFirstNode = currentNode;
            cancelCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         cancelCmd$RuleMemoStart = startIndex;
         cancelCmd$RuleMemoEnd = -1;
         cancelCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QuitCmd : ("quit" TestNoAlpha OptionalSpacing)
   protected boolean quitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (quitCmd$RuleMemoStart == index) {
         if (quitCmd$RuleMemoStart <= quitCmd$RuleMemoEnd) {
            index = quitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (quitCmd$RuleMemoStart == quitCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUIT_CMD, quitCmd$RuleMemoStart, quitCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(quitCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(quitCmd$RuleMemoFirstNode);
                  currentNode = quitCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("quit" TestNoAlpha OptionalSpacing)
      // "quit"
      match = ignoreCaseStringMatcher("quit", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         quitCmd$RuleMemoStart = startIndex;
         quitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            quitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            quitCmd$RuleMemoFirstNode = currentNode;
            quitCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         quitCmd$RuleMemoStart = startIndex;
         quitCmd$RuleMemoEnd = -1;
         quitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RunCmd : ((("run" | "exclamation") TestNoAlpha OptionalSpacing) CmdComplementation)
   protected boolean runCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (runCmd$RuleMemoStart == index) {
         if (runCmd$RuleMemoStart <= runCmd$RuleMemoEnd) {
            index = runCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (runCmd$RuleMemoStart == runCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RUN_CMD, runCmd$RuleMemoStart, runCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(runCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(runCmd$RuleMemoFirstNode);
                  currentNode = runCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("run" | "exclamation") TestNoAlpha OptionalSpacing) CmdComplementation)
      // (("run" | "exclamation") TestNoAlpha OptionalSpacing)
      // ("run" | "exclamation")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'r':
         case 'R':
            ++index;
            // "un"
            if (match = ignoreCaseStringTest("un", 2)) {
               index += 2;
            }
            break;
         case 'e':
         case 'E':
            ++index;
            // "xclamation"
            if (match = ignoreCaseStringTest("xclamation", 10)) {
               index += 10;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // CmdComplementation
         match = cmdComplementation$Rule();
      }
      if (match) {
         runCmd$RuleMemoStart = startIndex;
         runCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            runCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RUN_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            runCmd$RuleMemoFirstNode = currentNode;
            runCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         runCmd$RuleMemoStart = startIndex;
         runCmd$RuleMemoEnd = -1;
         runCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OutCmd : ("question" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean outCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (outCmd$RuleMemoStart == index) {
         if (outCmd$RuleMemoStart <= outCmd$RuleMemoEnd) {
            index = outCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (outCmd$RuleMemoStart == outCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.OUT_CMD, outCmd$RuleMemoStart, outCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(outCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(outCmd$RuleMemoFirstNode);
                  currentNode = outCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("question" TestNoAlpha OptionalSpacing CmdComplementation)
      // "question"
      match = ignoreCaseStringMatcher("question", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         outCmd$RuleMemoStart = startIndex;
         outCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            outCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OUT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            outCmd$RuleMemoFirstNode = currentNode;
            outCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         outCmd$RuleMemoStart = startIndex;
         outCmd$RuleMemoEnd = -1;
         outCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CloseCmd : ("close" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean closeCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (closeCmd$RuleMemoStart == index) {
         if (closeCmd$RuleMemoStart <= closeCmd$RuleMemoEnd) {
            index = closeCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (closeCmd$RuleMemoStart == closeCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLOSE_CMD, closeCmd$RuleMemoStart, closeCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(closeCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(closeCmd$RuleMemoFirstNode);
                  currentNode = closeCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("close" TestNoAlpha OptionalSpacing CmdComplementation)
      // "close"
      match = ignoreCaseStringMatcher("close", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         closeCmd$RuleMemoStart = startIndex;
         closeCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            closeCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLOSE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            closeCmd$RuleMemoFirstNode = currentNode;
            closeCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         closeCmd$RuleMemoStart = startIndex;
         closeCmd$RuleMemoEnd = -1;
         closeCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SelectCmd : ("select" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean selectCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (selectCmd$RuleMemoStart == index) {
         if (selectCmd$RuleMemoStart <= selectCmd$RuleMemoEnd) {
            index = selectCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (selectCmd$RuleMemoStart == selectCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELECT_CMD, selectCmd$RuleMemoStart, selectCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(selectCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(selectCmd$RuleMemoFirstNode);
                  currentNode = selectCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("select" TestNoAlpha OptionalSpacing CmdComplementation)
      // "select"
      match = ignoreCaseStringMatcher("select", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         selectCmd$RuleMemoStart = startIndex;
         selectCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selectCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELECT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selectCmd$RuleMemoFirstNode = currentNode;
            selectCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         selectCmd$RuleMemoStart = startIndex;
         selectCmd$RuleMemoEnd = -1;
         selectCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AppendCmd : ("append" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean appendCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (appendCmd$RuleMemoStart == index) {
         if (appendCmd$RuleMemoStart <= appendCmd$RuleMemoEnd) {
            index = appendCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (appendCmd$RuleMemoStart == appendCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.APPEND_CMD, appendCmd$RuleMemoStart, appendCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(appendCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(appendCmd$RuleMemoFirstNode);
                  currentNode = appendCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("append" TestNoAlpha OptionalSpacing CmdComplementation)
      // "append"
      match = ignoreCaseStringMatcher("append", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         appendCmd$RuleMemoStart = startIndex;
         appendCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            appendCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.APPEND_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            appendCmd$RuleMemoFirstNode = currentNode;
            appendCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         appendCmd$RuleMemoStart = startIndex;
         appendCmd$RuleMemoEnd = -1;
         appendCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PackCmd : ("pack" TestNoAlpha OptionalSpacing)
   protected boolean packCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (packCmd$RuleMemoStart == index) {
         if (packCmd$RuleMemoStart <= packCmd$RuleMemoEnd) {
            index = packCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (packCmd$RuleMemoStart == packCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PACK_CMD, packCmd$RuleMemoStart, packCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(packCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(packCmd$RuleMemoFirstNode);
                  currentNode = packCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("pack" TestNoAlpha OptionalSpacing)
      // "pack"
      match = ignoreCaseStringMatcher("pack", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         packCmd$RuleMemoStart = startIndex;
         packCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            packCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PACK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            packCmd$RuleMemoFirstNode = currentNode;
            packCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         packCmd$RuleMemoStart = startIndex;
         packCmd$RuleMemoEnd = -1;
         packCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ZapCmd : ("zap" TestNoAlpha OptionalSpacing)
   protected boolean zapCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (zapCmd$RuleMemoStart == index) {
         if (zapCmd$RuleMemoStart <= zapCmd$RuleMemoEnd) {
            index = zapCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (zapCmd$RuleMemoStart == zapCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ZAP_CMD, zapCmd$RuleMemoStart, zapCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(zapCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(zapCmd$RuleMemoFirstNode);
                  currentNode = zapCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("zap" TestNoAlpha OptionalSpacing)
      // "zap"
      match = ignoreCaseStringMatcher("zap", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         zapCmd$RuleMemoStart = startIndex;
         zapCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            zapCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ZAP_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            zapCmd$RuleMemoFirstNode = currentNode;
            zapCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         zapCmd$RuleMemoStart = startIndex;
         zapCmd$RuleMemoEnd = -1;
         zapCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UnlockCmd : ("unlock" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean unlockCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (unlockCmd$RuleMemoStart == index) {
         if (unlockCmd$RuleMemoStart <= unlockCmd$RuleMemoEnd) {
            index = unlockCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (unlockCmd$RuleMemoStart == unlockCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNLOCK_CMD, unlockCmd$RuleMemoStart, unlockCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(unlockCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(unlockCmd$RuleMemoFirstNode);
                  currentNode = unlockCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("unlock" TestNoAlpha OptionalSpacing CmdComplementation)
      // "unlock"
      match = ignoreCaseStringMatcher("unlock", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         unlockCmd$RuleMemoStart = startIndex;
         unlockCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            unlockCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UNLOCK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            unlockCmd$RuleMemoFirstNode = currentNode;
            unlockCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         unlockCmd$RuleMemoStart = startIndex;
         unlockCmd$RuleMemoEnd = -1;
         unlockCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommitCmd : ("commit" TestNoAlpha OptionalSpacing)
   protected boolean commitCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (commitCmd$RuleMemoStart == index) {
         if (commitCmd$RuleMemoStart <= commitCmd$RuleMemoEnd) {
            index = commitCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (commitCmd$RuleMemoStart == commitCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_CMD, commitCmd$RuleMemoStart, commitCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(commitCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(commitCmd$RuleMemoFirstNode);
                  currentNode = commitCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("commit" TestNoAlpha OptionalSpacing)
      // "commit"
      match = ignoreCaseStringMatcher("commit", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         commitCmd$RuleMemoStart = startIndex;
         commitCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            commitCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMIT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            commitCmd$RuleMemoFirstNode = currentNode;
            commitCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         commitCmd$RuleMemoStart = startIndex;
         commitCmd$RuleMemoEnd = -1;
         commitCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //GotoCmd : ("goto" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean gotoCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (gotoCmd$RuleMemoStart == index) {
         if (gotoCmd$RuleMemoStart <= gotoCmd$RuleMemoEnd) {
            index = gotoCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (gotoCmd$RuleMemoStart == gotoCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.GOTO_CMD, gotoCmd$RuleMemoStart, gotoCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(gotoCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(gotoCmd$RuleMemoFirstNode);
                  currentNode = gotoCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("goto" TestNoAlpha OptionalSpacing CmdComplementation)
      // "goto"
      match = ignoreCaseStringMatcher("goto", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         gotoCmd$RuleMemoStart = startIndex;
         gotoCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            gotoCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.GOTO_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            gotoCmd$RuleMemoFirstNode = currentNode;
            gotoCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         gotoCmd$RuleMemoStart = startIndex;
         gotoCmd$RuleMemoEnd = -1;
         gotoCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //GoCmd : ("go" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean goCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (goCmd$RuleMemoStart == index) {
         if (goCmd$RuleMemoStart <= goCmd$RuleMemoEnd) {
            index = goCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (goCmd$RuleMemoStart == goCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.GO_CMD, goCmd$RuleMemoStart, goCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(goCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(goCmd$RuleMemoFirstNode);
                  currentNode = goCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("go" TestNoAlpha OptionalSpacing CmdComplementation)
      // "go"
      match = ignoreCaseStringMatcher("go", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         goCmd$RuleMemoStart = startIndex;
         goCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            goCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.GO_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            goCmd$RuleMemoFirstNode = currentNode;
            goCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         goCmd$RuleMemoStart = startIndex;
         goCmd$RuleMemoEnd = -1;
         goCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SkipCmd : ("skip" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean skipCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (skipCmd$RuleMemoStart == index) {
         if (skipCmd$RuleMemoStart <= skipCmd$RuleMemoEnd) {
            index = skipCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (skipCmd$RuleMemoStart == skipCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SKIP_CMD, skipCmd$RuleMemoStart, skipCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(skipCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(skipCmd$RuleMemoFirstNode);
                  currentNode = skipCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("skip" TestNoAlpha OptionalSpacing CmdComplementation)
      // "skip"
      match = ignoreCaseStringMatcher("skip", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         skipCmd$RuleMemoStart = startIndex;
         skipCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            skipCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SKIP_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            skipCmd$RuleMemoFirstNode = currentNode;
            skipCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         skipCmd$RuleMemoStart = startIndex;
         skipCmd$RuleMemoEnd = -1;
         skipCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FindCmd : ("find" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean findCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (findCmd$RuleMemoStart == index) {
         if (findCmd$RuleMemoStart <= findCmd$RuleMemoEnd) {
            index = findCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (findCmd$RuleMemoStart == findCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIND_CMD, findCmd$RuleMemoStart, findCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(findCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(findCmd$RuleMemoFirstNode);
                  currentNode = findCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("find" TestNoAlpha OptionalSpacing CmdComplementation)
      // "find"
      match = ignoreCaseStringMatcher("find", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         findCmd$RuleMemoStart = startIndex;
         findCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            findCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FIND_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            findCmd$RuleMemoFirstNode = currentNode;
            findCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         findCmd$RuleMemoStart = startIndex;
         findCmd$RuleMemoEnd = -1;
         findCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueCmd : ("continue" TestNoAlpha OptionalSpacing)
   protected boolean continueCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueCmd$RuleMemoStart == index) {
         if (continueCmd$RuleMemoStart <= continueCmd$RuleMemoEnd) {
            index = continueCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (continueCmd$RuleMemoStart == continueCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_CMD, continueCmd$RuleMemoStart, continueCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(continueCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(continueCmd$RuleMemoFirstNode);
                  currentNode = continueCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("continue" TestNoAlpha OptionalSpacing)
      // "continue"
      match = ignoreCaseStringMatcher("continue", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         continueCmd$RuleMemoStart = startIndex;
         continueCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueCmd$RuleMemoFirstNode = currentNode;
            continueCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         continueCmd$RuleMemoStart = startIndex;
         continueCmd$RuleMemoEnd = -1;
         continueCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SeekCmd : ("seek" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean seekCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (seekCmd$RuleMemoStart == index) {
         if (seekCmd$RuleMemoStart <= seekCmd$RuleMemoEnd) {
            index = seekCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (seekCmd$RuleMemoStart == seekCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEEK_CMD, seekCmd$RuleMemoStart, seekCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(seekCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(seekCmd$RuleMemoFirstNode);
                  currentNode = seekCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("seek" TestNoAlpha OptionalSpacing CmdComplementation)
      // "seek"
      match = ignoreCaseStringMatcher("seek", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         seekCmd$RuleMemoStart = startIndex;
         seekCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            seekCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SEEK_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            seekCmd$RuleMemoFirstNode = currentNode;
            seekCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         seekCmd$RuleMemoStart = startIndex;
         seekCmd$RuleMemoEnd = -1;
         seekCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LocateCmd : ("locate" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean locateCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (locateCmd$RuleMemoStart == index) {
         if (locateCmd$RuleMemoStart <= locateCmd$RuleMemoEnd) {
            index = locateCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (locateCmd$RuleMemoStart == locateCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCATE_CMD, locateCmd$RuleMemoStart, locateCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(locateCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(locateCmd$RuleMemoFirstNode);
                  currentNode = locateCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("locate" TestNoAlpha OptionalSpacing CmdComplementation)
      // "locate"
      match = ignoreCaseStringMatcher("locate", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         locateCmd$RuleMemoStart = startIndex;
         locateCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            locateCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOCATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            locateCmd$RuleMemoFirstNode = currentNode;
            locateCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         locateCmd$RuleMemoStart = startIndex;
         locateCmd$RuleMemoEnd = -1;
         locateCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReplaceCmd : ("replace" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean replaceCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (replaceCmd$RuleMemoStart == index) {
         if (replaceCmd$RuleMemoStart <= replaceCmd$RuleMemoEnd) {
            index = replaceCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (replaceCmd$RuleMemoStart == replaceCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPLACE_CMD, replaceCmd$RuleMemoStart, replaceCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(replaceCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(replaceCmd$RuleMemoFirstNode);
                  currentNode = replaceCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("replace" TestNoAlpha OptionalSpacing CmdComplementation)
      // "replace"
      match = ignoreCaseStringMatcher("replace", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         replaceCmd$RuleMemoStart = startIndex;
         replaceCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            replaceCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPLACE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            replaceCmd$RuleMemoFirstNode = currentNode;
            replaceCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         replaceCmd$RuleMemoStart = startIndex;
         replaceCmd$RuleMemoEnd = -1;
         replaceCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //RecallCmd : ("recall" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean recallCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (recallCmd$RuleMemoStart == index) {
         if (recallCmd$RuleMemoStart <= recallCmd$RuleMemoEnd) {
            index = recallCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (recallCmd$RuleMemoStart == recallCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECALL_CMD, recallCmd$RuleMemoStart, recallCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(recallCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(recallCmd$RuleMemoFirstNode);
                  currentNode = recallCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("recall" TestNoAlpha OptionalSpacing CmdComplementation)
      // "recall"
      match = ignoreCaseStringMatcher("recall", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         recallCmd$RuleMemoStart = startIndex;
         recallCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recallCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECALL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recallCmd$RuleMemoFirstNode = currentNode;
            recallCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         recallCmd$RuleMemoStart = startIndex;
         recallCmd$RuleMemoEnd = -1;
         recallCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CreateCmd : ("create" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean createCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (createCmd$RuleMemoStart == index) {
         if (createCmd$RuleMemoStart <= createCmd$RuleMemoEnd) {
            index = createCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (createCmd$RuleMemoStart == createCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CMD, createCmd$RuleMemoStart, createCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(createCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(createCmd$RuleMemoFirstNode);
                  currentNode = createCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("create" TestNoAlpha OptionalSpacing CmdComplementation)
      // "create"
      match = ignoreCaseStringMatcher("create", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         createCmd$RuleMemoStart = startIndex;
         createCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            createCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CREATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            createCmd$RuleMemoFirstNode = currentNode;
            createCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         createCmd$RuleMemoStart = startIndex;
         createCmd$RuleMemoEnd = -1;
         createCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SortCmd : ("sort" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean sortCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sortCmd$RuleMemoStart == index) {
         if (sortCmd$RuleMemoStart <= sortCmd$RuleMemoEnd) {
            index = sortCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (sortCmd$RuleMemoStart == sortCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SORT_CMD, sortCmd$RuleMemoStart, sortCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(sortCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(sortCmd$RuleMemoFirstNode);
                  currentNode = sortCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("sort" TestNoAlpha OptionalSpacing CmdComplementation)
      // "sort"
      match = ignoreCaseStringMatcher("sort", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         sortCmd$RuleMemoStart = startIndex;
         sortCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sortCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SORT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sortCmd$RuleMemoFirstNode = currentNode;
            sortCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         sortCmd$RuleMemoStart = startIndex;
         sortCmd$RuleMemoEnd = -1;
         sortCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TotalCmd : ("total" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean totalCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (totalCmd$RuleMemoStart == index) {
         if (totalCmd$RuleMemoStart <= totalCmd$RuleMemoEnd) {
            index = totalCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (totalCmd$RuleMemoStart == totalCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TOTAL_CMD, totalCmd$RuleMemoStart, totalCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(totalCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(totalCmd$RuleMemoFirstNode);
                  currentNode = totalCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("total" TestNoAlpha OptionalSpacing CmdComplementation)
      // "total"
      match = ignoreCaseStringMatcher("total", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         totalCmd$RuleMemoStart = startIndex;
         totalCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            totalCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TOTAL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            totalCmd$RuleMemoFirstNode = currentNode;
            totalCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         totalCmd$RuleMemoStart = startIndex;
         totalCmd$RuleMemoEnd = -1;
         totalCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UpdateCmd : ("update" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean updateCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (updateCmd$RuleMemoStart == index) {
         if (updateCmd$RuleMemoStart <= updateCmd$RuleMemoEnd) {
            index = updateCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (updateCmd$RuleMemoStart == updateCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.UPDATE_CMD, updateCmd$RuleMemoStart, updateCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(updateCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(updateCmd$RuleMemoFirstNode);
                  currentNode = updateCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("update" TestNoAlpha OptionalSpacing CmdComplementation)
      // "update"
      match = ignoreCaseStringMatcher("update", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         updateCmd$RuleMemoStart = startIndex;
         updateCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            updateCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.UPDATE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            updateCmd$RuleMemoFirstNode = currentNode;
            updateCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         updateCmd$RuleMemoStart = startIndex;
         updateCmd$RuleMemoEnd = -1;
         updateCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CountCmd : ("count" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean countCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (countCmd$RuleMemoStart == index) {
         if (countCmd$RuleMemoStart <= countCmd$RuleMemoEnd) {
            index = countCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (countCmd$RuleMemoStart == countCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COUNT_CMD, countCmd$RuleMemoStart, countCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(countCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(countCmd$RuleMemoFirstNode);
                  currentNode = countCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("count" TestNoAlpha OptionalSpacing CmdComplementation)
      // "count"
      match = ignoreCaseStringMatcher("count", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         countCmd$RuleMemoStart = startIndex;
         countCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            countCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COUNT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            countCmd$RuleMemoFirstNode = currentNode;
            countCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         countCmd$RuleMemoStart = startIndex;
         countCmd$RuleMemoEnd = -1;
         countCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SumCmd : ("sum" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean sumCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (sumCmd$RuleMemoStart == index) {
         if (sumCmd$RuleMemoStart <= sumCmd$RuleMemoEnd) {
            index = sumCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (sumCmd$RuleMemoStart == sumCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SUM_CMD, sumCmd$RuleMemoStart, sumCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(sumCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(sumCmd$RuleMemoFirstNode);
                  currentNode = sumCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("sum" TestNoAlpha OptionalSpacing CmdComplementation)
      // "sum"
      match = ignoreCaseStringMatcher("sum", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         sumCmd$RuleMemoStart = startIndex;
         sumCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            sumCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SUM_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            sumCmd$RuleMemoFirstNode = currentNode;
            sumCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         sumCmd$RuleMemoStart = startIndex;
         sumCmd$RuleMemoEnd = -1;
         sumCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AverageCmd : ("average" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean averageCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (averageCmd$RuleMemoStart == index) {
         if (averageCmd$RuleMemoStart <= averageCmd$RuleMemoEnd) {
            index = averageCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (averageCmd$RuleMemoStart == averageCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.AVERAGE_CMD, averageCmd$RuleMemoStart, averageCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(averageCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(averageCmd$RuleMemoFirstNode);
                  currentNode = averageCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("average" TestNoAlpha OptionalSpacing CmdComplementation)
      // "average"
      match = ignoreCaseStringMatcher("average", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         averageCmd$RuleMemoStart = startIndex;
         averageCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            averageCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AVERAGE_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            averageCmd$RuleMemoFirstNode = currentNode;
            averageCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         averageCmd$RuleMemoStart = startIndex;
         averageCmd$RuleMemoEnd = -1;
         averageCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ListCmd : ("list" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean listCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (listCmd$RuleMemoStart == index) {
         if (listCmd$RuleMemoStart <= listCmd$RuleMemoEnd) {
            index = listCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (listCmd$RuleMemoStart == listCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LIST_CMD, listCmd$RuleMemoStart, listCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(listCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(listCmd$RuleMemoFirstNode);
                  currentNode = listCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("list" TestNoAlpha OptionalSpacing CmdComplementation)
      // "list"
      match = ignoreCaseStringMatcher("list", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         listCmd$RuleMemoStart = startIndex;
         listCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            listCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LIST_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            listCmd$RuleMemoFirstNode = currentNode;
            listCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         listCmd$RuleMemoStart = startIndex;
         listCmd$RuleMemoEnd = -1;
         listCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DisplayCmd : ("display" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean displayCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (displayCmd$RuleMemoStart == index) {
         if (displayCmd$RuleMemoStart <= displayCmd$RuleMemoEnd) {
            index = displayCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (displayCmd$RuleMemoStart == displayCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DISPLAY_CMD, displayCmd$RuleMemoStart, displayCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(displayCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(displayCmd$RuleMemoFirstNode);
                  currentNode = displayCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("display" TestNoAlpha OptionalSpacing CmdComplementation)
      // "display"
      match = ignoreCaseStringMatcher("display", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         displayCmd$RuleMemoStart = startIndex;
         displayCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            displayCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DISPLAY_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            displayCmd$RuleMemoFirstNode = currentNode;
            displayCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         displayCmd$RuleMemoStart = startIndex;
         displayCmd$RuleMemoEnd = -1;
         displayCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReportCmd : ("report" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean reportCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (reportCmd$RuleMemoStart == index) {
         if (reportCmd$RuleMemoStart <= reportCmd$RuleMemoEnd) {
            index = reportCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (reportCmd$RuleMemoStart == reportCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPORT_CMD, reportCmd$RuleMemoStart, reportCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(reportCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(reportCmd$RuleMemoFirstNode);
                  currentNode = reportCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("report" TestNoAlpha OptionalSpacing CmdComplementation)
      // "report"
      match = ignoreCaseStringMatcher("report", 6);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         reportCmd$RuleMemoStart = startIndex;
         reportCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            reportCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REPORT_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            reportCmd$RuleMemoFirstNode = currentNode;
            reportCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         reportCmd$RuleMemoStart = startIndex;
         reportCmd$RuleMemoEnd = -1;
         reportCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LabelCmd : ("label" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean labelCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (labelCmd$RuleMemoStart == index) {
         if (labelCmd$RuleMemoStart <= labelCmd$RuleMemoEnd) {
            index = labelCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (labelCmd$RuleMemoStart == labelCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LABEL_CMD, labelCmd$RuleMemoStart, labelCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(labelCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(labelCmd$RuleMemoFirstNode);
                  currentNode = labelCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("label" TestNoAlpha OptionalSpacing CmdComplementation)
      // "label"
      match = ignoreCaseStringMatcher("label", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         labelCmd$RuleMemoStart = startIndex;
         labelCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            labelCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LABEL_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            labelCmd$RuleMemoFirstNode = currentNode;
            labelCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         labelCmd$RuleMemoStart = startIndex;
         labelCmd$RuleMemoEnd = -1;
         labelCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexOnCmd : ("index" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean indexOnCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (indexOnCmd$RuleMemoStart == index) {
         if (indexOnCmd$RuleMemoStart <= indexOnCmd$RuleMemoEnd) {
            index = indexOnCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (indexOnCmd$RuleMemoStart == indexOnCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ON_CMD, indexOnCmd$RuleMemoStart, indexOnCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(indexOnCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(indexOnCmd$RuleMemoFirstNode);
                  currentNode = indexOnCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("index" TestNoAlpha OptionalSpacing "on" TestNoAlpha OptionalSpacing CmdComplementation)
      // "index"
      match = ignoreCaseStringMatcher("index", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "on"
               match = ignoreCaseStringMatcher("on", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // CmdComplementation
                        match = cmdComplementation$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         indexOnCmd$RuleMemoStart = startIndex;
         indexOnCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            indexOnCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ON_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            indexOnCmd$RuleMemoFirstNode = currentNode;
            indexOnCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         indexOnCmd$RuleMemoStart = startIndex;
         indexOnCmd$RuleMemoEnd = -1;
         indexOnCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ReindexCmd : ("reindex" TestNoAlpha OptionalSpacing CmdComplementation)
   protected boolean reindexCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (reindexCmd$RuleMemoStart == index) {
         if (reindexCmd$RuleMemoStart <= reindexCmd$RuleMemoEnd) {
            index = reindexCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (reindexCmd$RuleMemoStart == reindexCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.REINDEX_CMD, reindexCmd$RuleMemoStart, reindexCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(reindexCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(reindexCmd$RuleMemoFirstNode);
                  currentNode = reindexCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("reindex" TestNoAlpha OptionalSpacing CmdComplementation)
      // "reindex"
      match = ignoreCaseStringMatcher("reindex", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CmdComplementation
               match = cmdComplementation$Rule();
            }
         }
      }
      if (match) {
         reindexCmd$RuleMemoStart = startIndex;
         reindexCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            reindexCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REINDEX_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            reindexCmd$RuleMemoFirstNode = currentNode;
            reindexCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         reindexCmd$RuleMemoStart = startIndex;
         reindexCmd$RuleMemoEnd = -1;
         reindexCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QOutCommand : ((('?' | '??') OptionalSpacing) CmdComplementation)
   protected boolean qOutCommand$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qOutCommand$RuleMemoStart == index) {
         if (qOutCommand$RuleMemoStart <= qOutCommand$RuleMemoEnd) {
            index = qOutCommand$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (qOutCommand$RuleMemoStart == qOutCommand$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.QOUT_COMMAND, qOutCommand$RuleMemoStart, qOutCommand$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(qOutCommand$RuleMemoFirstNode != null) {
                  lastNode.setSibling(qOutCommand$RuleMemoFirstNode);
                  currentNode = qOutCommand$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((('?' | '??') OptionalSpacing) CmdComplementation)
      // (('?' | '??') OptionalSpacing)
      // ('?' | '??')
      int startIndex_1 = index;
      if (buffer.matchChar(index, '?')) {
         ++index;
         // ('?' | <EMPTY>)
         if (buffer.matchChar(index, '?')) {
            ++index;
            // <EMPTY>
            match = true;
         } else {
            match = true;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         // CmdComplementation
         match = cmdComplementation$Rule();
      }
      if (match) {
         qOutCommand$RuleMemoStart = startIndex;
         qOutCommand$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qOutCommand$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QOUT_COMMAND, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qOutCommand$RuleMemoFirstNode = currentNode;
            qOutCommand$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         qOutCommand$RuleMemoStart = startIndex;
         qOutCommand$RuleMemoEnd = -1;
         qOutCommand$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MenuToCmd : ("menu" TestNoAlpha OptionalSpacing "to" TestNoAlpha OptionalSpacing LeftValue)
   protected boolean menuToCmd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (menuToCmd$RuleMemoStart == index) {
         if (menuToCmd$RuleMemoStart <= menuToCmd$RuleMemoEnd) {
            index = menuToCmd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (menuToCmd$RuleMemoStart == menuToCmd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MENU_TO_CMD, menuToCmd$RuleMemoStart, menuToCmd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(menuToCmd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(menuToCmd$RuleMemoFirstNode);
                  currentNode = menuToCmd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("menu" TestNoAlpha OptionalSpacing "to" TestNoAlpha OptionalSpacing LeftValue)
      // "menu"
      match = ignoreCaseStringMatcher("menu", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "to"
               match = ignoreCaseStringMatcher("to", 2);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // LeftValue
                        match = leftValue$Rule();
                     }
                  }
               }
            }
         }
      }
      if (match) {
         menuToCmd$RuleMemoStart = startIndex;
         menuToCmd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            menuToCmd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MENU_TO_CMD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            menuToCmd$RuleMemoFirstNode = currentNode;
            menuToCmd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         menuToCmd$RuleMemoStart = startIndex;
         menuToCmd$RuleMemoEnd = -1;
         menuToCmd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IgnoreLine : ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)+
   protected boolean ignoreLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreLine$RuleMemoStart == index) {
         if (ignoreLine$RuleMemoStart <= ignoreLine$RuleMemoEnd) {
            index = ignoreLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ignoreLine$RuleMemoStart == ignoreLine$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_LINE, ignoreLine$RuleMemoStart, ignoreLine$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ignoreLine$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ignoreLine$RuleMemoFirstNode);
                  currentNode = ignoreLine$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)+
      // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)!
      Node lastNode_2 = currentNode;
      int lastIndex_2 = index;
      boolean lastAtomic_2 = currentRuleIsAtomic;
      // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)
      // ('\n' OptionalSpacing)
      Node lastNode_3 = currentNode;
      int lastIndex_3 = index;
      // '\n'
      match = charMatcher('\n');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (! match) {
            index = lastIndex_3;
            lastNode_3.setSibling(null);
            currentNode = lastNode_3;
         }
      }
      if (! match) {
         // ('\r' OptionalSpacing)
         Node lastNode_4 = currentNode;
         int lastIndex_4 = index;
         // '\r'
         match = charMatcher('\r');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (! match) {
               index = lastIndex_4;
               lastNode_4.setSibling(null);
               currentNode = lastNode_4;
            }
         }
         if (! match) {
            // <EOI>
            match = eoi();
         }
      }
      currentRuleIsAtomic = lastAtomic_2;
      index = lastIndex_2;
      lastNode_2.setSibling(null);
      currentNode = lastNode_2;
      match = ! match;
      if (match) {
         // .
         match = anyCharMatcher();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      if (match) {
         do {
            // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)
            Node lastNode_5 = currentNode;
            int lastIndex_5 = index;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)!
            Node lastNode_6 = currentNode;
            int lastIndex_6 = index;
            boolean lastAtomic_6 = currentRuleIsAtomic;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)
            // ('\n' OptionalSpacing)
            Node lastNode_7 = currentNode;
            int lastIndex_7 = index;
            // '\n'
            match = charMatcher('\n');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (! match) {
                  index = lastIndex_7;
                  lastNode_7.setSibling(null);
                  currentNode = lastNode_7;
               }
            }
            if (! match) {
               // ('\r' OptionalSpacing)
               Node lastNode_8 = currentNode;
               int lastIndex_8 = index;
               // '\r'
               match = charMatcher('\r');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (! match) {
                     index = lastIndex_8;
                     lastNode_8.setSibling(null);
                     currentNode = lastNode_8;
                  }
               }
               if (! match) {
                  // <EOI>
                  match = eoi();
               }
            }
            currentRuleIsAtomic = lastAtomic_6;
            index = lastIndex_6;
            lastNode_6.setSibling(null);
            currentNode = lastNode_6;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (! match) {
                     index = lastIndex_5;
                     lastNode_5.setSibling(null);
                     currentNode = lastNode_5;
                  }
               } else {
                  index = lastIndex_5;
                  lastNode_5.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         ignoreLine$RuleMemoStart = startIndex;
         ignoreLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_LINE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreLine$RuleMemoFirstNode = currentNode;
            ignoreLine$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ignoreLine$RuleMemoStart = startIndex;
         ignoreLine$RuleMemoEnd = -1;
         ignoreLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDeclarationList : (VariableDefinition VariableDefinitionCommaList)
   protected boolean variableDeclarationList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variableDeclarationList$RuleMemoStart == index) {
         if (variableDeclarationList$RuleMemoStart <= variableDeclarationList$RuleMemoEnd) {
            index = variableDeclarationList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (variableDeclarationList$RuleMemoStart == variableDeclarationList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DECLARATION_LIST, variableDeclarationList$RuleMemoStart, variableDeclarationList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(variableDeclarationList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(variableDeclarationList$RuleMemoFirstNode);
                  currentNode = variableDeclarationList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (VariableDefinition VariableDefinitionCommaList)
      // VariableDefinition
      match = variableDefinition$Rule();
      if (match) {
         // VariableDefinitionCommaList
         match = variableDefinitionCommaList$Rule();
      }
      if (match) {
         variableDeclarationList$RuleMemoStart = startIndex;
         variableDeclarationList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableDeclarationList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DECLARATION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableDeclarationList$RuleMemoFirstNode = currentNode;
            variableDeclarationList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         variableDeclarationList$RuleMemoStart = startIndex;
         variableDeclarationList$RuleMemoEnd = -1;
         variableDeclarationList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersDeclarationList : (ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)*)
   protected boolean parametersDeclarationList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parametersDeclarationList$RuleMemoStart == index) {
         if (parametersDeclarationList$RuleMemoStart <= parametersDeclarationList$RuleMemoEnd) {
            index = parametersDeclarationList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parametersDeclarationList$RuleMemoStart == parametersDeclarationList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION_LIST, parametersDeclarationList$RuleMemoStart, parametersDeclarationList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(parametersDeclarationList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parametersDeclarationList$RuleMemoFirstNode);
                  currentNode = parametersDeclarationList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParameterDeclaration (',' OptionalSpacing ParameterDeclaration)*)
      // ParameterDeclaration
      match = parameterDeclaration$Rule();
      if (match) {
         // (',' OptionalSpacing ParameterDeclaration)*
         do {
            // (',' OptionalSpacing ParameterDeclaration)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // ParameterDeclaration
                  match = parameterDeclaration$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         parametersDeclarationList$RuleMemoStart = startIndex;
         parametersDeclarationList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parametersDeclarationList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parametersDeclarationList$RuleMemoFirstNode = currentNode;
            parametersDeclarationList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parametersDeclarationList$RuleMemoStart = startIndex;
         parametersDeclarationList$RuleMemoEnd = -1;
         parametersDeclarationList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaVariableDefinition : (',' OptionalSpacing VariableDefinition)
   protected boolean commaVariableDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (',' OptionalSpacing VariableDefinition)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // VariableDefinition
            match = variableDefinition$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_VARIABLE_DEFINITION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDefinition : (AnyIdentifier OptionalArrayDimension AsType InitializeVariable)
   protected boolean variableDefinition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (variableDefinition$RuleMemoStart == index) {
         if (variableDefinition$RuleMemoStart <= variableDefinition$RuleMemoEnd) {
            index = variableDefinition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (variableDefinition$RuleMemoStart == variableDefinition$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION, variableDefinition$RuleMemoStart, variableDefinition$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(variableDefinition$RuleMemoFirstNode != null) {
                  lastNode.setSibling(variableDefinition$RuleMemoFirstNode);
                  currentNode = variableDefinition$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier OptionalArrayDimension AsType InitializeVariable)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // OptionalArrayDimension
         match = optionalArrayDimension$Rule();
         if (match) {
            // AsType
            match = asType$Rule();
            if (match) {
               // InitializeVariable
               match = initializeVariable$Rule();
            }
         }
      }
      if (match) {
         variableDefinition$RuleMemoStart = startIndex;
         variableDefinition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            variableDefinition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            variableDefinition$RuleMemoFirstNode = currentNode;
            variableDefinition$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         variableDefinition$RuleMemoStart = startIndex;
         variableDefinition$RuleMemoEnd = -1;
         variableDefinition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableDefinitionCommaList : CommaVariableDefinition*
   protected boolean variableDefinitionCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaVariableDefinition*
      do {
         // CommaVariableDefinition
         match = commaVariableDefinition$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_DEFINITION_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //AssignmentOperator : (AssignmentOperatorOnly OptionalSpacing)
   protected boolean assignmentOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignmentOperator$RuleMemoStart == index) {
         if (assignmentOperator$RuleMemoStart <= assignmentOperator$RuleMemoEnd) {
            index = assignmentOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (assignmentOperator$RuleMemoStart == assignmentOperator$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, assignmentOperator$RuleMemoStart, assignmentOperator$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(assignmentOperator$RuleMemoFirstNode != null) {
                  lastNode.setSibling(assignmentOperator$RuleMemoFirstNode);
                  currentNode = assignmentOperator$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignmentOperatorOnly OptionalSpacing)
      // AssignmentOperatorOnly
      match = assignmentOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         assignmentOperator$RuleMemoStart = startIndex;
         assignmentOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignmentOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignmentOperator$RuleMemoFirstNode = currentNode;
            assignmentOperator$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         assignmentOperator$RuleMemoStart = startIndex;
         assignmentOperator$RuleMemoEnd = -1;
         assignmentOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignmentOperatorOnly : (':=' | EqualOperator)
   protected boolean assignmentOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (':=' | EqualOperator)
      // ':='
      match = stringMatcher(":=", 2);
      if (! match) {
         // ('=' ('>' | '=')!)
         // '='
         match = charMatcher('=');
         if (match) {
            // ('>' | '=')!
            // ('>' | '=')
            int startIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '=':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '>':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            index = startIndex_1;
            match = ! match;
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //InitializeVariable : (AssignmentOperator ExpressionAsType)?
   protected boolean initializeVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (AssignmentOperator ExpressionAsType)?
      // (AssignmentOperator ExpressionAsType)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // AssignmentOperator
      match = assignmentOperator$Rule();
      if (match) {
         // ExpressionAsType
         match = expressionAsType$Rule();
         if (! match) {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
            currentNode = lastNode_1;
         }
      }
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.INITIALIZE_VARIABLE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ExpressionAsType : (Expression AsType)
   protected boolean expressionAsType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expressionAsType$RuleMemoStart == index) {
         if (expressionAsType$RuleMemoStart <= expressionAsType$RuleMemoEnd) {
            index = expressionAsType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (expressionAsType$RuleMemoStart == expressionAsType$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_AS_TYPE, expressionAsType$RuleMemoStart, expressionAsType$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(expressionAsType$RuleMemoFirstNode != null) {
                  lastNode.setSibling(expressionAsType$RuleMemoFirstNode);
                  currentNode = expressionAsType$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression AsType)
      // Expression
      match = expression$Rule();
      if (match) {
         // AsType
         match = asType$Rule();
      }
      if (match) {
         expressionAsType$RuleMemoStart = startIndex;
         expressionAsType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            expressionAsType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_AS_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            expressionAsType$RuleMemoFirstNode = currentNode;
            expressionAsType$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         expressionAsType$RuleMemoStart = startIndex;
         expressionAsType$RuleMemoEnd = -1;
         expressionAsType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AsType : AsDataType?
   protected boolean asType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (asType$RuleMemoStart == index) {
         if (asType$RuleMemoStart <= asType$RuleMemoEnd) {
            index = asType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (asType$RuleMemoStart == asType$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_TYPE, asType$RuleMemoStart, asType$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(asType$RuleMemoFirstNode != null) {
                  lastNode.setSibling(asType$RuleMemoFirstNode);
                  currentNode = asType$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // AsDataType?
      // AsDataType
      asDataType$Rule();
      asType$RuleMemoStart = startIndex;
      asType$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         asType$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_TYPE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         asType$RuleMemoFirstNode = currentNode;
         asType$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //OptionalArrayDimension : ArrayDimension?
   protected boolean optionalArrayDimension$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ArrayDimension?
      // ArrayDimension
      arrayDimension$Rule();
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_ARRAY_DIMENSION, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ArrayDimension : ('[' OptionalSpacing ValuesList ']' OptionalSpacing ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*)
   protected boolean arrayDimension$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' OptionalSpacing ValuesList ']' OptionalSpacing ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*)
      // '['
      match = charMatcher('[');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ValuesList
            match = valuesList$Rule();
            if (match) {
               // ']'
               match = charMatcher(']');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ('[' OptionalSpacing ValuesList ']' OptionalSpacing)*
                     do {
                        // ('[' OptionalSpacing ValuesList ']' OptionalSpacing)
                        Node lastNode_1 = currentNode;
                        int lastIndex_1 = index;
                        // '['
                        match = charMatcher('[');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // ValuesList
                              match = valuesList$Rule();
                              if (match) {
                                 // ']'
                                 match = charMatcher(']');
                                 if (match) {
                                    // OptionalSpacing
                                    match = optionalSpacing$Rule();
                                    if (! match) {
                                       index = lastIndex_1;
                                       lastNode_1.setSibling(null);
                                       currentNode = lastNode_1;
                                    }
                                 } else {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                 }
                              } else {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                              }
                           } else {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                           }
                        }
                     } while(match);
                     match = true;
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_DIMENSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ValuesList : (Expression? (',' OptionalSpacing Expression?)*)
   protected boolean valuesList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (valuesList$RuleMemoStart == index) {
         if (valuesList$RuleMemoStart <= valuesList$RuleMemoEnd) {
            index = valuesList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (valuesList$RuleMemoStart == valuesList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUES_LIST, valuesList$RuleMemoStart, valuesList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(valuesList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(valuesList$RuleMemoFirstNode);
                  currentNode = valuesList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression? (',' OptionalSpacing Expression?)*)
      // Expression?
      // Expression
      expression$Rule();
      match = true;
      // (',' OptionalSpacing Expression?)*
      do {
         // (',' OptionalSpacing Expression?)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ','
         match = charMatcher(',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               // Expression
               expression$Rule();
               match = true;
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
      } while(match);
      valuesList$RuleMemoStart = startIndex;
      valuesList$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         valuesList$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUES_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         valuesList$RuleMemoFirstNode = currentNode;
         valuesList$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //InTable : ("in" TestNoAlpha OptionalSpacing AnyIdentifier)
   protected boolean inTable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("in" TestNoAlpha OptionalSpacing AnyIdentifier)
      // "in"
      match = ignoreCaseStringMatcher("in", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IN_TABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //VariableList : (Variable (',' OptionalSpacing Variable)*)
   protected boolean variableList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (Variable (',' OptionalSpacing Variable)*)
      // Variable
      match = variable$Rule();
      if (match) {
         // (',' OptionalSpacing Variable)*
         do {
            // (',' OptionalSpacing Variable)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // Variable
                  match = variable$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierList : (AnyIdentifier (',' OptionalSpacing AnyIdentifier)*)
   protected boolean identifierList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (identifierList$RuleMemoStart == index) {
         if (identifierList$RuleMemoStart <= identifierList$RuleMemoEnd) {
            index = identifierList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (identifierList$RuleMemoStart == identifierList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER_LIST, identifierList$RuleMemoStart, identifierList$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(identifierList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(identifierList$RuleMemoFirstNode);
                  currentNode = identifierList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier (',' OptionalSpacing AnyIdentifier)*)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // (',' OptionalSpacing AnyIdentifier)*
         do {
            // (',' OptionalSpacing AnyIdentifier)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // AnyIdentifier
                  match = anyIdentifier$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         identifierList$RuleMemoStart = startIndex;
         identifierList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifierList$RuleMemoFirstNode = currentNode;
            identifierList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         identifierList$RuleMemoStart = startIndex;
         identifierList$RuleMemoEnd = -1;
         identifierList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemvarDeclaration : (("memvar" | "memva" | "memv") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean memvarDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (memvarDeclaration$RuleMemoStart == index) {
         if (memvarDeclaration$RuleMemoStart <= memvarDeclaration$RuleMemoEnd) {
            index = memvarDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (memvarDeclaration$RuleMemoStart == memvarDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMVAR_DECLARATION, memvarDeclaration$RuleMemoStart, memvarDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(memvarDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(memvarDeclaration$RuleMemoFirstNode);
                  currentNode = memvarDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("memvar" | "memva" | "memv") TestNoAlpha OptionalSpacing IdentifierList)
      // ("memvar" | "memva" | "memv")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
         ++index;
         // ("emvar" | "emva" | "emv")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("mvar" | "mva" | "mv")
            if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
               ++index;
               // ("var" | "va" | "v")
               if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                  ++index;
                  // ("ar" | "a" | <EMPTY>)
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // "r"
                     if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         memvarDeclaration$RuleMemoStart = startIndex;
         memvarDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            memvarDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMVAR_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            memvarDeclaration$RuleMemoFirstNode = currentNode;
            memvarDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         memvarDeclaration$RuleMemoStart = startIndex;
         memvarDeclaration$RuleMemoEnd = -1;
         memvarDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasIdentifier : (ParenthesesExpressionList | Macro | AnyIdentifier)
   protected boolean aliasIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasIdentifier$RuleMemoStart == index) {
         if (aliasIdentifier$RuleMemoStart <= aliasIdentifier$RuleMemoEnd) {
            index = aliasIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (aliasIdentifier$RuleMemoStart == aliasIdentifier$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIAS_IDENTIFIER, aliasIdentifier$RuleMemoStart, aliasIdentifier$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(aliasIdentifier$RuleMemoFirstNode != null) {
                  lastNode.setSibling(aliasIdentifier$RuleMemoFirstNode);
                  currentNode = aliasIdentifier$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesExpressionList | Macro | AnyIdentifier)
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // Macro
            match = macro$Rule();
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // Macro
            match = macro$Rule();
            if (! match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
            break;
         case '(':
            // ParenthesesExpressionList
            match = parenthesesExpressionList$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         aliasIdentifier$RuleMemoStart = startIndex;
         aliasIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIAS_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasIdentifier$RuleMemoFirstNode = currentNode;
            aliasIdentifier$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         aliasIdentifier$RuleMemoStart = startIndex;
         aliasIdentifier$RuleMemoEnd = -1;
         aliasIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ExpressionList : (Expression? (',' OptionalSpacing Expression?)*)
   protected boolean expressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expressionList$RuleMemoStart == index) {
         if (expressionList$RuleMemoStart <= expressionList$RuleMemoEnd) {
            index = expressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (expressionList$RuleMemoStart == expressionList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_LIST, expressionList$RuleMemoStart, expressionList$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(expressionList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(expressionList$RuleMemoFirstNode);
                  currentNode = expressionList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression? (',' OptionalSpacing Expression?)*)
      // Expression?
      // Expression
      expression$Rule();
      match = true;
      // (',' OptionalSpacing Expression?)*
      do {
         // (',' OptionalSpacing Expression?)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ','
         match = charMatcher(',');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               // Expression
               expression$Rule();
               match = true;
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
      } while(match);
      expressionList$RuleMemoStart = startIndex;
      expressionList$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         expressionList$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION_LIST, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         expressionList$RuleMemoFirstNode = currentNode;
         expressionList$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //Macro : (MacroVar | MacroExpression)
   protected boolean macro$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macro$RuleMemoStart == index) {
         if (macro$RuleMemoStart <= macro$RuleMemoEnd) {
            index = macro$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (macro$RuleMemoStart == macro$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO, macro$RuleMemoStart, macro$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(macro$RuleMemoFirstNode != null) {
                  lastNode.setSibling(macro$RuleMemoFirstNode);
                  currentNode = macro$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MacroVar | MacroExpression)
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // MacroVar
            match = macroVar$Rule();
            break;
         case '&':
            // MacroVar
            match = macroVar$Rule();
            if (! match) {
               // MacroExpression
               match = macroExpression$Rule();
            }
            break;
         default:
            match = false;
      }
      if (match) {
         macro$RuleMemoStart = startIndex;
         macro$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macro$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macro$RuleMemoFirstNode = currentNode;
            macro$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         macro$RuleMemoStart = startIndex;
         macro$RuleMemoEnd = -1;
         macro$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedExpression : (AliasIdentifier '->' OptionalSpacing ParenthesesExpressionList)
   protected boolean aliasedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedExpression$RuleMemoStart == index) {
         if (aliasedExpression$RuleMemoStart <= aliasedExpression$RuleMemoEnd) {
            index = aliasedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (aliasedExpression$RuleMemoStart == aliasedExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_EXPRESSION, aliasedExpression$RuleMemoStart, aliasedExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(aliasedExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(aliasedExpression$RuleMemoFirstNode);
                  currentNode = aliasedExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing ParenthesesExpressionList)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ParenthesesExpressionList
               match = parenthesesExpressionList$Rule();
            }
         }
      }
      if (match) {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedExpression$RuleMemoFirstNode = currentNode;
            aliasedExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         aliasedExpression$RuleMemoStart = startIndex;
         aliasedExpression$RuleMemoEnd = -1;
         aliasedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesExpressionList : ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
   protected boolean parenthesesExpressionList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesExpressionList$RuleMemoStart == index) {
         if (parenthesesExpressionList$RuleMemoStart <= parenthesesExpressionList$RuleMemoEnd) {
            index = parenthesesExpressionList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parenthesesExpressionList$RuleMemoStart == parenthesesExpressionList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_EXPRESSION_LIST, parenthesesExpressionList$RuleMemoStart, parenthesesExpressionList$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(parenthesesExpressionList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parenthesesExpressionList$RuleMemoFirstNode);
                  currentNode = parenthesesExpressionList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ExpressionList ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ExpressionList
            match = expressionList$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesExpressionList$RuleMemoStart = startIndex;
         parenthesesExpressionList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesExpressionList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_EXPRESSION_LIST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesExpressionList$RuleMemoFirstNode = currentNode;
            parenthesesExpressionList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parenthesesExpressionList$RuleMemoStart = startIndex;
         parenthesesExpressionList$RuleMemoEnd = -1;
         parenthesesExpressionList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QualifiedVariable : (Variable (':' OptionalSpacing AnyIdentifier)+)
   protected boolean qualifiedVariable$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qualifiedVariable$RuleMemoStart == index) {
         if (qualifiedVariable$RuleMemoStart <= qualifiedVariable$RuleMemoEnd) {
            index = qualifiedVariable$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (qualifiedVariable$RuleMemoStart == qualifiedVariable$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE, qualifiedVariable$RuleMemoStart, qualifiedVariable$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(qualifiedVariable$RuleMemoFirstNode != null) {
                  lastNode.setSibling(qualifiedVariable$RuleMemoFirstNode);
                  currentNode = qualifiedVariable$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Variable (':' OptionalSpacing AnyIdentifier)+)
      // Variable
      match = variable$Rule();
      if (match) {
         // (':' OptionalSpacing AnyIdentifier)+
         // (':' OptionalSpacing AnyIdentifier)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
         if (match) {
            do {
               // (':' OptionalSpacing AnyIdentifier)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ':'
               match = charMatcher(':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // AnyIdentifier
                     match = anyIdentifier$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
            } while(match);
            match = true;
         }
      }
      if (match) {
         qualifiedVariable$RuleMemoStart = startIndex;
         qualifiedVariable$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qualifiedVariable$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qualifiedVariable$RuleMemoFirstNode = currentNode;
            qualifiedVariable$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         qualifiedVariable$RuleMemoStart = startIndex;
         qualifiedVariable$RuleMemoEnd = -1;
         qualifiedVariable$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroFunctionCall : (Macro ParParameters)
   protected boolean macroFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroFunctionCall$RuleMemoStart == index) {
         if (macroFunctionCall$RuleMemoStart <= macroFunctionCall$RuleMemoEnd) {
            index = macroFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (macroFunctionCall$RuleMemoStart == macroFunctionCall$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_FUNCTION_CALL, macroFunctionCall$RuleMemoStart, macroFunctionCall$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(macroFunctionCall$RuleMemoFirstNode != null) {
                  lastNode.setSibling(macroFunctionCall$RuleMemoFirstNode);
                  currentNode = macroFunctionCall$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Macro ParParameters)
      // Macro
      match = macro$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         macroFunctionCall$RuleMemoStart = startIndex;
         macroFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroFunctionCall$RuleMemoFirstNode = currentNode;
            macroFunctionCall$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         macroFunctionCall$RuleMemoStart = startIndex;
         macroFunctionCall$RuleMemoEnd = -1;
         macroFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParParameters : ('(' OptionalSpacing (('...' OptionalSpacing) | OptionalParametersList) ')' OptionalSpacing)
   protected boolean parParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parParameters$RuleMemoStart == index) {
         if (parParameters$RuleMemoStart <= parParameters$RuleMemoEnd) {
            index = parParameters$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parParameters$RuleMemoStart == parParameters$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS, parParameters$RuleMemoStart, parParameters$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(parParameters$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parParameters$RuleMemoFirstNode);
                  currentNode = parParameters$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing (('...' OptionalSpacing) | OptionalParametersList) ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (('...' OptionalSpacing) | OptionalParametersList)
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '&':
               case '\'':
               case '(':
               case '+':
               case ',':
               case '-':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case '@':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{':
                  // OptionalParametersList
                  match = optionalParametersList$Rule();
                  break;
               case '.':
                  // ('...' OptionalSpacing)
                  // '...'
                  match = stringMatcher("...", 3);
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
                  if (! match) {
                     // OptionalParametersList
                     match = optionalParametersList$Rule();
                  }
                  break;
               default:
                  match = false;
            }
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parParameters$RuleMemoStart = startIndex;
         parParameters$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parParameters$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parParameters$RuleMemoFirstNode = currentNode;
            parParameters$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parParameters$RuleMemoStart = startIndex;
         parParameters$RuleMemoEnd = -1;
         parParameters$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SimpleFunctionCall : (Identifier ParParameters)
   protected boolean simpleFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (simpleFunctionCall$RuleMemoStart == index) {
         if (simpleFunctionCall$RuleMemoStart <= simpleFunctionCall$RuleMemoEnd) {
            index = simpleFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (simpleFunctionCall$RuleMemoStart == simpleFunctionCall$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, simpleFunctionCall$RuleMemoStart, simpleFunctionCall$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(simpleFunctionCall$RuleMemoFirstNode != null) {
                  lastNode.setSibling(simpleFunctionCall$RuleMemoFirstNode);
                  currentNode = simpleFunctionCall$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier ParParameters)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         simpleFunctionCall$RuleMemoStart = startIndex;
         simpleFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            simpleFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            simpleFunctionCall$RuleMemoFirstNode = currentNode;
            simpleFunctionCall$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         simpleFunctionCall$RuleMemoStart = startIndex;
         simpleFunctionCall$RuleMemoEnd = -1;
         simpleFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnySimpleFunctionCall : (AnyIdentifier ParParameters)
   protected boolean anySimpleFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anySimpleFunctionCall$RuleMemoStart == index) {
         if (anySimpleFunctionCall$RuleMemoStart <= anySimpleFunctionCall$RuleMemoEnd) {
            index = anySimpleFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (anySimpleFunctionCall$RuleMemoStart == anySimpleFunctionCall$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, anySimpleFunctionCall$RuleMemoStart, anySimpleFunctionCall$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(anySimpleFunctionCall$RuleMemoFirstNode != null) {
                  lastNode.setSibling(anySimpleFunctionCall$RuleMemoFirstNode);
                  currentNode = anySimpleFunctionCall$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier ParParameters)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         anySimpleFunctionCall$RuleMemoStart = startIndex;
         anySimpleFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anySimpleFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SIMPLE_FUNCTION_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anySimpleFunctionCall$RuleMemoFirstNode = currentNode;
            anySimpleFunctionCall$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         anySimpleFunctionCall$RuleMemoStart = startIndex;
         anySimpleFunctionCall$RuleMemoEnd = -1;
         anySimpleFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IgnoreRestOfLine : (TestNoAlpha ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?)
   protected boolean ignoreRestOfLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ignoreRestOfLine$RuleMemoStart == index) {
         if (ignoreRestOfLine$RuleMemoStart <= ignoreRestOfLine$RuleMemoEnd) {
            index = ignoreRestOfLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ignoreRestOfLine$RuleMemoStart == ignoreRestOfLine$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_REST_OF_LINE, ignoreRestOfLine$RuleMemoStart, ignoreRestOfLine$RuleMemoEnd, false, false);
                  lastNode.setSibling(currentNode);
               } else if(ignoreRestOfLine$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ignoreRestOfLine$RuleMemoFirstNode);
                  currentNode = ignoreRestOfLine$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (TestNoAlpha ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?)
      // TestNoAlpha
      match = testNoAlpha$Rule();
      if (match) {
         // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*?
         // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)*
         do {
            // ((('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)! . OptionalSpacing)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)!
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            boolean lastAtomic_2 = currentRuleIsAtomic;
            // (('\n' OptionalSpacing) | ('\r' OptionalSpacing) | <EOI>)
            // ('\n' OptionalSpacing)
            Node lastNode_3 = currentNode;
            int lastIndex_3 = index;
            // '\n'
            match = charMatcher('\n');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (! match) {
                  index = lastIndex_3;
                  lastNode_3.setSibling(null);
                  currentNode = lastNode_3;
               }
            }
            if (! match) {
               // ('\r' OptionalSpacing)
               Node lastNode_4 = currentNode;
               int lastIndex_4 = index;
               // '\r'
               match = charMatcher('\r');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (! match) {
                     index = lastIndex_4;
                     lastNode_4.setSibling(null);
                     currentNode = lastNode_4;
                  }
               }
               if (! match) {
                  // <EOI>
                  match = eoi();
               }
            }
            currentRuleIsAtomic = lastAtomic_2;
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         ignoreRestOfLine$RuleMemoStart = startIndex;
         ignoreRestOfLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ignoreRestOfLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IGNORE_REST_OF_LINE, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ignoreRestOfLine$RuleMemoFirstNode = currentNode;
            ignoreRestOfLine$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ignoreRestOfLine$RuleMemoStart = startIndex;
         ignoreRestOfLine$RuleMemoEnd = -1;
         ignoreRestOfLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfInLine : (IIFKeyword '(' OptionalSpacing Condition ',' OptionalSpacing Parameter? ',' OptionalSpacing Parameter? ')' OptionalSpacing)
   protected boolean ifInLine$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifInLine$RuleMemoStart == index) {
         if (ifInLine$RuleMemoStart <= ifInLine$RuleMemoEnd) {
            index = ifInLine$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifInLine$RuleMemoStart == ifInLine$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_IN_LINE, ifInLine$RuleMemoStart, ifInLine$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifInLine$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifInLine$RuleMemoFirstNode);
                  currentNode = ifInLine$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IIFKeyword '(' OptionalSpacing Condition ',' OptionalSpacing Parameter? ',' OptionalSpacing Parameter? ')' OptionalSpacing)
      // ("iif" | "if")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
         ++index;
         // ("if" | "f")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case 'i':
            case 'I':
               ++index;
               // "f"
               if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                  ++index;
               }
               break;
            default:
               match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
               if (match) {
                  // ','
                  match = charMatcher(',');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Parameter?
                        // Parameter
                        parameter$Rule();
                        // ','
                        match = charMatcher(',');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                           if (match) {
                              // Parameter?
                              // Parameter
                              parameter$Rule();
                              // ')'
                              match = charMatcher(')');
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         ifInLine$RuleMemoStart = startIndex;
         ifInLine$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifInLine$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_IN_LINE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifInLine$RuleMemoFirstNode = currentNode;
            ifInLine$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifInLine$RuleMemoStart = startIndex;
         ifInLine$RuleMemoEnd = -1;
         ifInLine$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfBegin : ("if" TestNoAlpha OptionalSpacing Condition)
   protected boolean ifBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifBegin$RuleMemoStart == index) {
         if (ifBegin$RuleMemoStart <= ifBegin$RuleMemoEnd) {
            index = ifBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifBegin$RuleMemoStart == ifBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_BEGIN, ifBegin$RuleMemoStart, ifBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifBegin$RuleMemoFirstNode);
                  currentNode = ifBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("if" TestNoAlpha OptionalSpacing Condition)
      // "if"
      match = ignoreCaseStringMatcher("if", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         ifBegin$RuleMemoStart = startIndex;
         ifBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifBegin$RuleMemoFirstNode = currentNode;
            ifBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifBegin$RuleMemoStart = startIndex;
         ifBegin$RuleMemoEnd = -1;
         ifBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Condition : Expression
   protected boolean condition$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (condition$RuleMemoStart == index) {
         if (condition$RuleMemoStart <= condition$RuleMemoEnd) {
            index = condition$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (condition$RuleMemoStart == condition$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION, condition$RuleMemoStart, condition$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(condition$RuleMemoFirstNode != null) {
                  lastNode.setSibling(condition$RuleMemoFirstNode);
                  currentNode = condition$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Expression
      match = expression$Rule();
      if (match) {
         condition$RuleMemoStart = startIndex;
         condition$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            condition$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            condition$RuleMemoFirstNode = currentNode;
            condition$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         condition$RuleMemoStart = startIndex;
         condition$RuleMemoEnd = -1;
         condition$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IfEnd : (("endif" | "endi") IgnoreRestOfLine)
   protected boolean ifEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (ifEnd$RuleMemoStart == index) {
         if (ifEnd$RuleMemoStart <= ifEnd$RuleMemoEnd) {
            index = ifEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (ifEnd$RuleMemoStart == ifEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_END, ifEnd$RuleMemoStart, ifEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(ifEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(ifEnd$RuleMemoFirstNode);
                  currentNode = ifEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("endif" | "endi") IgnoreRestOfLine)
      // ("endif" | "endi")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
         ++index;
         // ("ndif" | "ndi")
         if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
            ++index;
            // ("dif" | "di")
            if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
               ++index;
               // ("if" | "i")
               if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                  ++index;
                  // ("f" | <EMPTY>)
                  if (buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         ifEnd$RuleMemoStart = startIndex;
         ifEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            ifEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IF_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            ifEnd$RuleMemoFirstNode = currentNode;
            ifEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         ifEnd$RuleMemoStart = startIndex;
         ifEnd$RuleMemoEnd = -1;
         ifEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndKeyword : ("end" IgnoreRestOfLine)
   protected boolean endKeyword$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (endKeyword$RuleMemoStart == index) {
         if (endKeyword$RuleMemoStart <= endKeyword$RuleMemoEnd) {
            index = endKeyword$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (endKeyword$RuleMemoStart == endKeyword$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_KEYWORD, endKeyword$RuleMemoStart, endKeyword$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(endKeyword$RuleMemoFirstNode != null) {
                  lastNode.setSibling(endKeyword$RuleMemoFirstNode);
                  currentNode = endKeyword$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" IgnoreRestOfLine)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         endKeyword$RuleMemoStart = startIndex;
         endKeyword$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endKeyword$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_KEYWORD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            endKeyword$RuleMemoFirstNode = currentNode;
            endKeyword$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         endKeyword$RuleMemoStart = startIndex;
         endKeyword$RuleMemoEnd = -1;
         endKeyword$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoWhileBegin : (("do" TestNoAlpha OptionalSpacing)? ("while" | "whil") TestNoAlpha OptionalSpacing Condition)
   protected boolean doWhileBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doWhileBegin$RuleMemoStart == index) {
         if (doWhileBegin$RuleMemoStart <= doWhileBegin$RuleMemoEnd) {
            index = doWhileBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (doWhileBegin$RuleMemoStart == doWhileBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_BEGIN, doWhileBegin$RuleMemoStart, doWhileBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(doWhileBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(doWhileBegin$RuleMemoFirstNode);
                  currentNode = doWhileBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("do" TestNoAlpha OptionalSpacing)? ("while" | "whil") TestNoAlpha OptionalSpacing Condition)
      // ("do" TestNoAlpha OptionalSpacing)?
      // ("do" TestNoAlpha OptionalSpacing)
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      // "do"
      match = ignoreCaseStringMatcher("do", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (! match) {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
               currentNode = lastNode_1;
            }
         } else {
            index = lastIndex_1;
            lastNode_1.setSibling(null);
         }
      }
      match = true;
      // ("while" | "whil")
      int startIndex_2 = index;
      if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
         ++index;
         // ("hile" | "hil")
         if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
            ++index;
            // ("ile" | "il")
            if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
               ++index;
               // ("le" | "l")
               if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                  ++index;
                  // ("e" | <EMPTY>)
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         doWhileBegin$RuleMemoStart = startIndex;
         doWhileBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doWhileBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doWhileBegin$RuleMemoFirstNode = currentNode;
            doWhileBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         doWhileBegin$RuleMemoStart = startIndex;
         doWhileBegin$RuleMemoEnd = -1;
         doWhileBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoWhileEnd : (("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing) | (("enddo" | "endd") TestNoAlpha OptionalSpacing))
   protected boolean doWhileEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doWhileEnd$RuleMemoStart == index) {
         if (doWhileEnd$RuleMemoStart <= doWhileEnd$RuleMemoEnd) {
            index = doWhileEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (doWhileEnd$RuleMemoStart == doWhileEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_END, doWhileEnd$RuleMemoStart, doWhileEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(doWhileEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(doWhileEnd$RuleMemoFirstNode);
                  currentNode = doWhileEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing) | (("enddo" | "endd") TestNoAlpha OptionalSpacing))
      switch(buffer.getChar(index)) {
         case 'e':
         case 'E':
            // ("end" TestNoAlpha OptionalSpacing "do" TestNoAlpha OptionalSpacing)
            // "end"
            match = ignoreCaseStringMatcher("end", 3);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "do"
                     match = ignoreCaseStringMatcher("do", 2);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
            if (! match) {
               // (("enddo" | "endd") TestNoAlpha OptionalSpacing)
               // ("enddo" | "endd")
               int startIndex_1 = index;
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("nddo" | "ndd")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("ddo" | "dd")
                     if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                        ++index;
                        // ("do" | "d")
                        if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                           ++index;
                           // ("o" | <EMPTY>)
                           if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                              ++index;
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
               if (! match) {
                  index = startIndex_1;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         doWhileEnd$RuleMemoStart = startIndex;
         doWhileEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doWhileEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_WHILE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doWhileEnd$RuleMemoFirstNode = currentNode;
            doWhileEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         doWhileEnd$RuleMemoStart = startIndex;
         doWhileEnd$RuleMemoEnd = -1;
         doWhileEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForNextBegin : ("for" TestNoAlpha OptionalSpacing ForIndexInitialization "to" TestNoAlpha OptionalSpacing Expression Step)
   protected boolean forNextBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forNextBegin$RuleMemoStart == index) {
         if (forNextBegin$RuleMemoStart <= forNextBegin$RuleMemoEnd) {
            index = forNextBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (forNextBegin$RuleMemoStart == forNextBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_BEGIN, forNextBegin$RuleMemoStart, forNextBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(forNextBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(forNextBegin$RuleMemoFirstNode);
                  currentNode = forNextBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing ForIndexInitialization "to" TestNoAlpha OptionalSpacing Expression Step)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ForIndexInitialization
               match = forIndexInitialization$Rule();
               if (match) {
                  // "to"
                  match = ignoreCaseStringMatcher("to", 2);
                  if (match) {
                     // TestNoAlpha
                     match = testNoAlpha$Rule();
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // Expression
                           match = expression$Rule();
                           if (match) {
                              // Step
                              match = step$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forNextBegin$RuleMemoStart = startIndex;
         forNextBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forNextBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forNextBegin$RuleMemoFirstNode = currentNode;
            forNextBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         forNextBegin$RuleMemoStart = startIndex;
         forNextBegin$RuleMemoEnd = -1;
         forNextBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForNextEnd : ((("end" "for") | "next" | "endfor" | "endfo" | "endf") IgnoreRestOfLine)
   protected boolean forNextEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forNextEnd$RuleMemoStart == index) {
         if (forNextEnd$RuleMemoStart <= forNextEnd$RuleMemoEnd) {
            index = forNextEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (forNextEnd$RuleMemoStart == forNextEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_END, forNextEnd$RuleMemoStart, forNextEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(forNextEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(forNextEnd$RuleMemoFirstNode);
                  currentNode = forNextEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("end" "for") | "next" | "endfor" | "endfo" | "endf") IgnoreRestOfLine)
      // (("end" "for") | "next" | "endfor" | "endfo" | "endf")
      // ("end" "for")
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // "for"
         match = ignoreCaseStringMatcher("for", 3);
      }
      if (! match) {
         // "next"
         match = ignoreCaseStringMatcher("next", 4);
         if (! match) {
            // "endfor"
            match = ignoreCaseStringMatcher("endfor", 6);
            if (! match) {
               // "endfo"
               match = ignoreCaseStringMatcher("endfo", 5);
               if (! match) {
                  // "endf"
                  match = ignoreCaseStringMatcher("endf", 4);
               }
            }
         }
      }
      if (match) {
         // IgnoreRestOfLine
         match = ignoreRestOfLine$Rule();
      }
      if (match) {
         forNextEnd$RuleMemoStart = startIndex;
         forNextEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forNextEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_NEXT_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forNextEnd$RuleMemoFirstNode = currentNode;
            forNextEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         forNextEnd$RuleMemoStart = startIndex;
         forNextEnd$RuleMemoEnd = -1;
         forNextEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginSequenceBegin : (BeginSequenceKeyword WithCodeBlock)
   protected boolean beginSequenceBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginSequenceBegin$RuleMemoStart == index) {
         if (beginSequenceBegin$RuleMemoStart <= beginSequenceBegin$RuleMemoEnd) {
            index = beginSequenceBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (beginSequenceBegin$RuleMemoStart == beginSequenceBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_BEGIN, beginSequenceBegin$RuleMemoStart, beginSequenceBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(beginSequenceBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(beginSequenceBegin$RuleMemoFirstNode);
                  currentNode = beginSequenceBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (BeginSequenceKeyword WithCodeBlock)
      // BeginSequenceKeyword
      match = beginSequenceKeyword$Rule();
      if (match) {
         // WithCodeBlock
         match = withCodeBlock$Rule();
      }
      if (match) {
         beginSequenceBegin$RuleMemoStart = startIndex;
         beginSequenceBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginSequenceBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginSequenceBegin$RuleMemoFirstNode = currentNode;
            beginSequenceBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         beginSequenceBegin$RuleMemoStart = startIndex;
         beginSequenceBegin$RuleMemoEnd = -1;
         beginSequenceBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseBegin : ("do" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
   protected boolean doCaseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseBegin$RuleMemoStart == index) {
         if (doCaseBegin$RuleMemoStart <= doCaseBegin$RuleMemoEnd) {
            index = doCaseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (doCaseBegin$RuleMemoStart == doCaseBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_BEGIN, doCaseBegin$RuleMemoStart, doCaseBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(doCaseBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(doCaseBegin$RuleMemoFirstNode);
                  currentNode = doCaseBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("do" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
      // "do"
      match = ignoreCaseStringMatcher("do", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "case"
               match = ignoreCaseStringMatcher("case", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         doCaseBegin$RuleMemoStart = startIndex;
         doCaseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseBegin$RuleMemoFirstNode = currentNode;
            doCaseBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         doCaseBegin$RuleMemoStart = startIndex;
         doCaseBegin$RuleMemoEnd = -1;
         doCaseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseEnd : (("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing) | (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing))
   protected boolean doCaseEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseEnd$RuleMemoStart == index) {
         if (doCaseEnd$RuleMemoStart <= doCaseEnd$RuleMemoEnd) {
            index = doCaseEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (doCaseEnd$RuleMemoStart == doCaseEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_END, doCaseEnd$RuleMemoStart, doCaseEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(doCaseEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(doCaseEnd$RuleMemoFirstNode);
                  currentNode = doCaseEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing) | (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing))
      switch(buffer.getChar(index)) {
         case 'e':
         case 'E':
            // ("end" TestNoAlpha OptionalSpacing "case" TestNoAlpha OptionalSpacing)
            // "end"
            match = ignoreCaseStringMatcher("end", 3);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "case"
                     match = ignoreCaseStringMatcher("case", 4);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
            if (! match) {
               // (("endcase" | "endcas" | "endca" | "endc") TestNoAlpha OptionalSpacing)
               // ("endcase" | "endcas" | "endca" | "endc")
               int startIndex_1 = index;
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("ndcase" | "ndcas" | "ndca" | "ndc")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("dcase" | "dcas" | "dca" | "dc")
                     if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                        ++index;
                        // ("case" | "cas" | "ca" | "c")
                        if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                           ++index;
                           // ("ase" | "as" | "a" | <EMPTY>)
                           if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
               if (! match) {
                  index = startIndex_1;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         doCaseEnd$RuleMemoStart = startIndex;
         doCaseEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseEnd$RuleMemoFirstNode = currentNode;
            doCaseEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         doCaseEnd$RuleMemoStart = startIndex;
         doCaseEnd$RuleMemoEnd = -1;
         doCaseEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForEachBegin : ("for" TestNoAlpha OptionalSpacing "each" TestNoAlpha OptionalSpacing Variable "in" TestNoAlpha OptionalSpacing Expression)
   protected boolean forEachBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forEachBegin$RuleMemoStart == index) {
         if (forEachBegin$RuleMemoStart <= forEachBegin$RuleMemoEnd) {
            index = forEachBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (forEachBegin$RuleMemoStart == forEachBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_BEGIN, forEachBegin$RuleMemoStart, forEachBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(forEachBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(forEachBegin$RuleMemoFirstNode);
                  currentNode = forEachBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("for" TestNoAlpha OptionalSpacing "each" TestNoAlpha OptionalSpacing Variable "in" TestNoAlpha OptionalSpacing Expression)
      // "for"
      match = ignoreCaseStringMatcher("for", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "each"
               match = ignoreCaseStringMatcher("each", 4);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // Variable
                        match = variable$Rule();
                        if (match) {
                           // "in"
                           match = ignoreCaseStringMatcher("in", 2);
                           if (match) {
                              // TestNoAlpha
                              match = testNoAlpha$Rule();
                              if (match) {
                                 // OptionalSpacing
                                 match = optionalSpacing$Rule();
                                 if (match) {
                                    // Expression
                                    match = expression$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         forEachBegin$RuleMemoStart = startIndex;
         forEachBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forEachBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forEachBegin$RuleMemoFirstNode = currentNode;
            forEachBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         forEachBegin$RuleMemoStart = startIndex;
         forEachBegin$RuleMemoEnd = -1;
         forEachBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ForEachEnd : ("next" TestNoAlpha OptionalSpacing)
   protected boolean forEachEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (forEachEnd$RuleMemoStart == index) {
         if (forEachEnd$RuleMemoStart <= forEachEnd$RuleMemoEnd) {
            index = forEachEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (forEachEnd$RuleMemoStart == forEachEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_END, forEachEnd$RuleMemoStart, forEachEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(forEachEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(forEachEnd$RuleMemoFirstNode);
                  currentNode = forEachEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("next" TestNoAlpha OptionalSpacing)
      // "next"
      match = ignoreCaseStringMatcher("next", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         forEachEnd$RuleMemoStart = startIndex;
         forEachEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            forEachEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FOR_EACH_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            forEachEnd$RuleMemoFirstNode = currentNode;
            forEachEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         forEachEnd$RuleMemoStart = startIndex;
         forEachEnd$RuleMemoEnd = -1;
         forEachEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchBegin : (("switch" | "switc" | "swit") TestNoAlpha OptionalSpacing Expression)
   protected boolean switchBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchBegin$RuleMemoStart == index) {
         if (switchBegin$RuleMemoStart <= switchBegin$RuleMemoEnd) {
            index = switchBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (switchBegin$RuleMemoStart == switchBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_BEGIN, switchBegin$RuleMemoStart, switchBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(switchBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(switchBegin$RuleMemoFirstNode);
                  currentNode = switchBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("switch" | "switc" | "swit") TestNoAlpha OptionalSpacing Expression)
      // ("switch" | "switc" | "swit")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
         ++index;
         // ("witch" | "witc" | "wit")
         if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
            ++index;
            // ("itch" | "itc" | "it")
            if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
               ++index;
               // ("tch" | "tc" | "t")
               if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                  ++index;
                  // ("ch" | "c" | <EMPTY>)
                  if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                     ++index;
                     // "h"
                     if (match = buffer.matchIgnoreCaseChar(index, 'h')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         switchBegin$RuleMemoStart = startIndex;
         switchBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchBegin$RuleMemoFirstNode = currentNode;
            switchBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         switchBegin$RuleMemoStart = startIndex;
         switchBegin$RuleMemoEnd = -1;
         switchBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchEnd : ("end" TestNoAlpha OptionalSpacing "switch" TestNoAlpha OptionalSpacing)
   protected boolean switchEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchEnd$RuleMemoStart == index) {
         if (switchEnd$RuleMemoStart <= switchEnd$RuleMemoEnd) {
            index = switchEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (switchEnd$RuleMemoStart == switchEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_END, switchEnd$RuleMemoStart, switchEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(switchEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(switchEnd$RuleMemoFirstNode);
                  currentNode = switchEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "switch" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "switch"
               match = ignoreCaseStringMatcher("switch", 6);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         switchEnd$RuleMemoStart = startIndex;
         switchEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchEnd$RuleMemoFirstNode = currentNode;
            switchEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         switchEnd$RuleMemoStart = startIndex;
         switchEnd$RuleMemoEnd = -1;
         switchEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TryCatchBegin : ("try" TestNoAlpha OptionalSpacing)
   protected boolean tryCatchBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (tryCatchBegin$RuleMemoStart == index) {
         if (tryCatchBegin$RuleMemoStart <= tryCatchBegin$RuleMemoEnd) {
            index = tryCatchBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (tryCatchBegin$RuleMemoStart == tryCatchBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_BEGIN, tryCatchBegin$RuleMemoStart, tryCatchBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(tryCatchBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(tryCatchBegin$RuleMemoFirstNode);
                  currentNode = tryCatchBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("try" TestNoAlpha OptionalSpacing)
      // "try"
      match = ignoreCaseStringMatcher("try", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         tryCatchBegin$RuleMemoStart = startIndex;
         tryCatchBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tryCatchBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tryCatchBegin$RuleMemoFirstNode = currentNode;
            tryCatchBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         tryCatchBegin$RuleMemoStart = startIndex;
         tryCatchBegin$RuleMemoEnd = -1;
         tryCatchBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TryCatchEnd : ("end" TestNoAlpha OptionalSpacing "try" TestNoAlpha OptionalSpacing)
   protected boolean tryCatchEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (tryCatchEnd$RuleMemoStart == index) {
         if (tryCatchEnd$RuleMemoStart <= tryCatchEnd$RuleMemoEnd) {
            index = tryCatchEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (tryCatchEnd$RuleMemoStart == tryCatchEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_END, tryCatchEnd$RuleMemoStart, tryCatchEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(tryCatchEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(tryCatchEnd$RuleMemoFirstNode);
                  currentNode = tryCatchEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("end" TestNoAlpha OptionalSpacing "try" TestNoAlpha OptionalSpacing)
      // "end"
      match = ignoreCaseStringMatcher("end", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "try"
               match = ignoreCaseStringMatcher("try", 3);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         tryCatchEnd$RuleMemoStart = startIndex;
         tryCatchEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            tryCatchEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TRY_CATCH_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            tryCatchEnd$RuleMemoFirstNode = currentNode;
            tryCatchEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         tryCatchEnd$RuleMemoStart = startIndex;
         tryCatchEnd$RuleMemoEnd = -1;
         tryCatchEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FinallyBlockBegin : ("finally" TestNoAlpha OptionalSpacing)
   protected boolean finallyBlockBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (finallyBlockBegin$RuleMemoStart == index) {
         if (finallyBlockBegin$RuleMemoStart <= finallyBlockBegin$RuleMemoEnd) {
            index = finallyBlockBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (finallyBlockBegin$RuleMemoStart == finallyBlockBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FINALLY_BLOCK_BEGIN, finallyBlockBegin$RuleMemoStart, finallyBlockBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(finallyBlockBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(finallyBlockBegin$RuleMemoFirstNode);
                  currentNode = finallyBlockBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("finally" TestNoAlpha OptionalSpacing)
      // "finally"
      match = ignoreCaseStringMatcher("finally", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         finallyBlockBegin$RuleMemoStart = startIndex;
         finallyBlockBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            finallyBlockBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FINALLY_BLOCK_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            finallyBlockBegin$RuleMemoFirstNode = currentNode;
            finallyBlockBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         finallyBlockBegin$RuleMemoStart = startIndex;
         finallyBlockBegin$RuleMemoEnd = -1;
         finallyBlockBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Return : (("return" | "retur" | "retu") TestNoAlpha OptionalSpacing ExpressionAsType?)
   protected boolean return$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (return$RuleMemoStart == index) {
         if (return$RuleMemoStart <= return$RuleMemoEnd) {
            index = return$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (return$RuleMemoStart == return$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RETURN, return$RuleMemoStart, return$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(return$RuleMemoFirstNode != null) {
                  lastNode.setSibling(return$RuleMemoFirstNode);
                  currentNode = return$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("return" | "retur" | "retu") TestNoAlpha OptionalSpacing ExpressionAsType?)
      // ("return" | "retur" | "retu")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
         ++index;
         // ("eturn" | "etur" | "etu")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("turn" | "tur" | "tu")
            if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
               ++index;
               // ("urn" | "ur" | "u")
               if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                  ++index;
                  // ("rn" | "r" | <EMPTY>)
                  if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                     ++index;
                     // "n"
                     if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ExpressionAsType?
               // ExpressionAsType
               expressionAsType$Rule();
               match = true;
            }
         }
      }
      if (match) {
         return$RuleMemoStart = startIndex;
         return$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            return$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RETURN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            return$RuleMemoFirstNode = currentNode;
            return$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         return$RuleMemoStart = startIndex;
         return$RuleMemoEnd = -1;
         return$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Break : (("break" | "brea") TestNoAlpha OptionalSpacing Expression?)
   protected boolean break$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (break$RuleMemoStart == index) {
         if (break$RuleMemoStart <= break$RuleMemoEnd) {
            index = break$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (break$RuleMemoStart == break$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BREAK, break$RuleMemoStart, break$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(break$RuleMemoFirstNode != null) {
                  lastNode.setSibling(break$RuleMemoFirstNode);
                  currentNode = break$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("break" | "brea") TestNoAlpha OptionalSpacing Expression?)
      // ("break" | "brea")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
         ++index;
         // ("reak" | "rea")
         if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
            ++index;
            // ("eak" | "ea")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("ak" | "a")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("k" | <EMPTY>)
                  if (buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               // Expression
               expression$Rule();
               match = true;
            }
         }
      }
      if (match) {
         break$RuleMemoStart = startIndex;
         break$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            break$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BREAK, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            break$RuleMemoFirstNode = currentNode;
            break$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         break$RuleMemoStart = startIndex;
         break$RuleMemoEnd = -1;
         break$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClassMemberDeclaration : ('_HB_MEMBER' TestNoAlpha OptionalSpacing (MethodDeclaration | AttributeListDeclaration))
   protected boolean classMemberDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (classMemberDeclaration$RuleMemoStart == index) {
         if (classMemberDeclaration$RuleMemoStart <= classMemberDeclaration$RuleMemoEnd) {
            index = classMemberDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (classMemberDeclaration$RuleMemoStart == classMemberDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_MEMBER_DECLARATION, classMemberDeclaration$RuleMemoStart, classMemberDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(classMemberDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(classMemberDeclaration$RuleMemoFirstNode);
                  currentNode = classMemberDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('_HB_MEMBER' TestNoAlpha OptionalSpacing (MethodDeclaration | AttributeListDeclaration))
      // '_HB_MEMBER'
      match = stringMatcher("_HB_MEMBER", 10);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // (MethodDeclaration | AttributeListDeclaration)
               switch(buffer.getChar(index)) {
                  case '{':
                     // AttributeListDeclaration
                     match = attributeListDeclaration$Rule();
                     break;
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'I':
                  case 'J':
                  case 'K':
                  case 'L':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'S':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                  case 'g':
                  case 'h':
                  case 'i':
                  case 'j':
                  case 'k':
                  case 'l':
                  case 'm':
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 'r':
                  case 's':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'w':
                  case 'x':
                  case 'y':
                  case 'z':
                     // MethodDeclaration
                     match = methodDeclaration$Rule();
                     break;
                  default:
                     match = false;
               }
            }
         }
      }
      if (match) {
         classMemberDeclaration$RuleMemoStart = startIndex;
         classMemberDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            classMemberDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS_MEMBER_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            classMemberDeclaration$RuleMemoFirstNode = currentNode;
            classMemberDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         classMemberDeclaration$RuleMemoStart = startIndex;
         classMemberDeclaration$RuleMemoEnd = -1;
         classMemberDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PublicVariableDeclaration : (("public" | "publi" | "publ") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean publicVariableDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (publicVariableDeclaration$RuleMemoStart == index) {
         if (publicVariableDeclaration$RuleMemoStart <= publicVariableDeclaration$RuleMemoEnd) {
            index = publicVariableDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (publicVariableDeclaration$RuleMemoStart == publicVariableDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PUBLIC_VARIABLE_DECLARATION, publicVariableDeclaration$RuleMemoStart, publicVariableDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(publicVariableDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(publicVariableDeclaration$RuleMemoFirstNode);
                  currentNode = publicVariableDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("public" | "publi" | "publ") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("public" | "publi" | "publ")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P')) {
         ++index;
         // ("ublic" | "ubli" | "ubl")
         if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
            ++index;
            // ("blic" | "bli" | "bl")
            if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
               ++index;
               // ("lic" | "li" | "l")
               if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                  ++index;
                  // ("ic" | "i" | <EMPTY>)
                  if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                     ++index;
                     // "c"
                     if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         publicVariableDeclaration$RuleMemoStart = startIndex;
         publicVariableDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            publicVariableDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PUBLIC_VARIABLE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            publicVariableDeclaration$RuleMemoFirstNode = currentNode;
            publicVariableDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         publicVariableDeclaration$RuleMemoStart = startIndex;
         publicVariableDeclaration$RuleMemoEnd = -1;
         publicVariableDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrivateVariableDeclaration : (("private" | "privat" | "priva" | "priv") TestNoAlpha OptionalSpacing VariableDeclarationList)
   protected boolean privateVariableDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (privateVariableDeclaration$RuleMemoStart == index) {
         if (privateVariableDeclaration$RuleMemoStart <= privateVariableDeclaration$RuleMemoEnd) {
            index = privateVariableDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (privateVariableDeclaration$RuleMemoStart == privateVariableDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIVATE_VARIABLE_DECLARATION, privateVariableDeclaration$RuleMemoStart, privateVariableDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(privateVariableDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(privateVariableDeclaration$RuleMemoFirstNode);
                  currentNode = privateVariableDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("private" | "privat" | "priva" | "priv") TestNoAlpha OptionalSpacing VariableDeclarationList)
      // ("private" | "privat" | "priva" | "priv")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'p') || buffer.matchChar(index, 'P')) {
         ++index;
         // ("rivate" | "rivat" | "riva" | "riv")
         if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
            ++index;
            // ("ivate" | "ivat" | "iva" | "iv")
            if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
               ++index;
               // ("vate" | "vat" | "va" | "v")
               if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                  ++index;
                  // ("ate" | "at" | "a" | <EMPTY>)
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("te" | "t" | <EMPTY>)
                     if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                        ++index;
                        // "e"
                        if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // VariableDeclarationList
               match = variableDeclarationList$Rule();
            }
         }
      }
      if (match) {
         privateVariableDeclaration$RuleMemoStart = startIndex;
         privateVariableDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            privateVariableDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIVATE_VARIABLE_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            privateVariableDeclaration$RuleMemoFirstNode = currentNode;
            privateVariableDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         privateVariableDeclaration$RuleMemoStart = startIndex;
         privateVariableDeclaration$RuleMemoEnd = -1;
         privateVariableDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //External : (("external" | "externa" | "extern" | "exter" | "exte") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean external$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (external$RuleMemoStart == index) {
         if (external$RuleMemoStart <= external$RuleMemoEnd) {
            index = external$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (external$RuleMemoStart == external$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXTERNAL, external$RuleMemoStart, external$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(external$RuleMemoFirstNode != null) {
                  lastNode.setSibling(external$RuleMemoFirstNode);
                  currentNode = external$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("external" | "externa" | "extern" | "exter" | "exte") TestNoAlpha OptionalSpacing IdentifierList)
      // ("external" | "externa" | "extern" | "exter" | "exte")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
         ++index;
         // ("xternal" | "xterna" | "xtern" | "xter" | "xte")
         if (buffer.matchChar(index, 'x') || buffer.matchChar(index, 'X')) {
            ++index;
            // ("ternal" | "terna" | "tern" | "ter" | "te")
            if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
               ++index;
               // ("ernal" | "erna" | "ern" | "er" | "e")
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("rnal" | "rna" | "rn" | "r" | <EMPTY>)
                  if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                     ++index;
                     // ("nal" | "na" | "n" | <EMPTY>)
                     if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                        ++index;
                        // ("al" | "a" | <EMPTY>)
                        if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                           ++index;
                           // "l"
                           if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         external$RuleMemoStart = startIndex;
         external$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            external$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXTERNAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            external$RuleMemoFirstNode = currentNode;
            external$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         external$RuleMemoStart = startIndex;
         external$RuleMemoEnd = -1;
         external$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Announce : (("announce" | "announc" | "announ" | "annou" | "anno") TestNoAlpha OptionalSpacing Identifier)
   protected boolean announce$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (announce$RuleMemoStart == index) {
         if (announce$RuleMemoStart <= announce$RuleMemoEnd) {
            index = announce$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (announce$RuleMemoStart == announce$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANNOUNCE, announce$RuleMemoStart, announce$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(announce$RuleMemoFirstNode != null) {
                  lastNode.setSibling(announce$RuleMemoFirstNode);
                  currentNode = announce$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("announce" | "announc" | "announ" | "annou" | "anno") TestNoAlpha OptionalSpacing Identifier)
      // ("announce" | "announc" | "announ" | "annou" | "anno")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
         ++index;
         // ("nnounce" | "nnounc" | "nnoun" | "nnou" | "nno")
         if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
            ++index;
            // ("nounce" | "nounc" | "noun" | "nou" | "no")
            if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
               ++index;
               // ("ounce" | "ounc" | "oun" | "ou" | "o")
               if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                  ++index;
                  // ("unce" | "unc" | "un" | "u" | <EMPTY>)
                  if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                     ++index;
                     // ("nce" | "nc" | "n" | <EMPTY>)
                     if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                        ++index;
                        // ("ce" | "c" | <EMPTY>)
                        if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                           ++index;
                           // "e"
                           if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Identifier
               match = identifier$Rule();
            }
         }
      }
      if (match) {
         announce$RuleMemoStart = startIndex;
         announce$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            announce$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANNOUNCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            announce$RuleMemoFirstNode = currentNode;
            announce$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         announce$RuleMemoStart = startIndex;
         announce$RuleMemoEnd = -1;
         announce$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Request : (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing IdentifierList)
   protected boolean request$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (request$RuleMemoStart == index) {
         if (request$RuleMemoStart <= request$RuleMemoEnd) {
            index = request$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (request$RuleMemoStart == request$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST, request$RuleMemoStart, request$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(request$RuleMemoFirstNode != null) {
                  lastNode.setSibling(request$RuleMemoFirstNode);
                  currentNode = request$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("request" | "reques" | "reque" | "requ") TestNoAlpha OptionalSpacing IdentifierList)
      // ("request" | "reques" | "reque" | "requ")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
         ++index;
         // ("equest" | "eques" | "eque" | "equ")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("quest" | "ques" | "que" | "qu")
            if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
               ++index;
               // ("uest" | "ues" | "ue" | "u")
               if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                  ++index;
                  // ("est" | "es" | "e" | <EMPTY>)
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("st" | "s" | <EMPTY>)
                     if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                        ++index;
                        // "t"
                        if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // IdentifierList
               match = identifierList$Rule();
            }
         }
      }
      if (match) {
         request$RuleMemoStart = startIndex;
         request$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            request$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.REQUEST, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            request$RuleMemoFirstNode = currentNode;
            request$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         request$RuleMemoStart = startIndex;
         request$RuleMemoEnd = -1;
         request$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Throw : ("throw" TestNoAlpha OptionalSpacing '(' OptionalSpacing Expression ')' OptionalSpacing)
   protected boolean throw$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (throw$RuleMemoStart == index) {
         if (throw$RuleMemoStart <= throw$RuleMemoEnd) {
            index = throw$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (throw$RuleMemoStart == throw$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.THROW, throw$RuleMemoStart, throw$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(throw$RuleMemoFirstNode != null) {
                  lastNode.setSibling(throw$RuleMemoFirstNode);
                  currentNode = throw$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("throw" TestNoAlpha OptionalSpacing '(' OptionalSpacing Expression ')' OptionalSpacing)
      // "throw"
      match = ignoreCaseStringMatcher("throw", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // '('
               match = charMatcher('(');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // Expression
                     match = expression$Rule();
                     if (match) {
                        // ')'
                        match = charMatcher(')');
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         throw$RuleMemoStart = startIndex;
         throw$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            throw$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.THROW, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            throw$RuleMemoFirstNode = currentNode;
            throw$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         throw$RuleMemoStart = startIndex;
         throw$RuleMemoEnd = -1;
         throw$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StatementAssignmentExpression : (LeftValue AssignOperator (ValueByReference | Expression))
   protected boolean statementAssignmentExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (statementAssignmentExpression$RuleMemoStart == index) {
         if (statementAssignmentExpression$RuleMemoStart <= statementAssignmentExpression$RuleMemoEnd) {
            index = statementAssignmentExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (statementAssignmentExpression$RuleMemoStart == statementAssignmentExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT_ASSIGNMENT_EXPRESSION, statementAssignmentExpression$RuleMemoStart, statementAssignmentExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(statementAssignmentExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(statementAssignmentExpression$RuleMemoFirstNode);
                  currentNode = statementAssignmentExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LeftValue AssignOperator (ValueByReference | Expression))
      // LeftValue
      match = leftValue$Rule();
      if (match) {
         // AssignOperator
         match = assignOperator$Rule();
         if (match) {
            // (ValueByReference | Expression)
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '&':
               case '\'':
               case '(':
               case '+':
               case '-':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{':
                  // Expression
                  match = expression$Rule();
                  break;
               case '@':
                  // ValueByReference
                  match = valueByReference$Rule();
                  break;
               default:
                  match = false;
            }
         }
      }
      if (match) {
         statementAssignmentExpression$RuleMemoStart = startIndex;
         statementAssignmentExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            statementAssignmentExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STATEMENT_ASSIGNMENT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            statementAssignmentExpression$RuleMemoFirstNode = currentNode;
            statementAssignmentExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         statementAssignmentExpression$RuleMemoStart = startIndex;
         statementAssignmentExpression$RuleMemoEnd = -1;
         statementAssignmentExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SelfExpression : ('::' OptionalSpacing PrimaryExpression)
   protected boolean selfExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (selfExpression$RuleMemoStart == index) {
         if (selfExpression$RuleMemoStart <= selfExpression$RuleMemoEnd) {
            index = selfExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (selfExpression$RuleMemoStart == selfExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELF_EXPRESSION, selfExpression$RuleMemoStart, selfExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(selfExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(selfExpression$RuleMemoFirstNode);
                  currentNode = selfExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('::' OptionalSpacing PrimaryExpression)
      // '::'
      match = stringMatcher("::", 2);
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // PrimaryExpression
            match = primaryExpression$Rule();
         }
      }
      if (match) {
         selfExpression$RuleMemoStart = startIndex;
         selfExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            selfExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SELF_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            selfExpression$RuleMemoFirstNode = currentNode;
            selfExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         selfExpression$RuleMemoStart = startIndex;
         selfExpression$RuleMemoEnd = -1;
         selfExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedMacro : (AliasIdentifier '->' OptionalSpacing Macro)
   protected boolean aliasedMacro$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedMacro$RuleMemoStart == index) {
         if (aliasedMacro$RuleMemoStart <= aliasedMacro$RuleMemoEnd) {
            index = aliasedMacro$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (aliasedMacro$RuleMemoStart == aliasedMacro$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_MACRO, aliasedMacro$RuleMemoStart, aliasedMacro$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(aliasedMacro$RuleMemoFirstNode != null) {
                  lastNode.setSibling(aliasedMacro$RuleMemoFirstNode);
                  currentNode = aliasedMacro$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing Macro)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Macro
               match = macro$Rule();
            }
         }
      }
      if (match) {
         aliasedMacro$RuleMemoStart = startIndex;
         aliasedMacro$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedMacro$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_MACRO, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedMacro$RuleMemoFirstNode = currentNode;
            aliasedMacro$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         aliasedMacro$RuleMemoStart = startIndex;
         aliasedMacro$RuleMemoEnd = -1;
         aliasedMacro$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //QualifiedExpression : (AtomicExpression (':' OptionalSpacing MemberCall)+)
   protected boolean qualifiedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (qualifiedExpression$RuleMemoStart == index) {
         if (qualifiedExpression$RuleMemoStart <= qualifiedExpression$RuleMemoEnd) {
            index = qualifiedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (qualifiedExpression$RuleMemoStart == qualifiedExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_EXPRESSION, qualifiedExpression$RuleMemoStart, qualifiedExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(qualifiedExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(qualifiedExpression$RuleMemoFirstNode);
                  currentNode = qualifiedExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AtomicExpression (':' OptionalSpacing MemberCall)+)
      // AtomicExpression
      match = atomicExpression$Rule();
      if (match) {
         // (':' OptionalSpacing MemberCall)+
         // (':' OptionalSpacing MemberCall)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ':'
         match = charMatcher(':');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // MemberCall
               match = memberCall$Rule();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
         if (match) {
            do {
               // (':' OptionalSpacing MemberCall)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ':'
               match = charMatcher(':');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // MemberCall
                     match = memberCall$Rule();
                     if (! match) {
                        index = lastIndex_2;
                        lastNode_2.setSibling(null);
                        currentNode = lastNode_2;
                     }
                  } else {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                  }
               }
            } while(match);
            match = true;
         }
      }
      if (match) {
         qualifiedExpression$RuleMemoStart = startIndex;
         qualifiedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            qualifiedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.QUALIFIED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            qualifiedExpression$RuleMemoFirstNode = currentNode;
            qualifiedExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         qualifiedExpression$RuleMemoStart = startIndex;
         qualifiedExpression$RuleMemoEnd = -1;
         qualifiedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MemberCall : (ArrayAccess | MacroFunctionCall | AnySimpleFunctionCall | AnyIdentifier)
   protected boolean memberCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ArrayAccess | MacroFunctionCall | AnySimpleFunctionCall | AnyIdentifier)
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '(':
         case '[':
         case '{':
            // ArrayAccess
            match = arrayAccess$Rule();
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // MacroFunctionCall
               match = macroFunctionCall$Rule();
            }
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // MacroFunctionCall
               match = macroFunctionCall$Rule();
               if (! match) {
                  // AnySimpleFunctionCall
                  match = anySimpleFunctionCall$Rule();
                  if (! match) {
                     // AnyIdentifier
                     match = anyIdentifier$Rule();
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MEMBER_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeywordsFunctionCall : ((("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing) ParParameters)
   protected boolean keywordsFunctionCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keywordsFunctionCall$RuleMemoStart == index) {
         if (keywordsFunctionCall$RuleMemoStart <= keywordsFunctionCall$RuleMemoEnd) {
            index = keywordsFunctionCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (keywordsFunctionCall$RuleMemoStart == keywordsFunctionCall$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYWORDS_FUNCTION_CALL, keywordsFunctionCall$RuleMemoStart, keywordsFunctionCall$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(keywordsFunctionCall$RuleMemoFirstNode != null) {
                  lastNode.setSibling(keywordsFunctionCall$RuleMemoFirstNode);
                  currentNode = keywordsFunctionCall$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing) ParParameters)
      // (("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom") TestNoAlpha OptionalSpacing)
      // ("begin" | "break" | "brea" | "class" | "clas" | "command" | "comman" | "comma" | "comm" | "else" | "field" | "fiel" | "declare" | "declar" | "decla" | "decl" | "default" | "define" | "defin" | "defi" | "do" | "each" | "exit" | "external" | "externa" | "extern" | "exter" | "exte" | "function" | "functio" | "functi" | "funct" | "func" | "init" | "loop" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "step" | "to" | "translate" | "translat" | "transla" | "transl" | "trans" | "tran" | "xtranslate" | "xtranslat" | "xtransla" | "xtransl" | "xtrans" | "xtran" | "xtra" | "xcommand" | "xcomman" | "xcomma" | "xcomm" | "xcom")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F':
            ++index;
            // ("unction" | "unctio" | "uncti" | "ield" | "unct" | "iel" | "unc")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I':
                  ++index;
                  // ("eld" | "el")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("ld" | "l")
                     if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                        ++index;
                        // ("d" | <EMPTY>)
                        if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'u':
               case 'U':
                  ++index;
                  // ("nction" | "nctio" | "ncti" | "nct" | "nc")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("ction" | "ctio" | "cti" | "ct" | "c")
                     if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                        ++index;
                        // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                        if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                           ++index;
                           // ("ion" | "io" | "i" | <EMPTY>)
                           if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                              ++index;
                              // ("on" | "o" | <EMPTY>)
                              if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                                 ++index;
                                 // "n"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'x':
         case 'X':
            ++index;
            // ("translate" | "translat" | "transla" | "command" | "transl" | "comman" | "trans" | "comma" | "tran" | "comm" | "tra" | "com")
            switch(buffer.getChar(index)) {
               case 'c':
               case 'C':
                  ++index;
                  // ("ommand" | "omman" | "omma" | "omm" | "om")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("mmand" | "mman" | "mma" | "mm" | "m")
                     if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                        ++index;
                        // ("mand" | "man" | "ma" | "m" | <EMPTY>)
                        if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                           ++index;
                           // ("and" | "an" | "a" | <EMPTY>)
                           if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                              ++index;
                              // ("nd" | "n" | <EMPTY>)
                              if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                 ++index;
                                 // "d"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 't':
               case 'T':
                  ++index;
                  // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "ra")
                  if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                     ++index;
                     // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an" | "a")
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n" | <EMPTY>)
                        if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                           ++index;
                           // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                           if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                              ++index;
                              // ("late" | "lat" | "la" | "l" | <EMPTY>)
                              if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                                 ++index;
                                 // ("ate" | "at" | "a" | <EMPTY>)
                                 if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                                    ++index;
                                    // ("te" | "t" | <EMPTY>)
                                    if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                                       ++index;
                                       // "e"
                                       if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                          ++index;
                                       }
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'i':
         case 'I':
            ++index;
            // "nit"
            if (match = ignoreCaseStringTest("nit", 3)) {
               index += 3;
            }
            break;
         case 'l':
         case 'L':
            ++index;
            // "oop"
            if (match = ignoreCaseStringTest("oop", 3)) {
               index += 3;
            }
            break;
         case 'o':
         case 'O':
            ++index;
            // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
            if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
               ++index;
               // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
               if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
                  ++index;
                  // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                     if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                        ++index;
                        // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                        if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
                           ++index;
                           // ("ise" | "is" | "i" | <EMPTY>)
                           if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'p':
         case 'P':
            ++index;
            // ("rocedure" | "rocedur" | "rocedu" | "roced" | "ublic" | "roce" | "ubli" | "roc" | "ubl")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R':
                  ++index;
                  // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                     if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                        ++index;
                        // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                           if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                              ++index;
                              // ("ure" | "ur" | "u" | <EMPTY>)
                              if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                                 ++index;
                                 // ("re" | "r" | <EMPTY>)
                                 if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                    ++index;
                                    // "e"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'u':
               case 'U':
                  ++index;
                  // ("blic" | "bli" | "bl")
                  if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
                     ++index;
                     // ("lic" | "li" | "l")
                     if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // "c"
                           if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'b':
         case 'B':
            ++index;
            // ("egin" | "reak" | "rea")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R':
                  ++index;
                  // ("eak" | "ea")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("ak" | "a")
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // ("k" | <EMPTY>)
                        if (buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // "gin"
                  if (match = ignoreCaseStringTest("gin", 3)) {
                     index += 3;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'r':
         case 'R':
            ++index;
            // ("ecover" | "ecove" | "ecov" | "eco")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("cover" | "cove" | "cov" | "co")
               if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                  ++index;
                  // ("over" | "ove" | "ov" | "o")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("ver" | "ve" | "v" | <EMPTY>)
                     if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                        ++index;
                        // ("er" | "e" | <EMPTY>)
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // "r"
                           if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'c':
         case 'C':
            ++index;
            // ("ommand" | "omman" | "lass" | "omma" | "las" | "omm")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // ("mmand" | "mman" | "mma" | "mm")
                  if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                     ++index;
                     // ("mand" | "man" | "ma" | "m")
                     if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                        ++index;
                        // ("and" | "an" | "a" | <EMPTY>)
                        if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                           ++index;
                           // ("nd" | "n" | <EMPTY>)
                           if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                              ++index;
                              // "d"
                              if (match = buffer.matchIgnoreCaseChar(index, 'd')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'l':
               case 'L':
                  ++index;
                  // ("ass" | "as")
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("ss" | "s")
                     if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                        ++index;
                        // ("s" | <EMPTY>)
                        if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 's':
         case 'S':
            ++index;
            // ("equence" | "equenc" | "equen" | "eque" | "equ" | "tep")
            switch(buffer.getChar(index)) {
               case 't':
               case 'T':
                  ++index;
                  // "ep"
                  if (match = ignoreCaseStringTest("ep", 2)) {
                     index += 2;
                  }
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // ("quence" | "quenc" | "quen" | "que" | "qu")
                  if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
                     ++index;
                     // ("uence" | "uenc" | "uen" | "ue" | "u")
                     if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                        ++index;
                        // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("nce" | "nc" | "n" | <EMPTY>)
                           if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                              ++index;
                              // ("ce" | "c" | <EMPTY>)
                              if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'd':
         case 'D':
            ++index;
            // ("eclare" | "efault" | "eclar" | "efine" | "ecla" | "efin" | "ecl" | "efi" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // ("clare" | "fault" | "clar" | "fine" | "cla" | "fin" | "cl" | "fi")
                  switch(buffer.getChar(index)) {
                     case 'f':
                     case 'F':
                        ++index;
                        // ("ault" | "ine" | "in" | "i")
                        switch(buffer.getChar(index)) {
                           case 'a':
                           case 'A':
                              ++index;
                              // "ult"
                              if (match = ignoreCaseStringTest("ult", 3)) {
                                 index += 3;
                              }
                              break;
                           case 'i':
                           case 'I':
                              ++index;
                              // ("ne" | "n" | <EMPTY>)
                              if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                              break;
                           default:
                              match = false;
                        }
                        break;
                     case 'c':
                     case 'C':
                        ++index;
                        // ("lare" | "lar" | "la" | "l")
                        if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                           ++index;
                           // ("are" | "ar" | "a" | <EMPTY>)
                           if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                              ++index;
                              // ("re" | "r" | <EMPTY>)
                              if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                        break;
                     default:
                        match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 't':
         case 'T':
            ++index;
            // ("ranslate" | "ranslat" | "ransla" | "ransl" | "rans" | "ran" | "o")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case 'r':
               case 'R':
                  ++index;
                  // ("anslate" | "anslat" | "ansla" | "ansl" | "ans" | "an")
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("nslate" | "nslat" | "nsla" | "nsl" | "ns" | "n")
                     if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                        ++index;
                        // ("slate" | "slat" | "sla" | "sl" | "s" | <EMPTY>)
                        if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                           ++index;
                           // ("late" | "lat" | "la" | "l" | <EMPTY>)
                           if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                              ++index;
                              // ("ate" | "at" | "a" | <EMPTY>)
                              if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                                 ++index;
                                 // ("te" | "t" | <EMPTY>)
                                 if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                                    ++index;
                                    // "e"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'e':
         case 'E':
            ++index;
            // ("xternal" | "xterna" | "xtern" | "xter" | "lse" | "ach" | "xit" | "xte")
            switch(buffer.getChar(index)) {
               case 'x':
               case 'X':
                  ++index;
                  // ("ternal" | "terna" | "tern" | "ter" | "it" | "te")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I':
                        ++index;
                        // "t"
                        if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                        }
                        break;
                     case 't':
                     case 'T':
                        ++index;
                        // ("ernal" | "erna" | "ern" | "er" | "e")
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("rnal" | "rna" | "rn" | "r" | <EMPTY>)
                           if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                              ++index;
                              // ("nal" | "na" | "n" | <EMPTY>)
                              if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                 ++index;
                                 // ("al" | "a" | <EMPTY>)
                                 if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                                    ++index;
                                    // "l"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                        break;
                     default:
                        match = false;
                  }
                  break;
               case 'a':
               case 'A':
                  ++index;
                  // "ch"
                  if (match = ignoreCaseStringTest("ch", 2)) {
                     index += 2;
                  }
                  break;
               case 'l':
               case 'L':
                  ++index;
                  // "se"
                  if (match = ignoreCaseStringTest("se", 2)) {
                     index += 2;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         // ParParameters
         match = parParameters$Rule();
      }
      if (match) {
         keywordsFunctionCall$RuleMemoStart = startIndex;
         keywordsFunctionCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keywordsFunctionCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYWORDS_FUNCTION_CALL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keywordsFunctionCall$RuleMemoFirstNode = currentNode;
            keywordsFunctionCall$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         keywordsFunctionCall$RuleMemoStart = startIndex;
         keywordsFunctionCall$RuleMemoEnd = -1;
         keywordsFunctionCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MethodDeclaration : (Identifier ParParametersDeclaration)
   protected boolean methodDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (methodDeclaration$RuleMemoStart == index) {
         if (methodDeclaration$RuleMemoStart <= methodDeclaration$RuleMemoEnd) {
            index = methodDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (methodDeclaration$RuleMemoStart == methodDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DECLARATION, methodDeclaration$RuleMemoStart, methodDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(methodDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(methodDeclaration$RuleMemoFirstNode);
                  currentNode = methodDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier ParParametersDeclaration)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // ParParametersDeclaration
         match = parParametersDeclaration$Rule();
      }
      if (match) {
         methodDeclaration$RuleMemoStart = startIndex;
         methodDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            methodDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.METHOD_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            methodDeclaration$RuleMemoFirstNode = currentNode;
            methodDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         methodDeclaration$RuleMemoStart = startIndex;
         methodDeclaration$RuleMemoEnd = -1;
         methodDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParParametersDeclaration : ('(' OptionalSpacing ParametersDeclaration ')' OptionalSpacing)
   protected boolean parParametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parParametersDeclaration$RuleMemoStart == index) {
         if (parParametersDeclaration$RuleMemoStart <= parParametersDeclaration$RuleMemoEnd) {
            index = parParametersDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parParametersDeclaration$RuleMemoStart == parParametersDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS_DECLARATION, parParametersDeclaration$RuleMemoStart, parParametersDeclaration$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(parParametersDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parParametersDeclaration$RuleMemoFirstNode);
                  currentNode = parParametersDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing ParametersDeclaration ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ParametersDeclaration
            match = parametersDeclaration$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parParametersDeclaration$RuleMemoStart = startIndex;
         parParametersDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parParametersDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PAR_PARAMETERS_DECLARATION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parParametersDeclaration$RuleMemoFirstNode = currentNode;
            parParametersDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parParametersDeclaration$RuleMemoStart = startIndex;
         parParametersDeclaration$RuleMemoEnd = -1;
         parParametersDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AttributeListDeclaration : ('{' OptionalSpacing IdentifierList '}' OptionalSpacing)
   protected boolean attributeListDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (attributeListDeclaration$RuleMemoStart == index) {
         if (attributeListDeclaration$RuleMemoStart <= attributeListDeclaration$RuleMemoEnd) {
            index = attributeListDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (attributeListDeclaration$RuleMemoStart == attributeListDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATTRIBUTE_LIST_DECLARATION, attributeListDeclaration$RuleMemoStart, attributeListDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(attributeListDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(attributeListDeclaration$RuleMemoFirstNode);
                  currentNode = attributeListDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('{' OptionalSpacing IdentifierList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IdentifierList
            match = identifierList$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         attributeListDeclaration$RuleMemoStart = startIndex;
         attributeListDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            attributeListDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATTRIBUTE_LIST_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            attributeListDeclaration$RuleMemoFirstNode = currentNode;
            attributeListDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         attributeListDeclaration$RuleMemoStart = startIndex;
         attributeListDeclaration$RuleMemoEnd = -1;
         attributeListDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroPrefix : (Letter | Digit | '_')*
   protected boolean macroPrefix$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (Letter | Digit | '_')*
      do {
         // (Letter | Digit | '_')
         // ('a'-'z' | 'A'-'Z')
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
         }
         if (! match) {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
            if (! match) {
               // '_'
               match = charMatcher('_');
            }
         }
      } while(match);
      currentRuleIsAtomic = lastRuleIsAtomic;
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_PREFIX, startIndex, index, true, false);
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //MacroSufix : ('.' (Letter | Digit | '_')*)
   protected boolean macroSufix$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('.' (Letter | Digit | '_')*)
      // '.'
      match = charMatcher('.');
      if (match) {
         // (Letter | Digit | '_')*
         do {
            // (Letter | Digit | '_')
            // ('a'-'z' | 'A'-'Z')
            // 'a'-'z'
            match = charRangeMatcher('a', 'z');
            if (! match) {
               // 'A'-'Z'
               match = charRangeMatcher('A', 'Z');
            }
            if (! match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (! match) {
                  // '_'
                  match = charMatcher('_');
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_SUFIX, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroVar : (MacroPrefix '&' OptionalSpacing MacroVarName MacroSufix? OptionalSpacing)
   protected boolean macroVar$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroVar$RuleMemoStart == index) {
         if (macroVar$RuleMemoStart <= macroVar$RuleMemoEnd) {
            index = macroVar$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (macroVar$RuleMemoStart == macroVar$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_VAR, macroVar$RuleMemoStart, macroVar$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(macroVar$RuleMemoFirstNode != null) {
                  lastNode.setSibling(macroVar$RuleMemoFirstNode);
                  currentNode = macroVar$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (MacroPrefix '&' OptionalSpacing MacroVarName MacroSufix? OptionalSpacing)
      // MacroPrefix
      match = macroPrefix$Rule();
      if (match) {
         // '&'
         match = charMatcher('&');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // MacroVarName
               match = macroVarName$Rule();
               if (match) {
                  // MacroSufix?
                  // MacroSufix
                  macroSufix$Rule();
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         macroVar$RuleMemoStart = startIndex;
         macroVar$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroVar$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_VAR, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroVar$RuleMemoFirstNode = currentNode;
            macroVar$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         macroVar$RuleMemoStart = startIndex;
         macroVar$RuleMemoEnd = -1;
         macroVar$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroVarName : IdentifierPattern
   protected boolean macroVarName$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VARIABLE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MacroExpression : ('&' OptionalSpacing ParenthesesExpressionList)
   protected boolean macroExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (macroExpression$RuleMemoStart == index) {
         if (macroExpression$RuleMemoStart <= macroExpression$RuleMemoEnd) {
            index = macroExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (macroExpression$RuleMemoStart == macroExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_EXPRESSION, macroExpression$RuleMemoStart, macroExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(macroExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(macroExpression$RuleMemoFirstNode);
                  currentNode = macroExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('&' OptionalSpacing ParenthesesExpressionList)
      // '&'
      match = charMatcher('&');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ParenthesesExpressionList
            match = parenthesesExpressionList$Rule();
         }
      }
      if (match) {
         macroExpression$RuleMemoStart = startIndex;
         macroExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            macroExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MACRO_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            macroExpression$RuleMemoFirstNode = currentNode;
            macroExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         macroExpression$RuleMemoStart = startIndex;
         macroExpression$RuleMemoEnd = -1;
         macroExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionReference : (AnyIdentifier '(' OptionalSpacing ')' OptionalSpacing)
   protected boolean functionReference$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionReference$RuleMemoStart == index) {
         if (functionReference$RuleMemoStart <= functionReference$RuleMemoEnd) {
            index = functionReference$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (functionReference$RuleMemoStart == functionReference$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_REFERENCE, functionReference$RuleMemoStart, functionReference$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(functionReference$RuleMemoFirstNode != null) {
                  lastNode.setSibling(functionReference$RuleMemoFirstNode);
                  currentNode = functionReference$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AnyIdentifier '(' OptionalSpacing ')' OptionalSpacing)
      // AnyIdentifier
      match = anyIdentifier$Rule();
      if (match) {
         // '('
         match = charMatcher('(');
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         functionReference$RuleMemoStart = startIndex;
         functionReference$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            functionReference$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_REFERENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            functionReference$RuleMemoFirstNode = currentNode;
            functionReference$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         functionReference$RuleMemoStart = startIndex;
         functionReference$RuleMemoEnd = -1;
         functionReference$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ValueByReference : ('@' OptionalSpacing (FunctionReference | AliasedField | QualifiedVariable | Variable))
   protected boolean valueByReference$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (valueByReference$RuleMemoStart == index) {
         if (valueByReference$RuleMemoStart <= valueByReference$RuleMemoEnd) {
            index = valueByReference$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (valueByReference$RuleMemoStart == valueByReference$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUE_BY_REFERENCE, valueByReference$RuleMemoStart, valueByReference$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(valueByReference$RuleMemoFirstNode != null) {
                  lastNode.setSibling(valueByReference$RuleMemoFirstNode);
                  currentNode = valueByReference$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('@' OptionalSpacing (FunctionReference | AliasedField | QualifiedVariable | Variable))
      // '@'
      match = charMatcher('@');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (FunctionReference | AliasedField | QualifiedVariable | Variable)
            switch(buffer.getChar(index)) {
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '&':
               case '7':
               case '8':
               case '(':
               case '9':
                  // AliasedField
                  match = aliasedField$Rule();
                  break;
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
                  // FunctionReference
                  match = functionReference$Rule();
                  if (! match) {
                     // AliasedField
                     match = aliasedField$Rule();
                     if (! match) {
                        // QualifiedVariable
                        match = qualifiedVariable$Rule();
                        if (! match) {
                           // Variable
                           match = variable$Rule();
                        }
                     }
                  }
                  break;
               default:
                  match = false;
            }
         }
      }
      if (match) {
         valueByReference$RuleMemoStart = startIndex;
         valueByReference$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            valueByReference$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.VALUE_BY_REFERENCE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            valueByReference$RuleMemoFirstNode = currentNode;
            valueByReference$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         valueByReference$RuleMemoStart = startIndex;
         valueByReference$RuleMemoEnd = -1;
         valueByReference$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AliasedField : (AliasIdentifier '->' OptionalSpacing AnyIdentifier)
   protected boolean aliasedField$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (aliasedField$RuleMemoStart == index) {
         if (aliasedField$RuleMemoStart <= aliasedField$RuleMemoEnd) {
            index = aliasedField$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (aliasedField$RuleMemoStart == aliasedField$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD, aliasedField$RuleMemoStart, aliasedField$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(aliasedField$RuleMemoFirstNode != null) {
                  lastNode.setSibling(aliasedField$RuleMemoFirstNode);
                  currentNode = aliasedField$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AliasIdentifier '->' OptionalSpacing AnyIdentifier)
      // AliasIdentifier
      match = aliasIdentifier$Rule();
      if (match) {
         // '->'
         match = stringMatcher("->", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // AnyIdentifier
               match = anyIdentifier$Rule();
            }
         }
      }
      if (match) {
         aliasedField$RuleMemoStart = startIndex;
         aliasedField$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aliasedField$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALIASED_FIELD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            aliasedField$RuleMemoFirstNode = currentNode;
            aliasedField$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         aliasedField$RuleMemoStart = startIndex;
         aliasedField$RuleMemoEnd = -1;
         aliasedField$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Parameter : (ValueByReference | Expression | ')'& | ','&)
   protected boolean parameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parameter$RuleMemoStart == index) {
         if (parameter$RuleMemoStart <= parameter$RuleMemoEnd) {
            index = parameter$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parameter$RuleMemoStart == parameter$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER, parameter$RuleMemoStart, parameter$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(parameter$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parameter$RuleMemoFirstNode);
                  currentNode = parameter$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ValueByReference | Expression | ')'& | ','&)
      // ValueByReference
      match = valueByReference$Rule();
      if (! match) {
         // Expression
         match = expression$Rule();
         if (! match) {
            // ')'&
            // ')'
            match = buffer.matchChar(index, ')');
            if (! match) {
               // ','&
               // ','
               match = buffer.matchChar(index, ',');
            }
         }
      }
      if (match) {
         parameter$RuleMemoStart = startIndex;
         parameter$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parameter$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parameter$RuleMemoFirstNode = currentNode;
            parameter$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parameter$RuleMemoStart = startIndex;
         parameter$RuleMemoEnd = -1;
         parameter$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaParameter : (',' OptionalSpacing Parameter)
   protected boolean commaParameter$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (',' OptionalSpacing Parameter)
      // ','
      match = charMatcher(',');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // Parameter
            match = parameter$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_PARAMETER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParameterCommaList : CommaParameter*
   protected boolean parameterCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaParameter*
      do {
         // CommaParameter
         match = commaParameter$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ParametersList : (Parameter ParameterCommaList)
   protected boolean parametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parametersList$RuleMemoStart == index) {
         if (parametersList$RuleMemoStart <= parametersList$RuleMemoEnd) {
            index = parametersList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parametersList$RuleMemoStart == parametersList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_LIST, parametersList$RuleMemoStart, parametersList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(parametersList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parametersList$RuleMemoFirstNode);
                  currentNode = parametersList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Parameter ParameterCommaList)
      // Parameter
      match = parameter$Rule();
      if (match) {
         // ParameterCommaList
         match = parameterCommaList$Rule();
      }
      if (match) {
         parametersList$RuleMemoStart = startIndex;
         parametersList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parametersList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parametersList$RuleMemoFirstNode = currentNode;
            parametersList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parametersList$RuleMemoStart = startIndex;
         parametersList$RuleMemoEnd = -1;
         parametersList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OptionalParametersList : ParametersList?
   protected boolean optionalParametersList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalParametersList$RuleMemoStart == index) {
         if (optionalParametersList$RuleMemoStart <= optionalParametersList$RuleMemoEnd) {
            index = optionalParametersList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (optionalParametersList$RuleMemoStart == optionalParametersList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_PARAMETERS_LIST, optionalParametersList$RuleMemoStart, optionalParametersList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(optionalParametersList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(optionalParametersList$RuleMemoFirstNode);
                  currentNode = optionalParametersList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ParametersList?
      // ParametersList
      parametersList$Rule();
      optionalParametersList$RuleMemoStart = startIndex;
      optionalParametersList$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         optionalParametersList$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.OPTIONAL_PARAMETERS_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         optionalParametersList$RuleMemoFirstNode = currentNode;
         optionalParametersList$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //ElseIfBegin : (("elseif" | "elsei") TestNoAlpha OptionalSpacing Condition)
   protected boolean elseIfBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseIfBegin$RuleMemoStart == index) {
         if (elseIfBegin$RuleMemoStart <= elseIfBegin$RuleMemoEnd) {
            index = elseIfBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (elseIfBegin$RuleMemoStart == elseIfBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_IF_BEGIN, elseIfBegin$RuleMemoStart, elseIfBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(elseIfBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(elseIfBegin$RuleMemoFirstNode);
                  currentNode = elseIfBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("elseif" | "elsei") TestNoAlpha OptionalSpacing Condition)
      // ("elseif" | "elsei")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
         ++index;
         // ("lseif" | "lsei")
         if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
            ++index;
            // ("seif" | "sei")
            if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
               ++index;
               // ("eif" | "ei")
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("if" | "i")
                  if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                     ++index;
                     // ("f" | <EMPTY>)
                     if (buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F')) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         elseIfBegin$RuleMemoStart = startIndex;
         elseIfBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseIfBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_IF_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseIfBegin$RuleMemoFirstNode = currentNode;
            elseIfBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         elseIfBegin$RuleMemoStart = startIndex;
         elseIfBegin$RuleMemoEnd = -1;
         elseIfBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ElseBegin : ("else" TestNoAlpha OptionalSpacing)
   protected boolean elseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (elseBegin$RuleMemoStart == index) {
         if (elseBegin$RuleMemoStart <= elseBegin$RuleMemoEnd) {
            index = elseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (elseBegin$RuleMemoStart == elseBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_BEGIN, elseBegin$RuleMemoStart, elseBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(elseBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(elseBegin$RuleMemoFirstNode);
                  currentNode = elseBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("else" TestNoAlpha OptionalSpacing)
      // "else"
      match = ignoreCaseStringMatcher("else", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         elseBegin$RuleMemoStart = startIndex;
         elseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            elseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ELSE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            elseBegin$RuleMemoFirstNode = currentNode;
            elseBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         elseBegin$RuleMemoStart = startIndex;
         elseBegin$RuleMemoEnd = -1;
         elseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //OtherwiseBegin : (("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe") TestNoAlpha OptionalSpacing)
   protected boolean otherwiseBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (otherwiseBegin$RuleMemoStart == index) {
         if (otherwiseBegin$RuleMemoStart <= otherwiseBegin$RuleMemoEnd) {
            index = otherwiseBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (otherwiseBegin$RuleMemoStart == otherwiseBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.OTHERWISE_BEGIN, otherwiseBegin$RuleMemoStart, otherwiseBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(otherwiseBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(otherwiseBegin$RuleMemoFirstNode);
                  currentNode = otherwiseBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe") TestNoAlpha OptionalSpacing)
      // ("otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
         ++index;
         // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
         if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
            ++index;
            // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
            if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
               ++index;
               // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                  if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                     ++index;
                     // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                     if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
                        ++index;
                        // ("ise" | "is" | "i" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // ("se" | "s" | <EMPTY>)
                           if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                              ++index;
                              // "e"
                              if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         otherwiseBegin$RuleMemoStart = startIndex;
         otherwiseBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            otherwiseBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.OTHERWISE_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            otherwiseBegin$RuleMemoFirstNode = currentNode;
            otherwiseBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         otherwiseBegin$RuleMemoStart = startIndex;
         otherwiseBegin$RuleMemoEnd = -1;
         otherwiseBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DoCaseOptionBegin : ("case" TestNoAlpha OptionalSpacing Condition)
   protected boolean doCaseOptionBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (doCaseOptionBegin$RuleMemoStart == index) {
         if (doCaseOptionBegin$RuleMemoStart <= doCaseOptionBegin$RuleMemoEnd) {
            index = doCaseOptionBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (doCaseOptionBegin$RuleMemoStart == doCaseOptionBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_OPTION_BEGIN, doCaseOptionBegin$RuleMemoStart, doCaseOptionBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(doCaseOptionBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(doCaseOptionBegin$RuleMemoFirstNode);
                  currentNode = doCaseOptionBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing Condition)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Condition
               match = condition$Rule();
            }
         }
      }
      if (match) {
         doCaseOptionBegin$RuleMemoStart = startIndex;
         doCaseOptionBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            doCaseOptionBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DO_CASE_OPTION_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            doCaseOptionBegin$RuleMemoFirstNode = currentNode;
            doCaseOptionBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         doCaseOptionBegin$RuleMemoStart = startIndex;
         doCaseOptionBegin$RuleMemoEnd = -1;
         doCaseOptionBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StepArgument : ("step" TestNoAlpha OptionalSpacing Expression)
   protected boolean stepArgument$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("step" TestNoAlpha OptionalSpacing Expression)
      // "step"
      match = ignoreCaseStringMatcher("step", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STEP_ARGUMENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Step : StepArgument?
   protected boolean step$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // StepArgument?
      // StepArgument
      stepArgument$Rule();
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.STEP, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //ForIndexInitialization : ((AliasedField | Macro | QualifiedVariable | Variable) AssignmentOperator Expression)
   protected boolean forIndexInitialization$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((AliasedField | Macro | QualifiedVariable | Variable) AssignmentOperator Expression)
      // (AliasedField | Macro | QualifiedVariable | Variable)
      switch(buffer.getChar(index)) {
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // AliasedField
            match = aliasedField$Rule();
            if (! match) {
               // Macro
               match = macro$Rule();
            }
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // AliasedField
            match = aliasedField$Rule();
            if (! match) {
               // Macro
               match = macro$Rule();
               if (! match) {
                  // QualifiedVariable
                  match = qualifiedVariable$Rule();
                  if (! match) {
                     // Variable
                     match = variable$Rule();
                  }
               }
            }
            break;
         case '(':
            // AliasedField
            match = aliasedField$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         // AssignmentOperator
         match = assignmentOperator$Rule();
         if (match) {
            // Expression
            match = expression$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BeginSequenceKeyword : (("begin" | "begi") TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
   protected boolean beginSequenceKeyword$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("begin" | "begi") TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
      // ("begin" | "begi")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
         ++index;
         // ("egin" | "egi")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("gin" | "gi")
            if (buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G')) {
               ++index;
               // ("in" | "i")
               if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                  ++index;
                  // ("n" | <EMPTY>)
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ")
               int startIndex_2 = index;
               if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                  ++index;
                  // ("equence" | "equenc" | "equen" | "eque" | "equ")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("quence" | "quenc" | "quen" | "que" | "qu")
                     if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
                        ++index;
                        // ("uence" | "uenc" | "uen" | "ue" | "u")
                        if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                           ++index;
                           // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("nce" | "nc" | "n" | <EMPTY>)
                              if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                 ++index;
                                 // ("ce" | "c" | <EMPTY>)
                                 if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                    ++index;
                                    // "e"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
               if (! match) {
                  index = startIndex_2;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_KEYWORD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WithOption : ("with" TestNoAlpha OptionalSpacing CodeBlockLiteral)
   protected boolean withOption$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("with" TestNoAlpha OptionalSpacing CodeBlockLiteral)
      // "with"
      match = ignoreCaseStringMatcher("with", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // CodeBlockLiteral
               match = codeBlockLiteral$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WITH_OPTION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockLiteral : (CodeBlockPattern OptionalSpacing)
   protected boolean codeBlockLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (codeBlockLiteral$RuleMemoStart == index) {
         if (codeBlockLiteral$RuleMemoStart <= codeBlockLiteral$RuleMemoEnd) {
            index = codeBlockLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (codeBlockLiteral$RuleMemoStart == codeBlockLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_LITERAL, codeBlockLiteral$RuleMemoStart, codeBlockLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(codeBlockLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(codeBlockLiteral$RuleMemoFirstNode);
                  currentNode = codeBlockLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (CodeBlockPattern OptionalSpacing)
      // CodeBlockPattern
      match = codeBlockPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         codeBlockLiteral$RuleMemoStart = startIndex;
         codeBlockLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            codeBlockLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            codeBlockLiteral$RuleMemoFirstNode = currentNode;
            codeBlockLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         codeBlockLiteral$RuleMemoStart = startIndex;
         codeBlockLiteral$RuleMemoEnd = -1;
         codeBlockLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //WithCodeBlock : WithOption?
   protected boolean withCodeBlock$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // WithOption?
      // WithOption
      withOption$Rule();
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.WITH_CODE_BLOCK, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //BeginSequenceEnd : (("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing) | (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing))
   protected boolean beginSequenceEnd$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (beginSequenceEnd$RuleMemoStart == index) {
         if (beginSequenceEnd$RuleMemoStart <= beginSequenceEnd$RuleMemoEnd) {
            index = beginSequenceEnd$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (beginSequenceEnd$RuleMemoStart == beginSequenceEnd$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_END, beginSequenceEnd$RuleMemoStart, beginSequenceEnd$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(beginSequenceEnd$RuleMemoFirstNode != null) {
                  lastNode.setSibling(beginSequenceEnd$RuleMemoFirstNode);
                  currentNode = beginSequenceEnd$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing) | (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing))
      switch(buffer.getChar(index)) {
         case 'e':
         case 'E':
            // ("end" TestNoAlpha OptionalSpacing ("sequence" | "sequenc" | "sequen" | "seque" | "sequ") TestNoAlpha OptionalSpacing)
            // "end"
            match = ignoreCaseStringMatcher("end", 3);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ")
                     int startIndex_1 = index;
                     if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                        ++index;
                        // ("equence" | "equenc" | "equen" | "eque" | "equ")
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("quence" | "quenc" | "quen" | "que" | "qu")
                           if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
                              ++index;
                              // ("uence" | "uenc" | "uen" | "ue" | "u")
                              if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                                 ++index;
                                 // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                                 if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                                    ++index;
                                    // ("nce" | "nc" | "n" | <EMPTY>)
                                    if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                       ++index;
                                       // ("ce" | "c" | <EMPTY>)
                                       if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                          ++index;
                                          // "e"
                                          if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                             ++index;
                                          }
                                          // <EMPTY>
                                          match = true;
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = false;
                              }
                           } else {
                              match = false;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                     if (! match) {
                        index = startIndex_1;
                     } else if(! currentRuleIsAtomic) {
                        currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
                        currentNode = currentNode.getSibling();
                     }
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
            if (! match) {
               // (("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends") TestNoAlpha OptionalSpacing)
               // ("endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends")
               int startIndex_2 = index;
               if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                  ++index;
                  // ("ndsequence" | "ndsequenc" | "ndsequen" | "ndseque" | "ndsequ" | "ndseq" | "ndse" | "nds")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("dsequence" | "dsequenc" | "dsequen" | "dseque" | "dsequ" | "dseq" | "dse" | "ds")
                     if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                        ++index;
                        // ("sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "seq" | "se" | "s")
                        if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                           ++index;
                           // ("equence" | "equenc" | "equen" | "eque" | "equ" | "eq" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("quence" | "quenc" | "quen" | "que" | "qu" | "q" | <EMPTY>)
                              if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
                                 ++index;
                                 // ("uence" | "uenc" | "uen" | "ue" | "u" | <EMPTY>)
                                 if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                                    ++index;
                                    // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                                    if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                                       ++index;
                                       // ("nce" | "nc" | "n" | <EMPTY>)
                                       if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                          ++index;
                                          // ("ce" | "c" | <EMPTY>)
                                          if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                             ++index;
                                             // "e"
                                             if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                                ++index;
                                             }
                                             // <EMPTY>
                                             match = true;
                                          } else {
                                             match = true;
                                          }
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
               if (! match) {
                  index = startIndex_2;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         beginSequenceEnd$RuleMemoStart = startIndex;
         beginSequenceEnd$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            beginSequenceEnd$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BEGIN_SEQUENCE_END, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            beginSequenceEnd$RuleMemoFirstNode = currentNode;
            beginSequenceEnd$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         beginSequenceEnd$RuleMemoStart = startIndex;
         beginSequenceEnd$RuleMemoEnd = -1;
         beginSequenceEnd$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UsingSpec : (("using" | "usin") TestNoAlpha OptionalSpacing Variable)
   protected boolean usingSpec$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("using" | "usin") TestNoAlpha OptionalSpacing Variable)
      // ("using" | "usin")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
         ++index;
         // ("sing" | "sin")
         if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
            ++index;
            // ("ing" | "in")
            if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
               ++index;
               // ("ng" | "n")
               if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                  ++index;
                  // ("g" | <EMPTY>)
                  if (buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Variable
               match = variable$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.USING_SPEC, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //UsingIdentifier : UsingSpec?
   protected boolean usingIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // UsingSpec?
      // UsingSpec
      usingSpec$Rule();
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.USING_IDENTIFIER, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //RecoverBegin : (("recover" | "recove" | "recov" | "reco") TestNoAlpha OptionalSpacing UsingIdentifier)
   protected boolean recoverBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (recoverBegin$RuleMemoStart == index) {
         if (recoverBegin$RuleMemoStart <= recoverBegin$RuleMemoEnd) {
            index = recoverBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (recoverBegin$RuleMemoStart == recoverBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECOVER_BEGIN, recoverBegin$RuleMemoStart, recoverBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(recoverBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(recoverBegin$RuleMemoFirstNode);
                  currentNode = recoverBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("recover" | "recove" | "recov" | "reco") TestNoAlpha OptionalSpacing UsingIdentifier)
      // ("recover" | "recove" | "recov" | "reco")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
         ++index;
         // ("ecover" | "ecove" | "ecov" | "eco")
         if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
            ++index;
            // ("cover" | "cove" | "cov" | "co")
            if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
               ++index;
               // ("over" | "ove" | "ov" | "o")
               if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                  ++index;
                  // ("ver" | "ve" | "v" | <EMPTY>)
                  if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                     ++index;
                     // ("er" | "e" | <EMPTY>)
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // "r"
                        if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // UsingIdentifier
               match = usingIdentifier$Rule();
            }
         }
      }
      if (match) {
         recoverBegin$RuleMemoStart = startIndex;
         recoverBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            recoverBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.RECOVER_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            recoverBegin$RuleMemoFirstNode = currentNode;
            recoverBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         recoverBegin$RuleMemoStart = startIndex;
         recoverBegin$RuleMemoEnd = -1;
         recoverBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AlwaysBegin : (("always" | "alway" | "alwa") TestNoAlpha OptionalSpacing)
   protected boolean alwaysBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (alwaysBegin$RuleMemoStart == index) {
         if (alwaysBegin$RuleMemoStart <= alwaysBegin$RuleMemoEnd) {
            index = alwaysBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (alwaysBegin$RuleMemoStart == alwaysBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALWAYS_BEGIN, alwaysBegin$RuleMemoStart, alwaysBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(alwaysBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(alwaysBegin$RuleMemoFirstNode);
                  currentNode = alwaysBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("always" | "alway" | "alwa") TestNoAlpha OptionalSpacing)
      // ("always" | "alway" | "alwa")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
         ++index;
         // ("lways" | "lway" | "lwa")
         if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
            ++index;
            // ("ways" | "way" | "wa")
            if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
               ++index;
               // ("ays" | "ay" | "a")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("ys" | "y" | <EMPTY>)
                  if (buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y')) {
                     ++index;
                     // "s"
                     if (match = buffer.matchIgnoreCaseChar(index, 's')) {
                        ++index;
                     }
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         alwaysBegin$RuleMemoStart = startIndex;
         alwaysBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            alwaysBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALWAYS_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            alwaysBegin$RuleMemoFirstNode = currentNode;
            alwaysBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         alwaysBegin$RuleMemoStart = startIndex;
         alwaysBegin$RuleMemoEnd = -1;
         alwaysBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParenthesesSwitchConstant : ('(' OptionalSpacing SwitchConstant ')' OptionalSpacing)
   protected boolean parenthesesSwitchConstant$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parenthesesSwitchConstant$RuleMemoStart == index) {
         if (parenthesesSwitchConstant$RuleMemoStart <= parenthesesSwitchConstant$RuleMemoEnd) {
            index = parenthesesSwitchConstant$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parenthesesSwitchConstant$RuleMemoStart == parenthesesSwitchConstant$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_SWITCH_CONSTANT, parenthesesSwitchConstant$RuleMemoStart, parenthesesSwitchConstant$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(parenthesesSwitchConstant$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parenthesesSwitchConstant$RuleMemoFirstNode);
                  currentNode = parenthesesSwitchConstant$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ('(' OptionalSpacing SwitchConstant ')' OptionalSpacing)
      // '('
      match = charMatcher('(');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // SwitchConstant
            match = switchConstant$Rule();
            if (match) {
               // ')'
               match = charMatcher(')');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         parenthesesSwitchConstant$RuleMemoStart = startIndex;
         parenthesesSwitchConstant$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parenthesesSwitchConstant$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARENTHESES_SWITCH_CONSTANT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parenthesesSwitchConstant$RuleMemoFirstNode = currentNode;
            parenthesesSwitchConstant$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parenthesesSwitchConstant$RuleMemoStart = startIndex;
         parenthesesSwitchConstant$RuleMemoEnd = -1;
         parenthesesSwitchConstant$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchConstant : (ParenthesesSwitchConstant | LogicalLiteral | StringLiteral | NumberLiteral)
   protected boolean switchConstant$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchConstant$RuleMemoStart == index) {
         if (switchConstant$RuleMemoStart <= switchConstant$RuleMemoEnd) {
            index = switchConstant$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (switchConstant$RuleMemoStart == switchConstant$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_CONSTANT, switchConstant$RuleMemoStart, switchConstant$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(switchConstant$RuleMemoFirstNode != null) {
                  lastNode.setSibling(switchConstant$RuleMemoFirstNode);
                  currentNode = switchConstant$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ParenthesesSwitchConstant | LogicalLiteral | StringLiteral | NumberLiteral)
      switch(buffer.getChar(index)) {
         case '\"':
         case 'e':
         case 'E':
         case '\'':
         case '[':
            // StringLiteral
            match = stringLiteral$Rule();
            break;
         case '.':
            // LogicalLiteral
            match = logicalLiteral$Rule();
            if (! match) {
               // NumberLiteral
               match = numberLiteral$Rule();
            }
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            // NumberLiteral
            match = numberLiteral$Rule();
            break;
         case '(':
            // ParenthesesSwitchConstant
            match = parenthesesSwitchConstant$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         switchConstant$RuleMemoStart = startIndex;
         switchConstant$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchConstant$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_CONSTANT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchConstant$RuleMemoFirstNode = currentNode;
            switchConstant$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         switchConstant$RuleMemoStart = startIndex;
         switchConstant$RuleMemoEnd = -1;
         switchConstant$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalLiteral : (LogicalPattern OptionalSpacing)
   protected boolean logicalLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (logicalLiteral$RuleMemoStart == index) {
         if (logicalLiteral$RuleMemoStart <= logicalLiteral$RuleMemoEnd) {
            index = logicalLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (logicalLiteral$RuleMemoStart == logicalLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, logicalLiteral$RuleMemoStart, logicalLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(logicalLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(logicalLiteral$RuleMemoFirstNode);
                  currentNode = logicalLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LogicalPattern OptionalSpacing)
      // LogicalPattern
      match = logicalPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            logicalLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            logicalLiteral$RuleMemoFirstNode = currentNode;
            logicalLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         logicalLiteral$RuleMemoStart = startIndex;
         logicalLiteral$RuleMemoEnd = -1;
         logicalLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LogicalPattern : ((".T." | ".F." | ".Y." | ".N.") OptionalSpacing)
   protected boolean logicalPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((".T." | ".F." | ".Y." | ".N.") OptionalSpacing)
      // (".T." | ".F." | ".Y." | ".N.")
      int startIndex_1 = index;
      if (buffer.matchChar(index, '.')) {
         ++index;
         // ("T." | "F." | "Y." | "N.")
         switch(buffer.getChar(index)) {
            case 'f':
            case 'F':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 'n':
            case 'N':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 'y':
            case 'Y':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            case 't':
            case 'T':
               ++index;
               // "."
               if (match = buffer.matchIgnoreCaseChar(index, '.')) {
                  ++index;
               }
               break;
            default:
               match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LOGICAL_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchOptionBegin : ("case" TestNoAlpha OptionalSpacing SwitchConstant)
   protected boolean switchOptionBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchOptionBegin$RuleMemoStart == index) {
         if (switchOptionBegin$RuleMemoStart <= switchOptionBegin$RuleMemoEnd) {
            index = switchOptionBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (switchOptionBegin$RuleMemoStart == switchOptionBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_OPTION_BEGIN, switchOptionBegin$RuleMemoStart, switchOptionBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(switchOptionBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(switchOptionBegin$RuleMemoFirstNode);
                  currentNode = switchOptionBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("case" TestNoAlpha OptionalSpacing SwitchConstant)
      // "case"
      match = ignoreCaseStringMatcher("case", 4);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // SwitchConstant
               match = switchConstant$Rule();
            }
         }
      }
      if (match) {
         switchOptionBegin$RuleMemoStart = startIndex;
         switchOptionBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchOptionBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_OPTION_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchOptionBegin$RuleMemoFirstNode = currentNode;
            switchOptionBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         switchOptionBegin$RuleMemoStart = startIndex;
         switchOptionBegin$RuleMemoEnd = -1;
         switchOptionBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //SwitchDefaultBegin : ("default" TestNoAlpha OptionalSpacing)
   protected boolean switchDefaultBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (switchDefaultBegin$RuleMemoStart == index) {
         if (switchDefaultBegin$RuleMemoStart <= switchDefaultBegin$RuleMemoEnd) {
            index = switchDefaultBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (switchDefaultBegin$RuleMemoStart == switchDefaultBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_DEFAULT_BEGIN, switchDefaultBegin$RuleMemoStart, switchDefaultBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(switchDefaultBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(switchDefaultBegin$RuleMemoFirstNode);
                  currentNode = switchDefaultBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("default" TestNoAlpha OptionalSpacing)
      // "default"
      match = ignoreCaseStringMatcher("default", 7);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         switchDefaultBegin$RuleMemoStart = startIndex;
         switchDefaultBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            switchDefaultBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SWITCH_DEFAULT_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            switchDefaultBegin$RuleMemoFirstNode = currentNode;
            switchDefaultBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         switchDefaultBegin$RuleMemoStart = startIndex;
         switchDefaultBegin$RuleMemoEnd = -1;
         switchDefaultBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CatchBlockBegin : ("catch" TestNoAlpha OptionalSpacing Variable?)
   protected boolean catchBlockBegin$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (catchBlockBegin$RuleMemoStart == index) {
         if (catchBlockBegin$RuleMemoStart <= catchBlockBegin$RuleMemoEnd) {
            index = catchBlockBegin$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (catchBlockBegin$RuleMemoStart == catchBlockBegin$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CATCH_BLOCK_BEGIN, catchBlockBegin$RuleMemoStart, catchBlockBegin$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(catchBlockBegin$RuleMemoFirstNode != null) {
                  lastNode.setSibling(catchBlockBegin$RuleMemoFirstNode);
                  currentNode = catchBlockBegin$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("catch" TestNoAlpha OptionalSpacing Variable?)
      // "catch"
      match = ignoreCaseStringMatcher("catch", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Variable?
               // Variable
               variable$Rule();
               match = true;
            }
         }
      }
      if (match) {
         catchBlockBegin$RuleMemoStart = startIndex;
         catchBlockBegin$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            catchBlockBegin$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CATCH_BLOCK_BEGIN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            catchBlockBegin$RuleMemoFirstNode = currentNode;
            catchBlockBegin$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         catchBlockBegin$RuleMemoStart = startIndex;
         catchBlockBegin$RuleMemoEnd = -1;
         catchBlockBegin$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockParameters : VariableDeclarationList
   protected boolean codeBlockParameters$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // VariableDeclarationList
      match = variableDeclarationList$Rule();
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_PARAMETERS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CodeBlockPattern : ('{' OptionalSpacing '|' OptionalSpacing CodeBlockParameters? '|' OptionalSpacing ExpressionList '}' OptionalSpacing)
   protected boolean codeBlockPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing '|' OptionalSpacing CodeBlockParameters? '|' OptionalSpacing ExpressionList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // '|'
            match = charMatcher('|');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // CodeBlockParameters?
                  // CodeBlockParameters
                  codeBlockParameters$Rule();
                  // '|'
                  match = charMatcher('|');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                     if (match) {
                        // ExpressionList
                        match = expressionList$Rule();
                        if (match) {
                           // '}'
                           match = charMatcher('}');
                           if (match) {
                              // OptionalSpacing
                              match = optionalSpacing$Rule();
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CODE_BLOCK_PATTERN, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayLiteral : (ArrayPattern OptionalSpacing)
   protected boolean arrayLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayLiteral$RuleMemoStart == index) {
         if (arrayLiteral$RuleMemoStart <= arrayLiteral$RuleMemoEnd) {
            index = arrayLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (arrayLiteral$RuleMemoStart == arrayLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, arrayLiteral$RuleMemoStart, arrayLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(arrayLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(arrayLiteral$RuleMemoFirstNode);
                  currentNode = arrayLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (ArrayPattern OptionalSpacing)
      // ArrayPattern
      match = arrayPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         arrayLiteral$RuleMemoStart = startIndex;
         arrayLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayLiteral$RuleMemoFirstNode = currentNode;
            arrayLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         arrayLiteral$RuleMemoStart = startIndex;
         arrayLiteral$RuleMemoEnd = -1;
         arrayLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayPattern : ('{' OptionalSpacing ValuesList '}' OptionalSpacing)
   protected boolean arrayPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing ValuesList '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // ValuesList
            match = valuesList$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItem : (Expression '=>' OptionalSpacing Expression?)
   protected boolean hashItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItem$RuleMemoStart == index) {
         if (hashItem$RuleMemoStart <= hashItem$RuleMemoEnd) {
            index = hashItem$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (hashItem$RuleMemoStart == hashItem$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEM, hashItem$RuleMemoStart, hashItem$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(hashItem$RuleMemoFirstNode != null) {
                  lastNode.setSibling(hashItem$RuleMemoFirstNode);
                  currentNode = hashItem$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Expression '=>' OptionalSpacing Expression?)
      // Expression
      match = expression$Rule();
      if (match) {
         // '=>'
         match = stringMatcher("=>", 2);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression?
               // Expression
               expression$Rule();
               match = true;
            }
         }
      }
      if (match) {
         hashItem$RuleMemoStart = startIndex;
         hashItem$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashItem$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashItem$RuleMemoFirstNode = currentNode;
            hashItem$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         hashItem$RuleMemoStart = startIndex;
         hashItem$RuleMemoEnd = -1;
         hashItem$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItemsList : (HashItem (',' OptionalSpacing HashItem)*)
   protected boolean hashItemsList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItemsList$RuleMemoStart == index) {
         if (hashItemsList$RuleMemoStart <= hashItemsList$RuleMemoEnd) {
            index = hashItemsList$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (hashItemsList$RuleMemoStart == hashItemsList$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS_LIST, hashItemsList$RuleMemoStart, hashItemsList$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(hashItemsList$RuleMemoFirstNode != null) {
                  lastNode.setSibling(hashItemsList$RuleMemoFirstNode);
                  currentNode = hashItemsList$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (HashItem (',' OptionalSpacing HashItem)*)
      // HashItem
      match = hashItem$Rule();
      if (match) {
         // (',' OptionalSpacing HashItem)*
         do {
            // (',' OptionalSpacing HashItem)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // HashItem
                  match = hashItem$Rule();
                  if (! match) {
                     index = lastIndex_1;
                     lastNode_1.setSibling(null);
                     currentNode = lastNode_1;
                  }
               } else {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         hashItemsList$RuleMemoStart = startIndex;
         hashItemsList$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashItemsList$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashItemsList$RuleMemoFirstNode = currentNode;
            hashItemsList$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         hashItemsList$RuleMemoStart = startIndex;
         hashItemsList$RuleMemoEnd = -1;
         hashItemsList$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashItems : HashItemsList?
   protected boolean hashItems$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashItems$RuleMemoStart == index) {
         if (hashItems$RuleMemoStart <= hashItems$RuleMemoEnd) {
            index = hashItems$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (hashItems$RuleMemoStart == hashItems$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS, hashItems$RuleMemoStart, hashItems$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(hashItems$RuleMemoFirstNode != null) {
                  lastNode.setSibling(hashItems$RuleMemoFirstNode);
                  currentNode = hashItems$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // HashItemsList?
      // HashItemsList
      hashItemsList$Rule();
      hashItems$RuleMemoStart = startIndex;
      hashItems$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         hashItems$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_ITEMS, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         hashItems$RuleMemoFirstNode = currentNode;
         hashItems$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //HashContent : (('=>' OptionalSpacing) | HashItems)
   protected boolean hashContent$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (('=>' OptionalSpacing) | HashItems)
      switch(buffer.getChar(index)) {
         case '!':
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '+':
         case '-':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{':
            // HashItems
            match = hashItems$Rule();
            break;
         case '=':
            // ('=>' OptionalSpacing)
            // '=>'
            match = stringMatcher("=>", 2);
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            break;
         default:
            match = false;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_CONTENT, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashLiteral : (HashPattern OptionalSpacing)
   protected boolean hashLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (hashLiteral$RuleMemoStart == index) {
         if (hashLiteral$RuleMemoStart <= hashLiteral$RuleMemoEnd) {
            index = hashLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (hashLiteral$RuleMemoStart == hashLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, hashLiteral$RuleMemoStart, hashLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(hashLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(hashLiteral$RuleMemoFirstNode);
                  currentNode = hashLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (HashPattern OptionalSpacing)
      // HashPattern
      match = hashPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         hashLiteral$RuleMemoStart = startIndex;
         hashLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            hashLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            hashLiteral$RuleMemoFirstNode = currentNode;
            hashLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         hashLiteral$RuleMemoStart = startIndex;
         hashLiteral$RuleMemoEnd = -1;
         hashLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //HashPattern : ('{' OptionalSpacing HashContent '}' OptionalSpacing)
   protected boolean hashPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('{' OptionalSpacing HashContent '}' OptionalSpacing)
      // '{'
      match = charMatcher('{');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // HashContent
            match = hashContent$Rule();
            if (match) {
               // '}'
               match = charMatcher('}');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.HASH_LITERAL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NilValue : ("nil" TestNoAlpha OptionalSpacing)
   protected boolean nilValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (nilValue$RuleMemoStart == index) {
         if (nilValue$RuleMemoStart <= nilValue$RuleMemoEnd) {
            index = nilValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (nilValue$RuleMemoStart == nilValue$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.NIL_VALUE, nilValue$RuleMemoStart, nilValue$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(nilValue$RuleMemoFirstNode != null) {
                  lastNode.setSibling(nilValue$RuleMemoFirstNode);
                  currentNode = nilValue$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("nil" TestNoAlpha OptionalSpacing)
      // "nil"
      match = ignoreCaseStringMatcher("nil", 3);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         nilValue$RuleMemoStart = startIndex;
         nilValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            nilValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NIL_VALUE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            nilValue$RuleMemoFirstNode = currentNode;
            nilValue$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         nilValue$RuleMemoStart = startIndex;
         nilValue$RuleMemoEnd = -1;
         nilValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Literal : (StringLiteral | NumberLiteral | LogicalLiteral | ArrayLiteral | CodeBlockLiteral | HashLiteral | NilValue | DateTimeLiteral)
   protected boolean literal$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (literal$RuleMemoStart == index) {
         if (literal$RuleMemoStart <= literal$RuleMemoEnd) {
            index = literal$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (literal$RuleMemoStart == literal$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LITERAL, literal$RuleMemoStart, literal$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(literal$RuleMemoFirstNode != null) {
                  lastNode.setSibling(literal$RuleMemoFirstNode);
                  currentNode = literal$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (StringLiteral | NumberLiteral | LogicalLiteral | ArrayLiteral | CodeBlockLiteral | HashLiteral | NilValue | DateTimeLiteral)
      switch(buffer.getChar(index)) {
         case '\"':
         case 'e':
         case 'E':
         case '\'':
         case '[':
            // StringLiteral
            match = stringLiteral$Rule();
            break;
         case '{':
            // ArrayLiteral
            match = arrayLiteral$Rule();
            if (! match) {
               // CodeBlockLiteral
               match = codeBlockLiteral$Rule();
               if (! match) {
                  // HashLiteral
                  match = hashLiteral$Rule();
                  if (! match) {
                     // DateTimeLiteral
                     match = dateTimeLiteral$Rule();
                  }
               }
            }
            break;
         case '.':
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               // LogicalLiteral
               match = logicalLiteral$Rule();
            }
            break;
         case 'n':
         case 'N':
            // NilValue
            match = nilValue$Rule();
            break;
         case '0':
            // NumberLiteral
            match = numberLiteral$Rule();
            if (! match) {
               // DateTimeLiteral
               match = dateTimeLiteral$Rule();
            }
            break;
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            // NumberLiteral
            match = numberLiteral$Rule();
            break;
         case 'd':
         case 'D':
            // DateTimeLiteral
            match = dateTimeLiteral$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            literal$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            literal$RuleMemoFirstNode = currentNode;
            literal$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         literal$RuleMemoStart = startIndex;
         literal$RuleMemoEnd = -1;
         literal$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimeLiteral : (DateTimePattern OptionalSpacing)
   protected boolean dateTimeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dateTimeLiteral$RuleMemoStart == index) {
         if (dateTimeLiteral$RuleMemoStart <= dateTimeLiteral$RuleMemoEnd) {
            index = dateTimeLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (dateTimeLiteral$RuleMemoStart == dateTimeLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, dateTimeLiteral$RuleMemoStart, dateTimeLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(dateTimeLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(dateTimeLiteral$RuleMemoFirstNode);
                  currentNode = dateTimeLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (DateTimePattern OptionalSpacing)
      // DateTimePattern
      match = dateTimePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dateTimeLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dateTimeLiteral$RuleMemoFirstNode = currentNode;
            dateTimeLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         dateTimeLiteral$RuleMemoStart = startIndex;
         dateTimeLiteral$RuleMemoEnd = -1;
         dateTimeLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DateTimePattern : (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}'))
   protected boolean dateTimePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('0d' Digit Digit Digit Digit Digit Digit Digit Digit) | ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))) | ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}'))
      switch(buffer.getChar(index)) {
         case '{':
            // ('{' '^' (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)? TimePattern? OptionalSpacing '}')
            // '{'
            match = charMatcher('{');
            if (match) {
               // '^'
               match = charMatcher('^');
               if (match) {
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)?
                  // (IntegerNumber ('-' | '/') IntegerNumber ('-' | '/') IntegerNumber ','?)
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (match) {
                     // ('-' | '/')
                     switch(buffer.getChar(index)) {
                        case '-':
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        case '/':
                           ++index;
                           // <EMPTY>
                           match = true;
                           break;
                        default:
                           match = false;
                     }
                     if (match) {
                        // IntegerNumber
                        match = integerNumber$Rule();
                        if (match) {
                           // ('-' | '/')
                           switch(buffer.getChar(index)) {
                              case '-':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              case '/':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              default:
                                 match = false;
                           }
                           if (match) {
                              // IntegerNumber
                              match = integerNumber$Rule();
                              if (match) {
                                 // ','?
                                 // ','
                                 match = charMatcher(',');
                                 match = true;
                                 if (! match) {
                                    index = lastIndex_1;
                                    lastNode_1.setSibling(null);
                                    currentNode = lastNode_1;
                                 }
                              } else {
                                 index = lastIndex_1;
                                 lastNode_1.setSibling(null);
                              }
                           } else {
                              index = lastIndex_1;
                              lastNode_1.setSibling(null);
                           }
                        } else {
                           index = lastIndex_1;
                           lastNode_1.setSibling(null);
                        }
                     } else {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                     }
                  }
                  match = true;
                  if (match) {
                     // TimePattern?
                     // TimePattern
                     match = timePattern$Rule();
                     match = true;
                     if (match) {
                        // OptionalSpacing
                        match = optionalSpacing$Rule();
                        if (match) {
                           // '}'
                           match = charMatcher('}');
                        }
                     }
                  }
               }
            }
            break;
         case '0':
            // ('0d' Digit Digit Digit Digit Digit Digit Digit Digit)
            // '0d'
            match = stringMatcher("0d", 2);
            if (match) {
               // '0'-'9'
               match = charRangeMatcher('0', '9');
               if (match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (match) {
                     // '0'-'9'
                     match = charRangeMatcher('0', '9');
                     if (match) {
                        // '0'-'9'
                        match = charRangeMatcher('0', '9');
                        if (match) {
                           // '0'-'9'
                           match = charRangeMatcher('0', '9');
                           if (match) {
                              // '0'-'9'
                              match = charRangeMatcher('0', '9');
                              if (match) {
                                 // '0'-'9'
                                 match = charRangeMatcher('0', '9');
                                 if (match) {
                                    // '0'-'9'
                                    match = charRangeMatcher('0', '9');
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'd':
         case 'D':
            // ("d" (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']')))
            // "d"
            match = ignoreCaseCharMatcher('d');
            if (match) {
               // (('"' DatePattern ("T"? TimePattern)? '"') | (''' DatePattern ("T"? TimePattern)? ''') | ('[' DatePattern ("T"? TimePattern)? ']'))
               switch(buffer.getChar(index)) {
                  case '[':
                     // ('[' DatePattern ("T"? TimePattern)? ']')
                     // '['
                     match = charMatcher('[');
                     if (match) {
                        // DatePattern
                        match = datePattern$Rule();
                        if (match) {
                           // ("T"? TimePattern)?
                           // ("T"? TimePattern)
                           Node lastNode_2 = currentNode;
                           int lastIndex_2 = index;
                           // "T"?
                           // "T"
                           match = ignoreCaseCharMatcher('T');
                           match = true;
                           if (match) {
                              // TimePattern
                              match = timePattern$Rule();
                              if (! match) {
                                 index = lastIndex_2;
                                 lastNode_2.setSibling(null);
                                 currentNode = lastNode_2;
                              }
                           }
                           match = true;
                           if (match) {
                              // ']'
                              match = charMatcher(']');
                           }
                        }
                     }
                     break;
                  case '\"':
                     // ('"' DatePattern ("T"? TimePattern)? '"')
                     // '"'
                     match = charMatcher('\"');
                     if (match) {
                        // DatePattern
                        match = datePattern$Rule();
                        if (match) {
                           // ("T"? TimePattern)?
                           // ("T"? TimePattern)
                           Node lastNode_3 = currentNode;
                           int lastIndex_3 = index;
                           // "T"?
                           // "T"
                           match = ignoreCaseCharMatcher('T');
                           match = true;
                           if (match) {
                              // TimePattern
                              match = timePattern$Rule();
                              if (! match) {
                                 index = lastIndex_3;
                                 lastNode_3.setSibling(null);
                                 currentNode = lastNode_3;
                              }
                           }
                           match = true;
                           if (match) {
                              // '"'
                              match = charMatcher('\"');
                           }
                        }
                     }
                     break;
                  case '\'':
                     // (''' DatePattern ("T"? TimePattern)? ''')
                     // '''
                     match = charMatcher('\'');
                     if (match) {
                        // DatePattern
                        match = datePattern$Rule();
                        if (match) {
                           // ("T"? TimePattern)?
                           // ("T"? TimePattern)
                           Node lastNode_4 = currentNode;
                           int lastIndex_4 = index;
                           // "T"?
                           // "T"
                           match = ignoreCaseCharMatcher('T');
                           match = true;
                           if (match) {
                              // TimePattern
                              match = timePattern$Rule();
                              if (! match) {
                                 index = lastIndex_4;
                                 lastNode_4.setSibling(null);
                                 currentNode = lastNode_4;
                              }
                           }
                           match = true;
                           if (match) {
                              // '''
                              match = charMatcher('\'');
                           }
                        }
                     }
                     break;
                  default:
                     match = false;
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimeLiteral : (TimePattern OptionalSpacing)
   protected boolean timeLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (timeLiteral$RuleMemoStart == index) {
         if (timeLiteral$RuleMemoStart <= timeLiteral$RuleMemoEnd) {
            index = timeLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (timeLiteral$RuleMemoStart == timeLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, timeLiteral$RuleMemoStart, timeLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(timeLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(timeLiteral$RuleMemoFirstNode);
                  currentNode = timeLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (TimePattern OptionalSpacing)
      // TimePattern
      match = timePattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         timeLiteral$RuleMemoStart = startIndex;
         timeLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timeLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            timeLiteral$RuleMemoFirstNode = currentNode;
            timeLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         timeLiteral$RuleMemoStart = startIndex;
         timeLiteral$RuleMemoEnd = -1;
         timeLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IntegerNumber : Digit+
   protected boolean integerNumber$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (integerNumber$RuleMemoStart == index) {
         if (integerNumber$RuleMemoStart <= integerNumber$RuleMemoEnd) {
            index = integerNumber$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (integerNumber$RuleMemoStart == integerNumber$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.INTEGER_NUMBER, integerNumber$RuleMemoStart, integerNumber$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(integerNumber$RuleMemoFirstNode != null) {
                  lastNode.setSibling(integerNumber$RuleMemoFirstNode);
                  currentNode = integerNumber$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // Digit+
      // '0'-'9'
      match = charRangeMatcher('0', '9');
      if (match) {
         do {
            // '0'-'9'
            match = charRangeMatcher('0', '9');
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            integerNumber$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INTEGER_NUMBER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            integerNumber$RuleMemoFirstNode = currentNode;
            integerNumber$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         integerNumber$RuleMemoStart = startIndex;
         integerNumber$RuleMemoEnd = -1;
         integerNumber$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TimePattern : (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
   protected boolean timePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (timePattern$RuleMemoStart == index) {
         if (timePattern$RuleMemoStart <= timePattern$RuleMemoEnd) {
            index = timePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (timePattern$RuleMemoStart == timePattern$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, timePattern$RuleMemoStart, timePattern$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(timePattern$RuleMemoFirstNode != null) {
                  lastNode.setSibling(timePattern$RuleMemoFirstNode);
                  currentNode = timePattern$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)? ("AM" | "PM")?)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)?
         // (':' IntegerNumber (':' IntegerNumber)? ('.' IntegerNumber)?)
         Node lastNode_1 = currentNode;
         int lastIndex_1 = index;
         // ':'
         match = charMatcher(':');
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // (':' IntegerNumber)?
               // (':' IntegerNumber)
               Node lastNode_2 = currentNode;
               int lastIndex_2 = index;
               // ':'
               match = charMatcher(':');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (! match) {
                     index = lastIndex_2;
                     lastNode_2.setSibling(null);
                     currentNode = lastNode_2;
                  }
               }
               match = true;
               // ('.' IntegerNumber)?
               // ('.' IntegerNumber)
               Node lastNode_3 = currentNode;
               int lastIndex_3 = index;
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
                  if (! match) {
                     index = lastIndex_3;
                     lastNode_3.setSibling(null);
                     currentNode = lastNode_3;
                  }
               }
               match = true;
            } else {
               index = lastIndex_1;
               lastNode_1.setSibling(null);
            }
         }
         match = true;
         // ("AM" | "PM")?
         // ("AM" | "PM")
         switch(buffer.getChar(index)) {
            case 'p':
            case 'P':
               ++index;
               // "M"
               if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                  ++index;
               }
               break;
            case 'a':
            case 'A':
               ++index;
               // "M"
               if (match = buffer.matchIgnoreCaseChar(index, 'M')) {
                  ++index;
               }
               break;
            default:
               match = false;
         }
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            timePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.TIME_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            timePattern$RuleMemoFirstNode = currentNode;
            timePattern$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         timePattern$RuleMemoStart = startIndex;
         timePattern$RuleMemoEnd = -1;
         timePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DatePattern : (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
   protected boolean datePattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (datePattern$RuleMemoStart == index) {
         if (datePattern$RuleMemoStart <= datePattern$RuleMemoEnd) {
            index = datePattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (datePattern$RuleMemoStart == datePattern$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_PATTERN, datePattern$RuleMemoStart, datePattern$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(datePattern$RuleMemoFirstNode != null) {
                  lastNode.setSibling(datePattern$RuleMemoFirstNode);
                  currentNode = datePattern$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (IntegerNumber ('-' | '/' | '.') IntegerNumber ('-' | '/' | '.') IntegerNumber)
      // IntegerNumber
      match = integerNumber$Rule();
      if (match) {
         // ('-' | '/' | '.')
         switch(buffer.getChar(index)) {
            case '-':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '.':
               ++index;
               // <EMPTY>
               match = true;
               break;
            case '/':
               ++index;
               // <EMPTY>
               match = true;
               break;
            default:
               match = false;
         }
         if (match) {
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // ('-' | '/' | '.')
               switch(buffer.getChar(index)) {
                  case '-':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '.':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  case '/':
                     ++index;
                     // <EMPTY>
                     match = true;
                     break;
                  default:
                     match = false;
               }
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            datePattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATE_PATTERN, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            datePattern$RuleMemoFirstNode = currentNode;
            datePattern$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         datePattern$RuleMemoStart = startIndex;
         datePattern$RuleMemoEnd = -1;
         datePattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaOrCloseOpenBracket : ((',' OptionalSpacing) | (']' OptionalSpacing '[' OptionalSpacing))
   protected boolean commaOrCloseOpenBracket$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ((',' OptionalSpacing) | (']' OptionalSpacing '[' OptionalSpacing))
      switch(buffer.getChar(index)) {
         case ',':
            // (',' OptionalSpacing)
            // ','
            match = charMatcher(',');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
            }
            break;
         case ']':
            // (']' OptionalSpacing '[' OptionalSpacing)
            // ']'
            match = charMatcher(']');
            if (match) {
               // OptionalSpacing
               match = optionalSpacing$Rule();
               if (match) {
                  // '['
                  match = charMatcher('[');
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_OR_CLOSE_OPEN_BRACKET, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //CommaIndexItem : (CommaOrCloseOpenBracket IndexItem)
   protected boolean commaIndexItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (CommaOrCloseOpenBracket IndexItem)
      // CommaOrCloseOpenBracket
      match = commaOrCloseOpenBracket$Rule();
      if (match) {
         // IndexItem
         match = indexItem$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMMA_INDEX_ITEM, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexItemCommaList : CommaIndexItem*
   protected boolean indexItemCommaList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // CommaIndexItem*
      do {
         // CommaIndexItem
         match = commaIndexItem$Rule();
      } while(match);
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM_COMMA_LIST, startIndex, index, true, true);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //IndexList : (IndexItem IndexItemCommaList)
   protected boolean indexList$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (IndexItem IndexItemCommaList)
      // IndexItem
      match = indexItem$Rule();
      if (match) {
         // IndexItemCommaList
         match = indexItemCommaList$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_LIST, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IndexItem : Expression
   protected boolean indexItem$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (indexItem$RuleMemoStart == index) {
         if (indexItem$RuleMemoStart <= indexItem$RuleMemoEnd) {
            index = indexItem$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (indexItem$RuleMemoStart == indexItem$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM, indexItem$RuleMemoStart, indexItem$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(indexItem$RuleMemoFirstNode != null) {
                  lastNode.setSibling(indexItem$RuleMemoFirstNode);
                  currentNode = indexItem$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // Expression
      match = expression$Rule();
      if (match) {
         indexItem$RuleMemoStart = startIndex;
         indexItem$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            indexItem$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.INDEX_ITEM, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            indexItem$RuleMemoFirstNode = currentNode;
            indexItem$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         indexItem$RuleMemoStart = startIndex;
         indexItem$RuleMemoEnd = -1;
         indexItem$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayIndex : ('[' OptionalSpacing IndexList ']' OptionalSpacing)
   protected boolean arrayIndex$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('[' OptionalSpacing IndexList ']' OptionalSpacing)
      // '['
      match = charMatcher('[');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // IndexList
            match = indexList$Rule();
            if (match) {
               // ']'
               match = charMatcher(']');
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_INDEX, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignOperator : (AssignOperatorOnly OptionalSpacing)
   protected boolean assignOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignOperator$RuleMemoStart == index) {
         if (assignOperator$RuleMemoStart <= assignOperator$RuleMemoEnd) {
            index = assignOperator$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (assignOperator$RuleMemoStart == assignOperator$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, assignOperator$RuleMemoStart, assignOperator$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(assignOperator$RuleMemoFirstNode != null) {
                  lastNode.setSibling(assignOperator$RuleMemoFirstNode);
                  currentNode = assignOperator$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignOperatorOnly OptionalSpacing)
      // AssignOperatorOnly
      match = assignOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         assignOperator$RuleMemoStart = startIndex;
         assignOperator$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignOperator$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignOperator$RuleMemoFirstNode = currentNode;
            assignOperator$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         assignOperator$RuleMemoStart = startIndex;
         assignOperator$RuleMemoEnd = -1;
         assignOperator$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignOperatorOnly : (':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | EqualOperator)
   protected boolean assignOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '^=' | EqualOperator)
      // ':='
      match = stringMatcher(":=", 2);
      if (! match) {
         // '+='
         match = stringMatcher("+=", 2);
         if (! match) {
            // '-='
            match = stringMatcher("-=", 2);
            if (! match) {
               // '*='
               match = stringMatcher("*=", 2);
               if (! match) {
                  // '/='
                  match = stringMatcher("/=", 2);
                  if (! match) {
                     // '%='
                     match = stringMatcher("%=", 2);
                     if (! match) {
                        // '^='
                        match = stringMatcher("^=", 2);
                        if (! match) {
                           // ('=' ('>' | '=')!)
                           // '='
                           match = charMatcher('=');
                           if (match) {
                              // ('>' | '=')!
                              // ('>' | '=')
                              int startIndex_1 = index;
                              switch(buffer.getChar(index)) {
                                 case '=':
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 case '>':
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 default:
                                    match = false;
                              }
                              index = startIndex_1;
                              match = ! match;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGN_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Expression : (AssignmentExpression | MathExpression | ComparisonExpression | ConditionalExpression | PrimaryExpression)
   protected boolean expression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (expression$RuleMemoStart == index) {
         if (expression$RuleMemoStart <= expression$RuleMemoEnd) {
            index = expression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (expression$RuleMemoStart == expression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION, expression$RuleMemoStart, expression$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(expression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(expression$RuleMemoFirstNode);
                  currentNode = expression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (AssignmentExpression | MathExpression | ComparisonExpression | ConditionalExpression | PrimaryExpression)
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-':
            // MathExpression
            match = mathExpression$Rule();
            if (! match) {
               // ComparisonExpression
               match = comparisonExpression$Rule();
               if (! match) {
                  // ConditionalExpression
                  match = conditionalExpression$Rule();
                  if (! match) {
                     // PrimaryExpression
                     match = primaryExpression$Rule();
                  }
               }
            }
            break;
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{':
            // AssignmentExpression
            match = assignmentExpression$Rule();
            if (! match) {
               // MathExpression
               match = mathExpression$Rule();
               if (! match) {
                  // ComparisonExpression
                  match = comparisonExpression$Rule();
                  if (! match) {
                     // ConditionalExpression
                     match = conditionalExpression$Rule();
                     if (! match) {
                        // PrimaryExpression
                        match = primaryExpression$Rule();
                     }
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         expression$RuleMemoStart = startIndex;
         expression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            expression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            expression$RuleMemoFirstNode = currentNode;
            expression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         expression$RuleMemoStart = startIndex;
         expression$RuleMemoEnd = -1;
         expression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AssignmentExpression : (LeftValue AssignOperator (ValueByReference | Expression))
   protected boolean assignmentExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (assignmentExpression$RuleMemoStart == index) {
         if (assignmentExpression$RuleMemoStart <= assignmentExpression$RuleMemoEnd) {
            index = assignmentExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (assignmentExpression$RuleMemoStart == assignmentExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_EXPRESSION, assignmentExpression$RuleMemoStart, assignmentExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(assignmentExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(assignmentExpression$RuleMemoFirstNode);
                  currentNode = assignmentExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (LeftValue AssignOperator (ValueByReference | Expression))
      // LeftValue
      match = leftValue$Rule();
      if (match) {
         // AssignOperator
         match = assignOperator$Rule();
         if (match) {
            // (ValueByReference | Expression)
            switch(buffer.getChar(index)) {
               case '!':
               case '\"':
               case '&':
               case '\'':
               case '(':
               case '+':
               case '-':
               case '.':
               case '0':
               case '1':
               case '2':
               case '3':
               case '4':
               case '5':
               case '6':
               case '7':
               case '8':
               case '9':
               case ':':
               case 'A':
               case 'B':
               case 'C':
               case 'D':
               case 'E':
               case 'F':
               case 'G':
               case 'H':
               case 'I':
               case 'J':
               case 'K':
               case 'L':
               case 'M':
               case 'N':
               case 'O':
               case 'P':
               case 'Q':
               case 'R':
               case 'S':
               case 'T':
               case 'U':
               case 'V':
               case 'W':
               case 'X':
               case 'Y':
               case 'Z':
               case '[':
               case '_':
               case 'a':
               case 'b':
               case 'c':
               case 'd':
               case 'e':
               case 'f':
               case 'g':
               case 'h':
               case 'i':
               case 'j':
               case 'k':
               case 'l':
               case 'm':
               case 'n':
               case 'o':
               case 'p':
               case 'q':
               case 'r':
               case 's':
               case 't':
               case 'u':
               case 'v':
               case 'w':
               case 'x':
               case 'y':
               case 'z':
               case '{':
                  // Expression
                  match = expression$Rule();
                  break;
               case '@':
                  // ValueByReference
                  match = valueByReference$Rule();
                  break;
               default:
                  match = false;
            }
         }
      }
      if (match) {
         assignmentExpression$RuleMemoStart = startIndex;
         assignmentExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            assignmentExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ASSIGNMENT_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            assignmentExpression$RuleMemoFirstNode = currentNode;
            assignmentExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         assignmentExpression$RuleMemoStart = startIndex;
         assignmentExpression$RuleMemoEnd = -1;
         assignmentExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ConditionOperator : (ConditionOperatorOnly OptionalSpacing)
   protected boolean conditionOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ConditionOperatorOnly OptionalSpacing)
      // ConditionOperatorOnly
      match = conditionOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ConditionOperatorOnly : (".and." | ".or.")
   protected boolean conditionOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (".and." | ".or.")
      if (buffer.matchChar(index, '.')) {
         ++index;
         // ("and." | "or.")
         switch(buffer.getChar(index)) {
            case 'o':
            case 'O':
               ++index;
               // "r."
               if (match = ignoreCaseStringTest("r.", 2)) {
                  index += 2;
               }
               break;
            case 'a':
            case 'A':
               ++index;
               // "nd."
               if (match = ignoreCaseStringTest("nd.", 3)) {
                  index += 3;
               }
               break;
            default:
               match = false;
         }
      } else {
         match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITION_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ConditionalExpression : (PrimaryExpression ConditionOperator Expression)
   protected boolean conditionalExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (conditionalExpression$RuleMemoStart == index) {
         if (conditionalExpression$RuleMemoStart <= conditionalExpression$RuleMemoEnd) {
            index = conditionalExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (conditionalExpression$RuleMemoStart == conditionalExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITIONAL_EXPRESSION, conditionalExpression$RuleMemoStart, conditionalExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(conditionalExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(conditionalExpression$RuleMemoFirstNode);
                  currentNode = conditionalExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrimaryExpression ConditionOperator Expression)
      // PrimaryExpression
      match = primaryExpression$Rule();
      if (match) {
         // ConditionOperator
         match = conditionOperator$Rule();
         if (match) {
            // Expression
            match = expression$Rule();
         }
      }
      if (match) {
         conditionalExpression$RuleMemoStart = startIndex;
         conditionalExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            conditionalExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONDITIONAL_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            conditionalExpression$RuleMemoFirstNode = currentNode;
            conditionalExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         conditionalExpression$RuleMemoStart = startIndex;
         conditionalExpression$RuleMemoEnd = -1;
         conditionalExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ComparisonOperator : (ComparisonOperatorOnly OptionalSpacing)
   protected boolean comparisonOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ComparisonOperatorOnly OptionalSpacing)
      // ComparisonOperatorOnly
      match = comparisonOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMPARISON_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ComparisonOperatorOnly : ('>=' | '<=' | '<>' | '#' | '!=' | GreaterOperator | LessOperator | '==' | '$' | "in" | EqualOperator)
   protected boolean comparisonOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('>=' | '<=' | '<>' | '#' | '!=' | GreaterOperator | LessOperator | '==' | '$' | "in" | EqualOperator)
      // '>='
      match = stringMatcher(">=", 2);
      if (! match) {
         // '<='
         match = stringMatcher("<=", 2);
         if (! match) {
            // '<>'
            match = stringMatcher("<>", 2);
            if (! match) {
               // '#'
               match = charMatcher('#');
               if (! match) {
                  // '!='
                  match = stringMatcher("!=", 2);
                  if (! match) {
                     // ('>' '='!)
                     // '>'
                     match = charMatcher('>');
                     if (match) {
                        // '='!
                        // '='
                        match = buffer.matchChar(index, '=');
                        match = ! match;
                     }
                     if (! match) {
                        // ('<' ('=' | '>')!)
                        // '<'
                        match = charMatcher('<');
                        if (match) {
                           // ('=' | '>')!
                           // ('=' | '>')
                           int startIndex_1 = index;
                           switch(buffer.getChar(index)) {
                              case '=':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              case '>':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              default:
                                 match = false;
                           }
                           index = startIndex_1;
                           match = ! match;
                        }
                        if (! match) {
                           // '=='
                           match = stringMatcher("==", 2);
                           if (! match) {
                              // '$'
                              match = charMatcher('$');
                              if (! match) {
                                 // "in"
                                 match = ignoreCaseStringMatcher("in", 2);
                                 if (! match) {
                                    // ('=' ('>' | '=')!)
                                    // '='
                                    match = charMatcher('=');
                                    if (match) {
                                       // ('>' | '=')!
                                       // ('>' | '=')
                                       int startIndex_2 = index;
                                       switch(buffer.getChar(index)) {
                                          case '=':
                                             ++index;
                                             // <EMPTY>
                                             match = true;
                                             break;
                                          case '>':
                                             ++index;
                                             // <EMPTY>
                                             match = true;
                                             break;
                                          default:
                                             match = false;
                                       }
                                       index = startIndex_2;
                                       match = ! match;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMPARISON_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ComparisonExpression : (PrimaryExpression ComparisonOperator Expression)
   protected boolean comparisonExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (comparisonExpression$RuleMemoStart == index) {
         if (comparisonExpression$RuleMemoStart <= comparisonExpression$RuleMemoEnd) {
            index = comparisonExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (comparisonExpression$RuleMemoStart == comparisonExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMPARISON_EXPRESSION, comparisonExpression$RuleMemoStart, comparisonExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(comparisonExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(comparisonExpression$RuleMemoFirstNode);
                  currentNode = comparisonExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrimaryExpression ComparisonOperator Expression)
      // PrimaryExpression
      match = primaryExpression$Rule();
      if (match) {
         // ComparisonOperator
         match = comparisonOperator$Rule();
         if (match) {
            // Expression
            match = expression$Rule();
         }
      }
      if (match) {
         comparisonExpression$RuleMemoStart = startIndex;
         comparisonExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            comparisonExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.COMPARISON_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            comparisonExpression$RuleMemoFirstNode = currentNode;
            comparisonExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         comparisonExpression$RuleMemoStart = startIndex;
         comparisonExpression$RuleMemoEnd = -1;
         comparisonExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathOperator : (MathOperatorOnly OptionalSpacing)
   protected boolean mathOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (MathOperatorOnly OptionalSpacing)
      // MathOperatorOnly
      match = mathOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathOperatorOnly : (PlusSign | MinusSign | '**' | '*' | '/' | '%' | '^^' | '^' | '|' | '&' | '<<' | '>>')
   protected boolean mathOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (PlusSign | MinusSign | '**' | '*' | '/' | '%' | '^^' | '^' | '|' | '&' | '<<' | '>>')
      // ('+' '+'!)
      // '+'
      match = charMatcher('+');
      if (match) {
         // '+'!
         // '+'
         match = buffer.matchChar(index, '+');
         match = ! match;
      }
      if (! match) {
         // ('-' '-'!)
         // '-'
         match = charMatcher('-');
         if (match) {
            // '-'!
            // '-'
            match = buffer.matchChar(index, '-');
            match = ! match;
         }
         if (! match) {
            // '**'
            match = stringMatcher("**", 2);
            if (! match) {
               // '*'
               match = charMatcher('*');
               if (! match) {
                  // '/'
                  match = charMatcher('/');
                  if (! match) {
                     // '%'
                     match = charMatcher('%');
                     if (! match) {
                        // '^^'
                        match = stringMatcher("^^", 2);
                        if (! match) {
                           // '^'
                           match = charMatcher('^');
                           if (! match) {
                              // '|'
                              match = charMatcher('|');
                              if (! match) {
                                 // '&'
                                 match = charMatcher('&');
                                 if (! match) {
                                    // '<<'
                                    match = stringMatcher("<<", 2);
                                    if (! match) {
                                       // '>>'
                                       match = stringMatcher(">>", 2);
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //MathExpression : (PrimaryExpression MathOperator Expression)
   protected boolean mathExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (mathExpression$RuleMemoStart == index) {
         if (mathExpression$RuleMemoStart <= mathExpression$RuleMemoEnd) {
            index = mathExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (mathExpression$RuleMemoStart == mathExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_EXPRESSION, mathExpression$RuleMemoStart, mathExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(mathExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(mathExpression$RuleMemoFirstNode);
                  currentNode = mathExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrimaryExpression MathOperator Expression)
      // PrimaryExpression
      match = primaryExpression$Rule();
      if (match) {
         // MathOperator
         match = mathOperator$Rule();
         if (match) {
            // Expression
            match = expression$Rule();
         }
      }
      if (match) {
         mathExpression$RuleMemoStart = startIndex;
         mathExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            mathExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.MATH_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            mathExpression$RuleMemoFirstNode = currentNode;
            mathExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         mathExpression$RuleMemoStart = startIndex;
         mathExpression$RuleMemoEnd = -1;
         mathExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixedExpression : (PrefixOperator Expression)
   protected boolean prefixedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (prefixedExpression$RuleMemoStart == index) {
         if (prefixedExpression$RuleMemoStart <= prefixedExpression$RuleMemoEnd) {
            index = prefixedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (prefixedExpression$RuleMemoStart == prefixedExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIXED_EXPRESSION, prefixedExpression$RuleMemoStart, prefixedExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(prefixedExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(prefixedExpression$RuleMemoFirstNode);
                  currentNode = prefixedExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrefixOperator Expression)
      // PrefixOperator
      match = prefixOperator$Rule();
      if (match) {
         // Expression
         match = expression$Rule();
      }
      if (match) {
         prefixedExpression$RuleMemoStart = startIndex;
         prefixedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            prefixedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIXED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            prefixedExpression$RuleMemoFirstNode = currentNode;
            prefixedExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         prefixedExpression$RuleMemoStart = startIndex;
         prefixedExpression$RuleMemoEnd = -1;
         prefixedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixedExpression : ((QualifiedExpression | AtomicExpression) PostfixOperator+)
   protected boolean postfixedExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (postfixedExpression$RuleMemoStart == index) {
         if (postfixedExpression$RuleMemoStart <= postfixedExpression$RuleMemoEnd) {
            index = postfixedExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (postfixedExpression$RuleMemoStart == postfixedExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIXED_EXPRESSION, postfixedExpression$RuleMemoStart, postfixedExpression$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(postfixedExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(postfixedExpression$RuleMemoFirstNode);
                  currentNode = postfixedExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((QualifiedExpression | AtomicExpression) PostfixOperator+)
      // (QualifiedExpression | AtomicExpression)
      switch(buffer.getChar(index)) {
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '.':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               // AtomicExpression
               match = atomicExpression$Rule();
            }
            break;
         default:
            match = false;
      }
      if (match) {
         // PostfixOperator+
         // PostfixOperator
         match = postfixOperator$Rule();
         if (match) {
            do {
               // PostfixOperator
               match = postfixOperator$Rule();
            } while(match);
            match = true;
         }
      }
      if (match) {
         postfixedExpression$RuleMemoStart = startIndex;
         postfixedExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            postfixedExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIXED_EXPRESSION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            postfixedExpression$RuleMemoFirstNode = currentNode;
            postfixedExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         postfixedExpression$RuleMemoStart = startIndex;
         postfixedExpression$RuleMemoEnd = -1;
         postfixedExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrimaryExpression : (PrefixedExpression | PostfixedExpression | QualifiedExpression | AtomicExpression)
   protected boolean primaryExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (primaryExpression$RuleMemoStart == index) {
         if (primaryExpression$RuleMemoStart <= primaryExpression$RuleMemoEnd) {
            index = primaryExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (primaryExpression$RuleMemoStart == primaryExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIMARY_EXPRESSION, primaryExpression$RuleMemoStart, primaryExpression$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(primaryExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(primaryExpression$RuleMemoFirstNode);
                  currentNode = primaryExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (PrefixedExpression | PostfixedExpression | QualifiedExpression | AtomicExpression)
      switch(buffer.getChar(index)) {
         case '!':
         case '+':
         case '-':
            // PrefixedExpression
            match = prefixedExpression$Rule();
            break;
         case '.':
            // PrefixedExpression
            match = prefixedExpression$Rule();
            if (! match) {
               // PostfixedExpression
               match = postfixedExpression$Rule();
               if (! match) {
                  // QualifiedExpression
                  match = qualifiedExpression$Rule();
                  if (! match) {
                     // AtomicExpression
                     match = atomicExpression$Rule();
                  }
               }
            }
            break;
         case '\"':
         case '&':
         case '\'':
         case '(':
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         case ':':
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '[':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
         case '{':
            // PostfixedExpression
            match = postfixedExpression$Rule();
            if (! match) {
               // QualifiedExpression
               match = qualifiedExpression$Rule();
               if (! match) {
                  // AtomicExpression
                  match = atomicExpression$Rule();
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         primaryExpression$RuleMemoStart = startIndex;
         primaryExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            primaryExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PRIMARY_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            primaryExpression$RuleMemoFirstNode = currentNode;
            primaryExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         primaryExpression$RuleMemoStart = startIndex;
         primaryExpression$RuleMemoEnd = -1;
         primaryExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixOperator : (PrefixOperatorOnly OptionalSpacing)
   protected boolean prefixOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (PrefixOperatorOnly OptionalSpacing)
      // PrefixOperatorOnly
      match = prefixOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIX_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PrefixOperatorOnly : ('++' | '--' | NotOperator | PlusSign | MinusSign)
   protected boolean prefixOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('++' | '--' | NotOperator | PlusSign | MinusSign)
      // '++'
      match = stringMatcher("++", 2);
      if (! match) {
         // '--'
         match = stringMatcher("--", 2);
         if (! match) {
            // (".not." | ('!' '='!))
            // ".not."
            match = ignoreCaseStringMatcher(".not.", 5);
            if (! match) {
               // ('!' '='!)
               // '!'
               match = charMatcher('!');
               if (match) {
                  // '='!
                  // '='
                  match = buffer.matchChar(index, '=');
                  match = ! match;
               }
            }
            if (! match) {
               // ('+' '+'!)
               // '+'
               match = charMatcher('+');
               if (match) {
                  // '+'!
                  // '+'
                  match = buffer.matchChar(index, '+');
                  match = ! match;
               }
               if (! match) {
                  // ('-' '-'!)
                  // '-'
                  match = charMatcher('-');
                  if (match) {
                     // '-'!
                     // '-'
                     match = buffer.matchChar(index, '-');
                     match = ! match;
                  }
               }
            }
         }
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PREFIX_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixOperator : (PostfixOperatorOnly OptionalSpacing)
   protected boolean postfixOperator$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (PostfixOperatorOnly OptionalSpacing)
      // PostfixOperatorOnly
      match = postfixOperatorOnly$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIX_OPERATOR, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //PostfixOperatorOnly : ('++' | '--')
   protected boolean postfixOperatorOnly$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('++' | '--')
      switch(buffer.getChar(index)) {
         case '+':
            ++index;
            // '+'
            if (match = buffer.matchChar(index, '+')) {
               ++index;
            }
            break;
         case '-':
            ++index;
            // '-'
            if (match = buffer.matchChar(index, '-')) {
               ++index;
            }
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.POSTFIX_OPERATOR, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AtomicExpression : (SelfExpression | ArrayAccess | AliasedExpression | AliasedField | AliasedMacro | Literal | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | ParenthesesExpressionList | KeyboardCall | ClearTypehead | Variable)
   protected boolean atomicExpression$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (atomicExpression$RuleMemoStart == index) {
         if (atomicExpression$RuleMemoStart <= atomicExpression$RuleMemoEnd) {
            index = atomicExpression$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (atomicExpression$RuleMemoStart == atomicExpression$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATOMIC_EXPRESSION, atomicExpression$RuleMemoStart, atomicExpression$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(atomicExpression$RuleMemoFirstNode != null) {
                  lastNode.setSibling(atomicExpression$RuleMemoFirstNode);
                  currentNode = atomicExpression$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SelfExpression | ArrayAccess | AliasedExpression | AliasedField | AliasedMacro | Literal | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | ParenthesesExpressionList | KeyboardCall | ClearTypehead | Variable)
      switch(buffer.getChar(index)) {
         case 'K':
         case 'k':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 // KeyboardCall
                                 match = keyboardCall$Rule();
                                 if (! match) {
                                    // Variable
                                    match = variable$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case '\"':
         case '\'':
         case '[':
         case '{':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // Literal
               match = literal$Rule();
            }
            break;
         case '.':
            // Literal
            match = literal$Rule();
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // Literal
                        match = literal$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'A':
         case 'B':
         case 'F':
         case 'G':
         case 'H':
         case 'J':
         case 'L':
         case 'M':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'f':
         case 'g':
         case 'h':
         case 'j':
         case 'l':
         case 'm':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 // Variable
                                 match = variable$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'C':
         case 'c':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 // ClearTypehead
                                 match = clearTypehead$Rule();
                                 if (! match) {
                                    // Variable
                                    match = variable$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'D':
         case 'd':
         case 'E':
         case 'e':
         case 'N':
         case 'n':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // Literal
                        match = literal$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // AnySimpleFunctionCall
                              match = anySimpleFunctionCall$Rule();
                              if (! match) {
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    // Variable
                                    match = variable$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case '&':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // Macro
                           match = macro$Rule();
                        }
                     }
                  }
               }
            }
            break;
         case '(':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // ParenthesesExpressionList
                        match = parenthesesExpressionList$Rule();
                     }
                  }
               }
            }
            break;
         case 'I':
         case 'i':
            // ArrayAccess
            match = arrayAccess$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // IfInLine
                        match = ifInLine$Rule();
                        if (! match) {
                           // MacroFunctionCall
                           match = macroFunctionCall$Rule();
                           if (! match) {
                              // AnySimpleFunctionCall
                              match = anySimpleFunctionCall$Rule();
                              if (! match) {
                                 // Macro
                                 match = macro$Rule();
                                 if (! match) {
                                    // Variable
                                    match = variable$Rule();
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case ':':
            // SelfExpression
            match = selfExpression$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         atomicExpression$RuleMemoStart = startIndex;
         atomicExpression$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            atomicExpression$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ATOMIC_EXPRESSION, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            atomicExpression$RuleMemoFirstNode = currentNode;
            atomicExpression$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         atomicExpression$RuleMemoStart = startIndex;
         atomicExpression$RuleMemoEnd = -1;
         atomicExpression$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //KeyboardCall : ("keyboard" TestNoAlpha OptionalSpacing Expression)
   protected boolean keyboardCall$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (keyboardCall$RuleMemoStart == index) {
         if (keyboardCall$RuleMemoStart <= keyboardCall$RuleMemoEnd) {
            index = keyboardCall$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (keyboardCall$RuleMemoStart == keyboardCall$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CALL, keyboardCall$RuleMemoStart, keyboardCall$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(keyboardCall$RuleMemoFirstNode != null) {
                  lastNode.setSibling(keyboardCall$RuleMemoFirstNode);
                  currentNode = keyboardCall$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("keyboard" TestNoAlpha OptionalSpacing Expression)
      // "keyboard"
      match = ignoreCaseStringMatcher("keyboard", 8);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Expression
               match = expression$Rule();
            }
         }
      }
      if (match) {
         keyboardCall$RuleMemoStart = startIndex;
         keyboardCall$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            keyboardCall$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.KEYBOARD_CALL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            keyboardCall$RuleMemoFirstNode = currentNode;
            keyboardCall$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         keyboardCall$RuleMemoStart = startIndex;
         keyboardCall$RuleMemoEnd = -1;
         keyboardCall$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ClearTypehead : ("clear" TestNoAlpha OptionalSpacing "typeahead" TestNoAlpha OptionalSpacing)
   protected boolean clearTypehead$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (clearTypehead$RuleMemoStart == index) {
         if (clearTypehead$RuleMemoStart <= clearTypehead$RuleMemoEnd) {
            index = clearTypehead$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (clearTypehead$RuleMemoStart == clearTypehead$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_TYPEHEAD, clearTypehead$RuleMemoStart, clearTypehead$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(clearTypehead$RuleMemoFirstNode != null) {
                  lastNode.setSibling(clearTypehead$RuleMemoFirstNode);
                  currentNode = clearTypehead$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("clear" TestNoAlpha OptionalSpacing "typeahead" TestNoAlpha OptionalSpacing)
      // "clear"
      match = ignoreCaseStringMatcher("clear", 5);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // "typeahead"
               match = ignoreCaseStringMatcher("typeahead", 9);
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
            }
         }
      }
      if (match) {
         clearTypehead$RuleMemoStart = startIndex;
         clearTypehead$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            clearTypehead$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLEAR_TYPEHEAD, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            clearTypehead$RuleMemoFirstNode = currentNode;
            clearTypehead$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         clearTypehead$RuleMemoStart = startIndex;
         clearTypehead$RuleMemoEnd = -1;
         clearTypehead$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayAccess : ((ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable) ArrayIndex)
   protected boolean arrayAccess$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (arrayAccess$RuleMemoStart == index) {
         if (arrayAccess$RuleMemoStart <= arrayAccess$RuleMemoEnd) {
            index = arrayAccess$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (arrayAccess$RuleMemoStart == arrayAccess$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ACCESS, arrayAccess$RuleMemoStart, arrayAccess$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(arrayAccess$RuleMemoFirstNode != null) {
                  lastNode.setSibling(arrayAccess$RuleMemoFirstNode);
                  currentNode = arrayAccess$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable) ArrayIndex)
      // (ArrayLiteral | HashLiteral | StringLiteral | AliasedExpression | AliasedField | AliasedMacro | IfInLine | MacroFunctionCall | AnySimpleFunctionCall | Macro | Variable)
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '[':
            // StringLiteral
            match = stringLiteral$Rule();
            break;
         case '{':
            // ArrayLiteral
            match = arrayLiteral$Rule();
            if (! match) {
               // HashLiteral
               match = hashLiteral$Rule();
            }
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     // MacroFunctionCall
                     match = macroFunctionCall$Rule();
                     if (! match) {
                        // Macro
                        match = macro$Rule();
                     }
                  }
               }
            }
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'F':
         case 'G':
         case 'H':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'f':
         case 'g':
         case 'h':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     // MacroFunctionCall
                     match = macroFunctionCall$Rule();
                     if (! match) {
                        // AnySimpleFunctionCall
                        match = anySimpleFunctionCall$Rule();
                        if (! match) {
                           // Macro
                           match = macro$Rule();
                           if (! match) {
                              // Variable
                              match = variable$Rule();
                           }
                        }
                     }
                  }
               }
            }
            break;
         case 'E':
         case 'e':
            // StringLiteral
            match = stringLiteral$Rule();
            if (! match) {
               // AliasedExpression
               match = aliasedExpression$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 // Variable
                                 match = variable$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         case '(':
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  // AliasedMacro
                  match = aliasedMacro$Rule();
               }
            }
            break;
         case 'I':
         case 'i':
            // AliasedExpression
            match = aliasedExpression$Rule();
            if (! match) {
               // AliasedField
               match = aliasedField$Rule();
               if (! match) {
                  // AliasedMacro
                  match = aliasedMacro$Rule();
                  if (! match) {
                     // IfInLine
                     match = ifInLine$Rule();
                     if (! match) {
                        // MacroFunctionCall
                        match = macroFunctionCall$Rule();
                        if (! match) {
                           // AnySimpleFunctionCall
                           match = anySimpleFunctionCall$Rule();
                           if (! match) {
                              // Macro
                              match = macro$Rule();
                              if (! match) {
                                 // Variable
                                 match = variable$Rule();
                              }
                           }
                        }
                     }
                  }
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         // ArrayIndex
         match = arrayIndex$Rule();
      }
      if (match) {
         arrayAccess$RuleMemoStart = startIndex;
         arrayAccess$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            arrayAccess$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_ACCESS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            arrayAccess$RuleMemoFirstNode = currentNode;
            arrayAccess$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         arrayAccess$RuleMemoStart = startIndex;
         arrayAccess$RuleMemoEnd = -1;
         arrayAccess$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LeftValue : (SelfExpression | QualifiedExpression | ArrayAccess | AliasedField | AliasedMacro | Macro | Variable)
   protected boolean leftValue$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (leftValue$RuleMemoStart == index) {
         if (leftValue$RuleMemoStart <= leftValue$RuleMemoEnd) {
            index = leftValue$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (leftValue$RuleMemoStart == leftValue$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LEFT_VALUE, leftValue$RuleMemoStart, leftValue$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(leftValue$RuleMemoFirstNode != null) {
                  lastNode.setSibling(leftValue$RuleMemoFirstNode);
                  currentNode = leftValue$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (SelfExpression | QualifiedExpression | ArrayAccess | AliasedField | AliasedMacro | Macro | Variable)
      switch(buffer.getChar(index)) {
         case '\"':
         case '\'':
         case '[':
         case '{':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               // ArrayAccess
               match = arrayAccess$Rule();
            }
            break;
         case '.':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '&':
         case '7':
         case '8':
         case '9':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // Macro
                        match = macro$Rule();
                     }
                  }
               }
            }
            break;
         case 'A':
         case 'B':
         case 'C':
         case 'D':
         case 'E':
         case 'F':
         case 'G':
         case 'H':
         case 'I':
         case 'J':
         case 'K':
         case 'L':
         case 'M':
         case 'N':
         case 'O':
         case 'P':
         case 'Q':
         case 'R':
         case 'S':
         case 'T':
         case 'U':
         case 'V':
         case 'W':
         case 'X':
         case 'Y':
         case 'Z':
         case '_':
         case 'a':
         case 'b':
         case 'c':
         case 'd':
         case 'e':
         case 'f':
         case 'g':
         case 'h':
         case 'i':
         case 'j':
         case 'k':
         case 'l':
         case 'm':
         case 'n':
         case 'o':
         case 'p':
         case 'q':
         case 'r':
         case 's':
         case 't':
         case 'u':
         case 'v':
         case 'w':
         case 'x':
         case 'y':
         case 'z':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                     if (! match) {
                        // Macro
                        match = macro$Rule();
                        if (! match) {
                           // Variable
                           match = variable$Rule();
                        }
                     }
                  }
               }
            }
            break;
         case '(':
            // QualifiedExpression
            match = qualifiedExpression$Rule();
            if (! match) {
               // ArrayAccess
               match = arrayAccess$Rule();
               if (! match) {
                  // AliasedField
                  match = aliasedField$Rule();
                  if (! match) {
                     // AliasedMacro
                     match = aliasedMacro$Rule();
                  }
               }
            }
            break;
         case ':':
            // SelfExpression
            match = selfExpression$Rule();
            if (! match) {
               // QualifiedExpression
               match = qualifiedExpression$Rule();
            }
            break;
         default:
            match = false;
      }
      if (match) {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            leftValue$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LEFT_VALUE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            leftValue$RuleMemoFirstNode = currentNode;
            leftValue$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         leftValue$RuleMemoStart = startIndex;
         leftValue$RuleMemoEnd = -1;
         leftValue$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Dump : ("begindump" (EndDump! .)* EndDump)
   protected boolean dump$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("begindump" (EndDump! .)* EndDump)
      // "begindump"
      match = ignoreCaseStringMatcher("begindump", 9);
      if (match) {
         // (EndDump! .)*
         do {
            // (EndDump! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // EndDump!
            Node lastNode_2 = currentNode;
            int lastIndex_2 = index;
            boolean lastAtomic_2 = currentRuleIsAtomic;
            // EndDump
            match = endDump$Rule();
            currentRuleIsAtomic = lastAtomic_2;
            index = lastIndex_2;
            lastNode_2.setSibling(null);
            currentNode = lastNode_2;
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // EndDump
         match = endDump$Rule();
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DUMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndDump : ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing "enddump" TestNoAlpha OptionalSpacing)
   protected boolean endDump$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ('#' OptionalSpacing "pragma" TestNoAlpha OptionalSpacing "enddump" TestNoAlpha OptionalSpacing)
      // '#'
      match = charMatcher('#');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // "pragma"
            match = ignoreCaseStringMatcher("pragma", 6);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
                  if (match) {
                     // "enddump"
                     match = ignoreCaseStringMatcher("enddump", 7);
                     if (match) {
                        // TestNoAlpha
                        match = testNoAlpha$Rule();
                        if (match) {
                           // OptionalSpacing
                           match = optionalSpacing$Rule();
                        }
                     }
                  }
               }
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_DUMP, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParameterDeclaration : (Identifier AsType)
   protected boolean parameterDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (parameterDeclaration$RuleMemoStart == index) {
         if (parameterDeclaration$RuleMemoStart <= parameterDeclaration$RuleMemoEnd) {
            index = parameterDeclaration$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (parameterDeclaration$RuleMemoStart == parameterDeclaration$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_DECLARATION, parameterDeclaration$RuleMemoStart, parameterDeclaration$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(parameterDeclaration$RuleMemoFirstNode != null) {
                  lastNode.setSibling(parameterDeclaration$RuleMemoFirstNode);
                  currentNode = parameterDeclaration$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Identifier AsType)
      // Identifier
      match = identifier$Rule();
      if (match) {
         // AsType
         match = asType$Rule();
      }
      if (match) {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            parameterDeclaration$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETER_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            parameterDeclaration$RuleMemoFirstNode = currentNode;
            parameterDeclaration$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         parameterDeclaration$RuleMemoStart = startIndex;
         parameterDeclaration$RuleMemoEnd = -1;
         parameterDeclaration$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ParametersDeclaration : (ParametersDeclarationList | ('...' OptionalSpacing) | ')'&)
   protected boolean parametersDeclaration$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (ParametersDeclarationList | ('...' OptionalSpacing) | ')'&)
      // ParametersDeclarationList
      match = parametersDeclarationList$Rule();
      if (! match) {
         // ('...' OptionalSpacing)
         // '...'
         match = stringMatcher("...", 3);
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
         if (! match) {
            // ')'&
            // ')'
            match = buffer.matchChar(index, ')');
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.PARAMETERS_DECLARATION, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionModifiers : (("static" | "stati" | "stat" | "init" | "exit") TestNoAlpha OptionalSpacing)
   protected boolean functionModifiers$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // (("static" | "stati" | "stat" | "init" | "exit") TestNoAlpha OptionalSpacing)
      // ("static" | "stati" | "stat" | "init" | "exit")
      int startIndex_1 = index;
      switch(buffer.getChar(index)) {
         case 'i':
         case 'I':
            ++index;
            // "nit"
            if (match = ignoreCaseStringTest("nit", 3)) {
               index += 3;
            }
            break;
         case 's':
         case 'S':
            ++index;
            // ("tatic" | "tati" | "tat")
            if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
               ++index;
               // ("atic" | "ati" | "at")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("tic" | "ti" | "t")
                  if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                     ++index;
                     // ("ic" | "i" | <EMPTY>)
                     if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                        ++index;
                        // "c"
                        if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'e':
         case 'E':
            ++index;
            // "xit"
            if (match = ignoreCaseStringTest("xit", 3)) {
               index += 3;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIERS, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //FunctionModifier : FunctionModifiers?
   protected boolean functionModifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (functionModifier$RuleMemoStart == index) {
         if (functionModifier$RuleMemoStart <= functionModifier$RuleMemoEnd) {
            index = functionModifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (functionModifier$RuleMemoStart == functionModifier$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIER, functionModifier$RuleMemoStart, functionModifier$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(functionModifier$RuleMemoFirstNode != null) {
                  lastNode.setSibling(functionModifier$RuleMemoFirstNode);
                  currentNode = functionModifier$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // FunctionModifiers?
      // FunctionModifiers
      functionModifiers$Rule();
      functionModifier$RuleMemoStart = startIndex;
      functionModifier$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         functionModifier$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.FUNCTION_MODIFIER, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         functionModifier$RuleMemoFirstNode = currentNode;
         functionModifier$RuleMemoLastNode = currentNode;
      }
      return true;
   }

   //StringLiteral : (StringPattern OptionalSpacing)
   protected boolean stringLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (stringLiteral$RuleMemoStart == index) {
         if (stringLiteral$RuleMemoStart <= stringLiteral$RuleMemoEnd) {
            index = stringLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (stringLiteral$RuleMemoStart == stringLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, stringLiteral$RuleMemoStart, stringLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(stringLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(stringLiteral$RuleMemoFirstNode);
                  currentNode = stringLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (StringPattern OptionalSpacing)
      // StringPattern
      match = stringPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            stringLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            stringLiteral$RuleMemoFirstNode = currentNode;
            stringLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         stringLiteral$RuleMemoStart = startIndex;
         stringLiteral$RuleMemoEnd = -1;
         stringLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //StringPattern : (('"' (('\n' | '"')! .)* '"') | (''' (('\n' | ''')! .)* ''') | ('[' (('\n' | ']')! .)* ']') | ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"'))
   protected boolean stringPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('"' (('\n' | '"')! .)* '"') | (''' (('\n' | ''')! .)* ''') | ('[' (('\n' | ']')! .)* ']') | ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"'))
      switch(buffer.getChar(index)) {
         case '[':
            // ('[' (('\n' | ']')! .)* ']')
            // '['
            match = charMatcher('[');
            if (match) {
               // (('\n' | ']')! .)*
               do {
                  // (('\n' | ']')! .)
                  Node lastNode_1 = currentNode;
                  int lastIndex_1 = index;
                  // ('\n' | ']')!
                  // ('\n' | ']')
                  int startIndex_2 = index;
                  switch(buffer.getChar(index)) {
                     case ']':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     case '\n':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     default:
                        match = false;
                  }
                  index = startIndex_2;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                     if (! match) {
                        index = lastIndex_1;
                        lastNode_1.setSibling(null);
                        currentNode = lastNode_1;
                     }
                  }
               } while(match);
               match = true;
               if (match) {
                  // ']'
                  match = charMatcher(']');
               }
            }
            break;
         case '\"':
            // ('"' (('\n' | '"')! .)* '"')
            // '"'
            match = charMatcher('\"');
            if (match) {
               // (('\n' | '"')! .)*
               do {
                  // (('\n' | '"')! .)
                  Node lastNode_3 = currentNode;
                  int lastIndex_3 = index;
                  // ('\n' | '"')!
                  // ('\n' | '"')
                  int startIndex_4 = index;
                  switch(buffer.getChar(index)) {
                     case '\"':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     case '\n':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     default:
                        match = false;
                  }
                  index = startIndex_4;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                     if (! match) {
                        index = lastIndex_3;
                        lastNode_3.setSibling(null);
                        currentNode = lastNode_3;
                     }
                  }
               } while(match);
               match = true;
               if (match) {
                  // '"'
                  match = charMatcher('\"');
               }
            }
            break;
         case 'e':
         case 'E':
            // ("e" '"' (('\' '\n'! .) | (('\n' | '"')! .))* '"')
            // "e"
            match = ignoreCaseCharMatcher('e');
            if (match) {
               // '"'
               match = charMatcher('\"');
               if (match) {
                  // (('\' '\n'! .) | (('\n' | '"')! .))*
                  do {
                     // (('\' '\n'! .) | (('\n' | '"')! .))
                     switch(buffer.getChar(index)) {
                        case '\\':
                           // ('\' '\n'! .)
                           Node lastNode_5 = currentNode;
                           int lastIndex_5 = index;
                           // '\'
                           match = charMatcher('\\');
                           if (match) {
                              // '\n'!
                              // '\n'
                              match = buffer.matchChar(index, '\n');
                              match = ! match;
                              if (match) {
                                 // .
                                 match = anyCharMatcher();
                                 if (! match) {
                                    index = lastIndex_5;
                                    lastNode_5.setSibling(null);
                                    currentNode = lastNode_5;
                                 }
                              } else {
                                 index = lastIndex_5;
                                 lastNode_5.setSibling(null);
                              }
                           }
                           if (! match) {
                              // (('\n' | '"')! .)
                              Node lastNode_6 = currentNode;
                              int lastIndex_6 = index;
                              // ('\n' | '"')!
                              // ('\n' | '"')
                              int startIndex_7 = index;
                              switch(buffer.getChar(index)) {
                                 case '\"':
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 case '\n':
                                    ++index;
                                    // <EMPTY>
                                    match = true;
                                    break;
                                 default:
                                    match = false;
                              }
                              index = startIndex_7;
                              match = ! match;
                              if (match) {
                                 // .
                                 match = anyCharMatcher();
                                 if (! match) {
                                    index = lastIndex_6;
                                    lastNode_6.setSibling(null);
                                    currentNode = lastNode_6;
                                 }
                              }
                           }
                           break;
                        default:
                           // (('\n' | '"')! .)
                           Node lastNode_8 = currentNode;
                           int lastIndex_8 = index;
                           // ('\n' | '"')!
                           // ('\n' | '"')
                           int startIndex_9 = index;
                           switch(buffer.getChar(index)) {
                              case '\"':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              case '\n':
                                 ++index;
                                 // <EMPTY>
                                 match = true;
                                 break;
                              default:
                                 match = false;
                           }
                           index = startIndex_9;
                           match = ! match;
                           if (match) {
                              // .
                              match = anyCharMatcher();
                              if (! match) {
                                 index = lastIndex_8;
                                 lastNode_8.setSibling(null);
                                 currentNode = lastNode_8;
                              }
                           }
                     }
                  } while(match);
                  match = true;
                  if (match) {
                     // '"'
                     match = charMatcher('\"');
                  }
               }
            }
            break;
         case '\'':
            // (''' (('\n' | ''')! .)* ''')
            // '''
            match = charMatcher('\'');
            if (match) {
               // (('\n' | ''')! .)*
               do {
                  // (('\n' | ''')! .)
                  Node lastNode_10 = currentNode;
                  int lastIndex_10 = index;
                  // ('\n' | ''')!
                  // ('\n' | ''')
                  int startIndex_11 = index;
                  switch(buffer.getChar(index)) {
                     case '\'':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     case '\n':
                        ++index;
                        // <EMPTY>
                        match = true;
                        break;
                     default:
                        match = false;
                  }
                  index = startIndex_11;
                  match = ! match;
                  if (match) {
                     // .
                     match = anyCharMatcher();
                     if (! match) {
                        index = lastIndex_10;
                        lastNode_10.setSibling(null);
                        currentNode = lastNode_10;
                     }
                  }
               } while(match);
               match = true;
               if (match) {
                  // '''
                  match = charMatcher('\'');
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.STRING_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberLiteral : (NumberPattern EndsNumber)
   protected boolean numberLiteral$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (numberLiteral$RuleMemoStart == index) {
         if (numberLiteral$RuleMemoStart <= numberLiteral$RuleMemoEnd) {
            index = numberLiteral$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (numberLiteral$RuleMemoStart == numberLiteral$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, numberLiteral$RuleMemoStart, numberLiteral$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(numberLiteral$RuleMemoFirstNode != null) {
                  lastNode.setSibling(numberLiteral$RuleMemoFirstNode);
                  currentNode = numberLiteral$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (NumberPattern EndsNumber)
      // NumberPattern
      match = numberPattern$Rule();
      if (match) {
         // (('?' | '&' | '_' | '~')* OptionalSpacing)
         // ('?' | '&' | '_' | '~')*
         do {
            // ('?' | '&' | '_' | '~')
            int startIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '~':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '?':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '_':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '&':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            if (! match) {
               index = startIndex_1;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
               currentNode = currentNode.getSibling();
            }
         } while(match);
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            numberLiteral$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            numberLiteral$RuleMemoFirstNode = currentNode;
            numberLiteral$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         numberLiteral$RuleMemoStart = startIndex;
         numberLiteral$RuleMemoEnd = -1;
         numberLiteral$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //NumberPattern : ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
   protected boolean numberPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      currentRuleIsAtomic = true;
      startIndex = index;
      // ((IntegerNumber '.' IntegerNumber) | (IntegerNumber '.' Letter!) | IntegerNumber | ('.' IntegerNumber))
      switch(buffer.getChar(index)) {
         case '.':
            // ('.' IntegerNumber)
            // '.'
            match = charMatcher('.');
            if (match) {
               // IntegerNumber
               match = integerNumber$Rule();
            }
            break;
         case '0':
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
            // (IntegerNumber '.' IntegerNumber)
            // IntegerNumber
            match = integerNumber$Rule();
            if (match) {
               // '.'
               match = charMatcher('.');
               if (match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
            if (! match) {
               // (IntegerNumber '.' Letter!)
               // IntegerNumber
               match = integerNumber$Rule();
               if (match) {
                  // '.'
                  match = charMatcher('.');
                  if (match) {
                     // Letter!
                     // ('a'-'z' | 'A'-'Z')
                     // 'a'-'z'
                     match = buffer.matchCharRange(index, 'a', 'z');
                     if (! match) {
                        // 'A'-'Z'
                        match = buffer.matchCharRange(index, 'A', 'Z');
                     }
                     match = ! match;
                  }
               }
               if (! match) {
                  // IntegerNumber
                  match = integerNumber$Rule();
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.NUMBER_LITERAL, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArraySubType : ("of" TestNoAlpha OptionalSpacing DataType)
   protected boolean arraySubType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ("of" TestNoAlpha OptionalSpacing DataType)
      // "of"
      match = ignoreCaseStringMatcher("of", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DataType
               match = dataType$Rule();
            }
         }
      }
      if (match) {
         if (! currentRuleIsAtomic) {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_SUB_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
         }
         return true;
      } else {
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //DataType : ((("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing) | (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing) | ("date" TestNoAlpha OptionalSpacing) | (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing) | StringLiteral | (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing) | (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing) | ("hash" TestNoAlpha OptionalSpacing) | Array | Class)
   protected boolean dataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (dataType$RuleMemoStart == index) {
         if (dataType$RuleMemoStart <= dataType$RuleMemoEnd) {
            index = dataType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (dataType$RuleMemoStart == dataType$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATA_TYPE, dataType$RuleMemoStart, dataType$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(dataType$RuleMemoFirstNode != null) {
                  lastNode.setSibling(dataType$RuleMemoFirstNode);
                  currentNode = dataType$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ((("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing) | (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing) | ("date" TestNoAlpha OptionalSpacing) | (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing) | StringLiteral | (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing) | (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing) | ("hash" TestNoAlpha OptionalSpacing) | Array | Class)
      switch(buffer.getChar(index)) {
         case '\"':
         case 'e':
         case 'E':
         case '\'':
         case '[':
            // StringLiteral
            match = stringLiteral$Rule();
            break;
         case 'l':
         case 'L':
            // (("logical" | "logica" | "logic" | "logi") TestNoAlpha OptionalSpacing)
            // ("logical" | "logica" | "logic" | "logi")
            int startIndex_1 = index;
            if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
               ++index;
               // ("ogical" | "ogica" | "ogic" | "ogi")
               if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                  ++index;
                  // ("gical" | "gica" | "gic" | "gi")
                  if (buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G')) {
                     ++index;
                     // ("ical" | "ica" | "ic" | "i")
                     if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                        ++index;
                        // ("cal" | "ca" | "c" | <EMPTY>)
                        if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                           ++index;
                           // ("al" | "a" | <EMPTY>)
                           if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                              ++index;
                              // "l"
                              if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            if (! match) {
               index = startIndex_1;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         case 'n':
         case 'N':
            // (("numeric" | "numeri" | "numer" | "nume") TestNoAlpha OptionalSpacing)
            // ("numeric" | "numeri" | "numer" | "nume")
            int startIndex_2 = index;
            if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
               ++index;
               // ("umeric" | "umeri" | "umer" | "ume")
               if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                  ++index;
                  // ("meric" | "meri" | "mer" | "me")
                  if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                     ++index;
                     // ("eric" | "eri" | "er" | "e")
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // ("ric" | "ri" | "r" | <EMPTY>)
                        if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                           ++index;
                           // ("ic" | "i" | <EMPTY>)
                           if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                              ++index;
                              // "c"
                              if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            if (! match) {
               index = startIndex_2;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         case 'o':
         case 'O':
            // (("object" | "objec" | "obje") TestNoAlpha OptionalSpacing)
            // ("object" | "objec" | "obje")
            int startIndex_3 = index;
            if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
               ++index;
               // ("bject" | "bjec" | "bje")
               if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
                  ++index;
                  // ("ject" | "jec" | "je")
                  if (buffer.matchChar(index, 'j') || buffer.matchChar(index, 'J')) {
                     ++index;
                     // ("ect" | "ec" | "e")
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // ("ct" | "c" | <EMPTY>)
                        if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                           ++index;
                           // "t"
                           if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            if (! match) {
               index = startIndex_3;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_3, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         case 'a':
         case 'A':
            // Array
            match = array$Rule();
            break;
         case 'c':
         case 'C':
            // (("character" | "characte" | "charact" | "charac" | "chara" | "char") TestNoAlpha OptionalSpacing)
            // ("character" | "characte" | "charact" | "charac" | "chara" | "char")
            int startIndex_4 = index;
            if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
               ++index;
               // ("haracter" | "haracte" | "haract" | "harac" | "hara" | "har")
               if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
                  ++index;
                  // ("aracter" | "aracte" | "aract" | "arac" | "ara" | "ar")
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("racter" | "racte" | "ract" | "rac" | "ra" | "r")
                     if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                        ++index;
                        // ("acter" | "acte" | "act" | "ac" | "a" | <EMPTY>)
                        if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                           ++index;
                           // ("cter" | "cte" | "ct" | "c" | <EMPTY>)
                           if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                              ++index;
                              // ("ter" | "te" | "t" | <EMPTY>)
                              if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                                 ++index;
                                 // ("er" | "e" | <EMPTY>)
                                 if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                                    ++index;
                                    // "r"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            if (! match) {
               index = startIndex_4;
            } else if(! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_4, index, false, false));
               currentNode = currentNode.getSibling();
            }
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            if (! match) {
               // (("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code") TestNoAlpha OptionalSpacing)
               // ("codeblock" | "codebloc" | "codeblo" | "codebl" | "codeb" | "code")
               int startIndex_5 = index;
               if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                  ++index;
                  // ("odeblock" | "odebloc" | "odeblo" | "odebl" | "odeb" | "ode")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("deblock" | "debloc" | "deblo" | "debl" | "deb" | "de")
                     if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                        ++index;
                        // ("eblock" | "ebloc" | "eblo" | "ebl" | "eb" | "e")
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("block" | "bloc" | "blo" | "bl" | "b" | <EMPTY>)
                           if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
                              ++index;
                              // ("lock" | "loc" | "lo" | "l" | <EMPTY>)
                              if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                                 ++index;
                                 // ("ock" | "oc" | "o" | <EMPTY>)
                                 if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                                    ++index;
                                    // ("ck" | "c" | <EMPTY>)
                                    if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                       ++index;
                                       // "k"
                                       if (match = buffer.matchIgnoreCaseChar(index, 'k')) {
                                          ++index;
                                       }
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
               if (! match) {
                  index = startIndex_5;
               } else if(! currentRuleIsAtomic) {
                  currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_5, index, false, false));
                  currentNode = currentNode.getSibling();
               }
               if (match) {
                  // TestNoAlpha
                  match = testNoAlpha$Rule();
                  if (match) {
                     // OptionalSpacing
                     match = optionalSpacing$Rule();
                  }
               }
               if (! match) {
                  // Class
                  match = class$Rule();
               }
            }
            break;
         case 'd':
         case 'D':
            // ("date" TestNoAlpha OptionalSpacing)
            // "date"
            match = ignoreCaseStringMatcher("date", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         case 'h':
         case 'H':
            // ("hash" TestNoAlpha OptionalSpacing)
            // "hash"
            match = ignoreCaseStringMatcher("hash", 4);
            if (match) {
               // TestNoAlpha
               match = testNoAlpha$Rule();
               if (match) {
                  // OptionalSpacing
                  match = optionalSpacing$Rule();
               }
            }
            break;
         default:
            match = false;
      }
      if (match) {
         dataType$RuleMemoStart = startIndex;
         dataType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            dataType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.DATA_TYPE, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            dataType$RuleMemoFirstNode = currentNode;
            dataType$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         dataType$RuleMemoStart = startIndex;
         dataType$RuleMemoEnd = -1;
         dataType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ArrayType : ArraySubType?
   protected boolean arrayType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      startIndex = index;
      // ArraySubType?
      // ArraySubType
      arraySubType$Rule();
      if (! currentRuleIsAtomic) {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY_TYPE, startIndex, index, true, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
      }
      return true;
   }

   //Array : (("array" | "arra") TestNoAlpha OptionalSpacing ArrayType)
   protected boolean array$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (array$RuleMemoStart == index) {
         if (array$RuleMemoStart <= array$RuleMemoEnd) {
            index = array$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (array$RuleMemoStart == array$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY, array$RuleMemoStart, array$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(array$RuleMemoFirstNode != null) {
                  lastNode.setSibling(array$RuleMemoFirstNode);
                  currentNode = array$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("array" | "arra") TestNoAlpha OptionalSpacing ArrayType)
      // ("array" | "arra")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
         ++index;
         // ("rray" | "rra")
         if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
            ++index;
            // ("ray" | "ra")
            if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
               ++index;
               // ("ay" | "a")
               if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                  ++index;
                  // ("y" | <EMPTY>)
                  if (buffer.matchChar(index, 'y') || buffer.matchChar(index, 'Y')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // ArrayType
               match = arrayType$Rule();
            }
         }
      }
      if (match) {
         array$RuleMemoStart = startIndex;
         array$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            array$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ARRAY, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            array$RuleMemoFirstNode = currentNode;
            array$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         array$RuleMemoStart = startIndex;
         array$RuleMemoEnd = -1;
         array$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Class : (("class" | "clas") TestNoAlpha OptionalSpacing Identifier)
   protected boolean class$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (class$RuleMemoStart == index) {
         if (class$RuleMemoStart <= class$RuleMemoEnd) {
            index = class$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (class$RuleMemoStart == class$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS, class$RuleMemoStart, class$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(class$RuleMemoFirstNode != null) {
                  lastNode.setSibling(class$RuleMemoFirstNode);
                  currentNode = class$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (("class" | "clas") TestNoAlpha OptionalSpacing Identifier)
      // ("class" | "clas")
      int startIndex_1 = index;
      if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
         ++index;
         // ("lass" | "las")
         if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
            ++index;
            // ("ass" | "as")
            if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
               ++index;
               // ("ss" | "s")
               if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                  ++index;
                  // ("s" | <EMPTY>)
                  if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                     ++index;
                     // <EMPTY>
                     match = true;
                  } else {
                     match = true;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
         } else {
            match = false;
         }
      } else {
         match = false;
      }
      if (! match) {
         index = startIndex_1;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // Identifier
               match = identifier$Rule();
            }
         }
      }
      if (match) {
         class$RuleMemoStart = startIndex;
         class$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            class$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CLASS, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            class$RuleMemoFirstNode = currentNode;
            class$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         class$RuleMemoStart = startIndex;
         class$RuleMemoEnd = -1;
         class$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AsDataType : ("as" TestNoAlpha OptionalSpacing DataType)
   protected boolean asDataType$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (asDataType$RuleMemoStart == index) {
         if (asDataType$RuleMemoStart <= asDataType$RuleMemoEnd) {
            index = asDataType$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (asDataType$RuleMemoStart == asDataType$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_DATA_TYPE, asDataType$RuleMemoStart, asDataType$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(asDataType$RuleMemoFirstNode != null) {
                  lastNode.setSibling(asDataType$RuleMemoFirstNode);
                  currentNode = asDataType$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // ("as" TestNoAlpha OptionalSpacing DataType)
      // "as"
      match = ignoreCaseStringMatcher("as", 2);
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
            if (match) {
               // DataType
               match = dataType$Rule();
            }
         }
      }
      if (match) {
         asDataType$RuleMemoStart = startIndex;
         asDataType$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            asDataType$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.AS_DATA_TYPE, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            asDataType$RuleMemoFirstNode = currentNode;
            asDataType$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         asDataType$RuleMemoStart = startIndex;
         asDataType$RuleMemoEnd = -1;
         asDataType$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AnyIdentifier : (IdentifierPattern OptionalSpacing)
   protected boolean anyIdentifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (anyIdentifier$RuleMemoStart == index) {
         if (anyIdentifier$RuleMemoStart <= anyIdentifier$RuleMemoEnd) {
            index = anyIdentifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (anyIdentifier$RuleMemoStart == anyIdentifier$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_IDENTIFIER, anyIdentifier$RuleMemoStart, anyIdentifier$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(anyIdentifier$RuleMemoFirstNode != null) {
                  lastNode.setSibling(anyIdentifier$RuleMemoFirstNode);
                  currentNode = anyIdentifier$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (IdentifierPattern OptionalSpacing)
      // IdentifierPattern
      match = identifierPattern$Rule();
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
      }
      if (match) {
         anyIdentifier$RuleMemoStart = startIndex;
         anyIdentifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            anyIdentifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ANY_IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            anyIdentifier$RuleMemoFirstNode = currentNode;
            anyIdentifier$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         anyIdentifier$RuleMemoStart = startIndex;
         anyIdentifier$RuleMemoEnd = -1;
         anyIdentifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Identifier : (Keyword! IdentifierPattern OptionalSpacing)
   protected boolean identifier$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (identifier$RuleMemoStart == index) {
         if (identifier$RuleMemoStart <= identifier$RuleMemoEnd) {
            index = identifier$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (identifier$RuleMemoStart == identifier$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, identifier$RuleMemoStart, identifier$RuleMemoEnd, true, true);
                  lastNode.setSibling(currentNode);
               } else if(identifier$RuleMemoFirstNode != null) {
                  lastNode.setSibling(identifier$RuleMemoFirstNode);
                  currentNode = identifier$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Keyword! IdentifierPattern OptionalSpacing)
      // Keyword!
      Node lastNode_1 = currentNode;
      int lastIndex_1 = index;
      boolean lastAtomic_1 = currentRuleIsAtomic;
      // (("announce" | "announc" | "announ" | "annou" | "anno" | "begin" | "begi" | "break" | "brea" | "case" | "catch" | "catc" | "default" | "defaul" | "defau" | "defa" | "each" | "else" | "elseif" | "end" | "endcase" | "endcas" | "endca" | "endc" | "enddo" | "endd" | "endif" | "endi" | "endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends" | "exit" | "extern" | "exter" | "exte" | "field" | "fiel" | "for" | "function" | "functio" | "functi" | "funct" | "func" | "in" | "if" | "iif" | "init" | "local" | "loca" | "loop" | "memvar" | "memva" | "memv" | "next" | "nil" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "return" | "retur" | "retu" | "self" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "static" | "stati" | "stat" | "switch" | "switc" | "swit" | "try" | "using" | "usin" | "while" | "whil") TestNoAlpha)
      // ("announce" | "announc" | "announ" | "annou" | "anno" | "begin" | "begi" | "break" | "brea" | "case" | "catch" | "catc" | "default" | "defaul" | "defau" | "defa" | "each" | "else" | "elseif" | "end" | "endcase" | "endcas" | "endca" | "endc" | "enddo" | "endd" | "endif" | "endi" | "endsequence" | "endsequenc" | "endsequen" | "endseque" | "endsequ" | "endseq" | "endse" | "ends" | "exit" | "extern" | "exter" | "exte" | "field" | "fiel" | "for" | "function" | "functio" | "functi" | "funct" | "func" | "in" | "if" | "iif" | "init" | "local" | "loca" | "loop" | "memvar" | "memva" | "memv" | "next" | "nil" | "otherwise" | "otherwis" | "otherwi" | "otherw" | "other" | "othe" | "parameters" | "parameter" | "paramete" | "paramet" | "parame" | "param" | "para" | "procedure" | "procedur" | "procedu" | "proced" | "proce" | "proc" | "public" | "publi" | "publ" | "recover" | "recove" | "recov" | "reco" | "return" | "retur" | "retu" | "self" | "sequence" | "sequenc" | "sequen" | "seque" | "sequ" | "static" | "stati" | "stat" | "switch" | "switc" | "swit" | "try" | "using" | "usin" | "while" | "whil")
      int startIndex_2 = index;
      switch(buffer.getChar(index)) {
         case 'f':
         case 'F':
            ++index;
            // ("unction" | "unctio" | "uncti" | "ield" | "unct" | "iel" | "unc" | "or")
            switch(buffer.getChar(index)) {
               case 'o':
               case 'O':
                  ++index;
                  // "r"
                  if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                     ++index;
                  }
                  break;
               case 'i':
               case 'I':
                  ++index;
                  // ("eld" | "el")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("ld" | "l")
                     if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                        ++index;
                        // ("d" | <EMPTY>)
                        if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'u':
               case 'U':
                  ++index;
                  // ("nction" | "nctio" | "ncti" | "nct" | "nc")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("ction" | "ctio" | "cti" | "ct" | "c")
                     if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                        ++index;
                        // ("tion" | "tio" | "ti" | "t" | <EMPTY>)
                        if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                           ++index;
                           // ("ion" | "io" | "i" | <EMPTY>)
                           if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                              ++index;
                              // ("on" | "o" | <EMPTY>)
                              if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                                 ++index;
                                 // "n"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'w':
         case 'W':
            ++index;
            // ("hile" | "hil")
            if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
               ++index;
               // ("ile" | "il")
               if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                  ++index;
                  // ("le" | "l")
                  if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                     ++index;
                     // ("e" | <EMPTY>)
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'i':
         case 'I':
            ++index;
            // ("nit" | "if" | "n" | "f")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N':
                  ++index;
                  // ("it" | <EMPTY>)
                  if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                     ++index;
                     // "t"
                     if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                        ++index;
                     }
                  } else {
                     match = true;
                  }
                  break;
               case 'f':
               case 'F':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case 'i':
               case 'I':
                  ++index;
                  // "f"
                  if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                     ++index;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'l':
         case 'L':
            ++index;
            // ("ocal" | "oca" | "oop")
            if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
               ++index;
               // ("cal" | "ca" | "op")
               switch(buffer.getChar(index)) {
                  case 'o':
                  case 'O':
                     ++index;
                     // "p"
                     if (match = buffer.matchIgnoreCaseChar(index, 'p')) {
                        ++index;
                     }
                     break;
                  case 'c':
                  case 'C':
                     ++index;
                     // ("al" | "a")
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // ("l" | <EMPTY>)
                        if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                     break;
                  default:
                     match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'm':
         case 'M':
            ++index;
            // ("emvar" | "emva" | "emv")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("mvar" | "mva" | "mv")
               if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                  ++index;
                  // ("var" | "va" | "v")
                  if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                     ++index;
                     // ("ar" | "a" | <EMPTY>)
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // "r"
                        if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                           ++index;
                        }
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'n':
         case 'N':
            ++index;
            // ("ext" | "il")
            switch(buffer.getChar(index)) {
               case 'i':
               case 'I':
                  ++index;
                  // "l"
                  if (match = buffer.matchIgnoreCaseChar(index, 'l')) {
                     ++index;
                  }
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // "xt"
                  if (match = ignoreCaseStringTest("xt", 2)) {
                     index += 2;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'o':
         case 'O':
            ++index;
            // ("therwise" | "therwis" | "therwi" | "therw" | "ther" | "the")
            if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
               ++index;
               // ("herwise" | "herwis" | "herwi" | "herw" | "her" | "he")
               if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
                  ++index;
                  // ("erwise" | "erwis" | "erwi" | "erw" | "er" | "e")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("rwise" | "rwis" | "rwi" | "rw" | "r" | <EMPTY>)
                     if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                        ++index;
                        // ("wise" | "wis" | "wi" | "w" | <EMPTY>)
                        if (buffer.matchChar(index, 'w') || buffer.matchChar(index, 'W')) {
                           ++index;
                           // ("ise" | "is" | "i" | <EMPTY>)
                           if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'p':
         case 'P':
            ++index;
            // ("arameters" | "arameter" | "rocedure" | "aramete" | "rocedur" | "aramet" | "rocedu" | "arame" | "roced" | "ublic" | "aram" | "roce" | "ubli" | "ara" | "roc" | "ubl")
            switch(buffer.getChar(index)) {
               case 'a':
               case 'A':
                  ++index;
                  // ("rameters" | "rameter" | "ramete" | "ramet" | "rame" | "ram" | "ra")
                  if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                     ++index;
                     // ("ameters" | "ameter" | "amete" | "amet" | "ame" | "am" | "a")
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // ("meters" | "meter" | "mete" | "met" | "me" | "m" | <EMPTY>)
                        if (buffer.matchChar(index, 'm') || buffer.matchChar(index, 'M')) {
                           ++index;
                           // ("eters" | "eter" | "ete" | "et" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("ters" | "ter" | "te" | "t" | <EMPTY>)
                              if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                                 ++index;
                                 // ("ers" | "er" | "e" | <EMPTY>)
                                 if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                                    ++index;
                                    // ("rs" | "r" | <EMPTY>)
                                    if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                       ++index;
                                       // "s"
                                       if (match = buffer.matchIgnoreCaseChar(index, 's')) {
                                          ++index;
                                       }
                                       // <EMPTY>
                                       match = true;
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'r':
               case 'R':
                  ++index;
                  // ("ocedure" | "ocedur" | "ocedu" | "oced" | "oce" | "oc")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("cedure" | "cedur" | "cedu" | "ced" | "ce" | "c")
                     if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                        ++index;
                        // ("edure" | "edur" | "edu" | "ed" | "e" | <EMPTY>)
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("dure" | "dur" | "du" | "d" | <EMPTY>)
                           if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                              ++index;
                              // ("ure" | "ur" | "u" | <EMPTY>)
                              if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                                 ++index;
                                 // ("re" | "r" | <EMPTY>)
                                 if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                                    ++index;
                                    // "e"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'u':
               case 'U':
                  ++index;
                  // ("blic" | "bli" | "bl")
                  if (buffer.matchChar(index, 'b') || buffer.matchChar(index, 'B')) {
                     ++index;
                     // ("lic" | "li" | "l")
                     if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // "c"
                           if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'a':
         case 'A':
            ++index;
            // ("nnounce" | "nnounc" | "nnoun" | "nnou" | "nno")
            if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
               ++index;
               // ("nounce" | "nounc" | "noun" | "nou" | "no")
               if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                  ++index;
                  // ("ounce" | "ounc" | "oun" | "ou" | "o")
                  if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                     ++index;
                     // ("unce" | "unc" | "un" | "u" | <EMPTY>)
                     if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                        ++index;
                        // ("nce" | "nc" | "n" | <EMPTY>)
                        if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                           ++index;
                           // ("ce" | "c" | <EMPTY>)
                           if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                              ++index;
                              // "e"
                              if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'b':
         case 'B':
            ++index;
            // ("egin" | "reak" | "egi" | "rea")
            switch(buffer.getChar(index)) {
               case 'r':
               case 'R':
                  ++index;
                  // ("eak" | "ea")
                  if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                     ++index;
                     // ("ak" | "a")
                     if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                        ++index;
                        // ("k" | <EMPTY>)
                        if (buffer.matchChar(index, 'k') || buffer.matchChar(index, 'K')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // ("gin" | "gi")
                  if (buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G')) {
                     ++index;
                     // ("in" | "i")
                     if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                        ++index;
                        // ("n" | <EMPTY>)
                        if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'r':
         case 'R':
            ++index;
            // ("ecover" | "ecove" | "eturn" | "ecov" | "etur" | "eco" | "etu")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("cover" | "cove" | "turn" | "cov" | "tur" | "co" | "tu")
               switch(buffer.getChar(index)) {
                  case 'c':
                  case 'C':
                     ++index;
                     // ("over" | "ove" | "ov" | "o")
                     if (buffer.matchChar(index, 'o') || buffer.matchChar(index, 'O')) {
                        ++index;
                        // ("ver" | "ve" | "v" | <EMPTY>)
                        if (buffer.matchChar(index, 'v') || buffer.matchChar(index, 'V')) {
                           ++index;
                           // ("er" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // "r"
                              if (match = buffer.matchIgnoreCaseChar(index, 'r')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                     break;
                  case 't':
                  case 'T':
                     ++index;
                     // ("urn" | "ur" | "u")
                     if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                        ++index;
                        // ("rn" | "r" | <EMPTY>)
                        if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                           ++index;
                           // "n"
                           if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                     break;
                  default:
                     match = false;
               }
            } else {
               match = false;
            }
            break;
         case 'c':
         case 'C':
            ++index;
            // ("atch" | "ase" | "atc")
            if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
               ++index;
               // ("tch" | "se" | "tc")
               switch(buffer.getChar(index)) {
                  case 's':
                  case 'S':
                     ++index;
                     // "e"
                     if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                        ++index;
                     }
                     break;
                  case 't':
                  case 'T':
                     ++index;
                     // ("ch" | "c")
                     if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                        ++index;
                        // ("h" | <EMPTY>)
                        if (buffer.matchChar(index, 'h') || buffer.matchChar(index, 'H')) {
                           ++index;
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                     break;
                  default:
                     match = false;
               }
            } else {
               match = false;
            }
            break;
         case 's':
         case 'S':
            ++index;
            // ("equence" | "equenc" | "equen" | "tatic" | "witch" | "eque" | "tati" | "witc" | "elf" | "equ" | "tat" | "wit")
            switch(buffer.getChar(index)) {
               case 'w':
               case 'W':
                  ++index;
                  // ("itch" | "itc" | "it")
                  if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                     ++index;
                     // ("tch" | "tc" | "t")
                     if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                        ++index;
                        // ("ch" | "c" | <EMPTY>)
                        if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                           ++index;
                           // "h"
                           if (match = buffer.matchIgnoreCaseChar(index, 'h')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 't':
               case 'T':
                  ++index;
                  // ("atic" | "ati" | "at")
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("tic" | "ti" | "t")
                     if (buffer.matchChar(index, 't') || buffer.matchChar(index, 'T')) {
                        ++index;
                        // ("ic" | "i" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // "c"
                           if (match = buffer.matchIgnoreCaseChar(index, 'c')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'e':
               case 'E':
                  ++index;
                  // ("quence" | "quenc" | "quen" | "que" | "lf" | "qu")
                  switch(buffer.getChar(index)) {
                     case 'q':
                     case 'Q':
                        ++index;
                        // ("uence" | "uenc" | "uen" | "ue" | "u")
                        if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                           ++index;
                           // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("nce" | "nc" | "n" | <EMPTY>)
                              if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                 ++index;
                                 // ("ce" | "c" | <EMPTY>)
                                 if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                    ++index;
                                    // "e"
                                    if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                       ++index;
                                    }
                                    // <EMPTY>
                                    match = true;
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                        break;
                     case 'l':
                     case 'L':
                        ++index;
                        // "f"
                        if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                           ++index;
                        }
                        break;
                     default:
                        match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'd':
         case 'D':
            ++index;
            // ("efault" | "efaul" | "efau" | "efa")
            if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
               ++index;
               // ("fault" | "faul" | "fau" | "fa")
               if (buffer.matchChar(index, 'f') || buffer.matchChar(index, 'F')) {
                  ++index;
                  // ("ault" | "aul" | "au" | "a")
                  if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                     ++index;
                     // ("ult" | "ul" | "u" | <EMPTY>)
                     if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                        ++index;
                        // ("lt" | "l" | <EMPTY>)
                        if (buffer.matchChar(index, 'l') || buffer.matchChar(index, 'L')) {
                           ++index;
                           // "t"
                           if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                        } else {
                           match = true;
                        }
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         case 't':
         case 'T':
            ++index;
            // "ry"
            if (match = ignoreCaseStringTest("ry", 2)) {
               index += 2;
            }
            break;
         case 'e':
         case 'E':
            ++index;
            // ("ndsequence" | "ndsequenc" | "ndsequen" | "ndseque" | "ndcase" | "ndsequ" | "lseif" | "ndcas" | "ndseq" | "xtern" | "ndca" | "nddo" | "ndif" | "ndse" | "xter" | "ach" | "lse" | "ndc" | "ndd" | "ndi" | "nds" | "xit" | "xte" | "nd")
            switch(buffer.getChar(index)) {
               case 'n':
               case 'N':
                  ++index;
                  // ("dsequence" | "dsequenc" | "dsequen" | "dseque" | "dcase" | "dsequ" | "dcas" | "dseq" | "dca" | "ddo" | "dif" | "dse" | "dc" | "dd" | "di" | "ds" | "d")
                  if (buffer.matchChar(index, 'd') || buffer.matchChar(index, 'D')) {
                     ++index;
                     // ("sequence" | "sequenc" | "sequen" | "seque" | "case" | "sequ" | "cas" | "seq" | "ca" | "do" | "if" | "se" | "c" | "d" | "i" | "s" | <EMPTY>)
                     switch(buffer.getChar(index)) {
                        case 'i':
                        case 'I':
                           ++index;
                           // "f"
                           if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                           break;
                        case 's':
                        case 'S':
                           ++index;
                           // ("equence" | "equenc" | "equen" | "eque" | "equ" | "eq" | "e" | <EMPTY>)
                           if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                              ++index;
                              // ("quence" | "quenc" | "quen" | "que" | "qu" | "q" | <EMPTY>)
                              if (buffer.matchChar(index, 'q') || buffer.matchChar(index, 'Q')) {
                                 ++index;
                                 // ("uence" | "uenc" | "uen" | "ue" | "u" | <EMPTY>)
                                 if (buffer.matchChar(index, 'u') || buffer.matchChar(index, 'U')) {
                                    ++index;
                                    // ("ence" | "enc" | "en" | "e" | <EMPTY>)
                                    if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                                       ++index;
                                       // ("nce" | "nc" | "n" | <EMPTY>)
                                       if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                                          ++index;
                                          // ("ce" | "c" | <EMPTY>)
                                          if (buffer.matchChar(index, 'c') || buffer.matchChar(index, 'C')) {
                                             ++index;
                                             // "e"
                                             if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                                ++index;
                                             }
                                             // <EMPTY>
                                             match = true;
                                          } else {
                                             match = true;
                                          }
                                       } else {
                                          match = true;
                                       }
                                    } else {
                                       match = true;
                                    }
                                 } else {
                                    match = true;
                                 }
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                           break;
                        case 'c':
                        case 'C':
                           ++index;
                           // ("ase" | "as" | "a" | <EMPTY>)
                           if (buffer.matchChar(index, 'a') || buffer.matchChar(index, 'A')) {
                              ++index;
                              // ("se" | "s" | <EMPTY>)
                              if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                                 ++index;
                                 // "e"
                                 if (match = buffer.matchIgnoreCaseChar(index, 'e')) {
                                    ++index;
                                 }
                                 // <EMPTY>
                                 match = true;
                              } else {
                                 match = true;
                              }
                           } else {
                              match = true;
                           }
                           break;
                        case 'd':
                        case 'D':
                           ++index;
                           // "o"
                           if (match = buffer.matchIgnoreCaseChar(index, 'o')) {
                              ++index;
                           }
                           // <EMPTY>
                           match = true;
                           break;
                        default:
                           match = true;
                     }
                  } else {
                     match = false;
                  }
                  break;
               case 'x':
               case 'X':
                  ++index;
                  // ("tern" | "ter" | "it" | "te")
                  switch(buffer.getChar(index)) {
                     case 'i':
                     case 'I':
                        ++index;
                        // "t"
                        if (match = buffer.matchIgnoreCaseChar(index, 't')) {
                           ++index;
                        }
                        break;
                     case 't':
                     case 'T':
                        ++index;
                        // ("ern" | "er" | "e")
                        if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                           ++index;
                           // ("rn" | "r" | <EMPTY>)
                           if (buffer.matchChar(index, 'r') || buffer.matchChar(index, 'R')) {
                              ++index;
                              // "n"
                              if (match = buffer.matchIgnoreCaseChar(index, 'n')) {
                                 ++index;
                              }
                              // <EMPTY>
                              match = true;
                           } else {
                              match = true;
                           }
                        } else {
                           match = false;
                        }
                        break;
                     default:
                        match = false;
                  }
                  break;
               case 'a':
               case 'A':
                  ++index;
                  // "ch"
                  if (match = ignoreCaseStringTest("ch", 2)) {
                     index += 2;
                  }
                  break;
               case 'l':
               case 'L':
                  ++index;
                  // ("seif" | "se")
                  if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
                     ++index;
                     // ("eif" | "e")
                     if (buffer.matchChar(index, 'e') || buffer.matchChar(index, 'E')) {
                        ++index;
                        // ("if" | <EMPTY>)
                        if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                           ++index;
                           // "f"
                           if (match = buffer.matchIgnoreCaseChar(index, 'f')) {
                              ++index;
                           }
                        } else {
                           match = true;
                        }
                     } else {
                        match = false;
                     }
                  } else {
                     match = false;
                  }
                  break;
               default:
                  match = false;
            }
            break;
         case 'u':
         case 'U':
            ++index;
            // ("sing" | "sin")
            if (buffer.matchChar(index, 's') || buffer.matchChar(index, 'S')) {
               ++index;
               // ("ing" | "in")
               if (buffer.matchChar(index, 'i') || buffer.matchChar(index, 'I')) {
                  ++index;
                  // ("ng" | "n")
                  if (buffer.matchChar(index, 'n') || buffer.matchChar(index, 'N')) {
                     ++index;
                     // ("g" | <EMPTY>)
                     if (buffer.matchChar(index, 'g') || buffer.matchChar(index, 'G')) {
                        ++index;
                        // <EMPTY>
                        match = true;
                     } else {
                        match = true;
                     }
                  } else {
                     match = false;
                  }
               } else {
                  match = false;
               }
            } else {
               match = false;
            }
            break;
         default:
            match = false;
      }
      if (! match) {
         index = startIndex_2;
      } else if(! currentRuleIsAtomic) {
         currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_2, index, false, false));
         currentNode = currentNode.getSibling();
      }
      if (match) {
         // TestNoAlpha
         match = testNoAlpha$Rule();
      }
      currentRuleIsAtomic = lastAtomic_1;
      index = lastIndex_1;
      lastNode_1.setSibling(null);
      currentNode = lastNode_1;
      match = ! match;
      if (match) {
         // IdentifierPattern
         match = identifierPattern$Rule();
         if (match) {
            // OptionalSpacing
            match = optionalSpacing$Rule();
         }
      }
      if (match) {
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifier$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, startIndex, index, true, true);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            identifier$RuleMemoFirstNode = currentNode;
            identifier$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         identifier$RuleMemoStart = startIndex;
         identifier$RuleMemoEnd = -1;
         identifier$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //IdentifierPattern : (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
   protected boolean identifierPattern$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (identifierPattern$RuleMemoStart == index) {
         if (identifierPattern$RuleMemoStart <= identifierPattern$RuleMemoEnd) {
            index = identifierPattern$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (identifierPattern$RuleMemoStart == identifierPattern$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, identifierPattern$RuleMemoStart, identifierPattern$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(identifierPattern$RuleMemoFirstNode != null) {
                  lastNode.setSibling(identifierPattern$RuleMemoFirstNode);
                  currentNode = identifierPattern$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('A'-'Z' | 'a'-'z' | '_') ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*)
      // ('A'-'Z' | 'a'-'z' | '_')
      // 'A'-'Z'
      match = charRangeMatcher('A', 'Z');
      if (! match) {
         // 'a'-'z'
         match = charRangeMatcher('a', 'z');
         if (! match) {
            // '_'
            match = charMatcher('_');
         }
      }
      if (match) {
         // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')*
         do {
            // ('A'-'Z' | 'a'-'z' | '0'-'9' | '_')
            // 'A'-'Z'
            match = charRangeMatcher('A', 'Z');
            if (! match) {
               // 'a'-'z'
               match = charRangeMatcher('a', 'z');
               if (! match) {
                  // '0'-'9'
                  match = charRangeMatcher('0', '9');
                  if (! match) {
                     // '_'
                     match = charMatcher('_');
                  }
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifierPattern$RuleMemoStart = startIndex;
         identifierPattern$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            identifierPattern$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.IDENTIFIER, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            identifierPattern$RuleMemoFirstNode = currentNode;
            identifierPattern$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         identifierPattern$RuleMemoStart = startIndex;
         identifierPattern$RuleMemoEnd = -1;
         identifierPattern$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Whitespace : (' ' | '\t' | '\f')+
   protected boolean whitespace$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (whitespace$RuleMemoStart == index) {
         if (whitespace$RuleMemoStart <= whitespace$RuleMemoEnd) {
            index = whitespace$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (whitespace$RuleMemoStart == whitespace$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.WHITESPACE, whitespace$RuleMemoStart, whitespace$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(whitespace$RuleMemoFirstNode != null) {
                  lastNode.setSibling(whitespace$RuleMemoFirstNode);
                  currentNode = whitespace$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (' ' | '\t' | '\f')+
      // (' ' | '\t' | '\f')
      switch(buffer.getChar(index)) {
         case '\f':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case ' ':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\t':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (match) {
         do {
            // (' ' | '\t' | '\f')
            switch(buffer.getChar(index)) {
               case '\f':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case ' ':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               case '\t':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            whitespace$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.WHITESPACE, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            whitespace$RuleMemoFirstNode = currentNode;
            whitespace$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         whitespace$RuleMemoStart = startIndex;
         whitespace$RuleMemoEnd = -1;
         whitespace$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //LineComment : (('//' | '&&') (('\n' | '\r' | <EOI>)! .)*)
   protected boolean lineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (lineComment$RuleMemoStart == index) {
         if (lineComment$RuleMemoStart <= lineComment$RuleMemoEnd) {
            index = lineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (lineComment$RuleMemoStart == lineComment$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_COMMENT, lineComment$RuleMemoStart, lineComment$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(lineComment$RuleMemoFirstNode != null) {
                  lastNode.setSibling(lineComment$RuleMemoFirstNode);
                  currentNode = lineComment$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // (('//' | '&&') (('\n' | '\r' | <EOI>)! .)*)
      // ('//' | '&&')
      switch(buffer.getChar(index)) {
         case '/':
            ++index;
            // '/'
            if (match = buffer.matchChar(index, '/')) {
               ++index;
            }
            break;
         case '&':
            ++index;
            // '&'
            if (match = buffer.matchChar(index, '&')) {
               ++index;
            }
            break;
         default:
            match = false;
      }
      if (match) {
         // (('\n' | '\r' | <EOI>)! .)*
         do {
            // (('\n' | '\r' | <EOI>)! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | '\r' | <EOI>)!
            // ('\n' | '\r' | <EOI>)
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // '\r'
               match = buffer.matchChar(index, '\r');
               if (! match) {
                  // <EOI>
                  match = eoi();
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            lineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            lineComment$RuleMemoFirstNode = currentNode;
            lineComment$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         lineComment$RuleMemoStart = startIndex;
         lineComment$RuleMemoEnd = -1;
         lineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //BlockComment : ('/*' ('*/'! .)* '*/')
   protected boolean blockComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (blockComment$RuleMemoStart == index) {
         if (blockComment$RuleMemoStart <= blockComment$RuleMemoEnd) {
            index = blockComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (blockComment$RuleMemoStart == blockComment$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.BLOCK_COMMENT, blockComment$RuleMemoStart, blockComment$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(blockComment$RuleMemoFirstNode != null) {
                  lastNode.setSibling(blockComment$RuleMemoFirstNode);
                  currentNode = blockComment$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('/*' ('*/'! .)* '*/')
      // '/*'
      match = stringMatcher("/*", 2);
      if (match) {
         // ('*/'! .)*
         do {
            // ('*/'! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // '*/'!
            // '*/'
            match = stringTest("*/", 2);
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         // '*/'
         match = stringMatcher("*/", 2);
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            blockComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.BLOCK_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            blockComment$RuleMemoFirstNode = currentNode;
            blockComment$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         blockComment$RuleMemoStart = startIndex;
         blockComment$RuleMemoEnd = -1;
         blockComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //AloneLineComment : ('*' (('\n' | '\r' | <EOI>)! .)*)
   protected boolean aloneLineComment$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (aloneLineComment$RuleMemoStart == index) {
         if (aloneLineComment$RuleMemoStart <= aloneLineComment$RuleMemoEnd) {
            index = aloneLineComment$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (aloneLineComment$RuleMemoStart == aloneLineComment$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALONE_LINE_COMMENT, aloneLineComment$RuleMemoStart, aloneLineComment$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(aloneLineComment$RuleMemoFirstNode != null) {
                  lastNode.setSibling(aloneLineComment$RuleMemoFirstNode);
                  currentNode = aloneLineComment$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('*' (('\n' | '\r' | <EOI>)! .)*)
      // '*'
      match = charMatcher('*');
      if (match) {
         // (('\n' | '\r' | <EOI>)! .)*
         do {
            // (('\n' | '\r' | <EOI>)! .)
            Node lastNode_1 = currentNode;
            int lastIndex_1 = index;
            // ('\n' | '\r' | <EOI>)!
            // ('\n' | '\r' | <EOI>)
            // '\n'
            match = buffer.matchChar(index, '\n');
            if (! match) {
               // '\r'
               match = buffer.matchChar(index, '\r');
               if (! match) {
                  // <EOI>
                  match = eoi();
               }
            }
            match = ! match;
            if (match) {
               // .
               match = anyCharMatcher();
               if (! match) {
                  index = lastIndex_1;
                  lastNode_1.setSibling(null);
                  currentNode = lastNode_1;
               }
            }
         } while(match);
         match = true;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            aloneLineComment$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.ALONE_LINE_COMMENT, startIndex, index, true, false);
            lastNode.setSibling(currentNode);
            aloneLineComment$RuleMemoFirstNode = currentNode;
            aloneLineComment$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         aloneLineComment$RuleMemoStart = startIndex;
         aloneLineComment$RuleMemoEnd = -1;
         aloneLineComment$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //EndStmt : ('\n' | '\r\n' | ';')
   protected boolean endStmt$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      boolean lastRuleIsAtomic = currentRuleIsAtomic;
      if (endStmt$RuleMemoStart == index) {
         if (endStmt$RuleMemoStart <= endStmt$RuleMemoEnd) {
            index = endStmt$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (endStmt$RuleMemoStart == endStmt$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_STMT, endStmt$RuleMemoStart, endStmt$RuleMemoEnd, false, false);
                  lastNode.setSibling(currentNode);
               } else if(endStmt$RuleMemoFirstNode != null) {
                  lastNode.setSibling(endStmt$RuleMemoFirstNode);
                  currentNode = endStmt$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      currentRuleIsAtomic = true;
      startIndex = index;
      // ('\n' | '\r\n' | ';')
      switch(buffer.getChar(index)) {
         case ';':
            ++index;
            // <EMPTY>
            match = true;
            break;
         case '\r':
            ++index;
            // '\n'
            if (match = buffer.matchChar(index, '\n')) {
               ++index;
            }
            break;
         case '\n':
            ++index;
            // <EMPTY>
            match = true;
            break;
         default:
            match = false;
      }
      if (match) {
         currentRuleIsAtomic = lastRuleIsAtomic;
         endStmt$RuleMemoStart = startIndex;
         endStmt$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            endStmt$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.END_STMT, startIndex, index, false, false);
            lastNode.setSibling(currentNode);
            endStmt$RuleMemoFirstNode = currentNode;
            endStmt$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         currentRuleIsAtomic = lastRuleIsAtomic;
         endStmt$RuleMemoStart = startIndex;
         endStmt$RuleMemoEnd = -1;
         endStmt$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //Spacing : (Whitespace | LineComment | BlockComment | ContinueNL)+
   protected boolean spacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (spacing$RuleMemoStart == index) {
         if (spacing$RuleMemoStart <= spacing$RuleMemoEnd) {
            index = spacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (spacing$RuleMemoStart == spacing$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, spacing$RuleMemoStart, spacing$RuleMemoEnd, false, false);
                  lastNode.setSibling(currentNode);
               } else if(spacing$RuleMemoFirstNode != null) {
                  lastNode.setSibling(spacing$RuleMemoFirstNode);
                  currentNode = spacing$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | LineComment | BlockComment | ContinueNL)+
      // (Whitespace | LineComment | BlockComment | ContinueNL)
      switch(buffer.getChar(index)) {
         case ';':
            // ContinueNL
            match = continueNL$Rule();
            break;
         case ' ':
         case '\t':
         case '\f':
            // Whitespace
            match = whitespace$Rule();
            break;
         case '/':
            // LineComment
            match = lineComment$Rule();
            if (! match) {
               // BlockComment
               match = blockComment$Rule();
            }
            break;
         case '&':
            // LineComment
            match = lineComment$Rule();
            break;
         default:
            match = false;
      }
      if (match) {
         do {
            // (Whitespace | LineComment | BlockComment | ContinueNL)
            switch(buffer.getChar(index)) {
               case ';':
                  // ContinueNL
                  match = continueNL$Rule();
                  break;
               case ' ':
               case '\t':
               case '\f':
                  // Whitespace
                  match = whitespace$Rule();
                  break;
               case '/':
                  // LineComment
                  match = lineComment$Rule();
                  if (! match) {
                     // BlockComment
                     match = blockComment$Rule();
                  }
                  break;
               case '&':
                  // LineComment
                  match = lineComment$Rule();
                  break;
               default:
                  match = false;
            }
         } while(match);
         match = true;
      }
      if (match) {
         spacing$RuleMemoStart = startIndex;
         spacing$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            spacing$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, startIndex, index, false, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            spacing$RuleMemoFirstNode = currentNode;
            spacing$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         spacing$RuleMemoStart = startIndex;
         spacing$RuleMemoEnd = -1;
         spacing$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //ContinueNL : (';' OptionalSpacing (Whitespace | LineComment | BlockComment)* NewLine)
   protected boolean continueNL$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (continueNL$RuleMemoStart == index) {
         if (continueNL$RuleMemoStart <= continueNL$RuleMemoEnd) {
            index = continueNL$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (continueNL$RuleMemoStart == continueNL$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_NL, continueNL$RuleMemoStart, continueNL$RuleMemoEnd, true, false);
                  lastNode.setSibling(currentNode);
               } else if(continueNL$RuleMemoFirstNode != null) {
                  lastNode.setSibling(continueNL$RuleMemoFirstNode);
                  currentNode = continueNL$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (';' OptionalSpacing (Whitespace | LineComment | BlockComment)* NewLine)
      // ';'
      match = charMatcher(';');
      if (match) {
         // OptionalSpacing
         match = optionalSpacing$Rule();
         if (match) {
            // (Whitespace | LineComment | BlockComment)*
            do {
               // (Whitespace | LineComment | BlockComment)
               switch(buffer.getChar(index)) {
                  case ' ':
                  case '\t':
                  case '\f':
                     // Whitespace
                     match = whitespace$Rule();
                     break;
                  case '/':
                     // LineComment
                     match = lineComment$Rule();
                     if (! match) {
                        // BlockComment
                        match = blockComment$Rule();
                     }
                     break;
                  case '&':
                     // LineComment
                     match = lineComment$Rule();
                     break;
                  default:
                     match = false;
               }
            } while(match);
            match = true;
            // ('\n' | '\r\n')
            int startIndex_1 = index;
            switch(buffer.getChar(index)) {
               case '\r':
                  ++index;
                  // '\n'
                  if (match = buffer.matchChar(index, '\n')) {
                     ++index;
                  }
                  break;
               case '\n':
                  ++index;
                  // <EMPTY>
                  match = true;
                  break;
               default:
                  match = false;
            }
            if (! currentRuleIsAtomic) {
               currentNode.setSibling(new NodeImpl(Rule.TERMINAL, startIndex_1, index, false, false));
               currentNode = currentNode.getSibling();
            }
         }
      }
      if (match) {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = index;
         if (currentRuleIsAtomic) {
            continueNL$RuleMemoFirstNode = null;
         } else {
            currentNode = new NodeImpl(HarbourUnprocessedRuleType.CONTINUE_NL, startIndex, index, true, false);
            currentNode.setFirstChild(lastNode.getSibling());
            lastNode.setSibling(currentNode);
            continueNL$RuleMemoFirstNode = currentNode;
            continueNL$RuleMemoLastNode = currentNode;
         }
         return true;
      } else {
         continueNL$RuleMemoStart = startIndex;
         continueNL$RuleMemoEnd = -1;
         continueNL$RuleMemoFirstNode = null;
         index = startIndex;
         lastNode.setSibling(null);
         currentNode = lastNode;
         return false;
      }
   }

   //TestNoAlpha : ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
   protected boolean testNoAlpha$Rule() {
      boolean match;
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')!
      // ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')
      // 'a'-'z'
      match = buffer.matchCharRange(index, 'a', 'z');
      if (! match) {
         // 'A'-'Z'
         match = buffer.matchCharRange(index, 'A', 'Z');
         if (! match) {
            // '0'-'9'
            match = buffer.matchCharRange(index, '0', '9');
            if (! match) {
               // '_'
               match = buffer.matchChar(index, '_');
            }
         }
      }
      match = ! match;
      if (match) {
         return true;
      } else {
         return false;
      }
   }

   //OptionalSpacing : (Whitespace | LineComment | BlockComment | ContinueNL)*
   protected boolean optionalSpacing$Rule() {
      Node lastNode = currentNode;
      int startIndex;
      boolean match;
      if (optionalSpacing$RuleMemoStart == index) {
         if (optionalSpacing$RuleMemoStart <= optionalSpacing$RuleMemoEnd) {
            index = optionalSpacing$RuleMemoEnd;
            if (! currentRuleIsAtomic) {
               if (optionalSpacing$RuleMemoStart == optionalSpacing$RuleMemoEnd) {
                  currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, optionalSpacing$RuleMemoStart, optionalSpacing$RuleMemoEnd, false, false);
                  lastNode.setSibling(currentNode);
               } else if(optionalSpacing$RuleMemoFirstNode != null) {
                  lastNode.setSibling(optionalSpacing$RuleMemoFirstNode);
                  currentNode = optionalSpacing$RuleMemoLastNode;
               }
            }
            return true;
         } else {
            return false;
         }
      }
      startIndex = index;
      // (Whitespace | LineComment | BlockComment | ContinueNL)*
      do {
         // (Whitespace | LineComment | BlockComment | ContinueNL)
         switch(buffer.getChar(index)) {
            case ';':
               // ContinueNL
               match = continueNL$Rule();
               break;
            case ' ':
            case '\t':
            case '\f':
               // Whitespace
               match = whitespace$Rule();
               break;
            case '/':
               // LineComment
               match = lineComment$Rule();
               if (! match) {
                  // BlockComment
                  match = blockComment$Rule();
               }
               break;
            case '&':
               // LineComment
               match = lineComment$Rule();
               break;
            default:
               match = false;
         }
      } while(match);
      optionalSpacing$RuleMemoStart = startIndex;
      optionalSpacing$RuleMemoEnd = index;
      if (currentRuleIsAtomic) {
         optionalSpacing$RuleMemoFirstNode = null;
      } else {
         currentNode = new NodeImpl(HarbourUnprocessedRuleType.SPACING, startIndex, index, false, false);
         currentNode.setFirstChild(lastNode.getSibling());
         lastNode.setSibling(currentNode);
         optionalSpacing$RuleMemoFirstNode = currentNode;
         optionalSpacing$RuleMemoLastNode = currentNode;
      }
      return true;
   }
}
